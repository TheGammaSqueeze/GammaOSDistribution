// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module goldfish_vk_reserved_marshaling_guest
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "goldfish_vk_reserved_marshaling_guest.h"


#include "goldfish_vk_extension_structs_guest.h"
#include "goldfish_vk_private_defs.h"

#include "Resources.h"


namespace goldfish_vk {

void reservedmarshal_extension_struct(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const void* structExtension,
    uint8_t** ptr);

void reservedunmarshal_extension_struct(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    void* structExtension_out,
    uint8_t** ptr);

#ifdef VK_VERSION_1_0
void reservedmarshal_VkExtent2D(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExtent2D* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->height, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkExtent3D(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExtent3D* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->height, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->depth, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkOffset2D(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkOffset2D* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (int32_t*)&forMarshaling->x, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy(*ptr, (int32_t*)&forMarshaling->y, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedmarshal_VkOffset3D(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkOffset3D* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (int32_t*)&forMarshaling->x, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy(*ptr, (int32_t*)&forMarshaling->y, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy(*ptr, (int32_t*)&forMarshaling->z, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedmarshal_VkRect2D(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkRect2D* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    reservedmarshal_VkOffset2D(vkStream, rootType, (VkOffset2D*)(&forMarshaling->offset), ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->extent), ptr);
}

void reservedmarshal_VkBaseInStructure(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBaseInStructure* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
}

void reservedmarshal_VkBaseOutStructure(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBaseOutStructure* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
}

void reservedmarshal_VkBufferMemoryBarrier(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBufferMemoryBarrier* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->srcQueueFamilyIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstQueueFamilyIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkDispatchIndirectCommand(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDispatchIndirectCommand* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->x, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->y, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->z, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDrawIndexedIndirectCommand(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDrawIndexedIndirectCommand* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->indexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->instanceCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->firstIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (int32_t*)&forMarshaling->vertexOffset, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->firstInstance, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDrawIndirectCommand(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDrawIndirectCommand* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->vertexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->instanceCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->firstVertex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->firstInstance, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkImageSubresourceRange(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageSubresourceRange* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->baseMipLevel, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->levelCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->baseArrayLayer, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->layerCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkImageMemoryBarrier(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageMemoryBarrier* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->oldLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->newLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy(*ptr, (uint32_t*)&forMarshaling->srcQueueFamilyIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstQueueFamilyIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&forMarshaling->image));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    reservedmarshal_VkImageSubresourceRange(vkStream, rootType, (VkImageSubresourceRange*)(&forMarshaling->subresourceRange), ptr);
}

void reservedmarshal_VkMemoryBarrier(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMemoryBarrier* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
}

void reservedmarshal_VkAllocationCallbacks(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAllocationCallbacks* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pUserData;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pUserData)
    {
        memcpy(*ptr, (void*)forMarshaling->pUserData, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
    uint64_t cgen_var_1 = (uint64_t)forMarshaling->pfnAllocation;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    uint64_t cgen_var_2 = (uint64_t)forMarshaling->pfnReallocation;
    memcpy((*ptr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    uint64_t cgen_var_3 = (uint64_t)forMarshaling->pfnFree;
    memcpy((*ptr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    uint64_t cgen_var_4 = (uint64_t)forMarshaling->pfnInternalAllocation;
    memcpy((*ptr), &cgen_var_4, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    uint64_t cgen_var_5 = (uint64_t)forMarshaling->pfnInternalFree;
    memcpy((*ptr), &cgen_var_5, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
}

void reservedmarshal_VkApplicationInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkApplicationInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pApplicationName;
        memcpy((*ptr), &cgen_var_0, 8);
        android::base::Stream::toBe64((uint8_t*)(*ptr));
        *ptr += 8;
        if (forMarshaling->pApplicationName)
        {
            {
                uint32_t l = forMarshaling->pApplicationName ? strlen(forMarshaling->pApplicationName): 0;
                memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
                android::base::Stream::toBe32((uint8_t*)*ptr);
                *ptr += sizeof(uint32_t);
                memcpy(*ptr, (char*)forMarshaling->pApplicationName, l);
                *ptr += l;
            }
        }
    }
    else
    {
        {
            uint32_t l = forMarshaling->pApplicationName ? strlen(forMarshaling->pApplicationName): 0;
            memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*ptr);
            *ptr += sizeof(uint32_t);
            memcpy(*ptr, (char*)forMarshaling->pApplicationName, l);
            *ptr += l;
        }
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->applicationVersion, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pEngineName;
        memcpy((*ptr), &cgen_var_0, 8);
        android::base::Stream::toBe64((uint8_t*)(*ptr));
        *ptr += 8;
        if (forMarshaling->pEngineName)
        {
            {
                uint32_t l = forMarshaling->pEngineName ? strlen(forMarshaling->pEngineName): 0;
                memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
                android::base::Stream::toBe32((uint8_t*)*ptr);
                *ptr += sizeof(uint32_t);
                memcpy(*ptr, (char*)forMarshaling->pEngineName, l);
                *ptr += l;
            }
        }
    }
    else
    {
        {
            uint32_t l = forMarshaling->pEngineName ? strlen(forMarshaling->pEngineName): 0;
            memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*ptr);
            *ptr += sizeof(uint32_t);
            memcpy(*ptr, (char*)forMarshaling->pEngineName, l);
            *ptr += l;
        }
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->engineVersion, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->apiVersion, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkFormatProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkFormatProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkFormatFeatureFlags*)&forMarshaling->linearTilingFeatures, sizeof(VkFormatFeatureFlags));
    *ptr += sizeof(VkFormatFeatureFlags);
    memcpy(*ptr, (VkFormatFeatureFlags*)&forMarshaling->optimalTilingFeatures, sizeof(VkFormatFeatureFlags));
    *ptr += sizeof(VkFormatFeatureFlags);
    memcpy(*ptr, (VkFormatFeatureFlags*)&forMarshaling->bufferFeatures, sizeof(VkFormatFeatureFlags));
    *ptr += sizeof(VkFormatFeatureFlags);
}

void reservedmarshal_VkImageFormatProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageFormatProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    reservedmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forMarshaling->maxExtent), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxMipLevels, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxArrayLayers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->sampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->maxResourceSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkInstanceCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkInstanceCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkInstanceCreateFlags*)&forMarshaling->flags, sizeof(VkInstanceCreateFlags));
    *ptr += sizeof(VkInstanceCreateFlags);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pApplicationInfo;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pApplicationInfo)
    {
        reservedmarshal_VkApplicationInfo(vkStream, rootType, (const VkApplicationInfo*)(forMarshaling->pApplicationInfo), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->enabledLayerCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    {
        uint32_t c = 0;
        if (forMarshaling)
        {
            c = forMarshaling->enabledLayerCount;
        }
        memcpy(*ptr, (uint32_t*)&c, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        for (uint32_t i = 0; i < c; ++i)
        {
            uint32_t l = forMarshaling->ppEnabledLayerNames ? strlen(forMarshaling->ppEnabledLayerNames[i]): 0;
            memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*ptr);
            *ptr += sizeof(uint32_t);
            if (l)
            {
                memcpy(*ptr, (char*)(forMarshaling->ppEnabledLayerNames[i]), l);
                *ptr += l;
            }
        }
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->enabledExtensionCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    {
        uint32_t c = 0;
        if (forMarshaling)
        {
            c = forMarshaling->enabledExtensionCount;
        }
        memcpy(*ptr, (uint32_t*)&c, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        for (uint32_t i = 0; i < c; ++i)
        {
            uint32_t l = forMarshaling->ppEnabledExtensionNames ? strlen(forMarshaling->ppEnabledExtensionNames[i]): 0;
            memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*ptr);
            *ptr += sizeof(uint32_t);
            if (l)
            {
                memcpy(*ptr, (char*)(forMarshaling->ppEnabledExtensionNames[i]), l);
                *ptr += l;
            }
        }
    }
}

void reservedmarshal_VkMemoryHeap(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMemoryHeap* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkMemoryHeapFlags*)&forMarshaling->flags, sizeof(VkMemoryHeapFlags));
    *ptr += sizeof(VkMemoryHeapFlags);
}

void reservedmarshal_VkMemoryType(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMemoryType* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkMemoryPropertyFlags*)&forMarshaling->propertyFlags, sizeof(VkMemoryPropertyFlags));
    *ptr += sizeof(VkMemoryPropertyFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->heapIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPhysicalDeviceFeatures(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkBool32*)&forMarshaling->robustBufferAccess, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fullDrawIndexUint32, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->imageCubeArray, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->independentBlend, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->geometryShader, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->tessellationShader, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sampleRateShading, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->dualSrcBlend, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->logicOp, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->multiDrawIndirect, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->drawIndirectFirstInstance, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->depthClamp, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->depthBiasClamp, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fillModeNonSolid, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->depthBounds, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->wideLines, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->largePoints, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->alphaToOne, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->multiViewport, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->samplerAnisotropy, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->textureCompressionETC2, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->textureCompressionASTC_LDR, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->textureCompressionBC, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->occlusionQueryPrecise, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->pipelineStatisticsQuery, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->vertexPipelineStoresAndAtomics, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentStoresAndAtomics, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderTessellationAndGeometryPointSize, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderImageGatherExtended, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageImageExtendedFormats, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageImageMultisample, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageImageReadWithoutFormat, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageImageWriteWithoutFormat, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderUniformBufferArrayDynamicIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSampledImageArrayDynamicIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageBufferArrayDynamicIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageImageArrayDynamicIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderClipDistance, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderCullDistance, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderFloat64, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderInt64, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderInt16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderResourceResidency, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderResourceMinLod, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseBinding, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseResidencyBuffer, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseResidencyImage2D, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseResidencyImage3D, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseResidency2Samples, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseResidency4Samples, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseResidency8Samples, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseResidency16Samples, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseResidencyAliased, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->variableMultisampleRate, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->inheritedQueries, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceLimits(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceLimits* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxImageDimension1D, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxImageDimension2D, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxImageDimension3D, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxImageDimensionCube, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxImageArrayLayers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTexelBufferElements, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxUniformBufferRange, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxStorageBufferRange, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPushConstantsSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxMemoryAllocationCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxSamplerAllocationCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->bufferImageGranularity, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->sparseAddressSpaceSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxBoundDescriptorSets, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorSamplers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUniformBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorStorageBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorSampledImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorStorageImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorInputAttachments, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageResources, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetSamplers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUniformBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUniformBuffersDynamic, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetStorageBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetStorageBuffersDynamic, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetSampledImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetStorageImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetInputAttachments, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxVertexInputAttributes, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxVertexInputBindings, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxVertexInputAttributeOffset, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxVertexInputBindingStride, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxVertexOutputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTessellationGenerationLevel, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTessellationPatchSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTessellationControlPerVertexInputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTessellationControlPerVertexOutputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTessellationControlPerPatchOutputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTessellationControlTotalOutputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTessellationEvaluationInputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTessellationEvaluationOutputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxGeometryShaderInvocations, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxGeometryInputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxGeometryOutputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxGeometryOutputVertices, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxGeometryTotalOutputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxFragmentInputComponents, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxFragmentOutputAttachments, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxFragmentDualSrcAttachments, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxFragmentCombinedOutputResources, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxComputeSharedMemorySize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)forMarshaling->maxComputeWorkGroupCount, 3 * sizeof(uint32_t));
    *ptr += 3 * sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxComputeWorkGroupInvocations, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)forMarshaling->maxComputeWorkGroupSize, 3 * sizeof(uint32_t));
    *ptr += 3 * sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->subPixelPrecisionBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->subTexelPrecisionBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->mipmapPrecisionBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDrawIndexedIndexValue, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDrawIndirectCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (float*)&forMarshaling->maxSamplerLodBias, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxSamplerAnisotropy, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxViewports, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)forMarshaling->maxViewportDimensions, 2 * sizeof(uint32_t));
    *ptr += 2 * sizeof(uint32_t);
    memcpy(*ptr, (float*)forMarshaling->viewportBoundsRange, 2 * sizeof(float));
    *ptr += 2 * sizeof(float);
    memcpy(*ptr, (uint32_t*)&forMarshaling->viewportSubPixelBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->minMemoryMapAlignment;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->minTexelBufferOffsetAlignment, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->minUniformBufferOffsetAlignment, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->minStorageBufferOffsetAlignment, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (int32_t*)&forMarshaling->minTexelOffset, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTexelOffset, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (int32_t*)&forMarshaling->minTexelGatherOffset, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTexelGatherOffset, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (float*)&forMarshaling->minInterpolationOffset, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxInterpolationOffset, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (uint32_t*)&forMarshaling->subPixelInterpolationOffsetBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxFramebufferWidth, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxFramebufferHeight, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxFramebufferLayers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->framebufferColorSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->framebufferDepthSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->framebufferStencilSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->framebufferNoAttachmentsSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxColorAttachments, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->sampledImageColorSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->sampledImageIntegerSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->sampledImageDepthSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->sampledImageStencilSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->storageImageSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxSampleMaskWords, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkBool32*)&forMarshaling->timestampComputeAndGraphics, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (float*)&forMarshaling->timestampPeriod, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxClipDistances, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxCullDistances, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxCombinedClipAndCullDistances, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->discreteQueuePriorities, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (float*)forMarshaling->pointSizeRange, 2 * sizeof(float));
    *ptr += 2 * sizeof(float);
    memcpy(*ptr, (float*)forMarshaling->lineWidthRange, 2 * sizeof(float));
    *ptr += 2 * sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->pointSizeGranularity, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->lineWidthGranularity, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (VkBool32*)&forMarshaling->strictLines, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->standardSampleLocations, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->optimalBufferCopyOffsetAlignment, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->optimalBufferCopyRowPitchAlignment, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->nonCoherentAtomSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkPhysicalDeviceMemoryProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceMemoryProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->memoryTypeCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i)
    {
        reservedmarshal_VkMemoryType(vkStream, rootType, (VkMemoryType*)(forMarshaling->memoryTypes + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->memoryHeapCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i)
    {
        reservedmarshal_VkMemoryHeap(vkStream, rootType, (VkMemoryHeap*)(forMarshaling->memoryHeaps + i), ptr);
    }
}

void reservedmarshal_VkPhysicalDeviceSparseProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceSparseProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkBool32*)&forMarshaling->residencyStandard2DBlockShape, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->residencyStandard2DMultisampleBlockShape, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->residencyStandard3DBlockShape, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->residencyAlignedMipSize, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->residencyNonResidentStrict, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->apiVersion, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->driverVersion, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->vendorID, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceID, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkPhysicalDeviceType*)&forMarshaling->deviceType, sizeof(VkPhysicalDeviceType));
    *ptr += sizeof(VkPhysicalDeviceType);
    memcpy(*ptr, (char*)forMarshaling->deviceName, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char);
    memcpy(*ptr, (uint8_t*)forMarshaling->pipelineCacheUUID, VK_UUID_SIZE * sizeof(uint8_t));
    *ptr += VK_UUID_SIZE * sizeof(uint8_t);
    reservedmarshal_VkPhysicalDeviceLimits(vkStream, rootType, (VkPhysicalDeviceLimits*)(&forMarshaling->limits), ptr);
    reservedmarshal_VkPhysicalDeviceSparseProperties(vkStream, rootType, (VkPhysicalDeviceSparseProperties*)(&forMarshaling->sparseProperties), ptr);
}

void reservedmarshal_VkQueueFamilyProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkQueueFamilyProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkQueueFlags*)&forMarshaling->queueFlags, sizeof(VkQueueFlags));
    *ptr += sizeof(VkQueueFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->timestampValidBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forMarshaling->minImageTransferGranularity), ptr);
}

void reservedmarshal_VkDeviceQueueCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceQueueCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceQueueCreateFlags*)&forMarshaling->flags, sizeof(VkDeviceQueueCreateFlags));
    *ptr += sizeof(VkDeviceQueueCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueFamilyIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const float*)forMarshaling->pQueuePriorities, forMarshaling->queueCount * sizeof(const float));
    *ptr += forMarshaling->queueCount * sizeof(const float);
}

void reservedmarshal_VkDeviceCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceCreateFlags*)&forMarshaling->flags, sizeof(VkDeviceCreateFlags));
    *ptr += sizeof(VkDeviceCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueCreateInfoCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->queueCreateInfoCount; ++i)
    {
        reservedmarshal_VkDeviceQueueCreateInfo(vkStream, rootType, (const VkDeviceQueueCreateInfo*)(forMarshaling->pQueueCreateInfos + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->enabledLayerCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    {
        uint32_t c = 0;
        if (forMarshaling)
        {
            c = forMarshaling->enabledLayerCount;
        }
        memcpy(*ptr, (uint32_t*)&c, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        for (uint32_t i = 0; i < c; ++i)
        {
            uint32_t l = forMarshaling->ppEnabledLayerNames ? strlen(forMarshaling->ppEnabledLayerNames[i]): 0;
            memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*ptr);
            *ptr += sizeof(uint32_t);
            if (l)
            {
                memcpy(*ptr, (char*)(forMarshaling->ppEnabledLayerNames[i]), l);
                *ptr += l;
            }
        }
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->enabledExtensionCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    {
        uint32_t c = 0;
        if (forMarshaling)
        {
            c = forMarshaling->enabledExtensionCount;
        }
        memcpy(*ptr, (uint32_t*)&c, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        for (uint32_t i = 0; i < c; ++i)
        {
            uint32_t l = forMarshaling->ppEnabledExtensionNames ? strlen(forMarshaling->ppEnabledExtensionNames[i]): 0;
            memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*ptr);
            *ptr += sizeof(uint32_t);
            if (l)
            {
                memcpy(*ptr, (char*)(forMarshaling->ppEnabledExtensionNames[i]), l);
                *ptr += l;
            }
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pEnabledFeatures;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pEnabledFeatures)
    {
        reservedmarshal_VkPhysicalDeviceFeatures(vkStream, rootType, (const VkPhysicalDeviceFeatures*)(forMarshaling->pEnabledFeatures), ptr);
    }
}

void reservedmarshal_VkExtensionProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExtensionProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (char*)forMarshaling->extensionName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
    memcpy(*ptr, (uint32_t*)&forMarshaling->specVersion, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkLayerProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkLayerProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (char*)forMarshaling->layerName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
    memcpy(*ptr, (uint32_t*)&forMarshaling->specVersion, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->implementationVersion, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (char*)forMarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
}

void reservedmarshal_VkSubmitInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSubmitInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->waitSemaphoreCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->waitSemaphoreCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkSemaphore(forMarshaling->pWaitSemaphores[k]);
                memcpy(cgen_var_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->waitSemaphoreCount;
    }
    memcpy(*ptr, (const VkPipelineStageFlags*)forMarshaling->pWaitDstStageMask, forMarshaling->waitSemaphoreCount * sizeof(const VkPipelineStageFlags));
    *ptr += forMarshaling->waitSemaphoreCount * sizeof(const VkPipelineStageFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->commandBufferCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->commandBufferCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->commandBufferCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkCommandBuffer(forMarshaling->pCommandBuffers[k]);
                memcpy(cgen_var_1_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->commandBufferCount;
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->signalSemaphoreCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->signalSemaphoreCount)
    {
        uint8_t* cgen_var_2_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->signalSemaphoreCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkSemaphore(forMarshaling->pSignalSemaphores[k]);
                memcpy(cgen_var_2_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->signalSemaphoreCount;
    }
}

void reservedmarshal_VkMappedMemoryRange(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMappedMemoryRange* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDeviceMemory((*&forMarshaling->memory));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkMemoryAllocateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMemoryAllocateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->allocationSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (uint32_t*)&forMarshaling->memoryTypeIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkMemoryRequirements(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMemoryRequirements* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->alignment, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkSparseMemoryBind(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSparseMemoryBind* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->resourceOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDeviceMemory((*&forMarshaling->memory));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkSparseMemoryBindFlags*)&forMarshaling->flags, sizeof(VkSparseMemoryBindFlags));
    *ptr += sizeof(VkSparseMemoryBindFlags);
}

void reservedmarshal_VkSparseBufferMemoryBindInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSparseBufferMemoryBindInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->bindCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindCount; ++i)
    {
        reservedmarshal_VkSparseMemoryBind(vkStream, rootType, (const VkSparseMemoryBind*)(forMarshaling->pBinds + i), ptr);
    }
}

void reservedmarshal_VkSparseImageOpaqueMemoryBindInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSparseImageOpaqueMemoryBindInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&forMarshaling->image));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->bindCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindCount; ++i)
    {
        reservedmarshal_VkSparseMemoryBind(vkStream, rootType, (const VkSparseMemoryBind*)(forMarshaling->pBinds + i), ptr);
    }
}

void reservedmarshal_VkImageSubresource(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageSubresource* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->mipLevel, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->arrayLayer, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkSparseImageMemoryBind(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSparseImageMemoryBind* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    reservedmarshal_VkImageSubresource(vkStream, rootType, (VkImageSubresource*)(&forMarshaling->subresource), ptr);
    reservedmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forMarshaling->offset), ptr);
    reservedmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forMarshaling->extent), ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDeviceMemory((*&forMarshaling->memory));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkSparseMemoryBindFlags*)&forMarshaling->flags, sizeof(VkSparseMemoryBindFlags));
    *ptr += sizeof(VkSparseMemoryBindFlags);
}

void reservedmarshal_VkSparseImageMemoryBindInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSparseImageMemoryBindInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&forMarshaling->image));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->bindCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindCount; ++i)
    {
        reservedmarshal_VkSparseImageMemoryBind(vkStream, rootType, (const VkSparseImageMemoryBind*)(forMarshaling->pBinds + i), ptr);
    }
}

void reservedmarshal_VkBindSparseInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBindSparseInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->waitSemaphoreCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->waitSemaphoreCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkSemaphore(forMarshaling->pWaitSemaphores[k]);
                memcpy(cgen_var_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->waitSemaphoreCount;
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->bufferBindCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bufferBindCount; ++i)
    {
        reservedmarshal_VkSparseBufferMemoryBindInfo(vkStream, rootType, (const VkSparseBufferMemoryBindInfo*)(forMarshaling->pBufferBinds + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->imageOpaqueBindCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->imageOpaqueBindCount; ++i)
    {
        reservedmarshal_VkSparseImageOpaqueMemoryBindInfo(vkStream, rootType, (const VkSparseImageOpaqueMemoryBindInfo*)(forMarshaling->pImageOpaqueBinds + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->imageBindCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->imageBindCount; ++i)
    {
        reservedmarshal_VkSparseImageMemoryBindInfo(vkStream, rootType, (const VkSparseImageMemoryBindInfo*)(forMarshaling->pImageBinds + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->signalSemaphoreCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->signalSemaphoreCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->signalSemaphoreCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkSemaphore(forMarshaling->pSignalSemaphores[k]);
                memcpy(cgen_var_1_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->signalSemaphoreCount;
    }
}

void reservedmarshal_VkSparseImageFormatProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSparseImageFormatProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    reservedmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forMarshaling->imageGranularity), ptr);
    memcpy(*ptr, (VkSparseImageFormatFlags*)&forMarshaling->flags, sizeof(VkSparseImageFormatFlags));
    *ptr += sizeof(VkSparseImageFormatFlags);
}

void reservedmarshal_VkSparseImageMemoryRequirements(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSparseImageMemoryRequirements* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    reservedmarshal_VkSparseImageFormatProperties(vkStream, rootType, (VkSparseImageFormatProperties*)(&forMarshaling->formatProperties), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->imageMipTailFirstLod, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->imageMipTailSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->imageMipTailOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->imageMipTailStride, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkFenceCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkFenceCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkFenceCreateFlags*)&forMarshaling->flags, sizeof(VkFenceCreateFlags));
    *ptr += sizeof(VkFenceCreateFlags);
}

void reservedmarshal_VkSemaphoreCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSemaphoreCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSemaphoreCreateFlags*)&forMarshaling->flags, sizeof(VkSemaphoreCreateFlags));
    *ptr += sizeof(VkSemaphoreCreateFlags);
}

void reservedmarshal_VkEventCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkEventCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkEventCreateFlags*)&forMarshaling->flags, sizeof(VkEventCreateFlags));
    *ptr += sizeof(VkEventCreateFlags);
}

void reservedmarshal_VkQueryPoolCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkQueryPoolCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkQueryPoolCreateFlags*)&forMarshaling->flags, sizeof(VkQueryPoolCreateFlags));
    *ptr += sizeof(VkQueryPoolCreateFlags);
    memcpy(*ptr, (VkQueryType*)&forMarshaling->queryType, sizeof(VkQueryType));
    *ptr += sizeof(VkQueryType);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queryCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkQueryPipelineStatisticFlags*)&forMarshaling->pipelineStatistics, sizeof(VkQueryPipelineStatisticFlags));
    *ptr += sizeof(VkQueryPipelineStatisticFlags);
}

void reservedmarshal_VkBufferCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBufferCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBufferCreateFlags*)&forMarshaling->flags, sizeof(VkBufferCreateFlags));
    *ptr += sizeof(VkBufferCreateFlags);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkBufferUsageFlags*)&forMarshaling->usage, sizeof(VkBufferUsageFlags));
    *ptr += sizeof(VkBufferUsageFlags);
    memcpy(*ptr, (VkSharingMode*)&forMarshaling->sharingMode, sizeof(VkSharingMode));
    *ptr += sizeof(VkSharingMode);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pQueueFamilyIndices;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pQueueFamilyIndices)
    {
        memcpy(*ptr, (const uint32_t*)forMarshaling->pQueueFamilyIndices, forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        *ptr += forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t);
    }
}

void reservedmarshal_VkBufferViewCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBufferViewCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBufferViewCreateFlags*)&forMarshaling->flags, sizeof(VkBufferViewCreateFlags));
    *ptr += sizeof(VkBufferViewCreateFlags);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->range, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkImageCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkImageCreateFlags*)&forMarshaling->flags, sizeof(VkImageCreateFlags));
    *ptr += sizeof(VkImageCreateFlags);
    memcpy(*ptr, (VkImageType*)&forMarshaling->imageType, sizeof(VkImageType));
    *ptr += sizeof(VkImageType);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    reservedmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forMarshaling->extent), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->mipLevels, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->arrayLayers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy(*ptr, (VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
    *ptr += sizeof(VkImageTiling);
    memcpy(*ptr, (VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy(*ptr, (VkSharingMode*)&forMarshaling->sharingMode, sizeof(VkSharingMode));
    *ptr += sizeof(VkSharingMode);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pQueueFamilyIndices;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pQueueFamilyIndices)
    {
        memcpy(*ptr, (const uint32_t*)forMarshaling->pQueueFamilyIndices, forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        *ptr += forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t);
    }
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->initialLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedmarshal_VkSubresourceLayout(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSubresourceLayout* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->rowPitch, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->arrayPitch, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->depthPitch, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkComponentMapping(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkComponentMapping* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkComponentSwizzle*)&forMarshaling->r, sizeof(VkComponentSwizzle));
    *ptr += sizeof(VkComponentSwizzle);
    memcpy(*ptr, (VkComponentSwizzle*)&forMarshaling->g, sizeof(VkComponentSwizzle));
    *ptr += sizeof(VkComponentSwizzle);
    memcpy(*ptr, (VkComponentSwizzle*)&forMarshaling->b, sizeof(VkComponentSwizzle));
    *ptr += sizeof(VkComponentSwizzle);
    memcpy(*ptr, (VkComponentSwizzle*)&forMarshaling->a, sizeof(VkComponentSwizzle));
    *ptr += sizeof(VkComponentSwizzle);
}

void reservedmarshal_VkImageViewCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageViewCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkImageViewCreateFlags*)&forMarshaling->flags, sizeof(VkImageViewCreateFlags));
    *ptr += sizeof(VkImageViewCreateFlags);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&forMarshaling->image));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkImageViewType*)&forMarshaling->viewType, sizeof(VkImageViewType));
    *ptr += sizeof(VkImageViewType);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    reservedmarshal_VkComponentMapping(vkStream, rootType, (VkComponentMapping*)(&forMarshaling->components), ptr);
    reservedmarshal_VkImageSubresourceRange(vkStream, rootType, (VkImageSubresourceRange*)(&forMarshaling->subresourceRange), ptr);
}

void reservedmarshal_VkShaderModuleCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkShaderModuleCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkShaderModuleCreateFlags*)&forMarshaling->flags, sizeof(VkShaderModuleCreateFlags));
    *ptr += sizeof(VkShaderModuleCreateFlags);
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->codeSize;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    memcpy(*ptr, (const uint32_t*)forMarshaling->pCode, (forMarshaling->codeSize / 4) * sizeof(const uint32_t));
    *ptr += (forMarshaling->codeSize / 4) * sizeof(const uint32_t);
}

void reservedmarshal_VkPipelineCacheCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineCacheCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineCacheCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCacheCreateFlags));
    *ptr += sizeof(VkPipelineCacheCreateFlags);
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->initialDataSize;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    memcpy(*ptr, (const void*)forMarshaling->pInitialData, forMarshaling->initialDataSize * sizeof(const uint8_t));
    *ptr += forMarshaling->initialDataSize * sizeof(const uint8_t);
}

void reservedmarshal_VkSpecializationMapEntry(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSpecializationMapEntry* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->constantID, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->offset, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->size;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
}

void reservedmarshal_VkSpecializationInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSpecializationInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->mapEntryCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->mapEntryCount; ++i)
    {
        reservedmarshal_VkSpecializationMapEntry(vkStream, rootType, (const VkSpecializationMapEntry*)(forMarshaling->pMapEntries + i), ptr);
    }
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->dataSize;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    memcpy(*ptr, (const void*)forMarshaling->pData, forMarshaling->dataSize * sizeof(const uint8_t));
    *ptr += forMarshaling->dataSize * sizeof(const uint8_t);
}

void reservedmarshal_VkPipelineShaderStageCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineShaderStageCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineShaderStageCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineShaderStageCreateFlags));
    *ptr += sizeof(VkPipelineShaderStageCreateFlags);
    memcpy(*ptr, (VkShaderStageFlagBits*)&forMarshaling->stage, sizeof(VkShaderStageFlagBits));
    *ptr += sizeof(VkShaderStageFlagBits);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkShaderModule((*&forMarshaling->module));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    {
        uint32_t l = forMarshaling->pName ? strlen(forMarshaling->pName): 0;
        memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        memcpy(*ptr, (char*)forMarshaling->pName, l);
        *ptr += l;
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pSpecializationInfo;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pSpecializationInfo)
    {
        reservedmarshal_VkSpecializationInfo(vkStream, rootType, (const VkSpecializationInfo*)(forMarshaling->pSpecializationInfo), ptr);
    }
}

void reservedmarshal_VkComputePipelineCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkComputePipelineCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCreateFlags));
    *ptr += sizeof(VkPipelineCreateFlags);
    reservedmarshal_VkPipelineShaderStageCreateInfo(vkStream, rootType, (VkPipelineShaderStageCreateInfo*)(&forMarshaling->stage), ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPipelineLayout((*&forMarshaling->layout));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkPipeline((*&forMarshaling->basePipelineHandle));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (int32_t*)&forMarshaling->basePipelineIndex, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedmarshal_VkVertexInputBindingDescription(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkVertexInputBindingDescription* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->stride, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkVertexInputRate*)&forMarshaling->inputRate, sizeof(VkVertexInputRate));
    *ptr += sizeof(VkVertexInputRate);
}

void reservedmarshal_VkVertexInputAttributeDescription(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkVertexInputAttributeDescription* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->location, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (uint32_t*)&forMarshaling->offset, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPipelineVertexInputStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineVertexInputStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineVertexInputStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineVertexInputStateCreateFlags));
    *ptr += sizeof(VkPipelineVertexInputStateCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->vertexBindingDescriptionCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->vertexBindingDescriptionCount; ++i)
    {
        reservedmarshal_VkVertexInputBindingDescription(vkStream, rootType, (const VkVertexInputBindingDescription*)(forMarshaling->pVertexBindingDescriptions + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->vertexAttributeDescriptionCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->vertexAttributeDescriptionCount; ++i)
    {
        reservedmarshal_VkVertexInputAttributeDescription(vkStream, rootType, (const VkVertexInputAttributeDescription*)(forMarshaling->pVertexAttributeDescriptions + i), ptr);
    }
}

void reservedmarshal_VkPipelineInputAssemblyStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineInputAssemblyStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineInputAssemblyStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineInputAssemblyStateCreateFlags));
    *ptr += sizeof(VkPipelineInputAssemblyStateCreateFlags);
    memcpy(*ptr, (VkPrimitiveTopology*)&forMarshaling->topology, sizeof(VkPrimitiveTopology));
    *ptr += sizeof(VkPrimitiveTopology);
    memcpy(*ptr, (VkBool32*)&forMarshaling->primitiveRestartEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPipelineTessellationStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineTessellationStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineTessellationStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineTessellationStateCreateFlags));
    *ptr += sizeof(VkPipelineTessellationStateCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->patchControlPoints, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkViewport(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkViewport* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (float*)&forMarshaling->x, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->y, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->width, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->height, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->minDepth, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxDepth, sizeof(float));
    *ptr += sizeof(float);
}

void reservedmarshal_VkPipelineViewportStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineViewportStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineViewportStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineViewportStateCreateFlags));
    *ptr += sizeof(VkPipelineViewportStateCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->viewportCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pViewports;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pViewports)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->viewportCount; ++i)
        {
            reservedmarshal_VkViewport(vkStream, rootType, (const VkViewport*)(forMarshaling->pViewports + i), ptr);
        }
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->scissorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pScissors;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pScissors)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->scissorCount; ++i)
        {
            reservedmarshal_VkRect2D(vkStream, rootType, (const VkRect2D*)(forMarshaling->pScissors + i), ptr);
        }
    }
}

void reservedmarshal_VkPipelineRasterizationStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineRasterizationStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineRasterizationStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineRasterizationStateCreateFlags));
    *ptr += sizeof(VkPipelineRasterizationStateCreateFlags);
    memcpy(*ptr, (VkBool32*)&forMarshaling->depthClampEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->rasterizerDiscardEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkPolygonMode*)&forMarshaling->polygonMode, sizeof(VkPolygonMode));
    *ptr += sizeof(VkPolygonMode);
    memcpy(*ptr, (VkCullModeFlags*)&forMarshaling->cullMode, sizeof(VkCullModeFlags));
    *ptr += sizeof(VkCullModeFlags);
    memcpy(*ptr, (VkFrontFace*)&forMarshaling->frontFace, sizeof(VkFrontFace));
    *ptr += sizeof(VkFrontFace);
    memcpy(*ptr, (VkBool32*)&forMarshaling->depthBiasEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (float*)&forMarshaling->depthBiasConstantFactor, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->depthBiasClamp, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->depthBiasSlopeFactor, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->lineWidth, sizeof(float));
    *ptr += sizeof(float);
}

void reservedmarshal_VkPipelineMultisampleStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineMultisampleStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineMultisampleStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineMultisampleStateCreateFlags));
    *ptr += sizeof(VkPipelineMultisampleStateCreateFlags);
    memcpy(*ptr, (VkSampleCountFlagBits*)&forMarshaling->rasterizationSamples, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sampleShadingEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (float*)&forMarshaling->minSampleShading, sizeof(float));
    *ptr += sizeof(float);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pSampleMask;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pSampleMask)
    {
        memcpy(*ptr, (const VkSampleMask*)forMarshaling->pSampleMask, (((forMarshaling->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask));
        *ptr += (((forMarshaling->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask);
    }
    memcpy(*ptr, (VkBool32*)&forMarshaling->alphaToCoverageEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->alphaToOneEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkStencilOpState(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkStencilOpState* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStencilOp*)&forMarshaling->failOp, sizeof(VkStencilOp));
    *ptr += sizeof(VkStencilOp);
    memcpy(*ptr, (VkStencilOp*)&forMarshaling->passOp, sizeof(VkStencilOp));
    *ptr += sizeof(VkStencilOp);
    memcpy(*ptr, (VkStencilOp*)&forMarshaling->depthFailOp, sizeof(VkStencilOp));
    *ptr += sizeof(VkStencilOp);
    memcpy(*ptr, (VkCompareOp*)&forMarshaling->compareOp, sizeof(VkCompareOp));
    *ptr += sizeof(VkCompareOp);
    memcpy(*ptr, (uint32_t*)&forMarshaling->compareMask, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->writeMask, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->reference, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPipelineDepthStencilStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineDepthStencilStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineDepthStencilStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineDepthStencilStateCreateFlags));
    *ptr += sizeof(VkPipelineDepthStencilStateCreateFlags);
    memcpy(*ptr, (VkBool32*)&forMarshaling->depthTestEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->depthWriteEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkCompareOp*)&forMarshaling->depthCompareOp, sizeof(VkCompareOp));
    *ptr += sizeof(VkCompareOp);
    memcpy(*ptr, (VkBool32*)&forMarshaling->depthBoundsTestEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->stencilTestEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    reservedmarshal_VkStencilOpState(vkStream, rootType, (VkStencilOpState*)(&forMarshaling->front), ptr);
    reservedmarshal_VkStencilOpState(vkStream, rootType, (VkStencilOpState*)(&forMarshaling->back), ptr);
    memcpy(*ptr, (float*)&forMarshaling->minDepthBounds, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxDepthBounds, sizeof(float));
    *ptr += sizeof(float);
}

void reservedmarshal_VkPipelineColorBlendAttachmentState(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineColorBlendAttachmentState* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkBool32*)&forMarshaling->blendEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBlendFactor*)&forMarshaling->srcColorBlendFactor, sizeof(VkBlendFactor));
    *ptr += sizeof(VkBlendFactor);
    memcpy(*ptr, (VkBlendFactor*)&forMarshaling->dstColorBlendFactor, sizeof(VkBlendFactor));
    *ptr += sizeof(VkBlendFactor);
    memcpy(*ptr, (VkBlendOp*)&forMarshaling->colorBlendOp, sizeof(VkBlendOp));
    *ptr += sizeof(VkBlendOp);
    memcpy(*ptr, (VkBlendFactor*)&forMarshaling->srcAlphaBlendFactor, sizeof(VkBlendFactor));
    *ptr += sizeof(VkBlendFactor);
    memcpy(*ptr, (VkBlendFactor*)&forMarshaling->dstAlphaBlendFactor, sizeof(VkBlendFactor));
    *ptr += sizeof(VkBlendFactor);
    memcpy(*ptr, (VkBlendOp*)&forMarshaling->alphaBlendOp, sizeof(VkBlendOp));
    *ptr += sizeof(VkBlendOp);
    memcpy(*ptr, (VkColorComponentFlags*)&forMarshaling->colorWriteMask, sizeof(VkColorComponentFlags));
    *ptr += sizeof(VkColorComponentFlags);
}

void reservedmarshal_VkPipelineColorBlendStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineColorBlendStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineColorBlendStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineColorBlendStateCreateFlags));
    *ptr += sizeof(VkPipelineColorBlendStateCreateFlags);
    memcpy(*ptr, (VkBool32*)&forMarshaling->logicOpEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkLogicOp*)&forMarshaling->logicOp, sizeof(VkLogicOp));
    *ptr += sizeof(VkLogicOp);
    memcpy(*ptr, (uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentCount; ++i)
    {
        reservedmarshal_VkPipelineColorBlendAttachmentState(vkStream, rootType, (const VkPipelineColorBlendAttachmentState*)(forMarshaling->pAttachments + i), ptr);
    }
    memcpy(*ptr, (float*)forMarshaling->blendConstants, 4 * sizeof(float));
    *ptr += 4 * sizeof(float);
}

void reservedmarshal_VkPipelineDynamicStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineDynamicStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineDynamicStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineDynamicStateCreateFlags));
    *ptr += sizeof(VkPipelineDynamicStateCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dynamicStateCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const VkDynamicState*)forMarshaling->pDynamicStates, forMarshaling->dynamicStateCount * sizeof(const VkDynamicState));
    *ptr += forMarshaling->dynamicStateCount * sizeof(const VkDynamicState);
}

void reservedmarshal_VkGraphicsPipelineCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkGraphicsPipelineCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    uint32_t hasRasterization = 1;
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        hasRasterization = (((0 == forMarshaling->pRasterizationState)) ? (0) : (!((*(forMarshaling->pRasterizationState)).rasterizerDiscardEnable)));
        uint32_t cgen_var_0 = (uint32_t)hasRasterization;
        memcpy((*ptr), &cgen_var_0, 4);
        android::base::Stream::toBe32((uint8_t*)(*ptr));
        *ptr += 4;
    }
    uint32_t hasTessellation = 1;
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        hasTessellation = arrayany(forMarshaling->pStages, 0, forMarshaling->stageCount, [](VkPipelineShaderStageCreateInfo s) { return ((s.stage == VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT) || (s.stage == VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT)); });
        uint32_t cgen_var_0 = (uint32_t)hasTessellation;
        memcpy((*ptr), &cgen_var_0, 4);
        android::base::Stream::toBe32((uint8_t*)(*ptr));
        *ptr += 4;
    }
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCreateFlags));
    *ptr += sizeof(VkPipelineCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->stageCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->stageCount; ++i)
    {
        reservedmarshal_VkPipelineShaderStageCreateInfo(vkStream, rootType, (const VkPipelineShaderStageCreateInfo*)(forMarshaling->pStages + i), ptr);
    }
    // WARNING PTR CHECK
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pVertexInputState;
        memcpy((*ptr), &cgen_var_0, 8);
        android::base::Stream::toBe64((uint8_t*)(*ptr));
        *ptr += 8;
    }
    if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || forMarshaling->pVertexInputState))
    {
        reservedmarshal_VkPipelineVertexInputStateCreateInfo(vkStream, rootType, (const VkPipelineVertexInputStateCreateInfo*)(forMarshaling->pVertexInputState), ptr);
    }
    // WARNING PTR CHECK
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pInputAssemblyState;
        memcpy((*ptr), &cgen_var_0, 8);
        android::base::Stream::toBe64((uint8_t*)(*ptr));
        *ptr += 8;
    }
    if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || forMarshaling->pInputAssemblyState))
    {
        reservedmarshal_VkPipelineInputAssemblyStateCreateInfo(vkStream, rootType, (const VkPipelineInputAssemblyStateCreateInfo*)(forMarshaling->pInputAssemblyState), ptr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pTessellationState;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pTessellationState)
    {
        if (hasTessellation)
        {
            reservedmarshal_VkPipelineTessellationStateCreateInfo(vkStream, rootType, (const VkPipelineTessellationStateCreateInfo*)(forMarshaling->pTessellationState), ptr);
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pViewportState;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pViewportState)
    {
        if (hasRasterization)
        {
            reservedmarshal_VkPipelineViewportStateCreateInfo(vkStream, rootType, (const VkPipelineViewportStateCreateInfo*)(forMarshaling->pViewportState), ptr);
        }
    }
    // WARNING PTR CHECK
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        uint64_t cgen_var_1_0 = (uint64_t)(uintptr_t)forMarshaling->pRasterizationState;
        memcpy((*ptr), &cgen_var_1_0, 8);
        android::base::Stream::toBe64((uint8_t*)(*ptr));
        *ptr += 8;
    }
    if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || forMarshaling->pRasterizationState))
    {
        reservedmarshal_VkPipelineRasterizationStateCreateInfo(vkStream, rootType, (const VkPipelineRasterizationStateCreateInfo*)(forMarshaling->pRasterizationState), ptr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)forMarshaling->pMultisampleState;
    memcpy((*ptr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pMultisampleState)
    {
        if (hasRasterization)
        {
            reservedmarshal_VkPipelineMultisampleStateCreateInfo(vkStream, rootType, (const VkPipelineMultisampleStateCreateInfo*)(forMarshaling->pMultisampleState), ptr);
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)forMarshaling->pDepthStencilState;
    memcpy((*ptr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pDepthStencilState)
    {
        if (hasRasterization)
        {
            reservedmarshal_VkPipelineDepthStencilStateCreateInfo(vkStream, rootType, (const VkPipelineDepthStencilStateCreateInfo*)(forMarshaling->pDepthStencilState), ptr);
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_4 = (uint64_t)(uintptr_t)forMarshaling->pColorBlendState;
    memcpy((*ptr), &cgen_var_4, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pColorBlendState)
    {
        if (hasRasterization)
        {
            reservedmarshal_VkPipelineColorBlendStateCreateInfo(vkStream, rootType, (const VkPipelineColorBlendStateCreateInfo*)(forMarshaling->pColorBlendState), ptr);
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_5 = (uint64_t)(uintptr_t)forMarshaling->pDynamicState;
    memcpy((*ptr), &cgen_var_5, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pDynamicState)
    {
        reservedmarshal_VkPipelineDynamicStateCreateInfo(vkStream, rootType, (const VkPipelineDynamicStateCreateInfo*)(forMarshaling->pDynamicState), ptr);
    }
    uint64_t cgen_var_6;
    *&cgen_var_6 = get_host_u64_VkPipelineLayout((*&forMarshaling->layout));
    memcpy(*ptr, (uint64_t*)&cgen_var_6, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_7;
    *&cgen_var_7 = get_host_u64_VkRenderPass((*&forMarshaling->renderPass));
    memcpy(*ptr, (uint64_t*)&cgen_var_7, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->subpass, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_8;
    *&cgen_var_8 = get_host_u64_VkPipeline((*&forMarshaling->basePipelineHandle));
    memcpy(*ptr, (uint64_t*)&cgen_var_8, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (int32_t*)&forMarshaling->basePipelineIndex, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedmarshal_VkPushConstantRange(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPushConstantRange* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkShaderStageFlags*)&forMarshaling->stageFlags, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->offset, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->size, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPipelineLayoutCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineLayoutCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineLayoutCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineLayoutCreateFlags));
    *ptr += sizeof(VkPipelineLayoutCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->setLayoutCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->setLayoutCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->setLayoutCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkDescriptorSetLayout(forMarshaling->pSetLayouts[k]);
                memcpy(cgen_var_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->setLayoutCount;
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->pushConstantRangeCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->pushConstantRangeCount; ++i)
    {
        reservedmarshal_VkPushConstantRange(vkStream, rootType, (const VkPushConstantRange*)(forMarshaling->pPushConstantRanges + i), ptr);
    }
}

void reservedmarshal_VkSamplerCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSamplerCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSamplerCreateFlags*)&forMarshaling->flags, sizeof(VkSamplerCreateFlags));
    *ptr += sizeof(VkSamplerCreateFlags);
    memcpy(*ptr, (VkFilter*)&forMarshaling->magFilter, sizeof(VkFilter));
    *ptr += sizeof(VkFilter);
    memcpy(*ptr, (VkFilter*)&forMarshaling->minFilter, sizeof(VkFilter));
    *ptr += sizeof(VkFilter);
    memcpy(*ptr, (VkSamplerMipmapMode*)&forMarshaling->mipmapMode, sizeof(VkSamplerMipmapMode));
    *ptr += sizeof(VkSamplerMipmapMode);
    memcpy(*ptr, (VkSamplerAddressMode*)&forMarshaling->addressModeU, sizeof(VkSamplerAddressMode));
    *ptr += sizeof(VkSamplerAddressMode);
    memcpy(*ptr, (VkSamplerAddressMode*)&forMarshaling->addressModeV, sizeof(VkSamplerAddressMode));
    *ptr += sizeof(VkSamplerAddressMode);
    memcpy(*ptr, (VkSamplerAddressMode*)&forMarshaling->addressModeW, sizeof(VkSamplerAddressMode));
    *ptr += sizeof(VkSamplerAddressMode);
    memcpy(*ptr, (float*)&forMarshaling->mipLodBias, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (VkBool32*)&forMarshaling->anisotropyEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (float*)&forMarshaling->maxAnisotropy, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (VkBool32*)&forMarshaling->compareEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkCompareOp*)&forMarshaling->compareOp, sizeof(VkCompareOp));
    *ptr += sizeof(VkCompareOp);
    memcpy(*ptr, (float*)&forMarshaling->minLod, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxLod, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (VkBorderColor*)&forMarshaling->borderColor, sizeof(VkBorderColor));
    *ptr += sizeof(VkBorderColor);
    memcpy(*ptr, (VkBool32*)&forMarshaling->unnormalizedCoordinates, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkCopyDescriptorSet(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCopyDescriptorSet* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDescriptorSet((*&forMarshaling->srcSet));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->srcBinding, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->srcArrayElement, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDescriptorSet((*&forMarshaling->dstSet));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstBinding, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstArrayElement, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDescriptorBufferInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDescriptorBufferInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->range, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkDescriptorImageInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDescriptorImageInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkSampler((*&forMarshaling->sampler));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImageView((*&forMarshaling->imageView));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->imageLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedmarshal_VkDescriptorPoolSize(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDescriptorPoolSize* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkDescriptorType*)&forMarshaling->type, sizeof(VkDescriptorType));
    *ptr += sizeof(VkDescriptorType);
    memcpy(*ptr, (uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDescriptorPoolCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDescriptorPoolCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDescriptorPoolCreateFlags*)&forMarshaling->flags, sizeof(VkDescriptorPoolCreateFlags));
    *ptr += sizeof(VkDescriptorPoolCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxSets, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->poolSizeCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->poolSizeCount; ++i)
    {
        reservedmarshal_VkDescriptorPoolSize(vkStream, rootType, (const VkDescriptorPoolSize*)(forMarshaling->pPoolSizes + i), ptr);
    }
}

void reservedmarshal_VkDescriptorSetAllocateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDescriptorSetAllocateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDescriptorPool((*&forMarshaling->descriptorPool));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->descriptorSetCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->descriptorSetCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->descriptorSetCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkDescriptorSetLayout(forMarshaling->pSetLayouts[k]);
                memcpy(cgen_var_1_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->descriptorSetCount;
    }
}

void reservedmarshal_VkDescriptorSetLayoutBinding(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDescriptorSetLayoutBinding* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkDescriptorType*)&forMarshaling->descriptorType, sizeof(VkDescriptorType));
    *ptr += sizeof(VkDescriptorType);
    memcpy(*ptr, (uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkShaderStageFlags*)&forMarshaling->stageFlags, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pImmutableSamplers;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pImmutableSamplers)
    {
        if (forMarshaling->descriptorCount)
        {
            uint8_t* cgen_var_0_0_ptr = (uint8_t*)(*ptr);
            if (forMarshaling)
            {
                for (uint32_t k = 0; k < forMarshaling->descriptorCount; ++k)
                {
                    uint64_t tmpval = get_host_u64_VkSampler(forMarshaling->pImmutableSamplers[k]);
                    memcpy(cgen_var_0_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
                }
            }
            *ptr += 8 * forMarshaling->descriptorCount;
        }
    }
}

void reservedmarshal_VkDescriptorSetLayoutCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDescriptorSetLayoutCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDescriptorSetLayoutCreateFlags*)&forMarshaling->flags, sizeof(VkDescriptorSetLayoutCreateFlags));
    *ptr += sizeof(VkDescriptorSetLayoutCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->bindingCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindingCount; ++i)
    {
        reservedmarshal_VkDescriptorSetLayoutBinding(vkStream, rootType, (const VkDescriptorSetLayoutBinding*)(forMarshaling->pBindings + i), ptr);
    }
}

void reservedmarshal_VkWriteDescriptorSet(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkWriteDescriptorSet* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDescriptorSet((*&forMarshaling->dstSet));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstBinding, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstArrayElement, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkDescriptorType*)&forMarshaling->descriptorType, sizeof(VkDescriptorType));
    *ptr += sizeof(VkDescriptorType);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pImageInfo;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pImageInfo)
    {
        if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_SAMPLER == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_IMAGE == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT == forMarshaling->descriptorType))))
        {
            for (uint32_t i = 0; i < (uint32_t)forMarshaling->descriptorCount; ++i)
            {
                reservedmarshal_VkDescriptorImageInfo(vkStream, rootType, (const VkDescriptorImageInfo*)(forMarshaling->pImageInfo + i), ptr);
            }
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)forMarshaling->pBufferInfo;
    memcpy((*ptr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pBufferInfo)
    {
        if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_BUFFER == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC == forMarshaling->descriptorType))))
        {
            for (uint32_t i = 0; i < (uint32_t)forMarshaling->descriptorCount; ++i)
            {
                reservedmarshal_VkDescriptorBufferInfo(vkStream, rootType, (const VkDescriptorBufferInfo*)(forMarshaling->pBufferInfo + i), ptr);
            }
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)forMarshaling->pTexelBufferView;
    memcpy((*ptr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pTexelBufferView)
    {
        if ((!(vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER == forMarshaling->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER == forMarshaling->descriptorType))))
        {
            if (forMarshaling->descriptorCount)
            {
                uint8_t* cgen_var_3_0_ptr = (uint8_t*)(*ptr);
                if (forMarshaling)
                {
                    for (uint32_t k = 0; k < forMarshaling->descriptorCount; ++k)
                    {
                        uint64_t tmpval = get_host_u64_VkBufferView(forMarshaling->pTexelBufferView[k]);
                        memcpy(cgen_var_3_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
                    }
                }
                *ptr += 8 * forMarshaling->descriptorCount;
            }
        }
    }
}

void reservedmarshal_VkAttachmentDescription(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAttachmentDescription* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkAttachmentDescriptionFlags*)&forMarshaling->flags, sizeof(VkAttachmentDescriptionFlags));
    *ptr += sizeof(VkAttachmentDescriptionFlags);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy(*ptr, (VkAttachmentLoadOp*)&forMarshaling->loadOp, sizeof(VkAttachmentLoadOp));
    *ptr += sizeof(VkAttachmentLoadOp);
    memcpy(*ptr, (VkAttachmentStoreOp*)&forMarshaling->storeOp, sizeof(VkAttachmentStoreOp));
    *ptr += sizeof(VkAttachmentStoreOp);
    memcpy(*ptr, (VkAttachmentLoadOp*)&forMarshaling->stencilLoadOp, sizeof(VkAttachmentLoadOp));
    *ptr += sizeof(VkAttachmentLoadOp);
    memcpy(*ptr, (VkAttachmentStoreOp*)&forMarshaling->stencilStoreOp, sizeof(VkAttachmentStoreOp));
    *ptr += sizeof(VkAttachmentStoreOp);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->initialLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->finalLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedmarshal_VkAttachmentReference(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAttachmentReference* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->attachment, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->layout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedmarshal_VkFramebufferCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkFramebufferCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkFramebufferCreateFlags*)&forMarshaling->flags, sizeof(VkFramebufferCreateFlags));
    *ptr += sizeof(VkFramebufferCreateFlags);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkRenderPass((*&forMarshaling->renderPass));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->attachmentCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->attachmentCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkImageView(forMarshaling->pAttachments[k]);
                memcpy(cgen_var_1_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->attachmentCount;
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->height, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->layers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkSubpassDescription(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSubpassDescription* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkSubpassDescriptionFlags*)&forMarshaling->flags, sizeof(VkSubpassDescriptionFlags));
    *ptr += sizeof(VkSubpassDescriptionFlags);
    memcpy(*ptr, (VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    memcpy(*ptr, (uint32_t*)&forMarshaling->inputAttachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->inputAttachmentCount; ++i)
    {
        reservedmarshal_VkAttachmentReference(vkStream, rootType, (const VkAttachmentReference*)(forMarshaling->pInputAttachments + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->colorAttachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
    {
        reservedmarshal_VkAttachmentReference(vkStream, rootType, (const VkAttachmentReference*)(forMarshaling->pColorAttachments + i), ptr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pResolveAttachments;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pResolveAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
        {
            reservedmarshal_VkAttachmentReference(vkStream, rootType, (const VkAttachmentReference*)(forMarshaling->pResolveAttachments + i), ptr);
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pDepthStencilAttachment;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pDepthStencilAttachment)
    {
        reservedmarshal_VkAttachmentReference(vkStream, rootType, (const VkAttachmentReference*)(forMarshaling->pDepthStencilAttachment), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->preserveAttachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pPreserveAttachments, forMarshaling->preserveAttachmentCount * sizeof(const uint32_t));
    *ptr += forMarshaling->preserveAttachmentCount * sizeof(const uint32_t);
}

void reservedmarshal_VkSubpassDependency(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSubpassDependency* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->srcSubpass, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstSubpass, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkPipelineStageFlags*)&forMarshaling->srcStageMask, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
    memcpy(*ptr, (VkPipelineStageFlags*)&forMarshaling->dstStageMask, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy(*ptr, (VkDependencyFlags*)&forMarshaling->dependencyFlags, sizeof(VkDependencyFlags));
    *ptr += sizeof(VkDependencyFlags);
}

void reservedmarshal_VkRenderPassCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkRenderPassCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkRenderPassCreateFlags*)&forMarshaling->flags, sizeof(VkRenderPassCreateFlags));
    *ptr += sizeof(VkRenderPassCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentCount; ++i)
    {
        reservedmarshal_VkAttachmentDescription(vkStream, rootType, (const VkAttachmentDescription*)(forMarshaling->pAttachments + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->subpassCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->subpassCount; ++i)
    {
        reservedmarshal_VkSubpassDescription(vkStream, rootType, (const VkSubpassDescription*)(forMarshaling->pSubpasses + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->dependencyCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->dependencyCount; ++i)
    {
        reservedmarshal_VkSubpassDependency(vkStream, rootType, (const VkSubpassDependency*)(forMarshaling->pDependencies + i), ptr);
    }
}

void reservedmarshal_VkCommandPoolCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCommandPoolCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkCommandPoolCreateFlags*)&forMarshaling->flags, sizeof(VkCommandPoolCreateFlags));
    *ptr += sizeof(VkCommandPoolCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueFamilyIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkCommandBufferAllocateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCommandBufferAllocateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkCommandPool((*&forMarshaling->commandPool));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkCommandBufferLevel*)&forMarshaling->level, sizeof(VkCommandBufferLevel));
    *ptr += sizeof(VkCommandBufferLevel);
    memcpy(*ptr, (uint32_t*)&forMarshaling->commandBufferCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkCommandBufferInheritanceInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCommandBufferInheritanceInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkRenderPass((*&forMarshaling->renderPass));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->subpass, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkFramebuffer((*&forMarshaling->framebuffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkBool32*)&forMarshaling->occlusionQueryEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkQueryControlFlags*)&forMarshaling->queryFlags, sizeof(VkQueryControlFlags));
    *ptr += sizeof(VkQueryControlFlags);
    memcpy(*ptr, (VkQueryPipelineStatisticFlags*)&forMarshaling->pipelineStatistics, sizeof(VkQueryPipelineStatisticFlags));
    *ptr += sizeof(VkQueryPipelineStatisticFlags);
}

void reservedmarshal_VkCommandBufferBeginInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCommandBufferBeginInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkCommandBufferUsageFlags*)&forMarshaling->flags, sizeof(VkCommandBufferUsageFlags));
    *ptr += sizeof(VkCommandBufferUsageFlags);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pInheritanceInfo;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pInheritanceInfo)
    {
        reservedmarshal_VkCommandBufferInheritanceInfo(vkStream, rootType, (const VkCommandBufferInheritanceInfo*)(forMarshaling->pInheritanceInfo), ptr);
    }
}

void reservedmarshal_VkBufferCopy(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBufferCopy* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->srcOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->dstOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkImageSubresourceLayers(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageSubresourceLayers* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->mipLevel, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->baseArrayLayer, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->layerCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkBufferImageCopy(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBufferImageCopy* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->bufferOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (uint32_t*)&forMarshaling->bufferRowLength, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->bufferImageHeight, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forMarshaling->imageSubresource), ptr);
    reservedmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forMarshaling->imageOffset), ptr);
    reservedmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forMarshaling->imageExtent), ptr);
}

void reservedmarshal_VkClearColorValue(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkClearColorValue* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (float*)forMarshaling->float32, 4 * sizeof(float));
    *ptr += 4 * sizeof(float);
}

void reservedmarshal_VkClearDepthStencilValue(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkClearDepthStencilValue* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (float*)&forMarshaling->depth, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (uint32_t*)&forMarshaling->stencil, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkClearValue(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkClearValue* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    reservedmarshal_VkClearColorValue(vkStream, rootType, (VkClearColorValue*)(&forMarshaling->color), ptr);
}

void reservedmarshal_VkClearAttachment(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkClearAttachment* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->colorAttachment, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedmarshal_VkClearValue(vkStream, rootType, (VkClearValue*)(&forMarshaling->clearValue), ptr);
}

void reservedmarshal_VkClearRect(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkClearRect* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    reservedmarshal_VkRect2D(vkStream, rootType, (VkRect2D*)(&forMarshaling->rect), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->baseArrayLayer, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->layerCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkImageBlit(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageBlit* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    reservedmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource), ptr);
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        reservedmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(forMarshaling->srcOffsets + i), ptr);
    }
    reservedmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource), ptr);
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        reservedmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(forMarshaling->dstOffsets + i), ptr);
    }
}

void reservedmarshal_VkImageCopy(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageCopy* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    reservedmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource), ptr);
    reservedmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forMarshaling->srcOffset), ptr);
    reservedmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource), ptr);
    reservedmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forMarshaling->dstOffset), ptr);
    reservedmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forMarshaling->extent), ptr);
}

void reservedmarshal_VkImageResolve(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageResolve* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    reservedmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource), ptr);
    reservedmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forMarshaling->srcOffset), ptr);
    reservedmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource), ptr);
    reservedmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forMarshaling->dstOffset), ptr);
    reservedmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forMarshaling->extent), ptr);
}

void reservedmarshal_VkRenderPassBeginInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkRenderPassBeginInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkRenderPass((*&forMarshaling->renderPass));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkFramebuffer((*&forMarshaling->framebuffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    reservedmarshal_VkRect2D(vkStream, rootType, (VkRect2D*)(&forMarshaling->renderArea), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->clearValueCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)forMarshaling->pClearValues;
    memcpy((*ptr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pClearValues)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->clearValueCount; ++i)
        {
            reservedmarshal_VkClearValue(vkStream, rootType, (const VkClearValue*)(forMarshaling->pClearValues + i), ptr);
        }
    }
}

#endif
#ifdef VK_VERSION_1_1
void reservedmarshal_VkPhysicalDeviceSubgroupProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceSubgroupProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->subgroupSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkShaderStageFlags*)&forMarshaling->supportedStages, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    memcpy(*ptr, (VkSubgroupFeatureFlags*)&forMarshaling->supportedOperations, sizeof(VkSubgroupFeatureFlags));
    *ptr += sizeof(VkSubgroupFeatureFlags);
    memcpy(*ptr, (VkBool32*)&forMarshaling->quadOperationsInAllStages, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkBindBufferMemoryInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBindBufferMemoryInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDeviceMemory((*&forMarshaling->memory));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkBindImageMemoryInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBindImageMemoryInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&forMarshaling->image));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDeviceMemory((*&forMarshaling->memory));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkPhysicalDevice16BitStorageFeatures(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDevice16BitStorageFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->storageBuffer16BitAccess, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->uniformAndStorageBuffer16BitAccess, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->storagePushConstant16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->storageInputOutput16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkMemoryDedicatedRequirements(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMemoryDedicatedRequirements* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->prefersDedicatedAllocation, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->requiresDedicatedAllocation, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkMemoryDedicatedAllocateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMemoryDedicatedAllocateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&forMarshaling->image));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkMemoryAllocateFlagsInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMemoryAllocateFlagsInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkMemoryAllocateFlags*)&forMarshaling->flags, sizeof(VkMemoryAllocateFlags));
    *ptr += sizeof(VkMemoryAllocateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDeviceGroupRenderPassBeginInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceGroupRenderPassBeginInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceRenderAreaCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->deviceRenderAreaCount; ++i)
    {
        reservedmarshal_VkRect2D(vkStream, rootType, (const VkRect2D*)(forMarshaling->pDeviceRenderAreas + i), ptr);
    }
}

void reservedmarshal_VkDeviceGroupCommandBufferBeginInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceGroupCommandBufferBeginInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDeviceGroupSubmitInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceGroupSubmitInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pWaitSemaphoreDeviceIndices, forMarshaling->waitSemaphoreCount * sizeof(const uint32_t));
    *ptr += forMarshaling->waitSemaphoreCount * sizeof(const uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->commandBufferCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pCommandBufferDeviceMasks, forMarshaling->commandBufferCount * sizeof(const uint32_t));
    *ptr += forMarshaling->commandBufferCount * sizeof(const uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->signalSemaphoreCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pSignalSemaphoreDeviceIndices, forMarshaling->signalSemaphoreCount * sizeof(const uint32_t));
    *ptr += forMarshaling->signalSemaphoreCount * sizeof(const uint32_t);
}

void reservedmarshal_VkDeviceGroupBindSparseInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceGroupBindSparseInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->resourceDeviceIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->memoryDeviceIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkBindBufferMemoryDeviceGroupInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBindBufferMemoryDeviceGroupInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceIndexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pDeviceIndices, forMarshaling->deviceIndexCount * sizeof(const uint32_t));
    *ptr += forMarshaling->deviceIndexCount * sizeof(const uint32_t);
}

void reservedmarshal_VkBindImageMemoryDeviceGroupInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBindImageMemoryDeviceGroupInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceIndexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pDeviceIndices, forMarshaling->deviceIndexCount * sizeof(const uint32_t));
    *ptr += forMarshaling->deviceIndexCount * sizeof(const uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->splitInstanceBindRegionCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->splitInstanceBindRegionCount; ++i)
    {
        reservedmarshal_VkRect2D(vkStream, rootType, (const VkRect2D*)(forMarshaling->pSplitInstanceBindRegions + i), ptr);
    }
}

void reservedmarshal_VkPhysicalDeviceGroupProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceGroupProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->physicalDeviceCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkPhysicalDevice*)forMarshaling->physicalDevices, VK_MAX_DEVICE_GROUP_SIZE * sizeof(VkPhysicalDevice));
    *ptr += VK_MAX_DEVICE_GROUP_SIZE * sizeof(VkPhysicalDevice);
    memcpy(*ptr, (VkBool32*)&forMarshaling->subsetAllocation, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkDeviceGroupDeviceCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceGroupDeviceCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->physicalDeviceCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->physicalDeviceCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->physicalDeviceCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkPhysicalDevice(forMarshaling->pPhysicalDevices[k]);
                memcpy(cgen_var_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->physicalDeviceCount;
    }
}

void reservedmarshal_VkBufferMemoryRequirementsInfo2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBufferMemoryRequirementsInfo2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkImageMemoryRequirementsInfo2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageMemoryRequirementsInfo2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&forMarshaling->image));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkImageSparseMemoryRequirementsInfo2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageSparseMemoryRequirementsInfo2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&forMarshaling->image));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkMemoryRequirements2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMemoryRequirements2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkMemoryRequirements(vkStream, rootType, (VkMemoryRequirements*)(&forMarshaling->memoryRequirements), ptr);
}

void reservedmarshal_VkSparseImageMemoryRequirements2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSparseImageMemoryRequirements2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkSparseImageMemoryRequirements(vkStream, rootType, (VkSparseImageMemoryRequirements*)(&forMarshaling->memoryRequirements), ptr);
}

void reservedmarshal_VkPhysicalDeviceFeatures2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceFeatures2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkPhysicalDeviceFeatures(vkStream, rootType, (VkPhysicalDeviceFeatures*)(&forMarshaling->features), ptr);
}

void reservedmarshal_VkPhysicalDeviceProperties2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceProperties2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkPhysicalDeviceProperties(vkStream, rootType, (VkPhysicalDeviceProperties*)(&forMarshaling->properties), ptr);
}

void reservedmarshal_VkFormatProperties2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkFormatProperties2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkFormatProperties(vkStream, rootType, (VkFormatProperties*)(&forMarshaling->formatProperties), ptr);
}

void reservedmarshal_VkImageFormatProperties2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageFormatProperties2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkImageFormatProperties(vkStream, rootType, (VkImageFormatProperties*)(&forMarshaling->imageFormatProperties), ptr);
}

void reservedmarshal_VkPhysicalDeviceImageFormatInfo2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceImageFormatInfo2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (VkImageType*)&forMarshaling->type, sizeof(VkImageType));
    *ptr += sizeof(VkImageType);
    memcpy(*ptr, (VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
    *ptr += sizeof(VkImageTiling);
    memcpy(*ptr, (VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy(*ptr, (VkImageCreateFlags*)&forMarshaling->flags, sizeof(VkImageCreateFlags));
    *ptr += sizeof(VkImageCreateFlags);
}

void reservedmarshal_VkQueueFamilyProperties2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkQueueFamilyProperties2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkQueueFamilyProperties(vkStream, rootType, (VkQueueFamilyProperties*)(&forMarshaling->queueFamilyProperties), ptr);
}

void reservedmarshal_VkPhysicalDeviceMemoryProperties2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceMemoryProperties2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkPhysicalDeviceMemoryProperties(vkStream, rootType, (VkPhysicalDeviceMemoryProperties*)(&forMarshaling->memoryProperties), ptr);
}

void reservedmarshal_VkSparseImageFormatProperties2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSparseImageFormatProperties2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkSparseImageFormatProperties(vkStream, rootType, (VkSparseImageFormatProperties*)(&forMarshaling->properties), ptr);
}

void reservedmarshal_VkPhysicalDeviceSparseImageFormatInfo2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceSparseImageFormatInfo2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (VkImageType*)&forMarshaling->type, sizeof(VkImageType));
    *ptr += sizeof(VkImageType);
    memcpy(*ptr, (VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy(*ptr, (VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy(*ptr, (VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
    *ptr += sizeof(VkImageTiling);
}

void reservedmarshal_VkPhysicalDevicePointClippingProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDevicePointClippingProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPointClippingBehavior*)&forMarshaling->pointClippingBehavior, sizeof(VkPointClippingBehavior));
    *ptr += sizeof(VkPointClippingBehavior);
}

void reservedmarshal_VkInputAttachmentAspectReference(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkInputAttachmentAspectReference* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->subpass, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->inputAttachmentIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
}

void reservedmarshal_VkRenderPassInputAttachmentAspectCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkRenderPassInputAttachmentAspectCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->aspectReferenceCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->aspectReferenceCount; ++i)
    {
        reservedmarshal_VkInputAttachmentAspectReference(vkStream, rootType, (const VkInputAttachmentAspectReference*)(forMarshaling->pAspectReferences + i), ptr);
    }
}

void reservedmarshal_VkImageViewUsageCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageViewUsageCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
}

void reservedmarshal_VkPipelineTessellationDomainOriginStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineTessellationDomainOriginStateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkTessellationDomainOrigin*)&forMarshaling->domainOrigin, sizeof(VkTessellationDomainOrigin));
    *ptr += sizeof(VkTessellationDomainOrigin);
}

void reservedmarshal_VkRenderPassMultiviewCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkRenderPassMultiviewCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->subpassCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pViewMasks, forMarshaling->subpassCount * sizeof(const uint32_t));
    *ptr += forMarshaling->subpassCount * sizeof(const uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dependencyCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const int32_t*)forMarshaling->pViewOffsets, forMarshaling->dependencyCount * sizeof(const int32_t));
    *ptr += forMarshaling->dependencyCount * sizeof(const int32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->correlationMaskCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pCorrelationMasks, forMarshaling->correlationMaskCount * sizeof(const uint32_t));
    *ptr += forMarshaling->correlationMaskCount * sizeof(const uint32_t);
}

void reservedmarshal_VkPhysicalDeviceMultiviewFeatures(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceMultiviewFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->multiview, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->multiviewGeometryShader, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->multiviewTessellationShader, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceMultiviewProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceMultiviewProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxMultiviewViewCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxMultiviewInstanceIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPhysicalDeviceVariablePointersFeatures(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceVariablePointersFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->variablePointersStorageBuffer, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->variablePointers, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceProtectedMemoryFeatures(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceProtectedMemoryFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->protectedMemory, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceProtectedMemoryProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceProtectedMemoryProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->protectedNoFault, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkDeviceQueueInfo2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceQueueInfo2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceQueueCreateFlags*)&forMarshaling->flags, sizeof(VkDeviceQueueCreateFlags));
    *ptr += sizeof(VkDeviceQueueCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueFamilyIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkProtectedSubmitInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkProtectedSubmitInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->protectedSubmit, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkSamplerYcbcrConversionCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSamplerYcbcrConversionCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (VkSamplerYcbcrModelConversion*)&forMarshaling->ycbcrModel, sizeof(VkSamplerYcbcrModelConversion));
    *ptr += sizeof(VkSamplerYcbcrModelConversion);
    memcpy(*ptr, (VkSamplerYcbcrRange*)&forMarshaling->ycbcrRange, sizeof(VkSamplerYcbcrRange));
    *ptr += sizeof(VkSamplerYcbcrRange);
    reservedmarshal_VkComponentMapping(vkStream, rootType, (VkComponentMapping*)(&forMarshaling->components), ptr);
    memcpy(*ptr, (VkChromaLocation*)&forMarshaling->xChromaOffset, sizeof(VkChromaLocation));
    *ptr += sizeof(VkChromaLocation);
    memcpy(*ptr, (VkChromaLocation*)&forMarshaling->yChromaOffset, sizeof(VkChromaLocation));
    *ptr += sizeof(VkChromaLocation);
    memcpy(*ptr, (VkFilter*)&forMarshaling->chromaFilter, sizeof(VkFilter));
    *ptr += sizeof(VkFilter);
    memcpy(*ptr, (VkBool32*)&forMarshaling->forceExplicitReconstruction, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkSamplerYcbcrConversionInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSamplerYcbcrConversionInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkSamplerYcbcrConversion((*&forMarshaling->conversion));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkBindImagePlaneMemoryInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBindImagePlaneMemoryInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkImageAspectFlagBits*)&forMarshaling->planeAspect, sizeof(VkImageAspectFlagBits));
    *ptr += sizeof(VkImageAspectFlagBits);
}

void reservedmarshal_VkImagePlaneMemoryRequirementsInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImagePlaneMemoryRequirementsInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkImageAspectFlagBits*)&forMarshaling->planeAspect, sizeof(VkImageAspectFlagBits));
    *ptr += sizeof(VkImageAspectFlagBits);
}

void reservedmarshal_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->samplerYcbcrConversion, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkSamplerYcbcrConversionImageFormatProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSamplerYcbcrConversionImageFormatProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->combinedImageSamplerDescriptorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDescriptorUpdateTemplateEntry(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDescriptorUpdateTemplateEntry* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstBinding, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstArrayElement, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkDescriptorType*)&forMarshaling->descriptorType, sizeof(VkDescriptorType));
    *ptr += sizeof(VkDescriptorType);
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->offset;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    uint64_t cgen_var_1 = (uint64_t)forMarshaling->stride;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
}

void reservedmarshal_VkDescriptorUpdateTemplateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDescriptorUpdateTemplateCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDescriptorUpdateTemplateCreateFlags*)&forMarshaling->flags, sizeof(VkDescriptorUpdateTemplateCreateFlags));
    *ptr += sizeof(VkDescriptorUpdateTemplateCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->descriptorUpdateEntryCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->descriptorUpdateEntryCount; ++i)
    {
        reservedmarshal_VkDescriptorUpdateTemplateEntry(vkStream, rootType, (const VkDescriptorUpdateTemplateEntry*)(forMarshaling->pDescriptorUpdateEntries + i), ptr);
    }
    memcpy(*ptr, (VkDescriptorUpdateTemplateType*)&forMarshaling->templateType, sizeof(VkDescriptorUpdateTemplateType));
    *ptr += sizeof(VkDescriptorUpdateTemplateType);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDescriptorSetLayout((*&forMarshaling->descriptorSetLayout));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkPipelineLayout((*&forMarshaling->pipelineLayout));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->set, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkExternalMemoryProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExternalMemoryProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkExternalMemoryFeatureFlags*)&forMarshaling->externalMemoryFeatures, sizeof(VkExternalMemoryFeatureFlags));
    *ptr += sizeof(VkExternalMemoryFeatureFlags);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlags*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlags*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
}

void reservedmarshal_VkPhysicalDeviceExternalImageFormatInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceExternalImageFormatInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

void reservedmarshal_VkExternalImageFormatProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExternalImageFormatProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkExternalMemoryProperties(vkStream, rootType, (VkExternalMemoryProperties*)(&forMarshaling->externalMemoryProperties), ptr);
}

void reservedmarshal_VkPhysicalDeviceExternalBufferInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceExternalBufferInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBufferCreateFlags*)&forMarshaling->flags, sizeof(VkBufferCreateFlags));
    *ptr += sizeof(VkBufferCreateFlags);
    memcpy(*ptr, (VkBufferUsageFlags*)&forMarshaling->usage, sizeof(VkBufferUsageFlags));
    *ptr += sizeof(VkBufferUsageFlags);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

void reservedmarshal_VkExternalBufferProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExternalBufferProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkExternalMemoryProperties(vkStream, rootType, (VkExternalMemoryProperties*)(&forMarshaling->externalMemoryProperties), ptr);
}

void reservedmarshal_VkPhysicalDeviceIDProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceIDProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint8_t*)forMarshaling->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t));
    *ptr += VK_UUID_SIZE * sizeof(uint8_t);
    memcpy(*ptr, (uint8_t*)forMarshaling->driverUUID, VK_UUID_SIZE * sizeof(uint8_t));
    *ptr += VK_UUID_SIZE * sizeof(uint8_t);
    memcpy(*ptr, (uint8_t*)forMarshaling->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t));
    *ptr += VK_LUID_SIZE * sizeof(uint8_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceNodeMask, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkBool32*)&forMarshaling->deviceLUIDValid, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkExternalMemoryImageCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExternalMemoryImageCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
}

void reservedmarshal_VkExternalMemoryBufferCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExternalMemoryBufferCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
}

void reservedmarshal_VkExportMemoryAllocateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExportMemoryAllocateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlags);
}

void reservedmarshal_VkPhysicalDeviceExternalFenceInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceExternalFenceInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
}

void reservedmarshal_VkExternalFenceProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExternalFenceProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalFenceHandleTypeFlags*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalFenceHandleTypeFlags));
    *ptr += sizeof(VkExternalFenceHandleTypeFlags);
    memcpy(*ptr, (VkExternalFenceHandleTypeFlags*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalFenceHandleTypeFlags));
    *ptr += sizeof(VkExternalFenceHandleTypeFlags);
    memcpy(*ptr, (VkExternalFenceFeatureFlags*)&forMarshaling->externalFenceFeatures, sizeof(VkExternalFenceFeatureFlags));
    *ptr += sizeof(VkExternalFenceFeatureFlags);
}

void reservedmarshal_VkExportFenceCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExportFenceCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalFenceHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalFenceHandleTypeFlags));
    *ptr += sizeof(VkExternalFenceHandleTypeFlags);
}

void reservedmarshal_VkExportSemaphoreCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExportSemaphoreCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalSemaphoreHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlags);
}

void reservedmarshal_VkPhysicalDeviceExternalSemaphoreInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceExternalSemaphoreInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
}

void reservedmarshal_VkExternalSemaphoreProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExternalSemaphoreProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalSemaphoreHandleTypeFlags*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlags);
    memcpy(*ptr, (VkExternalSemaphoreHandleTypeFlags*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlags);
    memcpy(*ptr, (VkExternalSemaphoreFeatureFlags*)&forMarshaling->externalSemaphoreFeatures, sizeof(VkExternalSemaphoreFeatureFlags));
    *ptr += sizeof(VkExternalSemaphoreFeatureFlags);
}

void reservedmarshal_VkPhysicalDeviceMaintenance3Properties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceMaintenance3Properties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerSetDescriptors, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->maxMemoryAllocationSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkDescriptorSetLayoutSupport(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDescriptorSetLayoutSupport* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->supported, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceShaderDrawParametersFeatures(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderDrawParametersFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderDrawParameters, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_VERSION_1_2
void reservedmarshal_VkPhysicalDeviceVulkan11Features(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceVulkan11Features* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->storageBuffer16BitAccess, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->uniformAndStorageBuffer16BitAccess, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->storagePushConstant16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->storageInputOutput16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->multiview, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->multiviewGeometryShader, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->multiviewTessellationShader, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->variablePointersStorageBuffer, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->variablePointers, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->protectedMemory, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->samplerYcbcrConversion, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderDrawParameters, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceVulkan11Properties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceVulkan11Properties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint8_t*)forMarshaling->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t));
    *ptr += VK_UUID_SIZE * sizeof(uint8_t);
    memcpy(*ptr, (uint8_t*)forMarshaling->driverUUID, VK_UUID_SIZE * sizeof(uint8_t));
    *ptr += VK_UUID_SIZE * sizeof(uint8_t);
    memcpy(*ptr, (uint8_t*)forMarshaling->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t));
    *ptr += VK_LUID_SIZE * sizeof(uint8_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceNodeMask, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkBool32*)&forMarshaling->deviceLUIDValid, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (uint32_t*)&forMarshaling->subgroupSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkShaderStageFlags*)&forMarshaling->subgroupSupportedStages, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    memcpy(*ptr, (VkSubgroupFeatureFlags*)&forMarshaling->subgroupSupportedOperations, sizeof(VkSubgroupFeatureFlags));
    *ptr += sizeof(VkSubgroupFeatureFlags);
    memcpy(*ptr, (VkBool32*)&forMarshaling->subgroupQuadOperationsInAllStages, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkPointClippingBehavior*)&forMarshaling->pointClippingBehavior, sizeof(VkPointClippingBehavior));
    *ptr += sizeof(VkPointClippingBehavior);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxMultiviewViewCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxMultiviewInstanceIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkBool32*)&forMarshaling->protectedNoFault, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerSetDescriptors, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->maxMemoryAllocationSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkPhysicalDeviceVulkan12Features(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceVulkan12Features* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->samplerMirrorClampToEdge, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->drawIndirectCount, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->storageBuffer8BitAccess, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->uniformAndStorageBuffer8BitAccess, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->storagePushConstant8, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderBufferInt64Atomics, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSharedInt64Atomics, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderFloat16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderInt8, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderInputAttachmentArrayDynamicIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderUniformTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderUniformBufferArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSampledImageArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageBufferArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageImageArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderInputAttachmentArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderUniformTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingUniformBufferUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingSampledImageUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingStorageImageUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingStorageBufferUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingUniformTexelBufferUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingStorageTexelBufferUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingUpdateUnusedWhilePending, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingPartiallyBound, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingVariableDescriptorCount, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->runtimeDescriptorArray, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->samplerFilterMinmax, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->scalarBlockLayout, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->imagelessFramebuffer, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->uniformBufferStandardLayout, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSubgroupExtendedTypes, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->separateDepthStencilLayouts, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->hostQueryReset, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->timelineSemaphore, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->bufferDeviceAddress, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->bufferDeviceAddressCaptureReplay, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->bufferDeviceAddressMultiDevice, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->vulkanMemoryModel, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->vulkanMemoryModelDeviceScope, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->vulkanMemoryModelAvailabilityVisibilityChains, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderOutputViewportIndex, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderOutputLayer, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->subgroupBroadcastDynamicId, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkConformanceVersion(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkConformanceVersion* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint8_t*)&forMarshaling->major, sizeof(uint8_t));
    *ptr += sizeof(uint8_t);
    memcpy(*ptr, (uint8_t*)&forMarshaling->minor, sizeof(uint8_t));
    *ptr += sizeof(uint8_t);
    memcpy(*ptr, (uint8_t*)&forMarshaling->subminor, sizeof(uint8_t));
    *ptr += sizeof(uint8_t);
    memcpy(*ptr, (uint8_t*)&forMarshaling->patch, sizeof(uint8_t));
    *ptr += sizeof(uint8_t);
}

void reservedmarshal_VkPhysicalDeviceVulkan12Properties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceVulkan12Properties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDriverId*)&forMarshaling->driverID, sizeof(VkDriverId));
    *ptr += sizeof(VkDriverId);
    memcpy(*ptr, (char*)forMarshaling->driverName, VK_MAX_DRIVER_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_DRIVER_NAME_SIZE * sizeof(char);
    memcpy(*ptr, (char*)forMarshaling->driverInfo, VK_MAX_DRIVER_INFO_SIZE * sizeof(char));
    *ptr += VK_MAX_DRIVER_INFO_SIZE * sizeof(char);
    reservedmarshal_VkConformanceVersion(vkStream, rootType, (VkConformanceVersion*)(&forMarshaling->conformanceVersion), ptr);
    memcpy(*ptr, (VkShaderFloatControlsIndependence*)&forMarshaling->denormBehaviorIndependence, sizeof(VkShaderFloatControlsIndependence));
    *ptr += sizeof(VkShaderFloatControlsIndependence);
    memcpy(*ptr, (VkShaderFloatControlsIndependence*)&forMarshaling->roundingModeIndependence, sizeof(VkShaderFloatControlsIndependence));
    *ptr += sizeof(VkShaderFloatControlsIndependence);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSignedZeroInfNanPreserveFloat16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSignedZeroInfNanPreserveFloat32, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSignedZeroInfNanPreserveFloat64, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderDenormPreserveFloat16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderDenormPreserveFloat32, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderDenormPreserveFloat64, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderDenormFlushToZeroFloat16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderDenormFlushToZeroFloat32, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderDenormFlushToZeroFloat64, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderRoundingModeRTEFloat16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderRoundingModeRTEFloat32, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderRoundingModeRTEFloat64, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderRoundingModeRTZFloat16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderRoundingModeRTZFloat32, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderRoundingModeRTZFloat64, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxUpdateAfterBindDescriptorsInAllPools, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderUniformBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSampledImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderInputAttachmentArrayNonUniformIndexingNative, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->robustBufferAccessUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->quadDivergentImplicitLod, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindSamplers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindSampledImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindStorageImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindInputAttachments, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageUpdateAfterBindResources, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindSamplers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindSampledImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindInputAttachments, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkResolveModeFlags*)&forMarshaling->supportedDepthResolveModes, sizeof(VkResolveModeFlags));
    *ptr += sizeof(VkResolveModeFlags);
    memcpy(*ptr, (VkResolveModeFlags*)&forMarshaling->supportedStencilResolveModes, sizeof(VkResolveModeFlags));
    *ptr += sizeof(VkResolveModeFlags);
    memcpy(*ptr, (VkBool32*)&forMarshaling->independentResolveNone, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->independentResolve, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->filterMinmaxSingleComponentFormats, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->filterMinmaxImageComponentMapping, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (uint64_t*)&forMarshaling->maxTimelineSemaphoreValueDifference, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->framebufferIntegerColorSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
}

void reservedmarshal_VkImageFormatListCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageFormatListCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->viewFormatCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const VkFormat*)forMarshaling->pViewFormats, forMarshaling->viewFormatCount * sizeof(const VkFormat));
    *ptr += forMarshaling->viewFormatCount * sizeof(const VkFormat);
}

void reservedmarshal_VkAttachmentDescription2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAttachmentDescription2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkAttachmentDescriptionFlags*)&forMarshaling->flags, sizeof(VkAttachmentDescriptionFlags));
    *ptr += sizeof(VkAttachmentDescriptionFlags);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy(*ptr, (VkAttachmentLoadOp*)&forMarshaling->loadOp, sizeof(VkAttachmentLoadOp));
    *ptr += sizeof(VkAttachmentLoadOp);
    memcpy(*ptr, (VkAttachmentStoreOp*)&forMarshaling->storeOp, sizeof(VkAttachmentStoreOp));
    *ptr += sizeof(VkAttachmentStoreOp);
    memcpy(*ptr, (VkAttachmentLoadOp*)&forMarshaling->stencilLoadOp, sizeof(VkAttachmentLoadOp));
    *ptr += sizeof(VkAttachmentLoadOp);
    memcpy(*ptr, (VkAttachmentStoreOp*)&forMarshaling->stencilStoreOp, sizeof(VkAttachmentStoreOp));
    *ptr += sizeof(VkAttachmentStoreOp);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->initialLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->finalLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedmarshal_VkAttachmentReference2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAttachmentReference2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->attachment, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->layout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy(*ptr, (VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    *ptr += sizeof(VkImageAspectFlags);
}

void reservedmarshal_VkSubpassDescription2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSubpassDescription2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSubpassDescriptionFlags*)&forMarshaling->flags, sizeof(VkSubpassDescriptionFlags));
    *ptr += sizeof(VkSubpassDescriptionFlags);
    memcpy(*ptr, (VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    memcpy(*ptr, (uint32_t*)&forMarshaling->viewMask, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->inputAttachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->inputAttachmentCount; ++i)
    {
        reservedmarshal_VkAttachmentReference2(vkStream, rootType, (const VkAttachmentReference2*)(forMarshaling->pInputAttachments + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->colorAttachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
    {
        reservedmarshal_VkAttachmentReference2(vkStream, rootType, (const VkAttachmentReference2*)(forMarshaling->pColorAttachments + i), ptr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pResolveAttachments;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pResolveAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
        {
            reservedmarshal_VkAttachmentReference2(vkStream, rootType, (const VkAttachmentReference2*)(forMarshaling->pResolveAttachments + i), ptr);
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pDepthStencilAttachment;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pDepthStencilAttachment)
    {
        reservedmarshal_VkAttachmentReference2(vkStream, rootType, (const VkAttachmentReference2*)(forMarshaling->pDepthStencilAttachment), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->preserveAttachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pPreserveAttachments, forMarshaling->preserveAttachmentCount * sizeof(const uint32_t));
    *ptr += forMarshaling->preserveAttachmentCount * sizeof(const uint32_t);
}

void reservedmarshal_VkSubpassDependency2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSubpassDependency2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->srcSubpass, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dstSubpass, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkPipelineStageFlags*)&forMarshaling->srcStageMask, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
    memcpy(*ptr, (VkPipelineStageFlags*)&forMarshaling->dstStageMask, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy(*ptr, (VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    *ptr += sizeof(VkAccessFlags);
    memcpy(*ptr, (VkDependencyFlags*)&forMarshaling->dependencyFlags, sizeof(VkDependencyFlags));
    *ptr += sizeof(VkDependencyFlags);
    memcpy(*ptr, (int32_t*)&forMarshaling->viewOffset, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedmarshal_VkRenderPassCreateInfo2(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkRenderPassCreateInfo2* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkRenderPassCreateFlags*)&forMarshaling->flags, sizeof(VkRenderPassCreateFlags));
    *ptr += sizeof(VkRenderPassCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentCount; ++i)
    {
        reservedmarshal_VkAttachmentDescription2(vkStream, rootType, (const VkAttachmentDescription2*)(forMarshaling->pAttachments + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->subpassCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->subpassCount; ++i)
    {
        reservedmarshal_VkSubpassDescription2(vkStream, rootType, (const VkSubpassDescription2*)(forMarshaling->pSubpasses + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->dependencyCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->dependencyCount; ++i)
    {
        reservedmarshal_VkSubpassDependency2(vkStream, rootType, (const VkSubpassDependency2*)(forMarshaling->pDependencies + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->correlatedViewMaskCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pCorrelatedViewMasks, forMarshaling->correlatedViewMaskCount * sizeof(const uint32_t));
    *ptr += forMarshaling->correlatedViewMaskCount * sizeof(const uint32_t);
}

void reservedmarshal_VkSubpassBeginInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSubpassBeginInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSubpassContents*)&forMarshaling->contents, sizeof(VkSubpassContents));
    *ptr += sizeof(VkSubpassContents);
}

void reservedmarshal_VkSubpassEndInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSubpassEndInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
}

void reservedmarshal_VkPhysicalDevice8BitStorageFeatures(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDevice8BitStorageFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->storageBuffer8BitAccess, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->uniformAndStorageBuffer8BitAccess, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->storagePushConstant8, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceDriverProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceDriverProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDriverId*)&forMarshaling->driverID, sizeof(VkDriverId));
    *ptr += sizeof(VkDriverId);
    memcpy(*ptr, (char*)forMarshaling->driverName, VK_MAX_DRIVER_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_DRIVER_NAME_SIZE * sizeof(char);
    memcpy(*ptr, (char*)forMarshaling->driverInfo, VK_MAX_DRIVER_INFO_SIZE * sizeof(char));
    *ptr += VK_MAX_DRIVER_INFO_SIZE * sizeof(char);
    reservedmarshal_VkConformanceVersion(vkStream, rootType, (VkConformanceVersion*)(&forMarshaling->conformanceVersion), ptr);
}

void reservedmarshal_VkPhysicalDeviceShaderAtomicInt64Features(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderAtomicInt64Features* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderBufferInt64Atomics, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSharedInt64Atomics, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceShaderFloat16Int8Features(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderFloat16Int8Features* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderFloat16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderInt8, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceFloatControlsProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceFloatControlsProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkShaderFloatControlsIndependence*)&forMarshaling->denormBehaviorIndependence, sizeof(VkShaderFloatControlsIndependence));
    *ptr += sizeof(VkShaderFloatControlsIndependence);
    memcpy(*ptr, (VkShaderFloatControlsIndependence*)&forMarshaling->roundingModeIndependence, sizeof(VkShaderFloatControlsIndependence));
    *ptr += sizeof(VkShaderFloatControlsIndependence);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSignedZeroInfNanPreserveFloat16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSignedZeroInfNanPreserveFloat32, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSignedZeroInfNanPreserveFloat64, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderDenormPreserveFloat16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderDenormPreserveFloat32, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderDenormPreserveFloat64, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderDenormFlushToZeroFloat16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderDenormFlushToZeroFloat32, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderDenormFlushToZeroFloat64, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderRoundingModeRTEFloat16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderRoundingModeRTEFloat32, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderRoundingModeRTEFloat64, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderRoundingModeRTZFloat16, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderRoundingModeRTZFloat32, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderRoundingModeRTZFloat64, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkDescriptorSetLayoutBindingFlagsCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDescriptorSetLayoutBindingFlagsCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->bindingCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pBindingFlags;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pBindingFlags)
    {
        memcpy(*ptr, (const VkDescriptorBindingFlags*)forMarshaling->pBindingFlags, forMarshaling->bindingCount * sizeof(const VkDescriptorBindingFlags));
        *ptr += forMarshaling->bindingCount * sizeof(const VkDescriptorBindingFlags);
    }
}

void reservedmarshal_VkPhysicalDeviceDescriptorIndexingFeatures(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceDescriptorIndexingFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderInputAttachmentArrayDynamicIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderUniformTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderUniformBufferArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSampledImageArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageBufferArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageImageArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderInputAttachmentArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderUniformTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingUniformBufferUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingSampledImageUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingStorageImageUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingStorageBufferUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingUniformTexelBufferUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingStorageTexelBufferUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingUpdateUnusedWhilePending, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingPartiallyBound, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingVariableDescriptorCount, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->runtimeDescriptorArray, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceDescriptorIndexingProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceDescriptorIndexingProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxUpdateAfterBindDescriptorsInAllPools, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderUniformBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSampledImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderStorageImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderInputAttachmentArrayNonUniformIndexingNative, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->robustBufferAccessUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->quadDivergentImplicitLod, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindSamplers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindSampledImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindStorageImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindInputAttachments, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageUpdateAfterBindResources, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindSamplers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindSampledImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageImages, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindInputAttachments, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDescriptorSetVariableDescriptorCountAllocateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDescriptorSetVariableDescriptorCountAllocateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->descriptorSetCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pDescriptorCounts, forMarshaling->descriptorSetCount * sizeof(const uint32_t));
    *ptr += forMarshaling->descriptorSetCount * sizeof(const uint32_t);
}

void reservedmarshal_VkDescriptorSetVariableDescriptorCountLayoutSupport(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDescriptorSetVariableDescriptorCountLayoutSupport* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxVariableDescriptorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkSubpassDescriptionDepthStencilResolve(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSubpassDescriptionDepthStencilResolve* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkResolveModeFlagBits*)&forMarshaling->depthResolveMode, sizeof(VkResolveModeFlagBits));
    *ptr += sizeof(VkResolveModeFlagBits);
    memcpy(*ptr, (VkResolveModeFlagBits*)&forMarshaling->stencilResolveMode, sizeof(VkResolveModeFlagBits));
    *ptr += sizeof(VkResolveModeFlagBits);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pDepthStencilResolveAttachment;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pDepthStencilResolveAttachment)
    {
        reservedmarshal_VkAttachmentReference2(vkStream, rootType, (const VkAttachmentReference2*)(forMarshaling->pDepthStencilResolveAttachment), ptr);
    }
}

void reservedmarshal_VkPhysicalDeviceDepthStencilResolveProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceDepthStencilResolveProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkResolveModeFlags*)&forMarshaling->supportedDepthResolveModes, sizeof(VkResolveModeFlags));
    *ptr += sizeof(VkResolveModeFlags);
    memcpy(*ptr, (VkResolveModeFlags*)&forMarshaling->supportedStencilResolveModes, sizeof(VkResolveModeFlags));
    *ptr += sizeof(VkResolveModeFlags);
    memcpy(*ptr, (VkBool32*)&forMarshaling->independentResolveNone, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->independentResolve, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceScalarBlockLayoutFeatures(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceScalarBlockLayoutFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->scalarBlockLayout, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkImageStencilUsageCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageStencilUsageCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkImageUsageFlags*)&forMarshaling->stencilUsage, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
}

void reservedmarshal_VkSamplerReductionModeCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSamplerReductionModeCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSamplerReductionMode*)&forMarshaling->reductionMode, sizeof(VkSamplerReductionMode));
    *ptr += sizeof(VkSamplerReductionMode);
}

void reservedmarshal_VkPhysicalDeviceSamplerFilterMinmaxProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceSamplerFilterMinmaxProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->filterMinmaxSingleComponentFormats, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->filterMinmaxImageComponentMapping, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceVulkanMemoryModelFeatures(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceVulkanMemoryModelFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->vulkanMemoryModel, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->vulkanMemoryModelDeviceScope, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->vulkanMemoryModelAvailabilityVisibilityChains, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceImagelessFramebufferFeatures(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceImagelessFramebufferFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->imagelessFramebuffer, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkFramebufferAttachmentImageInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkFramebufferAttachmentImageInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkImageCreateFlags*)&forMarshaling->flags, sizeof(VkImageCreateFlags));
    *ptr += sizeof(VkImageCreateFlags);
    memcpy(*ptr, (VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->height, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->layerCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->viewFormatCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const VkFormat*)forMarshaling->pViewFormats, forMarshaling->viewFormatCount * sizeof(const VkFormat));
    *ptr += forMarshaling->viewFormatCount * sizeof(const VkFormat);
}

void reservedmarshal_VkFramebufferAttachmentsCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkFramebufferAttachmentsCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->attachmentImageInfoCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentImageInfoCount; ++i)
    {
        reservedmarshal_VkFramebufferAttachmentImageInfo(vkStream, rootType, (const VkFramebufferAttachmentImageInfo*)(forMarshaling->pAttachmentImageInfos + i), ptr);
    }
}

void reservedmarshal_VkRenderPassAttachmentBeginInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkRenderPassAttachmentBeginInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->attachmentCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->attachmentCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkImageView(forMarshaling->pAttachments[k]);
                memcpy(cgen_var_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->attachmentCount;
    }
}

void reservedmarshal_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceUniformBufferStandardLayoutFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->uniformBufferStandardLayout, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSubgroupExtendedTypes, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->separateDepthStencilLayouts, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkAttachmentReferenceStencilLayout(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAttachmentReferenceStencilLayout* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->stencilLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedmarshal_VkAttachmentDescriptionStencilLayout(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAttachmentDescriptionStencilLayout* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->stencilInitialLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->stencilFinalLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
}

void reservedmarshal_VkPhysicalDeviceHostQueryResetFeatures(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceHostQueryResetFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->hostQueryReset, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceTimelineSemaphoreFeatures(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceTimelineSemaphoreFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->timelineSemaphore, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceTimelineSemaphoreProperties(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceTimelineSemaphoreProperties* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint64_t*)&forMarshaling->maxTimelineSemaphoreValueDifference, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedmarshal_VkSemaphoreTypeCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSemaphoreTypeCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSemaphoreType*)&forMarshaling->semaphoreType, sizeof(VkSemaphoreType));
    *ptr += sizeof(VkSemaphoreType);
    memcpy(*ptr, (uint64_t*)&forMarshaling->initialValue, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedmarshal_VkTimelineSemaphoreSubmitInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkTimelineSemaphoreSubmitInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->waitSemaphoreValueCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pWaitSemaphoreValues;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pWaitSemaphoreValues)
    {
        memcpy(*ptr, (const uint64_t*)forMarshaling->pWaitSemaphoreValues, forMarshaling->waitSemaphoreValueCount * sizeof(const uint64_t));
        *ptr += forMarshaling->waitSemaphoreValueCount * sizeof(const uint64_t);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->signalSemaphoreValueCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pSignalSemaphoreValues;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pSignalSemaphoreValues)
    {
        memcpy(*ptr, (const uint64_t*)forMarshaling->pSignalSemaphoreValues, forMarshaling->signalSemaphoreValueCount * sizeof(const uint64_t));
        *ptr += forMarshaling->signalSemaphoreValueCount * sizeof(const uint64_t);
    }
}

void reservedmarshal_VkSemaphoreWaitInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSemaphoreWaitInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSemaphoreWaitFlags*)&forMarshaling->flags, sizeof(VkSemaphoreWaitFlags));
    *ptr += sizeof(VkSemaphoreWaitFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->semaphoreCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->semaphoreCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->semaphoreCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkSemaphore(forMarshaling->pSemaphores[k]);
                memcpy(cgen_var_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->semaphoreCount;
    }
    memcpy(*ptr, (const uint64_t*)forMarshaling->pValues, forMarshaling->semaphoreCount * sizeof(const uint64_t));
    *ptr += forMarshaling->semaphoreCount * sizeof(const uint64_t);
}

void reservedmarshal_VkSemaphoreSignalInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSemaphoreSignalInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkSemaphore((*&forMarshaling->semaphore));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint64_t*)&forMarshaling->value, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedmarshal_VkPhysicalDeviceBufferDeviceAddressFeatures(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceBufferDeviceAddressFeatures* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->bufferDeviceAddress, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->bufferDeviceAddressCaptureReplay, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->bufferDeviceAddressMultiDevice, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkBufferDeviceAddressInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBufferDeviceAddressInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkBufferOpaqueCaptureAddressCreateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBufferOpaqueCaptureAddressCreateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint64_t*)&forMarshaling->opaqueCaptureAddress, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedmarshal_VkMemoryOpaqueCaptureAddressAllocateInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMemoryOpaqueCaptureAddressAllocateInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint64_t*)&forMarshaling->opaqueCaptureAddress, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedmarshal_VkDeviceMemoryOpaqueCaptureAddressInfo(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceMemoryOpaqueCaptureAddressInfo* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDeviceMemory((*&forMarshaling->memory));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
}

#endif
#ifdef VK_KHR_surface
void reservedmarshal_VkSurfaceCapabilitiesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSurfaceCapabilitiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->minImageCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxImageCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->currentExtent), ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->minImageExtent), ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->maxImageExtent), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxImageArrayLayers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkSurfaceTransformFlagsKHR*)&forMarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagsKHR);
    memcpy(*ptr, (VkSurfaceTransformFlagBitsKHR*)&forMarshaling->currentTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
    memcpy(*ptr, (VkCompositeAlphaFlagsKHR*)&forMarshaling->supportedCompositeAlpha, sizeof(VkCompositeAlphaFlagsKHR));
    *ptr += sizeof(VkCompositeAlphaFlagsKHR);
    memcpy(*ptr, (VkImageUsageFlags*)&forMarshaling->supportedUsageFlags, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
}

void reservedmarshal_VkSurfaceFormatKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSurfaceFormatKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (VkColorSpaceKHR*)&forMarshaling->colorSpace, sizeof(VkColorSpaceKHR));
    *ptr += sizeof(VkColorSpaceKHR);
}

#endif
#ifdef VK_KHR_swapchain
void reservedmarshal_VkSwapchainCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSwapchainCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSwapchainCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkSwapchainCreateFlagsKHR));
    *ptr += sizeof(VkSwapchainCreateFlagsKHR);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkSurfaceKHR((*&forMarshaling->surface));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->minImageCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkFormat*)&forMarshaling->imageFormat, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (VkColorSpaceKHR*)&forMarshaling->imageColorSpace, sizeof(VkColorSpaceKHR));
    *ptr += sizeof(VkColorSpaceKHR);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->imageExtent), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->imageArrayLayers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkImageUsageFlags*)&forMarshaling->imageUsage, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy(*ptr, (VkSharingMode*)&forMarshaling->imageSharingMode, sizeof(VkSharingMode));
    *ptr += sizeof(VkSharingMode);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pQueueFamilyIndices;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pQueueFamilyIndices)
    {
        memcpy(*ptr, (const uint32_t*)forMarshaling->pQueueFamilyIndices, forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        *ptr += forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t);
    }
    memcpy(*ptr, (VkSurfaceTransformFlagBitsKHR*)&forMarshaling->preTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
    memcpy(*ptr, (VkCompositeAlphaFlagBitsKHR*)&forMarshaling->compositeAlpha, sizeof(VkCompositeAlphaFlagBitsKHR));
    *ptr += sizeof(VkCompositeAlphaFlagBitsKHR);
    memcpy(*ptr, (VkPresentModeKHR*)&forMarshaling->presentMode, sizeof(VkPresentModeKHR));
    *ptr += sizeof(VkPresentModeKHR);
    memcpy(*ptr, (VkBool32*)&forMarshaling->clipped, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    uint64_t cgen_var_2;
    *&cgen_var_2 = get_host_u64_VkSwapchainKHR((*&forMarshaling->oldSwapchain));
    memcpy(*ptr, (uint64_t*)&cgen_var_2, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkPresentInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPresentInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->waitSemaphoreCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->waitSemaphoreCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkSemaphore(forMarshaling->pWaitSemaphores[k]);
                memcpy(cgen_var_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->waitSemaphoreCount;
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->swapchainCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->swapchainCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkSwapchainKHR(forMarshaling->pSwapchains[k]);
                memcpy(cgen_var_1_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->swapchainCount;
    }
    memcpy(*ptr, (const uint32_t*)forMarshaling->pImageIndices, forMarshaling->swapchainCount * sizeof(const uint32_t));
    *ptr += forMarshaling->swapchainCount * sizeof(const uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)forMarshaling->pResults;
    memcpy((*ptr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pResults)
    {
        memcpy(*ptr, (VkResult*)forMarshaling->pResults, forMarshaling->swapchainCount * sizeof(VkResult));
        *ptr += forMarshaling->swapchainCount * sizeof(VkResult);
    }
}

void reservedmarshal_VkImageSwapchainCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageSwapchainCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkSwapchainKHR((*&forMarshaling->swapchain));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkBindImageMemorySwapchainInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBindImageMemorySwapchainInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkSwapchainKHR((*&forMarshaling->swapchain));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->imageIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkAcquireNextImageInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAcquireNextImageInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkSwapchainKHR((*&forMarshaling->swapchain));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint64_t*)&forMarshaling->timeout, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSemaphore((*&forMarshaling->semaphore));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_2;
    *&cgen_var_2 = get_host_u64_VkFence((*&forMarshaling->fence));
    memcpy(*ptr, (uint64_t*)&cgen_var_2, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDeviceGroupPresentCapabilitiesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceGroupPresentCapabilitiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)forMarshaling->presentMask, VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t));
    *ptr += VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t);
    memcpy(*ptr, (VkDeviceGroupPresentModeFlagsKHR*)&forMarshaling->modes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    *ptr += sizeof(VkDeviceGroupPresentModeFlagsKHR);
}

void reservedmarshal_VkDeviceGroupPresentInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceGroupPresentInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pDeviceMasks, forMarshaling->swapchainCount * sizeof(const uint32_t));
    *ptr += forMarshaling->swapchainCount * sizeof(const uint32_t);
    memcpy(*ptr, (VkDeviceGroupPresentModeFlagBitsKHR*)&forMarshaling->mode, sizeof(VkDeviceGroupPresentModeFlagBitsKHR));
    *ptr += sizeof(VkDeviceGroupPresentModeFlagBitsKHR);
}

void reservedmarshal_VkDeviceGroupSwapchainCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceGroupSwapchainCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceGroupPresentModeFlagsKHR*)&forMarshaling->modes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    *ptr += sizeof(VkDeviceGroupPresentModeFlagsKHR);
}

#endif
#ifdef VK_KHR_display
void reservedmarshal_VkDisplayModeParametersKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDisplayModeParametersKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->visibleRegion), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->refreshRate, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDisplayModeCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDisplayModeCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDisplayModeCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkDisplayModeCreateFlagsKHR));
    *ptr += sizeof(VkDisplayModeCreateFlagsKHR);
    reservedmarshal_VkDisplayModeParametersKHR(vkStream, rootType, (VkDisplayModeParametersKHR*)(&forMarshaling->parameters), ptr);
}

void reservedmarshal_VkDisplayModePropertiesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDisplayModePropertiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDisplayModeKHR((*&forMarshaling->displayMode));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    reservedmarshal_VkDisplayModeParametersKHR(vkStream, rootType, (VkDisplayModeParametersKHR*)(&forMarshaling->parameters), ptr);
}

void reservedmarshal_VkDisplayPlaneCapabilitiesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDisplayPlaneCapabilitiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkDisplayPlaneAlphaFlagsKHR*)&forMarshaling->supportedAlpha, sizeof(VkDisplayPlaneAlphaFlagsKHR));
    *ptr += sizeof(VkDisplayPlaneAlphaFlagsKHR);
    reservedmarshal_VkOffset2D(vkStream, rootType, (VkOffset2D*)(&forMarshaling->minSrcPosition), ptr);
    reservedmarshal_VkOffset2D(vkStream, rootType, (VkOffset2D*)(&forMarshaling->maxSrcPosition), ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->minSrcExtent), ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->maxSrcExtent), ptr);
    reservedmarshal_VkOffset2D(vkStream, rootType, (VkOffset2D*)(&forMarshaling->minDstPosition), ptr);
    reservedmarshal_VkOffset2D(vkStream, rootType, (VkOffset2D*)(&forMarshaling->maxDstPosition), ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->minDstExtent), ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->maxDstExtent), ptr);
}

void reservedmarshal_VkDisplayPlanePropertiesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDisplayPlanePropertiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDisplayKHR((*&forMarshaling->currentDisplay));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->currentStackIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDisplayPropertiesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDisplayPropertiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDisplayKHR((*&forMarshaling->display));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    {
        uint32_t l = forMarshaling->displayName ? strlen(forMarshaling->displayName): 0;
        memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        memcpy(*ptr, (char*)forMarshaling->displayName, l);
        *ptr += l;
    }
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->physicalDimensions), ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->physicalResolution), ptr);
    memcpy(*ptr, (VkSurfaceTransformFlagsKHR*)&forMarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagsKHR);
    memcpy(*ptr, (VkBool32*)&forMarshaling->planeReorderPossible, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->persistentContent, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkDisplaySurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDisplaySurfaceCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDisplaySurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkDisplaySurfaceCreateFlagsKHR));
    *ptr += sizeof(VkDisplaySurfaceCreateFlagsKHR);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDisplayModeKHR((*&forMarshaling->displayMode));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->planeIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->planeStackIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkSurfaceTransformFlagBitsKHR*)&forMarshaling->transform, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
    memcpy(*ptr, (float*)&forMarshaling->globalAlpha, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (VkDisplayPlaneAlphaFlagBitsKHR*)&forMarshaling->alphaMode, sizeof(VkDisplayPlaneAlphaFlagBitsKHR));
    *ptr += sizeof(VkDisplayPlaneAlphaFlagBitsKHR);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->imageExtent), ptr);
}

#endif
#ifdef VK_KHR_display_swapchain
void reservedmarshal_VkDisplayPresentInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDisplayPresentInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkRect2D(vkStream, rootType, (VkRect2D*)(&forMarshaling->srcRect), ptr);
    reservedmarshal_VkRect2D(vkStream, rootType, (VkRect2D*)(&forMarshaling->dstRect), ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->persistent, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_KHR_xlib_surface
void reservedmarshal_VkXlibSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkXlibSurfaceCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkXlibSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkXlibSurfaceCreateFlagsKHR));
    *ptr += sizeof(VkXlibSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->dpy;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->dpy)
    {
        memcpy(*ptr, (Display*)forMarshaling->dpy, sizeof(Display));
        *ptr += sizeof(Display);
    }
    memcpy(*ptr, (Window*)&forMarshaling->window, sizeof(Window));
    *ptr += sizeof(Window);
}

#endif
#ifdef VK_KHR_xcb_surface
void reservedmarshal_VkXcbSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkXcbSurfaceCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkXcbSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkXcbSurfaceCreateFlagsKHR));
    *ptr += sizeof(VkXcbSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->connection;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->connection)
    {
        memcpy(*ptr, (xcb_connection_t*)forMarshaling->connection, sizeof(xcb_connection_t));
        *ptr += sizeof(xcb_connection_t);
    }
    memcpy(*ptr, (xcb_window_t*)&forMarshaling->window, sizeof(xcb_window_t));
    *ptr += sizeof(xcb_window_t);
}

#endif
#ifdef VK_KHR_wayland_surface
void reservedmarshal_VkWaylandSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkWaylandSurfaceCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkWaylandSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkWaylandSurfaceCreateFlagsKHR));
    *ptr += sizeof(VkWaylandSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->display;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->display)
    {
        memcpy(*ptr, (wl_display*)forMarshaling->display, sizeof(wl_display));
        *ptr += sizeof(wl_display);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->surface;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->surface)
    {
        memcpy(*ptr, (wl_surface*)forMarshaling->surface, sizeof(wl_surface));
        *ptr += sizeof(wl_surface);
    }
}

#endif
#ifdef VK_KHR_android_surface
void reservedmarshal_VkAndroidSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAndroidSurfaceCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkAndroidSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkAndroidSurfaceCreateFlagsKHR));
    *ptr += sizeof(VkAndroidSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->window;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->window)
    {
        memcpy(*ptr, (ANativeWindow*)forMarshaling->window, sizeof(ANativeWindow));
        *ptr += sizeof(ANativeWindow);
    }
}

#endif
#ifdef VK_KHR_win32_surface
void reservedmarshal_VkWin32SurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkWin32SurfaceCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkWin32SurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkWin32SurfaceCreateFlagsKHR));
    *ptr += sizeof(VkWin32SurfaceCreateFlagsKHR);
    memcpy(*ptr, (HINSTANCE*)&forMarshaling->hinstance, sizeof(HINSTANCE));
    *ptr += sizeof(HINSTANCE);
    memcpy(*ptr, (HWND*)&forMarshaling->hwnd, sizeof(HWND));
    *ptr += sizeof(HWND);
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
#endif
#ifdef VK_KHR_device_group
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
#endif
#ifdef VK_KHR_device_group_creation
#endif
#ifdef VK_KHR_external_memory_capabilities
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
void reservedmarshal_VkImportMemoryWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImportMemoryWin32HandleInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
    memcpy(*ptr, (HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
    *ptr += sizeof(HANDLE);
    memcpy(*ptr, (LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedmarshal_VkExportMemoryWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExportMemoryWin32HandleInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pAttributes;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pAttributes)
    {
        memcpy(*ptr, (const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        *ptr += sizeof(const SECURITY_ATTRIBUTES);
    }
    memcpy(*ptr, (DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
    *ptr += sizeof(DWORD);
    memcpy(*ptr, (LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedmarshal_VkMemoryWin32HandlePropertiesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMemoryWin32HandlePropertiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkMemoryGetWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMemoryGetWin32HandleInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDeviceMemory((*&forMarshaling->memory));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_external_memory_fd
void reservedmarshal_VkImportMemoryFdInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImportMemoryFdInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
    memcpy(*ptr, (int*)&forMarshaling->fd, sizeof(int));
    *ptr += sizeof(int);
}

void reservedmarshal_VkMemoryFdPropertiesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMemoryFdPropertiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkMemoryGetFdInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMemoryGetFdInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDeviceMemory((*&forMarshaling->memory));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
void reservedmarshal_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkWin32KeyedMutexAcquireReleaseInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->acquireCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->acquireCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->acquireCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkDeviceMemory(forMarshaling->pAcquireSyncs[k]);
                memcpy(cgen_var_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->acquireCount;
    }
    memcpy(*ptr, (const uint64_t*)forMarshaling->pAcquireKeys, forMarshaling->acquireCount * sizeof(const uint64_t));
    *ptr += forMarshaling->acquireCount * sizeof(const uint64_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pAcquireTimeouts, forMarshaling->acquireCount * sizeof(const uint32_t));
    *ptr += forMarshaling->acquireCount * sizeof(const uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->releaseCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->releaseCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->releaseCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkDeviceMemory(forMarshaling->pReleaseSyncs[k]);
                memcpy(cgen_var_1_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->releaseCount;
    }
    memcpy(*ptr, (const uint64_t*)forMarshaling->pReleaseKeys, forMarshaling->releaseCount * sizeof(const uint64_t));
    *ptr += forMarshaling->releaseCount * sizeof(const uint64_t);
}

#endif
#ifdef VK_KHR_external_semaphore_capabilities
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
void reservedmarshal_VkImportSemaphoreWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImportSemaphoreWin32HandleInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkSemaphore((*&forMarshaling->semaphore));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkSemaphoreImportFlags*)&forMarshaling->flags, sizeof(VkSemaphoreImportFlags));
    *ptr += sizeof(VkSemaphoreImportFlags);
    memcpy(*ptr, (VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
    memcpy(*ptr, (HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
    *ptr += sizeof(HANDLE);
    memcpy(*ptr, (LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedmarshal_VkExportSemaphoreWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExportSemaphoreWin32HandleInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pAttributes;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pAttributes)
    {
        memcpy(*ptr, (const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        *ptr += sizeof(const SECURITY_ATTRIBUTES);
    }
    memcpy(*ptr, (DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
    *ptr += sizeof(DWORD);
    memcpy(*ptr, (LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedmarshal_VkD3D12FenceSubmitInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkD3D12FenceSubmitInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->waitSemaphoreValuesCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pWaitSemaphoreValues;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pWaitSemaphoreValues)
    {
        memcpy(*ptr, (const uint64_t*)forMarshaling->pWaitSemaphoreValues, forMarshaling->waitSemaphoreValuesCount * sizeof(const uint64_t));
        *ptr += forMarshaling->waitSemaphoreValuesCount * sizeof(const uint64_t);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->signalSemaphoreValuesCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pSignalSemaphoreValues;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pSignalSemaphoreValues)
    {
        memcpy(*ptr, (const uint64_t*)forMarshaling->pSignalSemaphoreValues, forMarshaling->signalSemaphoreValuesCount * sizeof(const uint64_t));
        *ptr += forMarshaling->signalSemaphoreValuesCount * sizeof(const uint64_t);
    }
}

void reservedmarshal_VkSemaphoreGetWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSemaphoreGetWin32HandleInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkSemaphore((*&forMarshaling->semaphore));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_external_semaphore_fd
void reservedmarshal_VkImportSemaphoreFdInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImportSemaphoreFdInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkSemaphore((*&forMarshaling->semaphore));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkSemaphoreImportFlags*)&forMarshaling->flags, sizeof(VkSemaphoreImportFlags));
    *ptr += sizeof(VkSemaphoreImportFlags);
    memcpy(*ptr, (VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
    memcpy(*ptr, (int*)&forMarshaling->fd, sizeof(int));
    *ptr += sizeof(int);
}

void reservedmarshal_VkSemaphoreGetFdInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSemaphoreGetFdInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkSemaphore((*&forMarshaling->semaphore));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    *ptr += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_push_descriptor
void reservedmarshal_VkPhysicalDevicePushDescriptorPropertiesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDevicePushDescriptorPropertiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPushDescriptors, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_KHR_shader_float16_int8
#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
void reservedmarshal_VkRectLayerKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkRectLayerKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    reservedmarshal_VkOffset2D(vkStream, rootType, (VkOffset2D*)(&forMarshaling->offset), ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->extent), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->layer, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPresentRegionKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPresentRegionKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->rectangleCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pRectangles;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pRectangles)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->rectangleCount; ++i)
        {
            reservedmarshal_VkRectLayerKHR(vkStream, rootType, (const VkRectLayerKHR*)(forMarshaling->pRectangles + i), ptr);
        }
    }
}

void reservedmarshal_VkPresentRegionsKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPresentRegionsKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pRegions;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->swapchainCount; ++i)
        {
            reservedmarshal_VkPresentRegionKHR(vkStream, rootType, (const VkPresentRegionKHR*)(forMarshaling->pRegions + i), ptr);
        }
    }
}

#endif
#ifdef VK_KHR_descriptor_update_template
#endif
#ifdef VK_KHR_imageless_framebuffer
#endif
#ifdef VK_KHR_create_renderpass2
#endif
#ifdef VK_KHR_shared_presentable_image
void reservedmarshal_VkSharedPresentSurfaceCapabilitiesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSharedPresentSurfaceCapabilitiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkImageUsageFlags*)&forMarshaling->sharedPresentSupportedUsageFlags, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
}

#endif
#ifdef VK_KHR_external_fence_capabilities
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
void reservedmarshal_VkImportFenceWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImportFenceWin32HandleInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkFence((*&forMarshaling->fence));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkFenceImportFlags*)&forMarshaling->flags, sizeof(VkFenceImportFlags));
    *ptr += sizeof(VkFenceImportFlags);
    memcpy(*ptr, (VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
    memcpy(*ptr, (HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
    *ptr += sizeof(HANDLE);
    memcpy(*ptr, (LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedmarshal_VkExportFenceWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExportFenceWin32HandleInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pAttributes;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pAttributes)
    {
        memcpy(*ptr, (const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        *ptr += sizeof(const SECURITY_ATTRIBUTES);
    }
    memcpy(*ptr, (DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
    *ptr += sizeof(DWORD);
    memcpy(*ptr, (LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
    *ptr += sizeof(LPCWSTR);
}

void reservedmarshal_VkFenceGetWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkFenceGetWin32HandleInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkFence((*&forMarshaling->fence));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_external_fence_fd
void reservedmarshal_VkImportFenceFdInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImportFenceFdInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkFence((*&forMarshaling->fence));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkFenceImportFlags*)&forMarshaling->flags, sizeof(VkFenceImportFlags));
    *ptr += sizeof(VkFenceImportFlags);
    memcpy(*ptr, (VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
    memcpy(*ptr, (int*)&forMarshaling->fd, sizeof(int));
    *ptr += sizeof(int);
}

void reservedmarshal_VkFenceGetFdInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkFenceGetFdInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkFence((*&forMarshaling->fence));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    *ptr += sizeof(VkExternalFenceHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_performance_query
void reservedmarshal_VkPhysicalDevicePerformanceQueryFeaturesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDevicePerformanceQueryFeaturesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->performanceCounterQueryPools, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->performanceCounterMultipleQueryPools, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDevicePerformanceQueryPropertiesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDevicePerformanceQueryPropertiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->allowCommandBufferQueryCopies, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPerformanceCounterKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPerformanceCounterKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPerformanceCounterUnitKHR*)&forMarshaling->unit, sizeof(VkPerformanceCounterUnitKHR));
    *ptr += sizeof(VkPerformanceCounterUnitKHR);
    memcpy(*ptr, (VkPerformanceCounterScopeKHR*)&forMarshaling->scope, sizeof(VkPerformanceCounterScopeKHR));
    *ptr += sizeof(VkPerformanceCounterScopeKHR);
    memcpy(*ptr, (VkPerformanceCounterStorageKHR*)&forMarshaling->storage, sizeof(VkPerformanceCounterStorageKHR));
    *ptr += sizeof(VkPerformanceCounterStorageKHR);
    memcpy(*ptr, (uint8_t*)forMarshaling->uuid, VK_UUID_SIZE * sizeof(uint8_t));
    *ptr += VK_UUID_SIZE * sizeof(uint8_t);
}

void reservedmarshal_VkPerformanceCounterDescriptionKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPerformanceCounterDescriptionKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPerformanceCounterDescriptionFlagsKHR*)&forMarshaling->flags, sizeof(VkPerformanceCounterDescriptionFlagsKHR));
    *ptr += sizeof(VkPerformanceCounterDescriptionFlagsKHR);
    memcpy(*ptr, (char*)forMarshaling->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    memcpy(*ptr, (char*)forMarshaling->category, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    memcpy(*ptr, (char*)forMarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
}

void reservedmarshal_VkQueryPoolPerformanceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkQueryPoolPerformanceCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueFamilyIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->counterIndexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pCounterIndices, forMarshaling->counterIndexCount * sizeof(const uint32_t));
    *ptr += forMarshaling->counterIndexCount * sizeof(const uint32_t);
}

void reservedmarshal_VkPerformanceCounterResultKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPerformanceCounterResultKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (int32_t*)&forMarshaling->int32, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedmarshal_VkAcquireProfilingLockInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAcquireProfilingLockInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkAcquireProfilingLockFlagsKHR*)&forMarshaling->flags, sizeof(VkAcquireProfilingLockFlagsKHR));
    *ptr += sizeof(VkAcquireProfilingLockFlagsKHR);
    memcpy(*ptr, (uint64_t*)&forMarshaling->timeout, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedmarshal_VkPerformanceQuerySubmitInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPerformanceQuerySubmitInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->counterPassIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
void reservedmarshal_VkPhysicalDeviceSurfaceInfo2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceSurfaceInfo2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkSurfaceKHR((*&forMarshaling->surface));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkSurfaceCapabilities2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSurfaceCapabilities2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkSurfaceCapabilitiesKHR(vkStream, rootType, (VkSurfaceCapabilitiesKHR*)(&forMarshaling->surfaceCapabilities), ptr);
}

void reservedmarshal_VkSurfaceFormat2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSurfaceFormat2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkSurfaceFormatKHR(vkStream, rootType, (VkSurfaceFormatKHR*)(&forMarshaling->surfaceFormat), ptr);
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
void reservedmarshal_VkDisplayProperties2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDisplayProperties2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkDisplayPropertiesKHR(vkStream, rootType, (VkDisplayPropertiesKHR*)(&forMarshaling->displayProperties), ptr);
}

void reservedmarshal_VkDisplayPlaneProperties2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDisplayPlaneProperties2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkDisplayPlanePropertiesKHR(vkStream, rootType, (VkDisplayPlanePropertiesKHR*)(&forMarshaling->displayPlaneProperties), ptr);
}

void reservedmarshal_VkDisplayModeProperties2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDisplayModeProperties2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkDisplayModePropertiesKHR(vkStream, rootType, (VkDisplayModePropertiesKHR*)(&forMarshaling->displayModeProperties), ptr);
}

void reservedmarshal_VkDisplayPlaneInfo2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDisplayPlaneInfo2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDisplayModeKHR((*&forMarshaling->mode));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->planeIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDisplayPlaneCapabilities2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDisplayPlaneCapabilities2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkDisplayPlaneCapabilitiesKHR(vkStream, rootType, (VkDisplayPlaneCapabilitiesKHR*)(&forMarshaling->capabilities), ptr);
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
#endif
#ifdef VK_KHR_bind_memory2
#endif
#ifdef VK_KHR_portability_subset
void reservedmarshal_VkPhysicalDevicePortabilitySubsetFeaturesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDevicePortabilitySubsetFeaturesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->constantAlphaColorBlendFactors, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->events, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->imageViewFormatReinterpretation, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->imageViewFormatSwizzle, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->imageView2DOn3DImage, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->multisampleArrayImage, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->mutableComparisonSamplers, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->pointPolygons, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->samplerMipLodBias, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->separateStencilMaskRef, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSampleRateInterpolationFunctions, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->tessellationIsolines, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->tessellationPointMode, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->triangleFans, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->vertexAttributeAccessBeyondStride, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDevicePortabilitySubsetPropertiesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDevicePortabilitySubsetPropertiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->minVertexInputBindingStrideAlignment, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_KHR_maintenance3
#endif
#ifdef VK_KHR_draw_indirect_count
#endif
#ifdef VK_KHR_shader_subgroup_extended_types
#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_KHR_shader_atomic_int64
#endif
#ifdef VK_KHR_shader_clock
void reservedmarshal_VkPhysicalDeviceShaderClockFeaturesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderClockFeaturesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSubgroupClock, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderDeviceClock, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_KHR_driver_properties
#endif
#ifdef VK_KHR_shader_float_controls
#endif
#ifdef VK_KHR_depth_stencil_resolve
#endif
#ifdef VK_KHR_swapchain_mutable_format
#endif
#ifdef VK_KHR_timeline_semaphore
#endif
#ifdef VK_KHR_vulkan_memory_model
#endif
#ifdef VK_KHR_shader_terminate_invocation
void reservedmarshal_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderTerminateInvocation, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_KHR_fragment_shading_rate
void reservedmarshal_VkFragmentShadingRateAttachmentInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkFragmentShadingRateAttachmentInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkAttachmentReference2(vkStream, rootType, (const VkAttachmentReference2*)(forMarshaling->pFragmentShadingRateAttachment), ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->shadingRateAttachmentTexelSize), ptr);
}

void reservedmarshal_VkPipelineFragmentShadingRateStateCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineFragmentShadingRateStateCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->fragmentSize), ptr);
    memcpy(*ptr, (VkFragmentShadingRateCombinerOpKHR*)forMarshaling->combinerOps, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
    *ptr += 2 * sizeof(VkFragmentShadingRateCombinerOpKHR);
}

void reservedmarshal_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentShadingRateFeaturesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->pipelineFragmentShadingRate, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->primitiveFragmentShadingRate, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->attachmentFragmentShadingRate, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentShadingRatePropertiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->minFragmentShadingRateAttachmentTexelSize), ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->maxFragmentShadingRateAttachmentTexelSize), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxFragmentShadingRateAttachmentTexelSizeAspectRatio, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkBool32*)&forMarshaling->primitiveFragmentShadingRateWithMultipleViewports, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->layeredShadingRateAttachments, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentShadingRateNonTrivialCombinerOps, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->maxFragmentSize), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxFragmentSizeAspectRatio, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxFragmentShadingRateCoverageSamples, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkSampleCountFlagBits*)&forMarshaling->maxFragmentShadingRateRasterizationSamples, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentShadingRateWithShaderDepthStencilWrites, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentShadingRateWithSampleMask, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentShadingRateWithShaderSampleMask, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentShadingRateWithConservativeRasterization, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentShadingRateWithFragmentShaderInterlock, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentShadingRateWithCustomSampleLocations, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentShadingRateStrictMultiplyCombiner, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceFragmentShadingRateKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentShadingRateKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->sampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->fragmentSize), ptr);
}

#endif
#ifdef VK_KHR_spirv_1_4
#endif
#ifdef VK_KHR_surface_protected_capabilities
void reservedmarshal_VkSurfaceProtectedCapabilitiesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSurfaceProtectedCapabilitiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->supportsProtected, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_KHR_separate_depth_stencil_layouts
#endif
#ifdef VK_KHR_uniform_buffer_standard_layout
#endif
#ifdef VK_KHR_buffer_device_address
#endif
#ifdef VK_KHR_deferred_host_operations
#endif
#ifdef VK_KHR_pipeline_executable_properties
void reservedmarshal_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->pipelineExecutableInfo, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPipelineInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPipeline((*&forMarshaling->pipeline));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkPipelineExecutablePropertiesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineExecutablePropertiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkShaderStageFlags*)&forMarshaling->stages, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    memcpy(*ptr, (char*)forMarshaling->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    memcpy(*ptr, (char*)forMarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    memcpy(*ptr, (uint32_t*)&forMarshaling->subgroupSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPipelineExecutableInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineExecutableInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPipeline((*&forMarshaling->pipeline));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->executableIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPipelineExecutableStatisticValueKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineExecutableStatisticValueKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkBool32*)&forMarshaling->b32, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPipelineExecutableStatisticKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineExecutableStatisticKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (char*)forMarshaling->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    memcpy(*ptr, (char*)forMarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    memcpy(*ptr, (VkPipelineExecutableStatisticFormatKHR*)&forMarshaling->format, sizeof(VkPipelineExecutableStatisticFormatKHR));
    *ptr += sizeof(VkPipelineExecutableStatisticFormatKHR);
    reservedmarshal_VkPipelineExecutableStatisticValueKHR(vkStream, rootType, (VkPipelineExecutableStatisticValueKHR*)(&forMarshaling->value), ptr);
}

void reservedmarshal_VkPipelineExecutableInternalRepresentationKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineExecutableInternalRepresentationKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (char*)forMarshaling->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    memcpy(*ptr, (char*)forMarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    memcpy(*ptr, (VkBool32*)&forMarshaling->isText, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->dataSize;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pData;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pData)
    {
        memcpy(*ptr, (void*)forMarshaling->pData, forMarshaling->dataSize * sizeof(uint8_t));
        *ptr += forMarshaling->dataSize * sizeof(uint8_t);
    }
}

#endif
#ifdef VK_KHR_pipeline_library
void reservedmarshal_VkPipelineLibraryCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineLibraryCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->libraryCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->libraryCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->libraryCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkPipeline(forMarshaling->pLibraries[k]);
                memcpy(cgen_var_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->libraryCount;
    }
}

#endif
#ifdef VK_KHR_shader_non_semantic_info
#endif
#ifdef VK_KHR_copy_commands2
void reservedmarshal_VkBufferCopy2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBufferCopy2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->srcOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->dstOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkCopyBufferInfo2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCopyBufferInfo2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&forMarshaling->srcBuffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&forMarshaling->dstBuffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->regionCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->regionCount; ++i)
    {
        reservedmarshal_VkBufferCopy2KHR(vkStream, rootType, (const VkBufferCopy2KHR*)(forMarshaling->pRegions + i), ptr);
    }
}

void reservedmarshal_VkImageCopy2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageCopy2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource), ptr);
    reservedmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forMarshaling->srcOffset), ptr);
    reservedmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource), ptr);
    reservedmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forMarshaling->dstOffset), ptr);
    reservedmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forMarshaling->extent), ptr);
}

void reservedmarshal_VkCopyImageInfo2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCopyImageInfo2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&forMarshaling->srcImage));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->srcImageLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImage((*&forMarshaling->dstImage));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->dstImageLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy(*ptr, (uint32_t*)&forMarshaling->regionCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->regionCount; ++i)
    {
        reservedmarshal_VkImageCopy2KHR(vkStream, rootType, (const VkImageCopy2KHR*)(forMarshaling->pRegions + i), ptr);
    }
}

void reservedmarshal_VkBufferImageCopy2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBufferImageCopy2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->bufferOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (uint32_t*)&forMarshaling->bufferRowLength, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->bufferImageHeight, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forMarshaling->imageSubresource), ptr);
    reservedmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forMarshaling->imageOffset), ptr);
    reservedmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forMarshaling->imageExtent), ptr);
}

void reservedmarshal_VkCopyBufferToImageInfo2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCopyBufferToImageInfo2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&forMarshaling->srcBuffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImage((*&forMarshaling->dstImage));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->dstImageLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy(*ptr, (uint32_t*)&forMarshaling->regionCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->regionCount; ++i)
    {
        reservedmarshal_VkBufferImageCopy2KHR(vkStream, rootType, (const VkBufferImageCopy2KHR*)(forMarshaling->pRegions + i), ptr);
    }
}

void reservedmarshal_VkCopyImageToBufferInfo2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCopyImageToBufferInfo2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&forMarshaling->srcImage));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->srcImageLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&forMarshaling->dstBuffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->regionCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->regionCount; ++i)
    {
        reservedmarshal_VkBufferImageCopy2KHR(vkStream, rootType, (const VkBufferImageCopy2KHR*)(forMarshaling->pRegions + i), ptr);
    }
}

void reservedmarshal_VkImageBlit2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageBlit2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource), ptr);
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        reservedmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(forMarshaling->srcOffsets + i), ptr);
    }
    reservedmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource), ptr);
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        reservedmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(forMarshaling->dstOffsets + i), ptr);
    }
}

void reservedmarshal_VkBlitImageInfo2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBlitImageInfo2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&forMarshaling->srcImage));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->srcImageLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImage((*&forMarshaling->dstImage));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->dstImageLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy(*ptr, (uint32_t*)&forMarshaling->regionCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->regionCount; ++i)
    {
        reservedmarshal_VkImageBlit2KHR(vkStream, rootType, (const VkImageBlit2KHR*)(forMarshaling->pRegions + i), ptr);
    }
    memcpy(*ptr, (VkFilter*)&forMarshaling->filter, sizeof(VkFilter));
    *ptr += sizeof(VkFilter);
}

void reservedmarshal_VkImageResolve2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageResolve2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource), ptr);
    reservedmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forMarshaling->srcOffset), ptr);
    reservedmarshal_VkImageSubresourceLayers(vkStream, rootType, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource), ptr);
    reservedmarshal_VkOffset3D(vkStream, rootType, (VkOffset3D*)(&forMarshaling->dstOffset), ptr);
    reservedmarshal_VkExtent3D(vkStream, rootType, (VkExtent3D*)(&forMarshaling->extent), ptr);
}

void reservedmarshal_VkResolveImageInfo2KHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkResolveImageInfo2KHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&forMarshaling->srcImage));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->srcImageLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImage((*&forMarshaling->dstImage));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkImageLayout*)&forMarshaling->dstImageLayout, sizeof(VkImageLayout));
    *ptr += sizeof(VkImageLayout);
    memcpy(*ptr, (uint32_t*)&forMarshaling->regionCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->regionCount; ++i)
    {
        reservedmarshal_VkImageResolve2KHR(vkStream, rootType, (const VkImageResolve2KHR*)(forMarshaling->pRegions + i), ptr);
    }
}

#endif
#ifdef VK_ANDROID_native_buffer
void reservedmarshal_VkNativeBufferANDROID(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkNativeBufferANDROID* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->handle;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->handle)
    {
        memcpy(*ptr, (const uint32_t*)forMarshaling->handle, sizeof(const uint32_t));
        *ptr += sizeof(const uint32_t);
    }
    memcpy(*ptr, (int*)&forMarshaling->stride, sizeof(int));
    *ptr += sizeof(int);
    memcpy(*ptr, (int*)&forMarshaling->format, sizeof(int));
    *ptr += sizeof(int);
    memcpy(*ptr, (int*)&forMarshaling->usage, sizeof(int));
    *ptr += sizeof(int);
    memcpy(*ptr, (uint64_t*)&forMarshaling->consumer, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->producer, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

#endif
#ifdef VK_EXT_debug_report
void reservedmarshal_VkDebugReportCallbackCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDebugReportCallbackCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDebugReportFlagsEXT*)&forMarshaling->flags, sizeof(VkDebugReportFlagsEXT));
    *ptr += sizeof(VkDebugReportFlagsEXT);
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->pfnCallback;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pUserData;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pUserData)
    {
        memcpy(*ptr, (void*)forMarshaling->pUserData, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
void reservedmarshal_VkPipelineRasterizationStateRasterizationOrderAMD(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineRasterizationStateRasterizationOrderAMD* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkRasterizationOrderAMD*)&forMarshaling->rasterizationOrder, sizeof(VkRasterizationOrderAMD));
    *ptr += sizeof(VkRasterizationOrderAMD);
}

#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
void reservedmarshal_VkDebugMarkerObjectNameInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDebugMarkerObjectNameInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDebugReportObjectTypeEXT*)&forMarshaling->objectType, sizeof(VkDebugReportObjectTypeEXT));
    *ptr += sizeof(VkDebugReportObjectTypeEXT);
    memcpy(*ptr, (uint64_t*)&forMarshaling->object, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    {
        uint32_t l = forMarshaling->pObjectName ? strlen(forMarshaling->pObjectName): 0;
        memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        memcpy(*ptr, (char*)forMarshaling->pObjectName, l);
        *ptr += l;
    }
}

void reservedmarshal_VkDebugMarkerObjectTagInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDebugMarkerObjectTagInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDebugReportObjectTypeEXT*)&forMarshaling->objectType, sizeof(VkDebugReportObjectTypeEXT));
    *ptr += sizeof(VkDebugReportObjectTypeEXT);
    memcpy(*ptr, (uint64_t*)&forMarshaling->object, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->tagName, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->tagSize;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    memcpy(*ptr, (const void*)forMarshaling->pTag, forMarshaling->tagSize * sizeof(const uint8_t));
    *ptr += forMarshaling->tagSize * sizeof(const uint8_t);
}

void reservedmarshal_VkDebugMarkerMarkerInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDebugMarkerMarkerInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    {
        uint32_t l = forMarshaling->pMarkerName ? strlen(forMarshaling->pMarkerName): 0;
        memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        memcpy(*ptr, (char*)forMarshaling->pMarkerName, l);
        *ptr += l;
    }
    memcpy(*ptr, (float*)forMarshaling->color, 4 * sizeof(float));
    *ptr += 4 * sizeof(float);
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
void reservedmarshal_VkDedicatedAllocationImageCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDedicatedAllocationImageCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->dedicatedAllocation, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkDedicatedAllocationBufferCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDedicatedAllocationBufferCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->dedicatedAllocation, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkDedicatedAllocationMemoryAllocateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDedicatedAllocationMemoryAllocateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&forMarshaling->image));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
}

#endif
#ifdef VK_EXT_transform_feedback
void reservedmarshal_VkPhysicalDeviceTransformFeedbackFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceTransformFeedbackFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->transformFeedback, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->geometryStreams, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceTransformFeedbackPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceTransformFeedbackPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTransformFeedbackStreams, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTransformFeedbackBuffers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->maxTransformFeedbackBufferSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTransformFeedbackStreamDataSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTransformFeedbackBufferDataSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTransformFeedbackBufferDataStride, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkBool32*)&forMarshaling->transformFeedbackQueries, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->transformFeedbackStreamsLinesTriangles, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->transformFeedbackRasterizationStreamSelect, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->transformFeedbackDraw, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPipelineRasterizationStateStreamCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineRasterizationStateStreamCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineRasterizationStateStreamCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkPipelineRasterizationStateStreamCreateFlagsEXT));
    *ptr += sizeof(VkPipelineRasterizationStateStreamCreateFlagsEXT);
    memcpy(*ptr, (uint32_t*)&forMarshaling->rasterizationStream, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_NVX_image_view_handle
void reservedmarshal_VkImageViewHandleInfoNVX(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageViewHandleInfoNVX* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImageView((*&forMarshaling->imageView));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDescriptorType*)&forMarshaling->descriptorType, sizeof(VkDescriptorType));
    *ptr += sizeof(VkDescriptorType);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSampler((*&forMarshaling->sampler));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkImageViewAddressPropertiesNVX(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageViewAddressPropertiesNVX* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceAddress*)&forMarshaling->deviceAddress, sizeof(VkDeviceAddress));
    *ptr += sizeof(VkDeviceAddress);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

#endif
#ifdef VK_AMD_draw_indirect_count
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
void reservedmarshal_VkTextureLODGatherFormatPropertiesAMD(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkTextureLODGatherFormatPropertiesAMD* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->supportsTextureGatherLODBiasAMD, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_AMD_shader_info
void reservedmarshal_VkShaderResourceUsageAMD(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkShaderResourceUsageAMD* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->numUsedVgprs, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->numUsedSgprs, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->ldsSizePerLocalWorkGroup, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->ldsUsageSizeInBytes;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    uint64_t cgen_var_1 = (uint64_t)forMarshaling->scratchMemUsageInBytes;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
}

void reservedmarshal_VkShaderStatisticsInfoAMD(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkShaderStatisticsInfoAMD* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkShaderStageFlags*)&forMarshaling->shaderStageMask, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    reservedmarshal_VkShaderResourceUsageAMD(vkStream, rootType, (VkShaderResourceUsageAMD*)(&forMarshaling->resourceUsage), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->numPhysicalVgprs, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->numPhysicalSgprs, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->numAvailableVgprs, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->numAvailableSgprs, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)forMarshaling->computeWorkGroupSize, 3 * sizeof(uint32_t));
    *ptr += 3 * sizeof(uint32_t);
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_GGP_stream_descriptor_surface
void reservedmarshal_VkStreamDescriptorSurfaceCreateInfoGGP(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkStreamDescriptorSurfaceCreateInfoGGP* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkStreamDescriptorSurfaceCreateFlagsGGP*)&forMarshaling->flags, sizeof(VkStreamDescriptorSurfaceCreateFlagsGGP));
    *ptr += sizeof(VkStreamDescriptorSurfaceCreateFlagsGGP);
    memcpy(*ptr, (GgpStreamDescriptor*)&forMarshaling->streamDescriptor, sizeof(GgpStreamDescriptor));
    *ptr += sizeof(GgpStreamDescriptor);
}

#endif
#ifdef VK_NV_corner_sampled_image
void reservedmarshal_VkPhysicalDeviceCornerSampledImageFeaturesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceCornerSampledImageFeaturesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->cornerSampledImage, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
void reservedmarshal_VkExternalImageFormatPropertiesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExternalImageFormatPropertiesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    reservedmarshal_VkImageFormatProperties(vkStream, rootType, (VkImageFormatProperties*)(&forMarshaling->imageFormatProperties), ptr);
    memcpy(*ptr, (VkExternalMemoryFeatureFlagsNV*)&forMarshaling->externalMemoryFeatures, sizeof(VkExternalMemoryFeatureFlagsNV));
    *ptr += sizeof(VkExternalMemoryFeatureFlagsNV);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
}

#endif
#ifdef VK_NV_external_memory
void reservedmarshal_VkExternalMemoryImageCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExternalMemoryImageCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
}

void reservedmarshal_VkExportMemoryAllocateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExportMemoryAllocateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
}

#endif
#ifdef VK_NV_external_memory_win32
void reservedmarshal_VkImportMemoryWin32HandleInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImportMemoryWin32HandleInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
    memcpy(*ptr, (HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
    *ptr += sizeof(HANDLE);
}

void reservedmarshal_VkExportMemoryWin32HandleInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExportMemoryWin32HandleInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pAttributes;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pAttributes)
    {
        memcpy(*ptr, (const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
        *ptr += sizeof(const SECURITY_ATTRIBUTES);
    }
    memcpy(*ptr, (DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
    *ptr += sizeof(DWORD);
}

#endif
#ifdef VK_NV_win32_keyed_mutex
void reservedmarshal_VkWin32KeyedMutexAcquireReleaseInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkWin32KeyedMutexAcquireReleaseInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->acquireCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->acquireCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->acquireCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkDeviceMemory(forMarshaling->pAcquireSyncs[k]);
                memcpy(cgen_var_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->acquireCount;
    }
    memcpy(*ptr, (const uint64_t*)forMarshaling->pAcquireKeys, forMarshaling->acquireCount * sizeof(const uint64_t));
    *ptr += forMarshaling->acquireCount * sizeof(const uint64_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pAcquireTimeoutMilliseconds, forMarshaling->acquireCount * sizeof(const uint32_t));
    *ptr += forMarshaling->acquireCount * sizeof(const uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->releaseCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->releaseCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->releaseCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkDeviceMemory(forMarshaling->pReleaseSyncs[k]);
                memcpy(cgen_var_1_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->releaseCount;
    }
    memcpy(*ptr, (const uint64_t*)forMarshaling->pReleaseKeys, forMarshaling->releaseCount * sizeof(const uint64_t));
    *ptr += forMarshaling->releaseCount * sizeof(const uint64_t);
}

#endif
#ifdef VK_EXT_validation_flags
void reservedmarshal_VkValidationFlagsEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkValidationFlagsEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->disabledValidationCheckCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const VkValidationCheckEXT*)forMarshaling->pDisabledValidationChecks, forMarshaling->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT));
    *ptr += forMarshaling->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT);
}

#endif
#ifdef VK_NN_vi_surface
void reservedmarshal_VkViSurfaceCreateInfoNN(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkViSurfaceCreateInfoNN* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkViSurfaceCreateFlagsNN*)&forMarshaling->flags, sizeof(VkViSurfaceCreateFlagsNN));
    *ptr += sizeof(VkViSurfaceCreateFlagsNN);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->window;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->window)
    {
        memcpy(*ptr, (void*)forMarshaling->window, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
void reservedmarshal_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->textureCompressionASTC_HDR, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_astc_decode_mode
void reservedmarshal_VkImageViewASTCDecodeModeEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageViewASTCDecodeModeEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkFormat*)&forMarshaling->decodeMode, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
}

void reservedmarshal_VkPhysicalDeviceASTCDecodeFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceASTCDecodeFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->decodeModeSharedExponent, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_conditional_rendering
void reservedmarshal_VkConditionalRenderingBeginInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkConditionalRenderingBeginInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkConditionalRenderingFlagsEXT*)&forMarshaling->flags, sizeof(VkConditionalRenderingFlagsEXT));
    *ptr += sizeof(VkConditionalRenderingFlagsEXT);
}

void reservedmarshal_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->conditionalRendering, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->inheritedConditionalRendering, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->conditionalRenderingEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void reservedmarshal_VkViewportWScalingNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkViewportWScalingNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (float*)&forMarshaling->xcoeff, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->ycoeff, sizeof(float));
    *ptr += sizeof(float);
}

void reservedmarshal_VkPipelineViewportWScalingStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineViewportWScalingStateCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->viewportWScalingEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (uint32_t*)&forMarshaling->viewportCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pViewportWScalings;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pViewportWScalings)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->viewportCount; ++i)
        {
            reservedmarshal_VkViewportWScalingNV(vkStream, rootType, (const VkViewportWScalingNV*)(forMarshaling->pViewportWScalings + i), ptr);
        }
    }
}

#endif
#ifdef VK_EXT_direct_mode_display
#endif
#ifdef VK_EXT_acquire_xlib_display
#endif
#ifdef VK_EXT_display_surface_counter
void reservedmarshal_VkSurfaceCapabilities2EXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSurfaceCapabilities2EXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->minImageCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxImageCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->currentExtent), ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->minImageExtent), ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->maxImageExtent), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxImageArrayLayers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkSurfaceTransformFlagsKHR*)&forMarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagsKHR);
    memcpy(*ptr, (VkSurfaceTransformFlagBitsKHR*)&forMarshaling->currentTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
    memcpy(*ptr, (VkCompositeAlphaFlagsKHR*)&forMarshaling->supportedCompositeAlpha, sizeof(VkCompositeAlphaFlagsKHR));
    *ptr += sizeof(VkCompositeAlphaFlagsKHR);
    memcpy(*ptr, (VkImageUsageFlags*)&forMarshaling->supportedUsageFlags, sizeof(VkImageUsageFlags));
    *ptr += sizeof(VkImageUsageFlags);
    memcpy(*ptr, (VkSurfaceCounterFlagsEXT*)&forMarshaling->supportedSurfaceCounters, sizeof(VkSurfaceCounterFlagsEXT));
    *ptr += sizeof(VkSurfaceCounterFlagsEXT);
}

#endif
#ifdef VK_EXT_display_control
void reservedmarshal_VkDisplayPowerInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDisplayPowerInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDisplayPowerStateEXT*)&forMarshaling->powerState, sizeof(VkDisplayPowerStateEXT));
    *ptr += sizeof(VkDisplayPowerStateEXT);
}

void reservedmarshal_VkDeviceEventInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceEventInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceEventTypeEXT*)&forMarshaling->deviceEvent, sizeof(VkDeviceEventTypeEXT));
    *ptr += sizeof(VkDeviceEventTypeEXT);
}

void reservedmarshal_VkDisplayEventInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDisplayEventInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDisplayEventTypeEXT*)&forMarshaling->displayEvent, sizeof(VkDisplayEventTypeEXT));
    *ptr += sizeof(VkDisplayEventTypeEXT);
}

void reservedmarshal_VkSwapchainCounterCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSwapchainCounterCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSurfaceCounterFlagsEXT*)&forMarshaling->surfaceCounters, sizeof(VkSurfaceCounterFlagsEXT));
    *ptr += sizeof(VkSurfaceCounterFlagsEXT);
}

#endif
#ifdef VK_GOOGLE_display_timing
void reservedmarshal_VkRefreshCycleDurationGOOGLE(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkRefreshCycleDurationGOOGLE* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint64_t*)&forMarshaling->refreshDuration, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedmarshal_VkPastPresentationTimingGOOGLE(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPastPresentationTimingGOOGLE* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->presentID, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->desiredPresentTime, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->actualPresentTime, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->earliestPresentTime, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->presentMargin, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedmarshal_VkPresentTimeGOOGLE(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPresentTimeGOOGLE* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->presentID, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->desiredPresentTime, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedmarshal_VkPresentTimesInfoGOOGLE(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPresentTimesInfoGOOGLE* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pTimes;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pTimes)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->swapchainCount; ++i)
        {
            reservedmarshal_VkPresentTimeGOOGLE(vkStream, rootType, (const VkPresentTimeGOOGLE*)(forMarshaling->pTimes + i), ptr);
        }
    }
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
void reservedmarshal_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->perViewPositionAllComponents, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_viewport_swizzle
void reservedmarshal_VkViewportSwizzleNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkViewportSwizzleNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkViewportCoordinateSwizzleNV*)&forMarshaling->x, sizeof(VkViewportCoordinateSwizzleNV));
    *ptr += sizeof(VkViewportCoordinateSwizzleNV);
    memcpy(*ptr, (VkViewportCoordinateSwizzleNV*)&forMarshaling->y, sizeof(VkViewportCoordinateSwizzleNV));
    *ptr += sizeof(VkViewportCoordinateSwizzleNV);
    memcpy(*ptr, (VkViewportCoordinateSwizzleNV*)&forMarshaling->z, sizeof(VkViewportCoordinateSwizzleNV));
    *ptr += sizeof(VkViewportCoordinateSwizzleNV);
    memcpy(*ptr, (VkViewportCoordinateSwizzleNV*)&forMarshaling->w, sizeof(VkViewportCoordinateSwizzleNV));
    *ptr += sizeof(VkViewportCoordinateSwizzleNV);
}

void reservedmarshal_VkPipelineViewportSwizzleStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineViewportSwizzleStateCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineViewportSwizzleStateCreateFlagsNV*)&forMarshaling->flags, sizeof(VkPipelineViewportSwizzleStateCreateFlagsNV));
    *ptr += sizeof(VkPipelineViewportSwizzleStateCreateFlagsNV);
    memcpy(*ptr, (uint32_t*)&forMarshaling->viewportCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pViewportSwizzles;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pViewportSwizzles)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->viewportCount; ++i)
        {
            reservedmarshal_VkViewportSwizzleNV(vkStream, rootType, (const VkViewportSwizzleNV*)(forMarshaling->pViewportSwizzles + i), ptr);
        }
    }
}

#endif
#ifdef VK_EXT_discard_rectangles
void reservedmarshal_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDiscardRectangles, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPipelineDiscardRectangleStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineDiscardRectangleStateCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineDiscardRectangleStateCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkPipelineDiscardRectangleStateCreateFlagsEXT));
    *ptr += sizeof(VkPipelineDiscardRectangleStateCreateFlagsEXT);
    memcpy(*ptr, (VkDiscardRectangleModeEXT*)&forMarshaling->discardRectangleMode, sizeof(VkDiscardRectangleModeEXT));
    *ptr += sizeof(VkDiscardRectangleModeEXT);
    memcpy(*ptr, (uint32_t*)&forMarshaling->discardRectangleCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pDiscardRectangles;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pDiscardRectangles)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->discardRectangleCount; ++i)
        {
            reservedmarshal_VkRect2D(vkStream, rootType, (const VkRect2D*)(forMarshaling->pDiscardRectangles + i), ptr);
        }
    }
}

#endif
#ifdef VK_EXT_conservative_rasterization
void reservedmarshal_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceConservativeRasterizationPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (float*)&forMarshaling->primitiveOverestimationSize, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxExtraPrimitiveOverestimationSize, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->extraPrimitiveOverestimationSizeGranularity, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (VkBool32*)&forMarshaling->primitiveUnderestimation, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->conservativePointAndLineRasterization, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->degenerateTrianglesRasterized, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->degenerateLinesRasterized, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fullyCoveredFragmentShaderInputVariable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->conservativeRasterizationPostDepthCoverage, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineRasterizationConservativeStateCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineRasterizationConservativeStateCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkPipelineRasterizationConservativeStateCreateFlagsEXT));
    *ptr += sizeof(VkPipelineRasterizationConservativeStateCreateFlagsEXT);
    memcpy(*ptr, (VkConservativeRasterizationModeEXT*)&forMarshaling->conservativeRasterizationMode, sizeof(VkConservativeRasterizationModeEXT));
    *ptr += sizeof(VkConservativeRasterizationModeEXT);
    memcpy(*ptr, (float*)&forMarshaling->extraPrimitiveOverestimationSize, sizeof(float));
    *ptr += sizeof(float);
}

#endif
#ifdef VK_EXT_depth_clip_enable
void reservedmarshal_VkPhysicalDeviceDepthClipEnableFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceDepthClipEnableFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->depthClipEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPipelineRasterizationDepthClipStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineRasterizationDepthClipStateCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineRasterizationDepthClipStateCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkPipelineRasterizationDepthClipStateCreateFlagsEXT));
    *ptr += sizeof(VkPipelineRasterizationDepthClipStateCreateFlagsEXT);
    memcpy(*ptr, (VkBool32*)&forMarshaling->depthClipEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void reservedmarshal_VkXYColorEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkXYColorEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (float*)&forMarshaling->x, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->y, sizeof(float));
    *ptr += sizeof(float);
}

void reservedmarshal_VkHdrMetadataEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkHdrMetadataEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkXYColorEXT(vkStream, rootType, (VkXYColorEXT*)(&forMarshaling->displayPrimaryRed), ptr);
    reservedmarshal_VkXYColorEXT(vkStream, rootType, (VkXYColorEXT*)(&forMarshaling->displayPrimaryGreen), ptr);
    reservedmarshal_VkXYColorEXT(vkStream, rootType, (VkXYColorEXT*)(&forMarshaling->displayPrimaryBlue), ptr);
    reservedmarshal_VkXYColorEXT(vkStream, rootType, (VkXYColorEXT*)(&forMarshaling->whitePoint), ptr);
    memcpy(*ptr, (float*)&forMarshaling->maxLuminance, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->minLuminance, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxContentLightLevel, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxFrameAverageLightLevel, sizeof(float));
    *ptr += sizeof(float);
}

#endif
#ifdef VK_MVK_ios_surface
void reservedmarshal_VkIOSSurfaceCreateInfoMVK(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkIOSSurfaceCreateInfoMVK* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkIOSSurfaceCreateFlagsMVK*)&forMarshaling->flags, sizeof(VkIOSSurfaceCreateFlagsMVK));
    *ptr += sizeof(VkIOSSurfaceCreateFlagsMVK);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pView;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pView)
    {
        memcpy(*ptr, (const void*)forMarshaling->pView, sizeof(const uint8_t));
        *ptr += sizeof(const uint8_t);
    }
}

#endif
#ifdef VK_MVK_macos_surface
void reservedmarshal_VkMacOSSurfaceCreateInfoMVK(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMacOSSurfaceCreateInfoMVK* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkMacOSSurfaceCreateFlagsMVK*)&forMarshaling->flags, sizeof(VkMacOSSurfaceCreateFlagsMVK));
    *ptr += sizeof(VkMacOSSurfaceCreateFlagsMVK);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pView;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pView)
    {
        memcpy(*ptr, (const void*)forMarshaling->pView, sizeof(const uint8_t));
        *ptr += sizeof(const uint8_t);
    }
}

#endif
#ifdef VK_MVK_moltenvk
#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
void reservedmarshal_VkDebugUtilsLabelEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDebugUtilsLabelEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    {
        uint32_t l = forMarshaling->pLabelName ? strlen(forMarshaling->pLabelName): 0;
        memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        memcpy(*ptr, (char*)forMarshaling->pLabelName, l);
        *ptr += l;
    }
    memcpy(*ptr, (float*)forMarshaling->color, 4 * sizeof(float));
    *ptr += 4 * sizeof(float);
}

void reservedmarshal_VkDebugUtilsObjectNameInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDebugUtilsObjectNameInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkObjectType*)&forMarshaling->objectType, sizeof(VkObjectType));
    *ptr += sizeof(VkObjectType);
    memcpy(*ptr, (uint64_t*)&forMarshaling->objectHandle, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pObjectName;
        memcpy((*ptr), &cgen_var_0, 8);
        android::base::Stream::toBe64((uint8_t*)(*ptr));
        *ptr += 8;
        if (forMarshaling->pObjectName)
        {
            {
                uint32_t l = forMarshaling->pObjectName ? strlen(forMarshaling->pObjectName): 0;
                memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
                android::base::Stream::toBe32((uint8_t*)*ptr);
                *ptr += sizeof(uint32_t);
                memcpy(*ptr, (char*)forMarshaling->pObjectName, l);
                *ptr += l;
            }
        }
    }
    else
    {
        {
            uint32_t l = forMarshaling->pObjectName ? strlen(forMarshaling->pObjectName): 0;
            memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*ptr);
            *ptr += sizeof(uint32_t);
            memcpy(*ptr, (char*)forMarshaling->pObjectName, l);
            *ptr += l;
        }
    }
}

void reservedmarshal_VkDebugUtilsMessengerCallbackDataEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDebugUtilsMessengerCallbackDataEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDebugUtilsMessengerCallbackDataFlagsEXT*)&forMarshaling->flags, sizeof(VkDebugUtilsMessengerCallbackDataFlagsEXT));
    *ptr += sizeof(VkDebugUtilsMessengerCallbackDataFlagsEXT);
    if (vkStream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pMessageIdName;
        memcpy((*ptr), &cgen_var_0, 8);
        android::base::Stream::toBe64((uint8_t*)(*ptr));
        *ptr += 8;
        if (forMarshaling->pMessageIdName)
        {
            {
                uint32_t l = forMarshaling->pMessageIdName ? strlen(forMarshaling->pMessageIdName): 0;
                memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
                android::base::Stream::toBe32((uint8_t*)*ptr);
                *ptr += sizeof(uint32_t);
                memcpy(*ptr, (char*)forMarshaling->pMessageIdName, l);
                *ptr += l;
            }
        }
    }
    else
    {
        {
            uint32_t l = forMarshaling->pMessageIdName ? strlen(forMarshaling->pMessageIdName): 0;
            memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*ptr);
            *ptr += sizeof(uint32_t);
            memcpy(*ptr, (char*)forMarshaling->pMessageIdName, l);
            *ptr += l;
        }
    }
    memcpy(*ptr, (int32_t*)&forMarshaling->messageIdNumber, sizeof(int32_t));
    *ptr += sizeof(int32_t);
    {
        uint32_t l = forMarshaling->pMessage ? strlen(forMarshaling->pMessage): 0;
        memcpy(*ptr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*ptr);
        *ptr += sizeof(uint32_t);
        memcpy(*ptr, (char*)forMarshaling->pMessage, l);
        *ptr += l;
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueLabelCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pQueueLabels;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pQueueLabels)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->queueLabelCount; ++i)
        {
            reservedmarshal_VkDebugUtilsLabelEXT(vkStream, rootType, (VkDebugUtilsLabelEXT*)(forMarshaling->pQueueLabels + i), ptr);
        }
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->cmdBufLabelCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pCmdBufLabels;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pCmdBufLabels)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->cmdBufLabelCount; ++i)
        {
            reservedmarshal_VkDebugUtilsLabelEXT(vkStream, rootType, (VkDebugUtilsLabelEXT*)(forMarshaling->pCmdBufLabels + i), ptr);
        }
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->objectCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)forMarshaling->pObjects;
    memcpy((*ptr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pObjects)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->objectCount; ++i)
        {
            reservedmarshal_VkDebugUtilsObjectNameInfoEXT(vkStream, rootType, (VkDebugUtilsObjectNameInfoEXT*)(forMarshaling->pObjects + i), ptr);
        }
    }
}

void reservedmarshal_VkDebugUtilsMessengerCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDebugUtilsMessengerCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDebugUtilsMessengerCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkDebugUtilsMessengerCreateFlagsEXT));
    *ptr += sizeof(VkDebugUtilsMessengerCreateFlagsEXT);
    memcpy(*ptr, (VkDebugUtilsMessageSeverityFlagsEXT*)&forMarshaling->messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagsEXT));
    *ptr += sizeof(VkDebugUtilsMessageSeverityFlagsEXT);
    memcpy(*ptr, (VkDebugUtilsMessageTypeFlagsEXT*)&forMarshaling->messageType, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
    *ptr += sizeof(VkDebugUtilsMessageTypeFlagsEXT);
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->pfnUserCallback;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pUserData;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pUserData)
    {
        memcpy(*ptr, (void*)forMarshaling->pUserData, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

void reservedmarshal_VkDebugUtilsObjectTagInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDebugUtilsObjectTagInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkObjectType*)&forMarshaling->objectType, sizeof(VkObjectType));
    *ptr += sizeof(VkObjectType);
    memcpy(*ptr, (uint64_t*)&forMarshaling->objectHandle, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->tagName, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->tagSize;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    memcpy(*ptr, (const void*)forMarshaling->pTag, forMarshaling->tagSize * sizeof(const uint8_t));
    *ptr += forMarshaling->tagSize * sizeof(const uint8_t);
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
void reservedmarshal_VkAndroidHardwareBufferUsageANDROID(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAndroidHardwareBufferUsageANDROID* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint64_t*)&forMarshaling->androidHardwareBufferUsage, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedmarshal_VkAndroidHardwareBufferPropertiesANDROID(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAndroidHardwareBufferPropertiesANDROID* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->allocationSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkAndroidHardwareBufferFormatPropertiesANDROID(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAndroidHardwareBufferFormatPropertiesANDROID* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (uint64_t*)&forMarshaling->externalFormat, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (VkFormatFeatureFlags*)&forMarshaling->formatFeatures, sizeof(VkFormatFeatureFlags));
    *ptr += sizeof(VkFormatFeatureFlags);
    reservedmarshal_VkComponentMapping(vkStream, rootType, (VkComponentMapping*)(&forMarshaling->samplerYcbcrConversionComponents), ptr);
    memcpy(*ptr, (VkSamplerYcbcrModelConversion*)&forMarshaling->suggestedYcbcrModel, sizeof(VkSamplerYcbcrModelConversion));
    *ptr += sizeof(VkSamplerYcbcrModelConversion);
    memcpy(*ptr, (VkSamplerYcbcrRange*)&forMarshaling->suggestedYcbcrRange, sizeof(VkSamplerYcbcrRange));
    *ptr += sizeof(VkSamplerYcbcrRange);
    memcpy(*ptr, (VkChromaLocation*)&forMarshaling->suggestedXChromaOffset, sizeof(VkChromaLocation));
    *ptr += sizeof(VkChromaLocation);
    memcpy(*ptr, (VkChromaLocation*)&forMarshaling->suggestedYChromaOffset, sizeof(VkChromaLocation));
    *ptr += sizeof(VkChromaLocation);
}

void reservedmarshal_VkImportAndroidHardwareBufferInfoANDROID(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImportAndroidHardwareBufferInfoANDROID* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (AHardwareBuffer*)forMarshaling->buffer, sizeof(AHardwareBuffer));
    *ptr += sizeof(AHardwareBuffer);
}

void reservedmarshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDeviceMemory((*&forMarshaling->memory));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkExternalFormatANDROID(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkExternalFormatANDROID* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint64_t*)&forMarshaling->externalFormat, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_inline_uniform_block
void reservedmarshal_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceInlineUniformBlockFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->inlineUniformBlock, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingInlineUniformBlockUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceInlineUniformBlockPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxInlineUniformBlockSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorInlineUniformBlocks, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetInlineUniformBlocks, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindInlineUniformBlocks, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkWriteDescriptorSetInlineUniformBlockEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkWriteDescriptorSetInlineUniformBlockEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->dataSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const void*)forMarshaling->pData, forMarshaling->dataSize * sizeof(const uint8_t));
    *ptr += forMarshaling->dataSize * sizeof(const uint8_t);
}

void reservedmarshal_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDescriptorPoolInlineUniformBlockCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxInlineUniformBlockBindings, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void reservedmarshal_VkSampleLocationEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSampleLocationEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (float*)&forMarshaling->x, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->y, sizeof(float));
    *ptr += sizeof(float);
}

void reservedmarshal_VkSampleLocationsInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSampleLocationsInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSampleCountFlagBits*)&forMarshaling->sampleLocationsPerPixel, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->sampleLocationGridSize), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->sampleLocationsCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->sampleLocationsCount; ++i)
    {
        reservedmarshal_VkSampleLocationEXT(vkStream, rootType, (const VkSampleLocationEXT*)(forMarshaling->pSampleLocations + i), ptr);
    }
}

void reservedmarshal_VkAttachmentSampleLocationsEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAttachmentSampleLocationsEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->attachmentIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedmarshal_VkSampleLocationsInfoEXT(vkStream, rootType, (VkSampleLocationsInfoEXT*)(&forMarshaling->sampleLocationsInfo), ptr);
}

void reservedmarshal_VkSubpassSampleLocationsEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSubpassSampleLocationsEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->subpassIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    reservedmarshal_VkSampleLocationsInfoEXT(vkStream, rootType, (VkSampleLocationsInfoEXT*)(&forMarshaling->sampleLocationsInfo), ptr);
}

void reservedmarshal_VkRenderPassSampleLocationsBeginInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkRenderPassSampleLocationsBeginInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->attachmentInitialSampleLocationsCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentInitialSampleLocationsCount; ++i)
    {
        reservedmarshal_VkAttachmentSampleLocationsEXT(vkStream, rootType, (const VkAttachmentSampleLocationsEXT*)(forMarshaling->pAttachmentInitialSampleLocations + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->postSubpassSampleLocationsCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->postSubpassSampleLocationsCount; ++i)
    {
        reservedmarshal_VkSubpassSampleLocationsEXT(vkStream, rootType, (const VkSubpassSampleLocationsEXT*)(forMarshaling->pPostSubpassSampleLocations + i), ptr);
    }
}

void reservedmarshal_VkPipelineSampleLocationsStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineSampleLocationsStateCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sampleLocationsEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    reservedmarshal_VkSampleLocationsInfoEXT(vkStream, rootType, (VkSampleLocationsInfoEXT*)(&forMarshaling->sampleLocationsInfo), ptr);
}

void reservedmarshal_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceSampleLocationsPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->sampleLocationSampleCounts, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->maxSampleLocationGridSize), ptr);
    memcpy(*ptr, (float*)forMarshaling->sampleLocationCoordinateRange, 2 * sizeof(float));
    *ptr += 2 * sizeof(float);
    memcpy(*ptr, (uint32_t*)&forMarshaling->sampleLocationSubPixelBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkBool32*)&forMarshaling->variableSampleLocations, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkMultisamplePropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMultisamplePropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->maxSampleLocationGridSize), ptr);
}

#endif
#ifdef VK_EXT_blend_operation_advanced
void reservedmarshal_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->advancedBlendCoherentOperations, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->advancedBlendMaxColorAttachments, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkBool32*)&forMarshaling->advancedBlendIndependentBlend, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->advancedBlendNonPremultipliedSrcColor, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->advancedBlendNonPremultipliedDstColor, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->advancedBlendCorrelatedOverlap, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->advancedBlendAllOperations, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineColorBlendAdvancedStateCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->srcPremultiplied, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->dstPremultiplied, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBlendOverlapEXT*)&forMarshaling->blendOverlap, sizeof(VkBlendOverlapEXT));
    *ptr += sizeof(VkBlendOverlapEXT);
}

#endif
#ifdef VK_NV_fragment_coverage_to_color
void reservedmarshal_VkPipelineCoverageToColorStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineCoverageToColorStateCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineCoverageToColorStateCreateFlagsNV*)&forMarshaling->flags, sizeof(VkPipelineCoverageToColorStateCreateFlagsNV));
    *ptr += sizeof(VkPipelineCoverageToColorStateCreateFlagsNV);
    memcpy(*ptr, (VkBool32*)&forMarshaling->coverageToColorEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (uint32_t*)&forMarshaling->coverageToColorLocation, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_NV_framebuffer_mixed_samples
void reservedmarshal_VkPipelineCoverageModulationStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineCoverageModulationStateCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineCoverageModulationStateCreateFlagsNV*)&forMarshaling->flags, sizeof(VkPipelineCoverageModulationStateCreateFlagsNV));
    *ptr += sizeof(VkPipelineCoverageModulationStateCreateFlagsNV);
    memcpy(*ptr, (VkCoverageModulationModeNV*)&forMarshaling->coverageModulationMode, sizeof(VkCoverageModulationModeNV));
    *ptr += sizeof(VkCoverageModulationModeNV);
    memcpy(*ptr, (VkBool32*)&forMarshaling->coverageModulationTableEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (uint32_t*)&forMarshaling->coverageModulationTableCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pCoverageModulationTable;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pCoverageModulationTable)
    {
        memcpy(*ptr, (const float*)forMarshaling->pCoverageModulationTable, forMarshaling->coverageModulationTableCount * sizeof(const float));
        *ptr += forMarshaling->coverageModulationTableCount * sizeof(const float);
    }
}

#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_NV_shader_sm_builtins
void reservedmarshal_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->shaderSMCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->shaderWarpsPerSM, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSMBuiltins, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_image_drm_format_modifier
void reservedmarshal_VkDrmFormatModifierPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDrmFormatModifierPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint64_t*)&forMarshaling->drmFormatModifier, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->drmFormatModifierPlaneCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkFormatFeatureFlags*)&forMarshaling->drmFormatModifierTilingFeatures, sizeof(VkFormatFeatureFlags));
    *ptr += sizeof(VkFormatFeatureFlags);
}

void reservedmarshal_VkDrmFormatModifierPropertiesListEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDrmFormatModifierPropertiesListEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->drmFormatModifierCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pDrmFormatModifierProperties;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pDrmFormatModifierProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->drmFormatModifierCount; ++i)
        {
            reservedmarshal_VkDrmFormatModifierPropertiesEXT(vkStream, rootType, (VkDrmFormatModifierPropertiesEXT*)(forMarshaling->pDrmFormatModifierProperties + i), ptr);
        }
    }
}

void reservedmarshal_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceImageDrmFormatModifierInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint64_t*)&forMarshaling->drmFormatModifier, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (VkSharingMode*)&forMarshaling->sharingMode, sizeof(VkSharingMode));
    *ptr += sizeof(VkSharingMode);
    memcpy(*ptr, (uint32_t*)&forMarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pQueueFamilyIndices;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pQueueFamilyIndices)
    {
        memcpy(*ptr, (const uint32_t*)forMarshaling->pQueueFamilyIndices, forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
        *ptr += forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t);
    }
}

void reservedmarshal_VkImageDrmFormatModifierListCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageDrmFormatModifierListCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->drmFormatModifierCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint64_t*)forMarshaling->pDrmFormatModifiers, forMarshaling->drmFormatModifierCount * sizeof(const uint64_t));
    *ptr += forMarshaling->drmFormatModifierCount * sizeof(const uint64_t);
}

void reservedmarshal_VkImageDrmFormatModifierExplicitCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageDrmFormatModifierExplicitCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint64_t*)&forMarshaling->drmFormatModifier, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->drmFormatModifierPlaneCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->drmFormatModifierPlaneCount; ++i)
    {
        reservedmarshal_VkSubresourceLayout(vkStream, rootType, (const VkSubresourceLayout*)(forMarshaling->pPlaneLayouts + i), ptr);
    }
}

void reservedmarshal_VkImageDrmFormatModifierPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImageDrmFormatModifierPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint64_t*)&forMarshaling->drmFormatModifier, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

#endif
#ifdef VK_EXT_validation_cache
void reservedmarshal_VkValidationCacheCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkValidationCacheCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkValidationCacheCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkValidationCacheCreateFlagsEXT));
    *ptr += sizeof(VkValidationCacheCreateFlagsEXT);
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->initialDataSize;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    memcpy(*ptr, (const void*)forMarshaling->pInitialData, forMarshaling->initialDataSize * sizeof(const uint8_t));
    *ptr += forMarshaling->initialDataSize * sizeof(const uint8_t);
}

void reservedmarshal_VkShaderModuleValidationCacheCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkShaderModuleValidationCacheCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkValidationCacheEXT((*&forMarshaling->validationCache));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
}

#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_NV_shading_rate_image
void reservedmarshal_VkShadingRatePaletteNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkShadingRatePaletteNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->shadingRatePaletteEntryCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const VkShadingRatePaletteEntryNV*)forMarshaling->pShadingRatePaletteEntries, forMarshaling->shadingRatePaletteEntryCount * sizeof(const VkShadingRatePaletteEntryNV));
    *ptr += forMarshaling->shadingRatePaletteEntryCount * sizeof(const VkShadingRatePaletteEntryNV);
}

void reservedmarshal_VkPipelineViewportShadingRateImageStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineViewportShadingRateImageStateCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shadingRateImageEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (uint32_t*)&forMarshaling->viewportCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pShadingRatePalettes;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pShadingRatePalettes)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->viewportCount; ++i)
        {
            reservedmarshal_VkShadingRatePaletteNV(vkStream, rootType, (const VkShadingRatePaletteNV*)(forMarshaling->pShadingRatePalettes + i), ptr);
        }
    }
}

void reservedmarshal_VkPhysicalDeviceShadingRateImageFeaturesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceShadingRateImageFeaturesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shadingRateImage, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shadingRateCoarseSampleOrder, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceShadingRateImagePropertiesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceShadingRateImagePropertiesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->shadingRateTexelSize), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->shadingRatePaletteSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->shadingRateMaxCoarseSamples, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkCoarseSampleLocationNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCoarseSampleLocationNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->pixelX, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->pixelY, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->sample, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkCoarseSampleOrderCustomNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCoarseSampleOrderCustomNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkShadingRatePaletteEntryNV*)&forMarshaling->shadingRate, sizeof(VkShadingRatePaletteEntryNV));
    *ptr += sizeof(VkShadingRatePaletteEntryNV);
    memcpy(*ptr, (uint32_t*)&forMarshaling->sampleCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->sampleLocationCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->sampleLocationCount; ++i)
    {
        reservedmarshal_VkCoarseSampleLocationNV(vkStream, rootType, (const VkCoarseSampleLocationNV*)(forMarshaling->pSampleLocations + i), ptr);
    }
}

void reservedmarshal_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkCoarseSampleOrderTypeNV*)&forMarshaling->sampleOrderType, sizeof(VkCoarseSampleOrderTypeNV));
    *ptr += sizeof(VkCoarseSampleOrderTypeNV);
    memcpy(*ptr, (uint32_t*)&forMarshaling->customSampleOrderCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->customSampleOrderCount; ++i)
    {
        reservedmarshal_VkCoarseSampleOrderCustomNV(vkStream, rootType, (const VkCoarseSampleOrderCustomNV*)(forMarshaling->pCustomSampleOrders + i), ptr);
    }
}

#endif
#ifdef VK_NV_ray_tracing
void reservedmarshal_VkRayTracingShaderGroupCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkRayTracingShaderGroupCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkRayTracingShaderGroupTypeKHR*)&forMarshaling->type, sizeof(VkRayTracingShaderGroupTypeKHR));
    *ptr += sizeof(VkRayTracingShaderGroupTypeKHR);
    memcpy(*ptr, (uint32_t*)&forMarshaling->generalShader, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->closestHitShader, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->anyHitShader, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->intersectionShader, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkRayTracingPipelineCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkRayTracingPipelineCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCreateFlags));
    *ptr += sizeof(VkPipelineCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->stageCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->stageCount; ++i)
    {
        reservedmarshal_VkPipelineShaderStageCreateInfo(vkStream, rootType, (const VkPipelineShaderStageCreateInfo*)(forMarshaling->pStages + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->groupCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->groupCount; ++i)
    {
        reservedmarshal_VkRayTracingShaderGroupCreateInfoNV(vkStream, rootType, (const VkRayTracingShaderGroupCreateInfoNV*)(forMarshaling->pGroups + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxRecursionDepth, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPipelineLayout((*&forMarshaling->layout));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkPipeline((*&forMarshaling->basePipelineHandle));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (int32_t*)&forMarshaling->basePipelineIndex, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedmarshal_VkGeometryTrianglesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkGeometryTrianglesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&forMarshaling->vertexData));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->vertexOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (uint32_t*)&forMarshaling->vertexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->vertexStride, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkFormat*)&forMarshaling->vertexFormat, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&forMarshaling->indexData));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->indexOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (uint32_t*)&forMarshaling->indexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkIndexType*)&forMarshaling->indexType, sizeof(VkIndexType));
    *ptr += sizeof(VkIndexType);
    uint64_t cgen_var_2;
    *&cgen_var_2 = get_host_u64_VkBuffer((*&forMarshaling->transformData));
    memcpy(*ptr, (uint64_t*)&cgen_var_2, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->transformOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkGeometryAABBNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkGeometryAABBNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&forMarshaling->aabbData));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->numAABBs, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->stride, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkGeometryDataNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkGeometryDataNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    reservedmarshal_VkGeometryTrianglesNV(vkStream, rootType, (VkGeometryTrianglesNV*)(&forMarshaling->triangles), ptr);
    reservedmarshal_VkGeometryAABBNV(vkStream, rootType, (VkGeometryAABBNV*)(&forMarshaling->aabbs), ptr);
}

void reservedmarshal_VkGeometryNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkGeometryNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkGeometryTypeKHR*)&forMarshaling->geometryType, sizeof(VkGeometryTypeKHR));
    *ptr += sizeof(VkGeometryTypeKHR);
    reservedmarshal_VkGeometryDataNV(vkStream, rootType, (VkGeometryDataNV*)(&forMarshaling->geometry), ptr);
    memcpy(*ptr, (VkGeometryFlagsKHR*)&forMarshaling->flags, sizeof(VkGeometryFlagsKHR));
    *ptr += sizeof(VkGeometryFlagsKHR);
}

void reservedmarshal_VkAccelerationStructureInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAccelerationStructureInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkAccelerationStructureTypeNV*)&forMarshaling->type, sizeof(VkAccelerationStructureTypeNV));
    *ptr += sizeof(VkAccelerationStructureTypeNV);
    memcpy(*ptr, (VkBuildAccelerationStructureFlagsNV*)&forMarshaling->flags, sizeof(VkBuildAccelerationStructureFlagsNV));
    *ptr += sizeof(VkBuildAccelerationStructureFlagsNV);
    memcpy(*ptr, (uint32_t*)&forMarshaling->instanceCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->geometryCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->geometryCount; ++i)
    {
        reservedmarshal_VkGeometryNV(vkStream, rootType, (const VkGeometryNV*)(forMarshaling->pGeometries + i), ptr);
    }
}

void reservedmarshal_VkAccelerationStructureCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAccelerationStructureCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->compactedSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    reservedmarshal_VkAccelerationStructureInfoNV(vkStream, rootType, (VkAccelerationStructureInfoNV*)(&forMarshaling->info), ptr);
}

void reservedmarshal_VkBindAccelerationStructureMemoryInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBindAccelerationStructureMemoryInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkAccelerationStructureNV((*&forMarshaling->accelerationStructure));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDeviceMemory((*&forMarshaling->memory));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (uint32_t*)&forMarshaling->deviceIndexCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pDeviceIndices, forMarshaling->deviceIndexCount * sizeof(const uint32_t));
    *ptr += forMarshaling->deviceIndexCount * sizeof(const uint32_t);
}

void reservedmarshal_VkWriteDescriptorSetAccelerationStructureNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkWriteDescriptorSetAccelerationStructureNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->accelerationStructureCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pAccelerationStructures;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pAccelerationStructures)
    {
        if (forMarshaling->accelerationStructureCount)
        {
            uint8_t* cgen_var_0_0_ptr = (uint8_t*)(*ptr);
            if (forMarshaling)
            {
                for (uint32_t k = 0; k < forMarshaling->accelerationStructureCount; ++k)
                {
                    uint64_t tmpval = get_host_u64_VkAccelerationStructureNV(forMarshaling->pAccelerationStructures[k]);
                    memcpy(cgen_var_0_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
                }
            }
            *ptr += 8 * forMarshaling->accelerationStructureCount;
        }
    }
}

void reservedmarshal_VkAccelerationStructureMemoryRequirementsInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAccelerationStructureMemoryRequirementsInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkAccelerationStructureMemoryRequirementsTypeNV*)&forMarshaling->type, sizeof(VkAccelerationStructureMemoryRequirementsTypeNV));
    *ptr += sizeof(VkAccelerationStructureMemoryRequirementsTypeNV);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkAccelerationStructureNV((*&forMarshaling->accelerationStructure));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkPhysicalDeviceRayTracingPropertiesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceRayTracingPropertiesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->shaderGroupHandleSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxRecursionDepth, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxShaderGroupStride, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->shaderGroupBaseAlignment, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->maxGeometryCount, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->maxInstanceCount, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->maxTriangleCount, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetAccelerationStructures, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkTransformMatrixKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkTransformMatrixKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (float*)forMarshaling->matrix, ((3)*(4)) * sizeof(float));
    *ptr += ((3)*(4)) * sizeof(float);
}

void reservedmarshal_VkAabbPositionsKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAabbPositionsKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (float*)&forMarshaling->minX, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->minY, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->minZ, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxX, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxY, sizeof(float));
    *ptr += sizeof(float);
    memcpy(*ptr, (float*)&forMarshaling->maxZ, sizeof(float));
    *ptr += sizeof(float);
}

void reservedmarshal_VkAccelerationStructureInstanceKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAccelerationStructureInstanceKHR* forMarshaling,
    uint8_t** ptr)
{
    
    typedef struct VkAccelerationStructureInstanceKHRWithoutBitFields {
        VkTransformMatrixKHR          transform;
        uint32_t                      dwords[2];
        uint64_t                      accelerationStructureReference;
    } VkAccelerationStructureInstanceKHRWithoutBitFields;
    
    (void)vkStream;
    const VkAccelerationStructureInstanceKHRWithoutBitFields* forMarshaling_new = (const VkAccelerationStructureInstanceKHRWithoutBitFields*)(forMarshaling);
    reservedmarshal_VkTransformMatrixKHR(vkStream, rootType, (VkTransformMatrixKHR*)(&forMarshaling_new->transform), ptr);
    for (uint32_t i = 0; i < 2; i++) {
        memcpy(*ptr, (uint32_t*)&(forMarshaling_new->dwords[i]), sizeof(uint32_t));
        *ptr += sizeof(uint32_t);
    }
    memcpy(*ptr, (uint64_t*)&forMarshaling_new->accelerationStructureReference, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    
}

#endif
#ifdef VK_NV_representative_fragment_test
void reservedmarshal_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->representativeFragmentTest, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineRepresentativeFragmentTestStateCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->representativeFragmentTestEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_filter_cubic
void reservedmarshal_VkPhysicalDeviceImageViewImageFormatInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceImageViewImageFormatInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkImageViewType*)&forMarshaling->imageViewType, sizeof(VkImageViewType));
    *ptr += sizeof(VkImageViewType);
}

void reservedmarshal_VkFilterCubicImageViewImageFormatPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkFilterCubicImageViewImageFormatPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->filterCubic, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->filterCubicMinmax, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_QCOM_render_pass_shader_resolve
#endif
#ifdef VK_EXT_global_priority
void reservedmarshal_VkDeviceQueueGlobalPriorityCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceQueueGlobalPriorityCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkQueueGlobalPriorityEXT*)&forMarshaling->globalPriority, sizeof(VkQueueGlobalPriorityEXT));
    *ptr += sizeof(VkQueueGlobalPriorityEXT);
}

#endif
#ifdef VK_EXT_external_memory_host
void reservedmarshal_VkImportMemoryHostPointerInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImportMemoryHostPointerInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *ptr += sizeof(VkExternalMemoryHandleTypeFlagBits);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pHostPointer;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pHostPointer)
    {
        memcpy(*ptr, (void*)forMarshaling->pHostPointer, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

void reservedmarshal_VkMemoryHostPointerPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMemoryHostPointerPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->minImportedHostPointerAlignment, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

#endif
#ifdef VK_AMD_buffer_marker
#endif
#ifdef VK_AMD_pipeline_compiler_control
void reservedmarshal_VkPipelineCompilerControlCreateInfoAMD(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineCompilerControlCreateInfoAMD* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineCompilerControlFlagsAMD*)&forMarshaling->compilerControlFlags, sizeof(VkPipelineCompilerControlFlagsAMD));
    *ptr += sizeof(VkPipelineCompilerControlFlagsAMD);
}

#endif
#ifdef VK_EXT_calibrated_timestamps
void reservedmarshal_VkCalibratedTimestampInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCalibratedTimestampInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkTimeDomainEXT*)&forMarshaling->timeDomain, sizeof(VkTimeDomainEXT));
    *ptr += sizeof(VkTimeDomainEXT);
}

#endif
#ifdef VK_AMD_shader_core_properties
void reservedmarshal_VkPhysicalDeviceShaderCorePropertiesAMD(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderCorePropertiesAMD* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->shaderEngineCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->shaderArraysPerEngineCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->computeUnitsPerShaderArray, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->simdPerComputeUnit, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->wavefrontsPerSimd, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->wavefrontSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->sgprsPerSimd, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->minSgprAllocation, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxSgprAllocation, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->sgprAllocationGranularity, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->vgprsPerSimd, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->minVgprAllocation, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxVgprAllocation, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->vgprAllocationGranularity, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_AMD_memory_overallocation_behavior
void reservedmarshal_VkDeviceMemoryOverallocationCreateInfoAMD(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceMemoryOverallocationCreateInfoAMD* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkMemoryOverallocationBehaviorAMD*)&forMarshaling->overallocationBehavior, sizeof(VkMemoryOverallocationBehaviorAMD));
    *ptr += sizeof(VkMemoryOverallocationBehaviorAMD);
}

#endif
#ifdef VK_EXT_vertex_attribute_divisor
void reservedmarshal_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxVertexAttribDivisor, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkVertexInputBindingDivisorDescriptionEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkVertexInputBindingDivisorDescriptionEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->divisor, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineVertexInputDivisorStateCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->vertexBindingDivisorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->vertexBindingDivisorCount; ++i)
    {
        reservedmarshal_VkVertexInputBindingDivisorDescriptionEXT(vkStream, rootType, (const VkVertexInputBindingDivisorDescriptionEXT*)(forMarshaling->pVertexBindingDivisors + i), ptr);
    }
}

void reservedmarshal_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->vertexAttributeInstanceRateDivisor, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->vertexAttributeInstanceRateZeroDivisor, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_GGP_frame_token
void reservedmarshal_VkPresentFrameTokenGGP(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPresentFrameTokenGGP* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (GgpFrameToken*)&forMarshaling->frameToken, sizeof(GgpFrameToken));
    *ptr += sizeof(GgpFrameToken);
}

#endif
#ifdef VK_EXT_pipeline_creation_feedback
void reservedmarshal_VkPipelineCreationFeedbackEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineCreationFeedbackEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkPipelineCreationFeedbackFlagsEXT*)&forMarshaling->flags, sizeof(VkPipelineCreationFeedbackFlagsEXT));
    *ptr += sizeof(VkPipelineCreationFeedbackFlagsEXT);
    memcpy(*ptr, (uint64_t*)&forMarshaling->duration, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedmarshal_VkPipelineCreationFeedbackCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineCreationFeedbackCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkPipelineCreationFeedbackEXT(vkStream, rootType, (VkPipelineCreationFeedbackEXT*)(forMarshaling->pPipelineCreationFeedback), ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->pipelineStageCreationFeedbackCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->pipelineStageCreationFeedbackCount; ++i)
    {
        reservedmarshal_VkPipelineCreationFeedbackEXT(vkStream, rootType, (VkPipelineCreationFeedbackEXT*)(forMarshaling->pPipelineStageCreationFeedbacks + i), ptr);
    }
}

#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_compute_shader_derivatives
void reservedmarshal_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->computeDerivativeGroupQuads, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->computeDerivativeGroupLinear, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_mesh_shader
void reservedmarshal_VkPhysicalDeviceMeshShaderFeaturesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceMeshShaderFeaturesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->taskShader, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->meshShader, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceMeshShaderPropertiesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceMeshShaderPropertiesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDrawMeshTasksCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTaskWorkGroupInvocations, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)forMarshaling->maxTaskWorkGroupSize, 3 * sizeof(uint32_t));
    *ptr += 3 * sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTaskTotalMemorySize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxTaskOutputCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxMeshWorkGroupInvocations, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)forMarshaling->maxMeshWorkGroupSize, 3 * sizeof(uint32_t));
    *ptr += 3 * sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxMeshTotalMemorySize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxMeshOutputVertices, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxMeshOutputPrimitives, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxMeshMultiviewViewCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->meshOutputPerVertexGranularity, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->meshOutputPerPrimitiveGranularity, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDrawMeshTasksIndirectCommandNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDrawMeshTasksIndirectCommandNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->taskCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->firstTask, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_NV_fragment_shader_barycentric
void reservedmarshal_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentShaderBarycentric, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_shader_image_footprint
void reservedmarshal_VkPhysicalDeviceShaderImageFootprintFeaturesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderImageFootprintFeaturesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->imageFootprint, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_scissor_exclusive
void reservedmarshal_VkPipelineViewportExclusiveScissorStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineViewportExclusiveScissorStateCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->exclusiveScissorCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pExclusiveScissors;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pExclusiveScissors)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->exclusiveScissorCount; ++i)
        {
            reservedmarshal_VkRect2D(vkStream, rootType, (const VkRect2D*)(forMarshaling->pExclusiveScissors + i), ptr);
        }
    }
}

void reservedmarshal_VkPhysicalDeviceExclusiveScissorFeaturesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceExclusiveScissorFeaturesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->exclusiveScissor, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void reservedmarshal_VkQueueFamilyCheckpointPropertiesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkQueueFamilyCheckpointPropertiesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineStageFlags*)&forMarshaling->checkpointExecutionStageMask, sizeof(VkPipelineStageFlags));
    *ptr += sizeof(VkPipelineStageFlags);
}

void reservedmarshal_VkCheckpointDataNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCheckpointDataNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineStageFlagBits*)&forMarshaling->stage, sizeof(VkPipelineStageFlagBits));
    *ptr += sizeof(VkPipelineStageFlagBits);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pCheckpointMarker;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pCheckpointMarker)
    {
        memcpy(*ptr, (void*)forMarshaling->pCheckpointMarker, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

#endif
#ifdef VK_INTEL_shader_integer_functions2
void reservedmarshal_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderIntegerFunctions2, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_INTEL_performance_query
void reservedmarshal_VkPerformanceValueDataINTEL(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPerformanceValueDataINTEL* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->value32, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPerformanceValueINTEL(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPerformanceValueINTEL* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkPerformanceValueTypeINTEL*)&forMarshaling->type, sizeof(VkPerformanceValueTypeINTEL));
    *ptr += sizeof(VkPerformanceValueTypeINTEL);
    reservedmarshal_VkPerformanceValueDataINTEL(vkStream, rootType, (VkPerformanceValueDataINTEL*)(&forMarshaling->data), ptr);
}

void reservedmarshal_VkInitializePerformanceApiInfoINTEL(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkInitializePerformanceApiInfoINTEL* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pUserData;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pUserData)
    {
        memcpy(*ptr, (void*)forMarshaling->pUserData, sizeof(uint8_t));
        *ptr += sizeof(uint8_t);
    }
}

void reservedmarshal_VkQueryPoolPerformanceQueryCreateInfoINTEL(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkQueryPoolPerformanceQueryCreateInfoINTEL* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkQueryPoolSamplingModeINTEL*)&forMarshaling->performanceCountersSampling, sizeof(VkQueryPoolSamplingModeINTEL));
    *ptr += sizeof(VkQueryPoolSamplingModeINTEL);
}

void reservedmarshal_VkPerformanceMarkerInfoINTEL(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPerformanceMarkerInfoINTEL* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint64_t*)&forMarshaling->marker, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedmarshal_VkPerformanceStreamMarkerInfoINTEL(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPerformanceStreamMarkerInfoINTEL* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->marker, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPerformanceOverrideInfoINTEL(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPerformanceOverrideInfoINTEL* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPerformanceOverrideTypeINTEL*)&forMarshaling->type, sizeof(VkPerformanceOverrideTypeINTEL));
    *ptr += sizeof(VkPerformanceOverrideTypeINTEL);
    memcpy(*ptr, (VkBool32*)&forMarshaling->enable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (uint64_t*)&forMarshaling->parameter, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
}

void reservedmarshal_VkPerformanceConfigurationAcquireInfoINTEL(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPerformanceConfigurationAcquireInfoINTEL* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPerformanceConfigurationTypeINTEL*)&forMarshaling->type, sizeof(VkPerformanceConfigurationTypeINTEL));
    *ptr += sizeof(VkPerformanceConfigurationTypeINTEL);
}

#endif
#ifdef VK_EXT_pci_bus_info
void reservedmarshal_VkPhysicalDevicePCIBusInfoPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDevicePCIBusInfoPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->pciDomain, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->pciBus, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->pciDevice, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->pciFunction, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_AMD_display_native_hdr
void reservedmarshal_VkDisplayNativeHdrSurfaceCapabilitiesAMD(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDisplayNativeHdrSurfaceCapabilitiesAMD* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->localDimmingSupport, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkSwapchainDisplayNativeHdrCreateInfoAMD(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSwapchainDisplayNativeHdrCreateInfoAMD* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->localDimmingEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_FUCHSIA_imagepipe_surface
void reservedmarshal_VkImagePipeSurfaceCreateInfoFUCHSIA(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImagePipeSurfaceCreateInfoFUCHSIA* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkImagePipeSurfaceCreateFlagsFUCHSIA*)&forMarshaling->flags, sizeof(VkImagePipeSurfaceCreateFlagsFUCHSIA));
    *ptr += sizeof(VkImagePipeSurfaceCreateFlagsFUCHSIA);
    memcpy(*ptr, (zx_handle_t*)&forMarshaling->imagePipeHandle, sizeof(zx_handle_t));
    *ptr += sizeof(zx_handle_t);
}

#endif
#ifdef VK_EXT_metal_surface
void reservedmarshal_VkMetalSurfaceCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMetalSurfaceCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkMetalSurfaceCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkMetalSurfaceCreateFlagsEXT));
    *ptr += sizeof(VkMetalSurfaceCreateFlagsEXT);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pLayer;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pLayer)
    {
        memcpy(*ptr, (const CAMetalLayer*)forMarshaling->pLayer, sizeof(const CAMetalLayer));
        *ptr += sizeof(const CAMetalLayer);
    }
}

#endif
#ifdef VK_EXT_fragment_density_map
void reservedmarshal_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentDensityMapFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentDensityMap, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentDensityMapDynamic, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentDensityMapNonSubsampledImages, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentDensityMapPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->minFragmentDensityTexelSize), ptr);
    reservedmarshal_VkExtent2D(vkStream, rootType, (VkExtent2D*)(&forMarshaling->maxFragmentDensityTexelSize), ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentDensityInvocations, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkRenderPassFragmentDensityMapCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkRenderPassFragmentDensityMapCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkAttachmentReference(vkStream, rootType, (VkAttachmentReference*)(&forMarshaling->fragmentDensityMapAttachment), ptr);
}

#endif
#ifdef VK_EXT_scalar_block_layout
#endif
#ifdef VK_GOOGLE_hlsl_functionality1
#endif
#ifdef VK_GOOGLE_decorate_string
#endif
#ifdef VK_EXT_subgroup_size_control
void reservedmarshal_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->subgroupSizeControl, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->computeFullSubgroups, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->minSubgroupSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxSubgroupSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxComputeWorkgroupSubgroups, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkShaderStageFlags*)&forMarshaling->requiredSubgroupSizeStages, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
}

void reservedmarshal_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->requiredSubgroupSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_AMD_shader_core_properties2
void reservedmarshal_VkPhysicalDeviceShaderCoreProperties2AMD(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderCoreProperties2AMD* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkShaderCorePropertiesFlagsAMD*)&forMarshaling->shaderCoreFeatures, sizeof(VkShaderCorePropertiesFlagsAMD));
    *ptr += sizeof(VkShaderCorePropertiesFlagsAMD);
    memcpy(*ptr, (uint32_t*)&forMarshaling->activeComputeUnitCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_AMD_device_coherent_memory
void reservedmarshal_VkPhysicalDeviceCoherentMemoryFeaturesAMD(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceCoherentMemoryFeaturesAMD* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->deviceCoherentMemory, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_shader_image_atomic_int64
void reservedmarshal_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderImageInt64Atomics, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseImageInt64Atomics, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_memory_budget
void reservedmarshal_VkPhysicalDeviceMemoryBudgetPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceMemoryBudgetPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceSize*)forMarshaling->heapBudget, VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize));
    *ptr += VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)forMarshaling->heapUsage, VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize));
    *ptr += VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize);
}

#endif
#ifdef VK_EXT_memory_priority
void reservedmarshal_VkPhysicalDeviceMemoryPriorityFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceMemoryPriorityFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->memoryPriority, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkMemoryPriorityAllocateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkMemoryPriorityAllocateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (float*)&forMarshaling->priority, sizeof(float));
    *ptr += sizeof(float);
}

#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
void reservedmarshal_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->dedicatedAllocationImageAliasing, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_buffer_device_address
void reservedmarshal_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->bufferDeviceAddress, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->bufferDeviceAddressCaptureReplay, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->bufferDeviceAddressMultiDevice, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkBufferDeviceAddressCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBufferDeviceAddressCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceAddress*)&forMarshaling->deviceAddress, sizeof(VkDeviceAddress));
    *ptr += sizeof(VkDeviceAddress);
}

#endif
#ifdef VK_EXT_tooling_info
void reservedmarshal_VkPhysicalDeviceToolPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceToolPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (char*)forMarshaling->name, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
    memcpy(*ptr, (char*)forMarshaling->version, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
    memcpy(*ptr, (VkToolPurposeFlagsEXT*)&forMarshaling->purposes, sizeof(VkToolPurposeFlagsEXT));
    *ptr += sizeof(VkToolPurposeFlagsEXT);
    memcpy(*ptr, (char*)forMarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    *ptr += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    memcpy(*ptr, (char*)forMarshaling->layer, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    *ptr += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
}

#endif
#ifdef VK_EXT_separate_stencil_usage
#endif
#ifdef VK_EXT_validation_features
void reservedmarshal_VkValidationFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkValidationFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->enabledValidationFeatureCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const VkValidationFeatureEnableEXT*)forMarshaling->pEnabledValidationFeatures, forMarshaling->enabledValidationFeatureCount * sizeof(const VkValidationFeatureEnableEXT));
    *ptr += forMarshaling->enabledValidationFeatureCount * sizeof(const VkValidationFeatureEnableEXT);
    memcpy(*ptr, (uint32_t*)&forMarshaling->disabledValidationFeatureCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const VkValidationFeatureDisableEXT*)forMarshaling->pDisabledValidationFeatures, forMarshaling->disabledValidationFeatureCount * sizeof(const VkValidationFeatureDisableEXT));
    *ptr += forMarshaling->disabledValidationFeatureCount * sizeof(const VkValidationFeatureDisableEXT);
}

#endif
#ifdef VK_NV_cooperative_matrix
void reservedmarshal_VkCooperativeMatrixPropertiesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCooperativeMatrixPropertiesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->MSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->NSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->KSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkComponentTypeNV*)&forMarshaling->AType, sizeof(VkComponentTypeNV));
    *ptr += sizeof(VkComponentTypeNV);
    memcpy(*ptr, (VkComponentTypeNV*)&forMarshaling->BType, sizeof(VkComponentTypeNV));
    *ptr += sizeof(VkComponentTypeNV);
    memcpy(*ptr, (VkComponentTypeNV*)&forMarshaling->CType, sizeof(VkComponentTypeNV));
    *ptr += sizeof(VkComponentTypeNV);
    memcpy(*ptr, (VkComponentTypeNV*)&forMarshaling->DType, sizeof(VkComponentTypeNV));
    *ptr += sizeof(VkComponentTypeNV);
    memcpy(*ptr, (VkScopeNV*)&forMarshaling->scope, sizeof(VkScopeNV));
    *ptr += sizeof(VkScopeNV);
}

void reservedmarshal_VkPhysicalDeviceCooperativeMatrixFeaturesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceCooperativeMatrixFeaturesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->cooperativeMatrix, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->cooperativeMatrixRobustBufferAccess, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceCooperativeMatrixPropertiesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceCooperativeMatrixPropertiesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkShaderStageFlags*)&forMarshaling->cooperativeMatrixSupportedStages, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
}

#endif
#ifdef VK_NV_coverage_reduction_mode
void reservedmarshal_VkPhysicalDeviceCoverageReductionModeFeaturesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceCoverageReductionModeFeaturesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->coverageReductionMode, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPipelineCoverageReductionStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineCoverageReductionStateCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineCoverageReductionStateCreateFlagsNV*)&forMarshaling->flags, sizeof(VkPipelineCoverageReductionStateCreateFlagsNV));
    *ptr += sizeof(VkPipelineCoverageReductionStateCreateFlagsNV);
    memcpy(*ptr, (VkCoverageReductionModeNV*)&forMarshaling->coverageReductionMode, sizeof(VkCoverageReductionModeNV));
    *ptr += sizeof(VkCoverageReductionModeNV);
}

void reservedmarshal_VkFramebufferMixedSamplesCombinationNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkFramebufferMixedSamplesCombinationNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkCoverageReductionModeNV*)&forMarshaling->coverageReductionMode, sizeof(VkCoverageReductionModeNV));
    *ptr += sizeof(VkCoverageReductionModeNV);
    memcpy(*ptr, (VkSampleCountFlagBits*)&forMarshaling->rasterizationSamples, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->depthStencilSamples, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
    memcpy(*ptr, (VkSampleCountFlags*)&forMarshaling->colorSamples, sizeof(VkSampleCountFlags));
    *ptr += sizeof(VkSampleCountFlags);
}

#endif
#ifdef VK_EXT_fragment_shader_interlock
void reservedmarshal_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentShaderSampleInterlock, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentShaderPixelInterlock, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentShaderShadingRateInterlock, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_ycbcr_image_arrays
void reservedmarshal_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->ycbcrImageArrays, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_full_screen_exclusive
void reservedmarshal_VkSurfaceFullScreenExclusiveInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSurfaceFullScreenExclusiveInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkFullScreenExclusiveEXT*)&forMarshaling->fullScreenExclusive, sizeof(VkFullScreenExclusiveEXT));
    *ptr += sizeof(VkFullScreenExclusiveEXT);
}

void reservedmarshal_VkSurfaceCapabilitiesFullScreenExclusiveEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSurfaceCapabilitiesFullScreenExclusiveEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fullScreenExclusiveSupported, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkSurfaceFullScreenExclusiveWin32InfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSurfaceFullScreenExclusiveWin32InfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (HMONITOR*)&forMarshaling->hmonitor, sizeof(HMONITOR));
    *ptr += sizeof(HMONITOR);
}

#endif
#ifdef VK_EXT_headless_surface
void reservedmarshal_VkHeadlessSurfaceCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkHeadlessSurfaceCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkHeadlessSurfaceCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkHeadlessSurfaceCreateFlagsEXT));
    *ptr += sizeof(VkHeadlessSurfaceCreateFlagsEXT);
}

#endif
#ifdef VK_EXT_line_rasterization
void reservedmarshal_VkPhysicalDeviceLineRasterizationFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceLineRasterizationFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->rectangularLines, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->bresenhamLines, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->smoothLines, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->stippledRectangularLines, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->stippledBresenhamLines, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->stippledSmoothLines, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceLineRasterizationPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceLineRasterizationPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->lineSubPixelPrecisionBits, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPipelineRasterizationLineStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineRasterizationLineStateCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkLineRasterizationModeEXT*)&forMarshaling->lineRasterizationMode, sizeof(VkLineRasterizationModeEXT));
    *ptr += sizeof(VkLineRasterizationModeEXT);
    memcpy(*ptr, (VkBool32*)&forMarshaling->stippledLineEnable, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (uint32_t*)&forMarshaling->lineStippleFactor, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint16_t*)&forMarshaling->lineStipplePattern, sizeof(uint16_t));
    *ptr += sizeof(uint16_t);
}

#endif
#ifdef VK_EXT_shader_atomic_float
void reservedmarshal_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderBufferFloat32Atomics, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderBufferFloat32AtomicAdd, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderBufferFloat64Atomics, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderBufferFloat64AtomicAdd, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSharedFloat32Atomics, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSharedFloat32AtomicAdd, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSharedFloat64Atomics, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderSharedFloat64AtomicAdd, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderImageFloat32Atomics, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderImageFloat32AtomicAdd, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseImageFloat32Atomics, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->sparseImageFloat32AtomicAdd, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_host_query_reset
#endif
#ifdef VK_EXT_index_type_uint8
void reservedmarshal_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceIndexTypeUint8FeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->indexTypeUint8, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_extended_dynamic_state
void reservedmarshal_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->extendedDynamicState, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
void reservedmarshal_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->shaderDemoteToHelperInvocation, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_device_generated_commands
void reservedmarshal_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxGraphicsShaderGroupCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxIndirectSequenceCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxIndirectCommandsTokenCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxIndirectCommandsStreamCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxIndirectCommandsTokenOffset, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxIndirectCommandsStreamStride, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->minSequencesCountBufferOffsetAlignment, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->minSequencesIndexBufferOffsetAlignment, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->minIndirectCommandsBufferOffsetAlignment, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->deviceGeneratedCommands, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkGraphicsShaderGroupCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkGraphicsShaderGroupCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->stageCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->stageCount; ++i)
    {
        reservedmarshal_VkPipelineShaderStageCreateInfo(vkStream, rootType, (const VkPipelineShaderStageCreateInfo*)(forMarshaling->pStages + i), ptr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pVertexInputState;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pVertexInputState)
    {
        reservedmarshal_VkPipelineVertexInputStateCreateInfo(vkStream, rootType, (const VkPipelineVertexInputStateCreateInfo*)(forMarshaling->pVertexInputState), ptr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pTessellationState;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pTessellationState)
    {
        reservedmarshal_VkPipelineTessellationStateCreateInfo(vkStream, rootType, (const VkPipelineTessellationStateCreateInfo*)(forMarshaling->pTessellationState), ptr);
    }
}

void reservedmarshal_VkGraphicsPipelineShaderGroupsCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkGraphicsPipelineShaderGroupsCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->groupCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->groupCount; ++i)
    {
        reservedmarshal_VkGraphicsShaderGroupCreateInfoNV(vkStream, rootType, (const VkGraphicsShaderGroupCreateInfoNV*)(forMarshaling->pGroups + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->pipelineCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    if (forMarshaling->pipelineCount)
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*ptr);
        if (forMarshaling)
        {
            for (uint32_t k = 0; k < forMarshaling->pipelineCount; ++k)
            {
                uint64_t tmpval = get_host_u64_VkPipeline(forMarshaling->pPipelines[k]);
                memcpy(cgen_var_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
        }
        *ptr += 8 * forMarshaling->pipelineCount;
    }
}

void reservedmarshal_VkBindShaderGroupIndirectCommandNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBindShaderGroupIndirectCommandNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->groupIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkBindIndexBufferIndirectCommandNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBindIndexBufferIndirectCommandNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkDeviceAddress*)&forMarshaling->bufferAddress, sizeof(VkDeviceAddress));
    *ptr += sizeof(VkDeviceAddress);
    memcpy(*ptr, (uint32_t*)&forMarshaling->size, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkIndexType*)&forMarshaling->indexType, sizeof(VkIndexType));
    *ptr += sizeof(VkIndexType);
}

void reservedmarshal_VkBindVertexBufferIndirectCommandNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkBindVertexBufferIndirectCommandNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkDeviceAddress*)&forMarshaling->bufferAddress, sizeof(VkDeviceAddress));
    *ptr += sizeof(VkDeviceAddress);
    memcpy(*ptr, (uint32_t*)&forMarshaling->size, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->stride, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkSetStateFlagsIndirectCommandNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSetStateFlagsIndirectCommandNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->data, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkIndirectCommandsStreamNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkIndirectCommandsStreamNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkIndirectCommandsLayoutTokenNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkIndirectCommandsLayoutTokenNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkIndirectCommandsTokenTypeNV*)&forMarshaling->tokenType, sizeof(VkIndirectCommandsTokenTypeNV));
    *ptr += sizeof(VkIndirectCommandsTokenTypeNV);
    memcpy(*ptr, (uint32_t*)&forMarshaling->stream, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->offset, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->vertexBindingUnit, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkBool32*)&forMarshaling->vertexDynamicStride, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPipelineLayout((*&forMarshaling->pushconstantPipelineLayout));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkShaderStageFlags*)&forMarshaling->pushconstantShaderStageFlags, sizeof(VkShaderStageFlags));
    *ptr += sizeof(VkShaderStageFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->pushconstantOffset, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->pushconstantSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkIndirectStateFlagsNV*)&forMarshaling->indirectStateFlags, sizeof(VkIndirectStateFlagsNV));
    *ptr += sizeof(VkIndirectStateFlagsNV);
    memcpy(*ptr, (uint32_t*)&forMarshaling->indexTypeCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const VkIndexType*)forMarshaling->pIndexTypes, forMarshaling->indexTypeCount * sizeof(const VkIndexType));
    *ptr += forMarshaling->indexTypeCount * sizeof(const VkIndexType);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pIndexTypeValues, forMarshaling->indexTypeCount * sizeof(const uint32_t));
    *ptr += forMarshaling->indexTypeCount * sizeof(const uint32_t);
}

void reservedmarshal_VkIndirectCommandsLayoutCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkIndirectCommandsLayoutCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkIndirectCommandsLayoutUsageFlagsNV*)&forMarshaling->flags, sizeof(VkIndirectCommandsLayoutUsageFlagsNV));
    *ptr += sizeof(VkIndirectCommandsLayoutUsageFlagsNV);
    memcpy(*ptr, (VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    memcpy(*ptr, (uint32_t*)&forMarshaling->tokenCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->tokenCount; ++i)
    {
        reservedmarshal_VkIndirectCommandsLayoutTokenNV(vkStream, rootType, (const VkIndirectCommandsLayoutTokenNV*)(forMarshaling->pTokens + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->streamCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (const uint32_t*)forMarshaling->pStreamStrides, forMarshaling->streamCount * sizeof(const uint32_t));
    *ptr += forMarshaling->streamCount * sizeof(const uint32_t);
}

void reservedmarshal_VkGeneratedCommandsInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkGeneratedCommandsInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPipeline((*&forMarshaling->pipeline));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkIndirectCommandsLayoutNV((*&forMarshaling->indirectCommandsLayout));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->streamCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->streamCount; ++i)
    {
        reservedmarshal_VkIndirectCommandsStreamNV(vkStream, rootType, (const VkIndirectCommandsStreamNV*)(forMarshaling->pStreams + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->sequencesCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    uint64_t cgen_var_2;
    *&cgen_var_2 = get_host_u64_VkBuffer((*&forMarshaling->preprocessBuffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_2, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->preprocessOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->preprocessSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    uint64_t cgen_var_3;
    *&cgen_var_3 = get_host_u64_VkBuffer((*&forMarshaling->sequencesCountBuffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_3, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->sequencesCountOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    uint64_t cgen_var_4;
    *&cgen_var_4 = get_host_u64_VkBuffer((*&forMarshaling->sequencesIndexBuffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_4, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->sequencesIndexOffset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkGeneratedCommandsMemoryRequirementsInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkGeneratedCommandsMemoryRequirementsInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    *ptr += sizeof(VkPipelineBindPoint);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPipeline((*&forMarshaling->pipeline));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkIndirectCommandsLayoutNV((*&forMarshaling->indirectCommandsLayout));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxSequencesCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_EXT_texel_buffer_alignment
void reservedmarshal_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->texelBufferAlignment, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->storageTexelBufferOffsetAlignmentBytes, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkBool32*)&forMarshaling->storageTexelBufferOffsetSingleTexelAlignment, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->uniformTexelBufferOffsetAlignmentBytes, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkBool32*)&forMarshaling->uniformTexelBufferOffsetSingleTexelAlignment, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_QCOM_render_pass_transform
void reservedmarshal_VkRenderPassTransformBeginInfoQCOM(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkRenderPassTransformBeginInfoQCOM* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSurfaceTransformFlagBitsKHR*)&forMarshaling->transform, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
}

void reservedmarshal_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCommandBufferInheritanceRenderPassTransformInfoQCOM* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSurfaceTransformFlagBitsKHR*)&forMarshaling->transform, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
    reservedmarshal_VkRect2D(vkStream, rootType, (VkRect2D*)(&forMarshaling->renderArea), ptr);
}

#endif
#ifdef VK_EXT_device_memory_report
void reservedmarshal_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->deviceMemoryReport, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkDeviceMemoryReportCallbackDataEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceMemoryReportCallbackDataEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceMemoryReportFlagsEXT*)&forMarshaling->flags, sizeof(VkDeviceMemoryReportFlagsEXT));
    *ptr += sizeof(VkDeviceMemoryReportFlagsEXT);
    memcpy(*ptr, (VkDeviceMemoryReportEventTypeEXT*)&forMarshaling->type, sizeof(VkDeviceMemoryReportEventTypeEXT));
    *ptr += sizeof(VkDeviceMemoryReportEventTypeEXT);
    memcpy(*ptr, (uint64_t*)&forMarshaling->memoryObjectId, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkObjectType*)&forMarshaling->objectType, sizeof(VkObjectType));
    *ptr += sizeof(VkObjectType);
    memcpy(*ptr, (uint64_t*)&forMarshaling->objectHandle, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->heapIndex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkDeviceDeviceMemoryReportCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceDeviceMemoryReportCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceMemoryReportFlagsEXT*)&forMarshaling->flags, sizeof(VkDeviceMemoryReportFlagsEXT));
    *ptr += sizeof(VkDeviceMemoryReportFlagsEXT);
    uint64_t cgen_var_0 = (uint64_t)forMarshaling->pfnUserCallback;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    memcpy(*ptr, (void*)forMarshaling->pUserData, sizeof(uint8_t));
    *ptr += sizeof(uint8_t);
}

#endif
#ifdef VK_EXT_robustness2
void reservedmarshal_VkPhysicalDeviceRobustness2FeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceRobustness2FeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->robustBufferAccess2, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->robustImageAccess2, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->nullDescriptor, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceRobustness2PropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceRobustness2PropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->robustStorageBufferAccessSizeAlignment, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->robustUniformBufferAccessSizeAlignment, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

#endif
#ifdef VK_EXT_custom_border_color
void reservedmarshal_VkSamplerCustomBorderColorCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkSamplerCustomBorderColorCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkClearColorValue(vkStream, rootType, (VkClearColorValue*)(&forMarshaling->customBorderColor), ptr);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
}

void reservedmarshal_VkPhysicalDeviceCustomBorderColorPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceCustomBorderColorPropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxCustomBorderColorSamplers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPhysicalDeviceCustomBorderColorFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceCustomBorderColorFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->customBorderColors, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->customBorderColorWithoutFormat, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_GOOGLE_user_type
#endif
#ifdef VK_EXT_private_data
void reservedmarshal_VkPhysicalDevicePrivateDataFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDevicePrivateDataFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->privateData, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkDevicePrivateDataCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDevicePrivateDataCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->privateDataSlotRequestCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkPrivateDataSlotCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPrivateDataSlotCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPrivateDataSlotCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkPrivateDataSlotCreateFlagsEXT));
    *ptr += sizeof(VkPrivateDataSlotCreateFlagsEXT);
}

#endif
#ifdef VK_EXT_pipeline_creation_cache_control
void reservedmarshal_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->pipelineCreationCacheControl, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_device_diagnostics_config
void reservedmarshal_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceDiagnosticsConfigFeaturesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->diagnosticsConfig, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkDeviceDiagnosticsConfigCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceDiagnosticsConfigCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceDiagnosticsConfigFlagsNV*)&forMarshaling->flags, sizeof(VkDeviceDiagnosticsConfigFlagsNV));
    *ptr += sizeof(VkDeviceDiagnosticsConfigFlagsNV);
}

#endif
#ifdef VK_QCOM_render_pass_store_ops
#endif
#ifdef VK_NV_fragment_shading_rate_enums
void reservedmarshal_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentShadingRateEnums, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->supersampleFragmentShadingRates, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->noInvocationFragmentShadingRates, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSampleCountFlagBits*)&forMarshaling->maxFragmentShadingRateInvocationCount, sizeof(VkSampleCountFlagBits));
    *ptr += sizeof(VkSampleCountFlagBits);
}

void reservedmarshal_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPipelineFragmentShadingRateEnumStateCreateInfoNV* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkFragmentShadingRateTypeNV*)&forMarshaling->shadingRateType, sizeof(VkFragmentShadingRateTypeNV));
    *ptr += sizeof(VkFragmentShadingRateTypeNV);
    memcpy(*ptr, (VkFragmentShadingRateNV*)&forMarshaling->shadingRate, sizeof(VkFragmentShadingRateNV));
    *ptr += sizeof(VkFragmentShadingRateNV);
    memcpy(*ptr, (VkFragmentShadingRateCombinerOpKHR*)forMarshaling->combinerOps, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
    *ptr += 2 * sizeof(VkFragmentShadingRateCombinerOpKHR);
}

#endif
#ifdef VK_EXT_fragment_density_map2
void reservedmarshal_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->fragmentDensityMapDeferred, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->subsampledLoads, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->subsampledCoarseReconstructionEarlyAccess, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxSubsampledArrayLayers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetSubsampledSamplers, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_QCOM_rotated_copy_commands
void reservedmarshal_VkCopyCommandTransformInfoQCOM(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCopyCommandTransformInfoQCOM* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkSurfaceTransformFlagBitsKHR*)&forMarshaling->transform, sizeof(VkSurfaceTransformFlagBitsKHR));
    *ptr += sizeof(VkSurfaceTransformFlagBitsKHR);
}

#endif
#ifdef VK_EXT_image_robustness
void reservedmarshal_VkPhysicalDeviceImageRobustnessFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceImageRobustnessFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->robustImageAccess, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_4444_formats
void reservedmarshal_VkPhysicalDevice4444FormatsFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDevice4444FormatsFeaturesEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->formatA4R4G4B4, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->formatA4B4G4R4, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_directfb_surface
void reservedmarshal_VkDirectFBSurfaceCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDirectFBSurfaceCreateInfoEXT* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDirectFBSurfaceCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkDirectFBSurfaceCreateFlagsEXT));
    *ptr += sizeof(VkDirectFBSurfaceCreateFlagsEXT);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->dfb;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->dfb)
    {
        memcpy(*ptr, (IDirectFB*)forMarshaling->dfb, sizeof(IDirectFB));
        *ptr += sizeof(IDirectFB);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->surface;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->surface)
    {
        memcpy(*ptr, (IDirectFBSurface*)forMarshaling->surface, sizeof(IDirectFBSurface));
        *ptr += sizeof(IDirectFBSurface);
    }
}

#endif
#ifdef VK_GOOGLE_gfxstream
void reservedmarshal_VkImportColorBufferGOOGLE(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImportColorBufferGOOGLE* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->colorBuffer, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkImportBufferGOOGLE(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImportBufferGOOGLE* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->buffer, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkImportPhysicalAddressGOOGLE(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkImportPhysicalAddressGOOGLE* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint64_t*)&forMarshaling->physicalAddress, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    memcpy(*ptr, (VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
    *ptr += sizeof(VkImageTiling);
    memcpy(*ptr, (uint32_t*)&forMarshaling->tilingParameter, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_KHR_acceleration_structure
void reservedmarshal_VkDeviceOrHostAddressKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceOrHostAddressKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkDeviceAddress*)&forMarshaling->deviceAddress, sizeof(VkDeviceAddress));
    *ptr += sizeof(VkDeviceAddress);
}

void reservedmarshal_VkDeviceOrHostAddressConstKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkDeviceOrHostAddressConstKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkDeviceAddress*)&forMarshaling->deviceAddress, sizeof(VkDeviceAddress));
    *ptr += sizeof(VkDeviceAddress);
}

void reservedmarshal_VkAccelerationStructureBuildRangeInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAccelerationStructureBuildRangeInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->primitiveCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->primitiveOffset, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->firstVertex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->transformOffset, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkAccelerationStructureGeometryTrianglesDataKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAccelerationStructureGeometryTrianglesDataKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkFormat*)&forMarshaling->vertexFormat, sizeof(VkFormat));
    *ptr += sizeof(VkFormat);
    reservedmarshal_VkDeviceOrHostAddressConstKHR(vkStream, rootType, (VkDeviceOrHostAddressConstKHR*)(&forMarshaling->vertexData), ptr);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->vertexStride, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxVertex, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (VkIndexType*)&forMarshaling->indexType, sizeof(VkIndexType));
    *ptr += sizeof(VkIndexType);
    reservedmarshal_VkDeviceOrHostAddressConstKHR(vkStream, rootType, (VkDeviceOrHostAddressConstKHR*)(&forMarshaling->indexData), ptr);
    reservedmarshal_VkDeviceOrHostAddressConstKHR(vkStream, rootType, (VkDeviceOrHostAddressConstKHR*)(&forMarshaling->transformData), ptr);
}

void reservedmarshal_VkAccelerationStructureGeometryAabbsDataKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAccelerationStructureGeometryAabbsDataKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkDeviceOrHostAddressConstKHR(vkStream, rootType, (VkDeviceOrHostAddressConstKHR*)(&forMarshaling->data), ptr);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->stride, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkAccelerationStructureGeometryInstancesDataKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAccelerationStructureGeometryInstancesDataKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->arrayOfPointers, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    reservedmarshal_VkDeviceOrHostAddressConstKHR(vkStream, rootType, (VkDeviceOrHostAddressConstKHR*)(&forMarshaling->data), ptr);
}

void reservedmarshal_VkAccelerationStructureGeometryDataKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAccelerationStructureGeometryDataKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    reservedmarshal_VkAccelerationStructureGeometryTrianglesDataKHR(vkStream, rootType, (VkAccelerationStructureGeometryTrianglesDataKHR*)(&forMarshaling->triangles), ptr);
}

void reservedmarshal_VkAccelerationStructureGeometryKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAccelerationStructureGeometryKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkGeometryTypeKHR*)&forMarshaling->geometryType, sizeof(VkGeometryTypeKHR));
    *ptr += sizeof(VkGeometryTypeKHR);
    reservedmarshal_VkAccelerationStructureGeometryDataKHR(vkStream, rootType, (VkAccelerationStructureGeometryDataKHR*)(&forMarshaling->geometry), ptr);
    memcpy(*ptr, (VkGeometryFlagsKHR*)&forMarshaling->flags, sizeof(VkGeometryFlagsKHR));
    *ptr += sizeof(VkGeometryFlagsKHR);
}

void reservedmarshal_VkAccelerationStructureBuildGeometryInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAccelerationStructureBuildGeometryInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkAccelerationStructureTypeKHR*)&forMarshaling->type, sizeof(VkAccelerationStructureTypeKHR));
    *ptr += sizeof(VkAccelerationStructureTypeKHR);
    memcpy(*ptr, (VkBuildAccelerationStructureFlagsKHR*)&forMarshaling->flags, sizeof(VkBuildAccelerationStructureFlagsKHR));
    *ptr += sizeof(VkBuildAccelerationStructureFlagsKHR);
    memcpy(*ptr, (VkBuildAccelerationStructureModeKHR*)&forMarshaling->mode, sizeof(VkBuildAccelerationStructureModeKHR));
    *ptr += sizeof(VkBuildAccelerationStructureModeKHR);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkAccelerationStructureKHR((*&forMarshaling->srcAccelerationStructure));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkAccelerationStructureKHR((*&forMarshaling->dstAccelerationStructure));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (uint32_t*)&forMarshaling->geometryCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)forMarshaling->pGeometries;
    memcpy((*ptr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pGeometries)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->geometryCount; ++i)
        {
            reservedmarshal_VkAccelerationStructureGeometryKHR(vkStream, rootType, (const VkAccelerationStructureGeometryKHR*)(forMarshaling->pGeometries + i), ptr);
        }
    }
    reservedmarshal_VkDeviceOrHostAddressKHR(vkStream, rootType, (VkDeviceOrHostAddressKHR*)(&forMarshaling->scratchData), ptr);
}

void reservedmarshal_VkAccelerationStructureCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAccelerationStructureCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkAccelerationStructureCreateFlagsKHR*)&forMarshaling->createFlags, sizeof(VkAccelerationStructureCreateFlagsKHR));
    *ptr += sizeof(VkAccelerationStructureCreateFlagsKHR);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&forMarshaling->buffer));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkAccelerationStructureTypeKHR*)&forMarshaling->type, sizeof(VkAccelerationStructureTypeKHR));
    *ptr += sizeof(VkAccelerationStructureTypeKHR);
    memcpy(*ptr, (VkDeviceAddress*)&forMarshaling->deviceAddress, sizeof(VkDeviceAddress));
    *ptr += sizeof(VkDeviceAddress);
}

void reservedmarshal_VkWriteDescriptorSetAccelerationStructureKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkWriteDescriptorSetAccelerationStructureKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->accelerationStructureCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pAccelerationStructures;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pAccelerationStructures)
    {
        if (forMarshaling->accelerationStructureCount)
        {
            uint8_t* cgen_var_0_0_ptr = (uint8_t*)(*ptr);
            if (forMarshaling)
            {
                for (uint32_t k = 0; k < forMarshaling->accelerationStructureCount; ++k)
                {
                    uint64_t tmpval = get_host_u64_VkAccelerationStructureKHR(forMarshaling->pAccelerationStructures[k]);
                    memcpy(cgen_var_0_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
                }
            }
            *ptr += 8 * forMarshaling->accelerationStructureCount;
        }
    }
}

void reservedmarshal_VkPhysicalDeviceAccelerationStructureFeaturesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceAccelerationStructureFeaturesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->accelerationStructure, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->accelerationStructureCaptureReplay, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->accelerationStructureIndirectBuild, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->accelerationStructureHostCommands, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->descriptorBindingAccelerationStructureUpdateAfterBind, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceAccelerationStructurePropertiesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceAccelerationStructurePropertiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint64_t*)&forMarshaling->maxGeometryCount, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->maxInstanceCount, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint64_t*)&forMarshaling->maxPrimitiveCount, sizeof(uint64_t));
    *ptr += sizeof(uint64_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorAccelerationStructures, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindAccelerationStructures, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetAccelerationStructures, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindAccelerationStructures, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->minAccelerationStructureScratchOffsetAlignment, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkAccelerationStructureDeviceAddressInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAccelerationStructureDeviceAddressInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkAccelerationStructureKHR((*&forMarshaling->accelerationStructure));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
}

void reservedmarshal_VkAccelerationStructureVersionInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAccelerationStructureVersionInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (const uint8_t*)forMarshaling->pVersionData, 2*VK_UUID_SIZE * sizeof(const uint8_t));
    *ptr += 2*VK_UUID_SIZE * sizeof(const uint8_t);
}

void reservedmarshal_VkCopyAccelerationStructureToMemoryInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCopyAccelerationStructureToMemoryInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkAccelerationStructureKHR((*&forMarshaling->src));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    reservedmarshal_VkDeviceOrHostAddressKHR(vkStream, rootType, (VkDeviceOrHostAddressKHR*)(&forMarshaling->dst), ptr);
    memcpy(*ptr, (VkCopyAccelerationStructureModeKHR*)&forMarshaling->mode, sizeof(VkCopyAccelerationStructureModeKHR));
    *ptr += sizeof(VkCopyAccelerationStructureModeKHR);
}

void reservedmarshal_VkCopyMemoryToAccelerationStructureInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCopyMemoryToAccelerationStructureInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    reservedmarshal_VkDeviceOrHostAddressConstKHR(vkStream, rootType, (VkDeviceOrHostAddressConstKHR*)(&forMarshaling->src), ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkAccelerationStructureKHR((*&forMarshaling->dst));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkCopyAccelerationStructureModeKHR*)&forMarshaling->mode, sizeof(VkCopyAccelerationStructureModeKHR));
    *ptr += sizeof(VkCopyAccelerationStructureModeKHR);
}

void reservedmarshal_VkCopyAccelerationStructureInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkCopyAccelerationStructureInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkAccelerationStructureKHR((*&forMarshaling->src));
    memcpy(*ptr, (uint64_t*)&cgen_var_0, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkAccelerationStructureKHR((*&forMarshaling->dst));
    memcpy(*ptr, (uint64_t*)&cgen_var_1, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (VkCopyAccelerationStructureModeKHR*)&forMarshaling->mode, sizeof(VkCopyAccelerationStructureModeKHR));
    *ptr += sizeof(VkCopyAccelerationStructureModeKHR);
}

void reservedmarshal_VkAccelerationStructureBuildSizesInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkAccelerationStructureBuildSizesInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->accelerationStructureSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->updateScratchSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->buildScratchSize, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

#endif
#ifdef VK_KHR_ray_tracing_pipeline
void reservedmarshal_VkRayTracingShaderGroupCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkRayTracingShaderGroupCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkRayTracingShaderGroupTypeKHR*)&forMarshaling->type, sizeof(VkRayTracingShaderGroupTypeKHR));
    *ptr += sizeof(VkRayTracingShaderGroupTypeKHR);
    memcpy(*ptr, (uint32_t*)&forMarshaling->generalShader, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->closestHitShader, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->anyHitShader, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->intersectionShader, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pShaderGroupCaptureReplayHandle;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pShaderGroupCaptureReplayHandle)
    {
        memcpy(*ptr, (const void*)forMarshaling->pShaderGroupCaptureReplayHandle, sizeof(const uint8_t));
        *ptr += sizeof(const uint8_t);
    }
}

void reservedmarshal_VkRayTracingPipelineInterfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkRayTracingPipelineInterfaceCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPipelineRayPayloadSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPipelineRayHitAttributeSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkRayTracingPipelineCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkRayTracingPipelineCreateInfoKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkPipelineCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCreateFlags));
    *ptr += sizeof(VkPipelineCreateFlags);
    memcpy(*ptr, (uint32_t*)&forMarshaling->stageCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->stageCount; ++i)
    {
        reservedmarshal_VkPipelineShaderStageCreateInfo(vkStream, rootType, (const VkPipelineShaderStageCreateInfo*)(forMarshaling->pStages + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->groupCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->groupCount; ++i)
    {
        reservedmarshal_VkRayTracingShaderGroupCreateInfoKHR(vkStream, rootType, (const VkRayTracingShaderGroupCreateInfoKHR*)(forMarshaling->pGroups + i), ptr);
    }
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxPipelineRayRecursionDepth, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pLibraryInfo;
    memcpy((*ptr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pLibraryInfo)
    {
        reservedmarshal_VkPipelineLibraryCreateInfoKHR(vkStream, rootType, (const VkPipelineLibraryCreateInfoKHR*)(forMarshaling->pLibraryInfo), ptr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)forMarshaling->pLibraryInterface;
    memcpy((*ptr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pLibraryInterface)
    {
        reservedmarshal_VkRayTracingPipelineInterfaceCreateInfoKHR(vkStream, rootType, (const VkRayTracingPipelineInterfaceCreateInfoKHR*)(forMarshaling->pLibraryInterface), ptr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)forMarshaling->pDynamicState;
    memcpy((*ptr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*ptr));
    *ptr += 8;
    if (forMarshaling->pDynamicState)
    {
        reservedmarshal_VkPipelineDynamicStateCreateInfo(vkStream, rootType, (const VkPipelineDynamicStateCreateInfo*)(forMarshaling->pDynamicState), ptr);
    }
    uint64_t cgen_var_3;
    *&cgen_var_3 = get_host_u64_VkPipelineLayout((*&forMarshaling->layout));
    memcpy(*ptr, (uint64_t*)&cgen_var_3, 1 * 8);
    *ptr += 1 * 8;
    uint64_t cgen_var_4;
    *&cgen_var_4 = get_host_u64_VkPipeline((*&forMarshaling->basePipelineHandle));
    memcpy(*ptr, (uint64_t*)&cgen_var_4, 1 * 8);
    *ptr += 1 * 8;
    memcpy(*ptr, (int32_t*)&forMarshaling->basePipelineIndex, sizeof(int32_t));
    *ptr += sizeof(int32_t);
}

void reservedmarshal_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceRayTracingPipelineFeaturesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->rayTracingPipeline, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->rayTracingPipelineShaderGroupHandleCaptureReplay, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->rayTracingPipelineShaderGroupHandleCaptureReplayMixed, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->rayTracingPipelineTraceRaysIndirect, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
    memcpy(*ptr, (VkBool32*)&forMarshaling->rayTraversalPrimitiveCulling, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

void reservedmarshal_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceRayTracingPipelinePropertiesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (uint32_t*)&forMarshaling->shaderGroupHandleSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxRayRecursionDepth, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxShaderGroupStride, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->shaderGroupBaseAlignment, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->shaderGroupHandleCaptureReplaySize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxRayDispatchInvocationCount, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->shaderGroupHandleAlignment, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->maxRayHitAttributeSize, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

void reservedmarshal_VkStridedDeviceAddressRegionKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkStridedDeviceAddressRegionKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkDeviceAddress*)&forMarshaling->deviceAddress, sizeof(VkDeviceAddress));
    *ptr += sizeof(VkDeviceAddress);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->stride, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
    memcpy(*ptr, (VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    *ptr += sizeof(VkDeviceSize);
}

void reservedmarshal_VkTraceRaysIndirectCommandKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkTraceRaysIndirectCommandKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->height, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
    memcpy(*ptr, (uint32_t*)&forMarshaling->depth, sizeof(uint32_t));
    *ptr += sizeof(uint32_t);
}

#endif
#ifdef VK_KHR_ray_query
void reservedmarshal_VkPhysicalDeviceRayQueryFeaturesKHR(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const VkPhysicalDeviceRayQueryFeaturesKHR* forMarshaling,
    uint8_t** ptr)
{
    (void)vkStream;
    (void)rootType;
    memcpy(*ptr, (VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    *ptr += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = forMarshaling->sType;
    }
    reservedmarshal_extension_struct(vkStream, rootType, forMarshaling->pNext, ptr);
    memcpy(*ptr, (VkBool32*)&forMarshaling->rayQuery, sizeof(VkBool32));
    *ptr += sizeof(VkBool32);
}

#endif
void reservedmarshal_extension_struct(
    VulkanStreamGuest* vkStream,
    VkStructureType rootType,
    const void* structExtension,
    uint8_t** ptr)
{
    VkInstanceCreateInfo* structAccess = (VkInstanceCreateInfo*)(structExtension);
    uint32_t currExtSize = goldfish_vk_extension_struct_size_with_stream_features(vkStream->getFeatureBits(), rootType, structExtension);
    if (!currExtSize && structExtension)
    {
        // unknown struct extension; skip and call on its pNext field
        reservedmarshal_extension_struct(vkStream, rootType, (void*)structAccess->pNext, ptr);
        return;
    }
    else
    {
        // known or null extension struct
        memcpy(*ptr, &currExtSize, sizeof(uint32_t));;
        android::base::Stream::toBe32((uint8_t*)*ptr); *ptr += sizeof(uint32_t);
        if (!currExtSize)
        {
            // exit if this was a null extension struct (size == 0 in this branch)
            return;
        }
    }
    memcpy(*ptr, structExtension, sizeof(VkStructureType)); *ptr += sizeof(VkStructureType);
    if (!structExtension)
    {
        return;
    }
    uint32_t structType = (uint32_t)goldfish_vk_struct_type(structExtension);
    switch(structType)
    {
#ifdef VK_VERSION_1_1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDeviceSubgroupProperties(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceSubgroupProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            reservedmarshal_VkPhysicalDevice16BitStorageFeatures(vkStream, rootType, reinterpret_cast<const VkPhysicalDevice16BitStorageFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            reservedmarshal_VkMemoryDedicatedRequirements(vkStream, rootType, reinterpret_cast<const VkMemoryDedicatedRequirements*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            reservedmarshal_VkMemoryDedicatedAllocateInfo(vkStream, rootType, reinterpret_cast<const VkMemoryDedicatedAllocateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            reservedmarshal_VkMemoryAllocateFlagsInfo(vkStream, rootType, reinterpret_cast<const VkMemoryAllocateFlagsInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            reservedmarshal_VkDeviceGroupRenderPassBeginInfo(vkStream, rootType, reinterpret_cast<const VkDeviceGroupRenderPassBeginInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
            reservedmarshal_VkDeviceGroupCommandBufferBeginInfo(vkStream, rootType, reinterpret_cast<const VkDeviceGroupCommandBufferBeginInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            reservedmarshal_VkDeviceGroupSubmitInfo(vkStream, rootType, reinterpret_cast<const VkDeviceGroupSubmitInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
            reservedmarshal_VkDeviceGroupBindSparseInfo(vkStream, rootType, reinterpret_cast<const VkDeviceGroupBindSparseInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
            reservedmarshal_VkBindBufferMemoryDeviceGroupInfo(vkStream, rootType, reinterpret_cast<const VkBindBufferMemoryDeviceGroupInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            reservedmarshal_VkBindImageMemoryDeviceGroupInfo(vkStream, rootType, reinterpret_cast<const VkBindImageMemoryDeviceGroupInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            reservedmarshal_VkDeviceGroupDeviceCreateInfo(vkStream, rootType, reinterpret_cast<const VkDeviceGroupDeviceCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            reservedmarshal_VkPhysicalDeviceFeatures2(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceFeatures2*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDevicePointClippingProperties(vkStream, rootType, reinterpret_cast<const VkPhysicalDevicePointClippingProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
            reservedmarshal_VkRenderPassInputAttachmentAspectCreateInfo(vkStream, rootType, reinterpret_cast<const VkRenderPassInputAttachmentAspectCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
            reservedmarshal_VkImageViewUsageCreateInfo(vkStream, rootType, reinterpret_cast<const VkImageViewUsageCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
            reservedmarshal_VkPipelineTessellationDomainOriginStateCreateInfo(vkStream, rootType, reinterpret_cast<const VkPipelineTessellationDomainOriginStateCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
            reservedmarshal_VkRenderPassMultiviewCreateInfo(vkStream, rootType, reinterpret_cast<const VkRenderPassMultiviewCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceMultiviewFeatures(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceMultiviewFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDeviceMultiviewProperties(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceMultiviewProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceVariablePointersFeatures(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceVariablePointersFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceProtectedMemoryFeatures(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDeviceProtectedMemoryProperties(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceProtectedMemoryProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            reservedmarshal_VkProtectedSubmitInfo(vkStream, rootType, reinterpret_cast<const VkProtectedSubmitInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            reservedmarshal_VkSamplerYcbcrConversionInfo(vkStream, rootType, reinterpret_cast<const VkSamplerYcbcrConversionInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            reservedmarshal_VkBindImagePlaneMemoryInfo(vkStream, rootType, reinterpret_cast<const VkBindImagePlaneMemoryInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
            reservedmarshal_VkImagePlaneMemoryRequirementsInfo(vkStream, rootType, reinterpret_cast<const VkImagePlaneMemoryRequirementsInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceSamplerYcbcrConversionFeatures(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            reservedmarshal_VkSamplerYcbcrConversionImageFormatProperties(vkStream, rootType, reinterpret_cast<const VkSamplerYcbcrConversionImageFormatProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            reservedmarshal_VkPhysicalDeviceExternalImageFormatInfo(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceExternalImageFormatInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            reservedmarshal_VkExternalImageFormatProperties(vkStream, rootType, reinterpret_cast<const VkExternalImageFormatProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDeviceIDProperties(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceIDProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            reservedmarshal_VkExternalMemoryImageCreateInfo(vkStream, rootType, reinterpret_cast<const VkExternalMemoryImageCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            reservedmarshal_VkExternalMemoryBufferCreateInfo(vkStream, rootType, reinterpret_cast<const VkExternalMemoryBufferCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            reservedmarshal_VkExportMemoryAllocateInfo(vkStream, rootType, reinterpret_cast<const VkExportMemoryAllocateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
            reservedmarshal_VkExportFenceCreateInfo(vkStream, rootType, reinterpret_cast<const VkExportFenceCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            reservedmarshal_VkExportSemaphoreCreateInfo(vkStream, rootType, reinterpret_cast<const VkExportSemaphoreCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDeviceMaintenance3Properties(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceMaintenance3Properties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceShaderDrawParametersFeatures(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceShaderDrawParametersFeatures*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_VERSION_1_2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceVulkan11Features(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceVulkan11Features*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDeviceVulkan11Properties(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceVulkan11Properties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceVulkan12Features(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceVulkan12Features*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDeviceVulkan12Properties(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceVulkan12Properties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
            reservedmarshal_VkImageFormatListCreateInfo(vkStream, rootType, reinterpret_cast<const VkImageFormatListCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {
            reservedmarshal_VkPhysicalDevice8BitStorageFeatures(vkStream, rootType, reinterpret_cast<const VkPhysicalDevice8BitStorageFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDeviceDriverProperties(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceDriverProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceShaderAtomicInt64Features(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceShaderAtomicInt64Features*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceShaderFloat16Int8Features(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceShaderFloat16Int8Features*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDeviceFloatControlsProperties(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceFloatControlsProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
        {
            reservedmarshal_VkDescriptorSetLayoutBindingFlagsCreateInfo(vkStream, rootType, reinterpret_cast<const VkDescriptorSetLayoutBindingFlagsCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceDescriptorIndexingFeatures(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDeviceDescriptorIndexingProperties(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
        {
            reservedmarshal_VkDescriptorSetVariableDescriptorCountAllocateInfo(vkStream, rootType, reinterpret_cast<const VkDescriptorSetVariableDescriptorCountAllocateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
        {
            reservedmarshal_VkDescriptorSetVariableDescriptorCountLayoutSupport(vkStream, rootType, reinterpret_cast<const VkDescriptorSetVariableDescriptorCountLayoutSupport*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
        {
            reservedmarshal_VkSubpassDescriptionDepthStencilResolve(vkStream, rootType, reinterpret_cast<const VkSubpassDescriptionDepthStencilResolve*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDeviceDepthStencilResolveProperties(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceDepthStencilResolveProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceScalarBlockLayoutFeatures(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceScalarBlockLayoutFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
            reservedmarshal_VkImageStencilUsageCreateInfo(vkStream, rootType, reinterpret_cast<const VkImageStencilUsageCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
        {
            reservedmarshal_VkSamplerReductionModeCreateInfo(vkStream, rootType, reinterpret_cast<const VkSamplerReductionModeCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDeviceSamplerFilterMinmaxProperties(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceSamplerFilterMinmaxProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceVulkanMemoryModelFeatures(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceVulkanMemoryModelFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceImagelessFramebufferFeatures(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceImagelessFramebufferFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
        {
            reservedmarshal_VkFramebufferAttachmentsCreateInfo(vkStream, rootType, reinterpret_cast<const VkFramebufferAttachmentsCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
        {
            reservedmarshal_VkRenderPassAttachmentBeginInfo(vkStream, rootType, reinterpret_cast<const VkRenderPassAttachmentBeginInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceUniformBufferStandardLayoutFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:
        {
            reservedmarshal_VkAttachmentReferenceStencilLayout(vkStream, rootType, reinterpret_cast<const VkAttachmentReferenceStencilLayout*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:
        {
            reservedmarshal_VkAttachmentDescriptionStencilLayout(vkStream, rootType, reinterpret_cast<const VkAttachmentDescriptionStencilLayout*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceHostQueryResetFeatures(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceHostQueryResetFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceTimelineSemaphoreFeatures(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceTimelineSemaphoreFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
        {
            reservedmarshal_VkPhysicalDeviceTimelineSemaphoreProperties(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceTimelineSemaphoreProperties*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
        {
            reservedmarshal_VkSemaphoreTypeCreateInfo(vkStream, rootType, reinterpret_cast<const VkSemaphoreTypeCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
            reservedmarshal_VkTimelineSemaphoreSubmitInfo(vkStream, rootType, reinterpret_cast<const VkTimelineSemaphoreSubmitInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
            reservedmarshal_VkPhysicalDeviceBufferDeviceAddressFeatures(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceBufferDeviceAddressFeatures*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
        {
            reservedmarshal_VkBufferOpaqueCaptureAddressCreateInfo(vkStream, rootType, reinterpret_cast<const VkBufferOpaqueCaptureAddressCreateInfo*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
        {
            reservedmarshal_VkMemoryOpaqueCaptureAddressAllocateInfo(vkStream, rootType, reinterpret_cast<const VkMemoryOpaqueCaptureAddressAllocateInfo*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_swapchain
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            reservedmarshal_VkImageSwapchainCreateInfoKHR(vkStream, rootType, reinterpret_cast<const VkImageSwapchainCreateInfoKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            reservedmarshal_VkBindImageMemorySwapchainInfoKHR(vkStream, rootType, reinterpret_cast<const VkBindImageMemorySwapchainInfoKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
            reservedmarshal_VkDeviceGroupPresentInfoKHR(vkStream, rootType, reinterpret_cast<const VkDeviceGroupPresentInfoKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
            reservedmarshal_VkDeviceGroupSwapchainCreateInfoKHR(vkStream, rootType, reinterpret_cast<const VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_display_swapchain
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {
            reservedmarshal_VkDisplayPresentInfoKHR(vkStream, rootType, reinterpret_cast<const VkDisplayPresentInfoKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            reservedmarshal_VkImportMemoryWin32HandleInfoKHR(vkStream, rootType, reinterpret_cast<const VkImportMemoryWin32HandleInfoKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            reservedmarshal_VkExportMemoryWin32HandleInfoKHR(vkStream, rootType, reinterpret_cast<const VkExportMemoryWin32HandleInfoKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_external_memory_fd
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
            reservedmarshal_VkImportMemoryFdInfoKHR(vkStream, rootType, reinterpret_cast<const VkImportMemoryFdInfoKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            reservedmarshal_VkWin32KeyedMutexAcquireReleaseInfoKHR(vkStream, rootType, reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_external_semaphore_win32
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {
            reservedmarshal_VkExportSemaphoreWin32HandleInfoKHR(vkStream, rootType, reinterpret_cast<const VkExportSemaphoreWin32HandleInfoKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {
            reservedmarshal_VkD3D12FenceSubmitInfoKHR(vkStream, rootType, reinterpret_cast<const VkD3D12FenceSubmitInfoKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_push_descriptor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
            reservedmarshal_VkPhysicalDevicePushDescriptorPropertiesKHR(vkStream, rootType, reinterpret_cast<const VkPhysicalDevicePushDescriptorPropertiesKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_incremental_present
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
            reservedmarshal_VkPresentRegionsKHR(vkStream, rootType, reinterpret_cast<const VkPresentRegionsKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_shared_presentable_image
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {
            reservedmarshal_VkSharedPresentSurfaceCapabilitiesKHR(vkStream, rootType, reinterpret_cast<const VkSharedPresentSurfaceCapabilitiesKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_external_fence_win32
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {
            reservedmarshal_VkExportFenceWin32HandleInfoKHR(vkStream, rootType, reinterpret_cast<const VkExportFenceWin32HandleInfoKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_performance_query
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {
            reservedmarshal_VkPhysicalDevicePerformanceQueryFeaturesKHR(vkStream, rootType, reinterpret_cast<const VkPhysicalDevicePerformanceQueryFeaturesKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
        {
            reservedmarshal_VkPhysicalDevicePerformanceQueryPropertiesKHR(vkStream, rootType, reinterpret_cast<const VkPhysicalDevicePerformanceQueryPropertiesKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
        {
            reservedmarshal_VkQueryPoolPerformanceCreateInfoKHR(vkStream, rootType, reinterpret_cast<const VkQueryPoolPerformanceCreateInfoKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
            reservedmarshal_VkPerformanceQuerySubmitInfoKHR(vkStream, rootType, reinterpret_cast<const VkPerformanceQuerySubmitInfoKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_portability_subset
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR:
        {
            reservedmarshal_VkPhysicalDevicePortabilitySubsetFeaturesKHR(vkStream, rootType, reinterpret_cast<const VkPhysicalDevicePortabilitySubsetFeaturesKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR:
        {
            reservedmarshal_VkPhysicalDevicePortabilitySubsetPropertiesKHR(vkStream, rootType, reinterpret_cast<const VkPhysicalDevicePortabilitySubsetPropertiesKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_shader_clock
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {
            reservedmarshal_VkPhysicalDeviceShaderClockFeaturesKHR(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceShaderClockFeaturesKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_shader_terminate_invocation
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR:
        {
            reservedmarshal_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_fragment_shading_rate
        case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {
            reservedmarshal_VkFragmentShadingRateAttachmentInfoKHR(vkStream, rootType, reinterpret_cast<const VkFragmentShadingRateAttachmentInfoKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
        {
            reservedmarshal_VkPipelineFragmentShadingRateStateCreateInfoKHR(vkStream, rootType, reinterpret_cast<const VkPipelineFragmentShadingRateStateCreateInfoKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {
            reservedmarshal_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateFeaturesKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
        {
            reservedmarshal_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentShadingRatePropertiesKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_surface_protected_capabilities
        case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
        {
            reservedmarshal_VkSurfaceProtectedCapabilitiesKHR(vkStream, rootType, reinterpret_cast<const VkSurfaceProtectedCapabilitiesKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_pipeline_executable_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {
            reservedmarshal_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(vkStream, rootType, reinterpret_cast<const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_ANDROID_native_buffer
        case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID:
        {
            reservedmarshal_VkNativeBufferANDROID(vkStream, rootType, reinterpret_cast<const VkNativeBufferANDROID*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_debug_report
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            reservedmarshal_VkDebugReportCallbackCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkDebugReportCallbackCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_AMD_rasterization_order
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
            reservedmarshal_VkPipelineRasterizationStateRasterizationOrderAMD(vkStream, rootType, reinterpret_cast<const VkPipelineRasterizationStateRasterizationOrderAMD*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            reservedmarshal_VkDedicatedAllocationImageCreateInfoNV(vkStream, rootType, reinterpret_cast<const VkDedicatedAllocationImageCreateInfoNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            reservedmarshal_VkDedicatedAllocationBufferCreateInfoNV(vkStream, rootType, reinterpret_cast<const VkDedicatedAllocationBufferCreateInfoNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            reservedmarshal_VkDedicatedAllocationMemoryAllocateInfoNV(vkStream, rootType, reinterpret_cast<const VkDedicatedAllocationMemoryAllocateInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_transform_feedback
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceTransformFeedbackFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceTransformFeedbackPropertiesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceTransformFeedbackPropertiesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
        {
            reservedmarshal_VkPipelineRasterizationStateStreamCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkPipelineRasterizationStateStreamCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_AMD_texture_gather_bias_lod
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            reservedmarshal_VkTextureLODGatherFormatPropertiesAMD(vkStream, rootType, reinterpret_cast<const VkTextureLODGatherFormatPropertiesAMD*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_corner_sampled_image
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {
            reservedmarshal_VkPhysicalDeviceCornerSampledImageFeaturesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceCornerSampledImageFeaturesNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_external_memory
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {
            reservedmarshal_VkExternalMemoryImageCreateInfoNV(vkStream, rootType, reinterpret_cast<const VkExternalMemoryImageCreateInfoNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {
            reservedmarshal_VkExportMemoryAllocateInfoNV(vkStream, rootType, reinterpret_cast<const VkExportMemoryAllocateInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            reservedmarshal_VkImportMemoryWin32HandleInfoNV(vkStream, rootType, reinterpret_cast<const VkImportMemoryWin32HandleInfoNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            reservedmarshal_VkExportMemoryWin32HandleInfoNV(vkStream, rootType, reinterpret_cast<const VkExportMemoryWin32HandleInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
        {
            reservedmarshal_VkWin32KeyedMutexAcquireReleaseInfoNV(vkStream, rootType, reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_validation_flags
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            reservedmarshal_VkValidationFlagsEXT(vkStream, rootType, reinterpret_cast<const VkValidationFlagsEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_astc_decode_mode
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
        {
            reservedmarshal_VkImageViewASTCDecodeModeEXT(vkStream, rootType, reinterpret_cast<const VkImageViewASTCDecodeModeEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceASTCDecodeFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceASTCDecodeFeaturesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_conditional_rendering
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceConditionalRenderingFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
            reservedmarshal_VkCommandBufferInheritanceConditionalRenderingInfoEXT(vkStream, rootType, reinterpret_cast<const VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_clip_space_w_scaling
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
            reservedmarshal_VkPipelineViewportWScalingStateCreateInfoNV(vkStream, rootType, reinterpret_cast<const VkPipelineViewportWScalingStateCreateInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_display_control
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {
            reservedmarshal_VkSwapchainCounterCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkSwapchainCounterCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_GOOGLE_display_timing
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {
            reservedmarshal_VkPresentTimesInfoGOOGLE(vkStream, rootType, reinterpret_cast<const VkPresentTimesInfoGOOGLE*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NVX_multiview_per_view_attributes
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {
            reservedmarshal_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_viewport_swizzle
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
            reservedmarshal_VkPipelineViewportSwizzleStateCreateInfoNV(vkStream, rootType, reinterpret_cast<const VkPipelineViewportSwizzleStateCreateInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_discard_rectangles
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceDiscardRectanglePropertiesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            reservedmarshal_VkPipelineDiscardRectangleStateCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkPipelineDiscardRectangleStateCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_conservative_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
            reservedmarshal_VkPipelineRasterizationConservativeStateCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkPipelineRasterizationConservativeStateCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_depth_clip_enable
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceDepthClipEnableFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
        {
            reservedmarshal_VkPipelineRasterizationDepthClipStateCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkPipelineRasterizationDepthClipStateCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_debug_utils
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            reservedmarshal_VkDebugUtilsMessengerCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkDebugUtilsMessengerCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
        {
            reservedmarshal_VkAndroidHardwareBufferUsageANDROID(vkStream, rootType, reinterpret_cast<const VkAndroidHardwareBufferUsageANDROID*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
        {
            reservedmarshal_VkAndroidHardwareBufferFormatPropertiesANDROID(vkStream, rootType, reinterpret_cast<const VkAndroidHardwareBufferFormatPropertiesANDROID*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {
            reservedmarshal_VkImportAndroidHardwareBufferInfoANDROID(vkStream, rootType, reinterpret_cast<const VkImportAndroidHardwareBufferInfoANDROID*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
        {
            reservedmarshal_VkExternalFormatANDROID(vkStream, rootType, reinterpret_cast<const VkExternalFormatANDROID*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_inline_uniform_block
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceInlineUniformBlockFeaturesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceInlineUniformBlockPropertiesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT:
        {
            reservedmarshal_VkWriteDescriptorSetInlineUniformBlockEXT(vkStream, rootType, reinterpret_cast<const VkWriteDescriptorSetInlineUniformBlockEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT:
        {
            reservedmarshal_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkDescriptorPoolInlineUniformBlockCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_sample_locations
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            reservedmarshal_VkSampleLocationsInfoEXT(vkStream, rootType, reinterpret_cast<const VkSampleLocationsInfoEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
            reservedmarshal_VkRenderPassSampleLocationsBeginInfoEXT(vkStream, rootType, reinterpret_cast<const VkRenderPassSampleLocationsBeginInfoEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
            reservedmarshal_VkPipelineSampleLocationsStateCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkPipelineSampleLocationsStateCreateInfoEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceSampleLocationsPropertiesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceSampleLocationsPropertiesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_blend_operation_advanced
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
            reservedmarshal_VkPipelineColorBlendAdvancedStateCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_fragment_coverage_to_color
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
            reservedmarshal_VkPipelineCoverageToColorStateCreateInfoNV(vkStream, rootType, reinterpret_cast<const VkPipelineCoverageToColorStateCreateInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_framebuffer_mixed_samples
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
            reservedmarshal_VkPipelineCoverageModulationStateCreateInfoNV(vkStream, rootType, reinterpret_cast<const VkPipelineCoverageModulationStateCreateInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_shader_sm_builtins
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
        {
            reservedmarshal_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {
            reservedmarshal_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_image_drm_format_modifier
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
        {
            reservedmarshal_VkDrmFormatModifierPropertiesListEXT(vkStream, rootType, reinterpret_cast<const VkDrmFormatModifierPropertiesListEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
        {
            reservedmarshal_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceImageDrmFormatModifierInfoEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
        {
            reservedmarshal_VkImageDrmFormatModifierListCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkImageDrmFormatModifierListCreateInfoEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
        {
            reservedmarshal_VkImageDrmFormatModifierExplicitCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkImageDrmFormatModifierExplicitCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_validation_cache
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            reservedmarshal_VkShaderModuleValidationCacheCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkShaderModuleValidationCacheCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_shading_rate_image
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
        {
            reservedmarshal_VkPipelineViewportShadingRateImageStateCreateInfoNV(vkStream, rootType, reinterpret_cast<const VkPipelineViewportShadingRateImageStateCreateInfoNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {
            reservedmarshal_VkPhysicalDeviceShadingRateImageFeaturesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceShadingRateImageFeaturesNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
        {
            reservedmarshal_VkPhysicalDeviceShadingRateImagePropertiesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceShadingRateImagePropertiesNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
        {
            reservedmarshal_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(vkStream, rootType, reinterpret_cast<const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_ray_tracing
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
        {
            reservedmarshal_VkWriteDescriptorSetAccelerationStructureNV(vkStream, rootType, reinterpret_cast<const VkWriteDescriptorSetAccelerationStructureNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
        {
            reservedmarshal_VkPhysicalDeviceRayTracingPropertiesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceRayTracingPropertiesNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_representative_fragment_test
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {
            reservedmarshal_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
        {
            reservedmarshal_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(vkStream, rootType, reinterpret_cast<const VkPipelineRepresentativeFragmentTestStateCreateInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_filter_cubic
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
        {
            reservedmarshal_VkPhysicalDeviceImageViewImageFormatInfoEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceImageViewImageFormatInfoEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
        {
            reservedmarshal_VkFilterCubicImageViewImageFormatPropertiesEXT(vkStream, rootType, reinterpret_cast<const VkFilterCubicImageViewImageFormatPropertiesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_global_priority
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
        {
            reservedmarshal_VkDeviceQueueGlobalPriorityCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkDeviceQueueGlobalPriorityCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_external_memory_host
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            reservedmarshal_VkImportMemoryHostPointerInfoEXT(vkStream, rootType, reinterpret_cast<const VkImportMemoryHostPointerInfoEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_AMD_pipeline_compiler_control
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
        {
            reservedmarshal_VkPipelineCompilerControlCreateInfoAMD(vkStream, rootType, reinterpret_cast<const VkPipelineCompilerControlCreateInfoAMD*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            reservedmarshal_VkPhysicalDeviceShaderCorePropertiesAMD(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceShaderCorePropertiesAMD*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_AMD_memory_overallocation_behavior
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
        {
            reservedmarshal_VkDeviceMemoryOverallocationCreateInfoAMD(vkStream, rootType, reinterpret_cast<const VkDeviceMemoryOverallocationCreateInfoAMD*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_vertex_attribute_divisor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
            reservedmarshal_VkPipelineVertexInputDivisorStateCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkPipelineVertexInputDivisorStateCreateInfoEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_GGP_frame_token
        case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
        {
            reservedmarshal_VkPresentFrameTokenGGP(vkStream, rootType, reinterpret_cast<const VkPresentFrameTokenGGP*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_pipeline_creation_feedback
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT:
        {
            reservedmarshal_VkPipelineCreationFeedbackCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkPipelineCreationFeedbackCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_compute_shader_derivatives
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
        {
            reservedmarshal_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_mesh_shader
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {
            reservedmarshal_VkPhysicalDeviceMeshShaderFeaturesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceMeshShaderFeaturesNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
        {
            reservedmarshal_VkPhysicalDeviceMeshShaderPropertiesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceMeshShaderPropertiesNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_fragment_shader_barycentric
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV:
        {
            reservedmarshal_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_shader_image_footprint
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {
            reservedmarshal_VkPhysicalDeviceShaderImageFootprintFeaturesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_scissor_exclusive
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
        {
            reservedmarshal_VkPipelineViewportExclusiveScissorStateCreateInfoNV(vkStream, rootType, reinterpret_cast<const VkPipelineViewportExclusiveScissorStateCreateInfoNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {
            reservedmarshal_VkPhysicalDeviceExclusiveScissorFeaturesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceExclusiveScissorFeaturesNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            reservedmarshal_VkQueueFamilyCheckpointPropertiesNV(vkStream, rootType, reinterpret_cast<const VkQueueFamilyCheckpointPropertiesNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_INTEL_shader_integer_functions2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {
            reservedmarshal_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_INTEL_performance_query
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
        {
            reservedmarshal_VkQueryPoolPerformanceQueryCreateInfoINTEL(vkStream, rootType, reinterpret_cast<const VkQueryPoolPerformanceQueryCreateInfoINTEL*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_pci_bus_info
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDevicePCIBusInfoPropertiesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDevicePCIBusInfoPropertiesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_AMD_display_native_hdr
        case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
        {
            reservedmarshal_VkDisplayNativeHdrSurfaceCapabilitiesAMD(vkStream, rootType, reinterpret_cast<const VkDisplayNativeHdrSurfaceCapabilitiesAMD*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
        {
            reservedmarshal_VkSwapchainDisplayNativeHdrCreateInfoAMD(vkStream, rootType, reinterpret_cast<const VkSwapchainDisplayNativeHdrCreateInfoAMD*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_fragment_density_map
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
        {
            switch(rootType)
            {
                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
                {
                    reservedmarshal_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(structExtension), ptr);
                    break;
                }
                case VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO:
                {
                    reservedmarshal_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(structExtension), ptr);
                    break;
                }
                case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:
                {
                    reservedmarshal_VkImportColorBufferGOOGLE(vkStream, rootType, reinterpret_cast<const VkImportColorBufferGOOGLE*>(structExtension), ptr);
                    break;
                }
                default:
                {
                    reservedmarshal_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(structExtension), ptr);
                    break;
                }
            }
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
        {
            switch(rootType)
            {
                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2:
                {
                    reservedmarshal_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentDensityMapPropertiesEXT*>(structExtension), ptr);
                    break;
                }
                case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:
                {
                    reservedmarshal_VkImportPhysicalAddressGOOGLE(vkStream, rootType, reinterpret_cast<const VkImportPhysicalAddressGOOGLE*>(structExtension), ptr);
                    break;
                }
                default:
                {
                    reservedmarshal_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentDensityMapPropertiesEXT*>(structExtension), ptr);
                    break;
                }
            }
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
        {
            switch(rootType)
            {
                case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO:
                {
                    reservedmarshal_VkRenderPassFragmentDensityMapCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkRenderPassFragmentDensityMapCreateInfoEXT*>(structExtension), ptr);
                    break;
                }
                case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2:
                {
                    reservedmarshal_VkRenderPassFragmentDensityMapCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkRenderPassFragmentDensityMapCreateInfoEXT*>(structExtension), ptr);
                    break;
                }
                case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:
                {
                    reservedmarshal_VkImportBufferGOOGLE(vkStream, rootType, reinterpret_cast<const VkImportBufferGOOGLE*>(structExtension), ptr);
                    break;
                }
                default:
                {
                    reservedmarshal_VkRenderPassFragmentDensityMapCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkRenderPassFragmentDensityMapCreateInfoEXT*>(structExtension), ptr);
                    break;
                }
            }
            break;
        }
#endif
#ifdef VK_EXT_subgroup_size_control
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT:
        {
            reservedmarshal_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
        {
            reservedmarshal_VkPhysicalDeviceShaderCoreProperties2AMD(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceShaderCoreProperties2AMD*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_AMD_device_coherent_memory
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {
            reservedmarshal_VkPhysicalDeviceCoherentMemoryFeaturesAMD(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceCoherentMemoryFeaturesAMD*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_shader_image_atomic_int64
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_memory_budget
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceMemoryBudgetPropertiesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceMemoryBudgetPropertiesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_memory_priority
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceMemoryPriorityFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceMemoryPriorityFeaturesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
        {
            reservedmarshal_VkMemoryPriorityAllocateInfoEXT(vkStream, rootType, reinterpret_cast<const VkMemoryPriorityAllocateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {
            reservedmarshal_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_buffer_device_address
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
        {
            reservedmarshal_VkBufferDeviceAddressCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkBufferDeviceAddressCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_validation_features
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
        {
            reservedmarshal_VkValidationFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkValidationFeaturesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_cooperative_matrix
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {
            reservedmarshal_VkPhysicalDeviceCooperativeMatrixFeaturesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceCooperativeMatrixFeaturesNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {
            reservedmarshal_VkPhysicalDeviceCooperativeMatrixPropertiesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceCooperativeMatrixPropertiesNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_coverage_reduction_mode
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {
            reservedmarshal_VkPhysicalDeviceCoverageReductionModeFeaturesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceCoverageReductionModeFeaturesNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
        {
            reservedmarshal_VkPipelineCoverageReductionStateCreateInfoNV(vkStream, rootType, reinterpret_cast<const VkPipelineCoverageReductionStateCreateInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_fragment_shader_interlock
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_ycbcr_image_arrays
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_full_screen_exclusive
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
        {
            reservedmarshal_VkSurfaceFullScreenExclusiveInfoEXT(vkStream, rootType, reinterpret_cast<const VkSurfaceFullScreenExclusiveInfoEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
        {
            reservedmarshal_VkSurfaceCapabilitiesFullScreenExclusiveEXT(vkStream, rootType, reinterpret_cast<const VkSurfaceCapabilitiesFullScreenExclusiveEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
        {
            reservedmarshal_VkSurfaceFullScreenExclusiveWin32InfoEXT(vkStream, rootType, reinterpret_cast<const VkSurfaceFullScreenExclusiveWin32InfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_line_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceLineRasterizationFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceLineRasterizationFeaturesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceLineRasterizationPropertiesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceLineRasterizationPropertiesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
        {
            reservedmarshal_VkPipelineRasterizationLineStateCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkPipelineRasterizationLineStateCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_shader_atomic_float
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_index_type_uint8
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceIndexTypeUint8FeaturesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_device_generated_commands
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
        {
            reservedmarshal_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {
            reservedmarshal_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
        {
            reservedmarshal_VkGraphicsPipelineShaderGroupsCreateInfoNV(vkStream, rootType, reinterpret_cast<const VkGraphicsPipelineShaderGroupsCreateInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_texel_buffer_alignment
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_QCOM_render_pass_transform
        case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM:
        {
            reservedmarshal_VkRenderPassTransformBeginInfoQCOM(vkStream, rootType, reinterpret_cast<const VkRenderPassTransformBeginInfoQCOM*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
        {
            reservedmarshal_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(vkStream, rootType, reinterpret_cast<const VkCommandBufferInheritanceRenderPassTransformInfoQCOM*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_device_memory_report
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT:
        {
            reservedmarshal_VkDeviceDeviceMemoryReportCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkDeviceDeviceMemoryReportCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_robustness2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceRobustness2FeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceRobustness2FeaturesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceRobustness2PropertiesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceRobustness2PropertiesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_custom_border_color
        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
        {
            reservedmarshal_VkSamplerCustomBorderColorCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkSamplerCustomBorderColorCreateInfoEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceCustomBorderColorPropertiesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceCustomBorderColorPropertiesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceCustomBorderColorFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceCustomBorderColorFeaturesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_private_data
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDevicePrivateDataFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDevicePrivateDataFeaturesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT:
        {
            reservedmarshal_VkDevicePrivateDataCreateInfoEXT(vkStream, rootType, reinterpret_cast<const VkDevicePrivateDataCreateInfoEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_pipeline_creation_cache_control
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_device_diagnostics_config
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {
            reservedmarshal_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceDiagnosticsConfigFeaturesNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
        {
            reservedmarshal_VkDeviceDiagnosticsConfigCreateInfoNV(vkStream, rootType, reinterpret_cast<const VkDeviceDiagnosticsConfigCreateInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_NV_fragment_shading_rate_enums
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {
            reservedmarshal_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
        {
            reservedmarshal_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
        {
            reservedmarshal_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(vkStream, rootType, reinterpret_cast<const VkPipelineFragmentShadingRateEnumStateCreateInfoNV*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_fragment_density_map2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_QCOM_rotated_copy_commands
        case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
        {
            reservedmarshal_VkCopyCommandTransformInfoQCOM(vkStream, rootType, reinterpret_cast<const VkCopyCommandTransformInfoQCOM*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_image_robustness
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDeviceImageRobustnessFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceImageRobustnessFeaturesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_EXT_4444_formats
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {
            reservedmarshal_VkPhysicalDevice4444FormatsFeaturesEXT(vkStream, rootType, reinterpret_cast<const VkPhysicalDevice4444FormatsFeaturesEXT*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_GOOGLE_gfxstream
        case VK_STRUCTURE_TYPE_IMPORT_COLOR_BUFFER_GOOGLE:
        {
            reservedmarshal_VkImportColorBufferGOOGLE(vkStream, rootType, reinterpret_cast<const VkImportColorBufferGOOGLE*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_BUFFER_GOOGLE:
        {
            reservedmarshal_VkImportBufferGOOGLE(vkStream, rootType, reinterpret_cast<const VkImportBufferGOOGLE*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_PHYSICAL_ADDRESS_GOOGLE:
        {
            reservedmarshal_VkImportPhysicalAddressGOOGLE(vkStream, rootType, reinterpret_cast<const VkImportPhysicalAddressGOOGLE*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
        {
            reservedmarshal_VkWriteDescriptorSetAccelerationStructureKHR(vkStream, rootType, reinterpret_cast<const VkWriteDescriptorSetAccelerationStructureKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {
            reservedmarshal_VkPhysicalDeviceAccelerationStructureFeaturesKHR(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceAccelerationStructureFeaturesKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
        {
            reservedmarshal_VkPhysicalDeviceAccelerationStructurePropertiesKHR(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceAccelerationStructurePropertiesKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {
            reservedmarshal_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceRayTracingPipelineFeaturesKHR*>(structExtension), ptr);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
        {
            reservedmarshal_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceRayTracingPipelinePropertiesKHR*>(structExtension), ptr);
            break;
        }
#endif
#ifdef VK_KHR_ray_query
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {
            reservedmarshal_VkPhysicalDeviceRayQueryFeaturesKHR(vkStream, rootType, reinterpret_cast<const VkPhysicalDeviceRayQueryFeaturesKHR*>(structExtension), ptr);
            break;
        }
#endif
        default:
        {
            // fatal; the switch is only taken if the extension struct is known
            abort();
        }
    }
}


} // namespace goldfish_vk
