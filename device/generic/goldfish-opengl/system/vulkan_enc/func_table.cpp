// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module func_table
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "func_table.h"


#include "VkEncoder.h"
#include "../OpenglSystemCommon/HostConnection.h"
#include "ResourceTracker.h"

#include "goldfish_vk_private_defs.h"

#include <log/log.h>

// Stuff we are not going to use but if included,
// will cause compile errors. These are Android Vulkan
// required extensions, but the approach will be to
// implement them completely on the guest side.
#undef VK_KHR_android_surface


namespace goldfish_vk {

static void sOnInvalidDynamicallyCheckedCall(const char* apiname, const char* neededFeature)
{
    ALOGE("invalid call to %s: %s not supported", apiname, neededFeature);
    abort();
}
#ifdef VK_VERSION_1_0
static VkResult entry_vkCreateInstance(
    const VkInstanceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkInstance* pInstance)
{
    AEMU_SCOPED_TRACE("vkCreateInstance");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateInstance_VkResult_return = (VkResult)0;
    vkCreateInstance_VkResult_return = vkEnc->vkCreateInstance(pCreateInfo, pAllocator, pInstance, true /* do lock */);
    return vkCreateInstance_VkResult_return;
}
static void entry_vkDestroyInstance(
    VkInstance instance,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyInstance");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyInstance(instance, pAllocator, true /* do lock */);
}
static VkResult entry_vkEnumeratePhysicalDevices(
    VkInstance instance,
    uint32_t* pPhysicalDeviceCount,
    VkPhysicalDevice* pPhysicalDevices)
{
    AEMU_SCOPED_TRACE("vkEnumeratePhysicalDevices");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkEnumeratePhysicalDevices_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkEnumeratePhysicalDevices_VkResult_return = resources->on_vkEnumeratePhysicalDevices(vkEnc, VK_SUCCESS, instance, pPhysicalDeviceCount, pPhysicalDevices);
    return vkEnumeratePhysicalDevices_VkResult_return;
}
static void entry_vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures* pFeatures)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFeatures");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceFeatures(physicalDevice, pFeatures, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties* pFormatProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFormatProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties, true /* do lock */);
}
static VkResult entry_vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkImageTiling tiling,
    VkImageUsageFlags usage,
    VkImageCreateFlags flags,
    VkImageFormatProperties* pImageFormatProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceImageFormatProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceImageFormatProperties_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceImageFormatProperties_VkResult_return = vkEnc->vkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties, true /* do lock */);
    return vkGetPhysicalDeviceImageFormatProperties_VkResult_return;
}
static void entry_vkGetPhysicalDeviceProperties(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties* pProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceProperties(physicalDevice, pProperties, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties* pQueueFamilyProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties* pMemoryProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMemoryProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties, true /* do lock */);
}
static PFN_vkVoidFunction entry_vkGetInstanceProcAddr(
    VkInstance instance,
    const char* pName)
{
    AEMU_SCOPED_TRACE("vkGetInstanceProcAddr");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    PFN_vkVoidFunction vkGetInstanceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
    vkGetInstanceProcAddr_PFN_vkVoidFunction_return = vkEnc->vkGetInstanceProcAddr(instance, pName, true /* do lock */);
    return vkGetInstanceProcAddr_PFN_vkVoidFunction_return;
}
static PFN_vkVoidFunction entry_vkGetDeviceProcAddr(
    VkDevice device,
    const char* pName)
{
    AEMU_SCOPED_TRACE("vkGetDeviceProcAddr");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    PFN_vkVoidFunction vkGetDeviceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
    vkGetDeviceProcAddr_PFN_vkVoidFunction_return = vkEnc->vkGetDeviceProcAddr(device, pName, true /* do lock */);
    return vkGetDeviceProcAddr_PFN_vkVoidFunction_return;
}
static VkResult entry_vkCreateDevice(
    VkPhysicalDevice physicalDevice,
    const VkDeviceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDevice* pDevice)
{
    AEMU_SCOPED_TRACE("vkCreateDevice");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDevice_VkResult_return = (VkResult)0;
    vkCreateDevice_VkResult_return = vkEnc->vkCreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice, true /* do lock */);
    return vkCreateDevice_VkResult_return;
}
static void entry_vkDestroyDevice(
    VkDevice device,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyDevice");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyDevice(device, pAllocator, true /* do lock */);
}
static VkResult entry_vkEnumerateInstanceExtensionProperties(
    const char* pLayerName,
    uint32_t* pPropertyCount,
    VkExtensionProperties* pProperties)
{
    AEMU_SCOPED_TRACE("vkEnumerateInstanceExtensionProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkEnumerateInstanceExtensionProperties_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkEnumerateInstanceExtensionProperties_VkResult_return = resources->on_vkEnumerateInstanceExtensionProperties(vkEnc, VK_SUCCESS, pLayerName, pPropertyCount, pProperties);
    return vkEnumerateInstanceExtensionProperties_VkResult_return;
}
static VkResult entry_vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice physicalDevice,
    const char* pLayerName,
    uint32_t* pPropertyCount,
    VkExtensionProperties* pProperties)
{
    AEMU_SCOPED_TRACE("vkEnumerateDeviceExtensionProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkEnumerateDeviceExtensionProperties_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkEnumerateDeviceExtensionProperties_VkResult_return = resources->on_vkEnumerateDeviceExtensionProperties(vkEnc, VK_SUCCESS, physicalDevice, pLayerName, pPropertyCount, pProperties);
    return vkEnumerateDeviceExtensionProperties_VkResult_return;
}
static VkResult entry_vkEnumerateInstanceLayerProperties(
    uint32_t* pPropertyCount,
    VkLayerProperties* pProperties)
{
    AEMU_SCOPED_TRACE("vkEnumerateInstanceLayerProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkEnumerateInstanceLayerProperties_VkResult_return = (VkResult)0;
    vkEnumerateInstanceLayerProperties_VkResult_return = vkEnc->vkEnumerateInstanceLayerProperties(pPropertyCount, pProperties, true /* do lock */);
    return vkEnumerateInstanceLayerProperties_VkResult_return;
}
static VkResult entry_vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkLayerProperties* pProperties)
{
    AEMU_SCOPED_TRACE("vkEnumerateDeviceLayerProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkEnumerateDeviceLayerProperties_VkResult_return = (VkResult)0;
    vkEnumerateDeviceLayerProperties_VkResult_return = vkEnc->vkEnumerateDeviceLayerProperties(physicalDevice, pPropertyCount, pProperties, true /* do lock */);
    return vkEnumerateDeviceLayerProperties_VkResult_return;
}
static void entry_vkGetDeviceQueue(
    VkDevice device,
    uint32_t queueFamilyIndex,
    uint32_t queueIndex,
    VkQueue* pQueue)
{
    AEMU_SCOPED_TRACE("vkGetDeviceQueue");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue, true /* do lock */);
}
static VkResult entry_vkQueueSubmit(
    VkQueue queue,
    uint32_t submitCount,
    const VkSubmitInfo* pSubmits,
    VkFence fence)
{
    AEMU_SCOPED_TRACE("vkQueueSubmit");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    VkResult vkQueueSubmit_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkQueueSubmit_VkResult_return = resources->on_vkQueueSubmit(vkEnc, VK_SUCCESS, queue, submitCount, pSubmits, fence);
    return vkQueueSubmit_VkResult_return;
}
static VkResult entry_vkQueueWaitIdle(
    VkQueue queue)
{
    AEMU_SCOPED_TRACE("vkQueueWaitIdle");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    VkResult vkQueueWaitIdle_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkQueueWaitIdle_VkResult_return = resources->on_vkQueueWaitIdle(vkEnc, VK_SUCCESS, queue);
    return vkQueueWaitIdle_VkResult_return;
}
static VkResult entry_vkDeviceWaitIdle(
    VkDevice device)
{
    AEMU_SCOPED_TRACE("vkDeviceWaitIdle");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkDeviceWaitIdle_VkResult_return = (VkResult)0;
    vkDeviceWaitIdle_VkResult_return = vkEnc->vkDeviceWaitIdle(device, true /* do lock */);
    return vkDeviceWaitIdle_VkResult_return;
}
static VkResult entry_vkAllocateMemory(
    VkDevice device,
    const VkMemoryAllocateInfo* pAllocateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDeviceMemory* pMemory)
{
    AEMU_SCOPED_TRACE("vkAllocateMemory");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAllocateMemory_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkAllocateMemory_VkResult_return = resources->on_vkAllocateMemory(vkEnc, VK_SUCCESS, device, pAllocateInfo, pAllocator, pMemory);
    return vkAllocateMemory_VkResult_return;
}
static void entry_vkFreeMemory(
    VkDevice device,
    VkDeviceMemory memory,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkFreeMemory");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkFreeMemory(vkEnc, device, memory, pAllocator);
}
static VkResult entry_vkMapMemory(
    VkDevice device,
    VkDeviceMemory memory,
    VkDeviceSize offset,
    VkDeviceSize size,
    VkMemoryMapFlags flags,
    void** ppData)
{
    AEMU_SCOPED_TRACE("vkMapMemory");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkMapMemory_VkResult_return = (VkResult)0;
    vkMapMemory_VkResult_return = vkEnc->vkMapMemory(device, memory, offset, size, flags, ppData, true /* do lock */);
    return vkMapMemory_VkResult_return;
}
static void entry_vkUnmapMemory(
    VkDevice device,
    VkDeviceMemory memory)
{
    AEMU_SCOPED_TRACE("vkUnmapMemory");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkUnmapMemory(device, memory, true /* do lock */);
}
static VkResult entry_vkFlushMappedMemoryRanges(
    VkDevice device,
    uint32_t memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges)
{
    AEMU_SCOPED_TRACE("vkFlushMappedMemoryRanges");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkFlushMappedMemoryRanges_VkResult_return = (VkResult)0;
    vkFlushMappedMemoryRanges_VkResult_return = vkEnc->vkFlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges, true /* do lock */);
    return vkFlushMappedMemoryRanges_VkResult_return;
}
static VkResult entry_vkInvalidateMappedMemoryRanges(
    VkDevice device,
    uint32_t memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges)
{
    AEMU_SCOPED_TRACE("vkInvalidateMappedMemoryRanges");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkInvalidateMappedMemoryRanges_VkResult_return = (VkResult)0;
    vkInvalidateMappedMemoryRanges_VkResult_return = vkEnc->vkInvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges, true /* do lock */);
    return vkInvalidateMappedMemoryRanges_VkResult_return;
}
static void entry_vkGetDeviceMemoryCommitment(
    VkDevice device,
    VkDeviceMemory memory,
    VkDeviceSize* pCommittedMemoryInBytes)
{
    AEMU_SCOPED_TRACE("vkGetDeviceMemoryCommitment");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes, true /* do lock */);
}
static VkResult entry_vkBindBufferMemory(
    VkDevice device,
    VkBuffer buffer,
    VkDeviceMemory memory,
    VkDeviceSize memoryOffset)
{
    AEMU_SCOPED_TRACE("vkBindBufferMemory");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindBufferMemory_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkBindBufferMemory_VkResult_return = resources->on_vkBindBufferMemory(vkEnc, VK_SUCCESS, device, buffer, memory, memoryOffset);
    return vkBindBufferMemory_VkResult_return;
}
static VkResult entry_vkBindImageMemory(
    VkDevice device,
    VkImage image,
    VkDeviceMemory memory,
    VkDeviceSize memoryOffset)
{
    AEMU_SCOPED_TRACE("vkBindImageMemory");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindImageMemory_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkBindImageMemory_VkResult_return = resources->on_vkBindImageMemory(vkEnc, VK_SUCCESS, device, image, memory, memoryOffset);
    return vkBindImageMemory_VkResult_return;
}
static void entry_vkGetBufferMemoryRequirements(
    VkDevice device,
    VkBuffer buffer,
    VkMemoryRequirements* pMemoryRequirements)
{
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkGetBufferMemoryRequirements(vkEnc, device, buffer, pMemoryRequirements);
}
static void entry_vkGetImageMemoryRequirements(
    VkDevice device,
    VkImage image,
    VkMemoryRequirements* pMemoryRequirements)
{
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkGetImageMemoryRequirements(vkEnc, device, image, pMemoryRequirements);
}
static void entry_vkGetImageSparseMemoryRequirements(
    VkDevice device,
    VkImage image,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements)
{
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkSampleCountFlagBits samples,
    VkImageUsageFlags usage,
    VkImageTiling tiling,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties* pProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSparseImageFormatProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties, true /* do lock */);
}
static VkResult entry_vkQueueBindSparse(
    VkQueue queue,
    uint32_t bindInfoCount,
    const VkBindSparseInfo* pBindInfo,
    VkFence fence)
{
    AEMU_SCOPED_TRACE("vkQueueBindSparse");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    VkResult vkQueueBindSparse_VkResult_return = (VkResult)0;
    vkQueueBindSparse_VkResult_return = vkEnc->vkQueueBindSparse(queue, bindInfoCount, pBindInfo, fence, true /* do lock */);
    return vkQueueBindSparse_VkResult_return;
}
static VkResult entry_vkCreateFence(
    VkDevice device,
    const VkFenceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    AEMU_SCOPED_TRACE("vkCreateFence");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateFence_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateFence_VkResult_return = resources->on_vkCreateFence(vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pFence);
    return vkCreateFence_VkResult_return;
}
static void entry_vkDestroyFence(
    VkDevice device,
    VkFence fence,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyFence");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyFence(device, fence, pAllocator, true /* do lock */);
}
static VkResult entry_vkResetFences(
    VkDevice device,
    uint32_t fenceCount,
    const VkFence* pFences)
{
    AEMU_SCOPED_TRACE("vkResetFences");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkResetFences_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkResetFences_VkResult_return = resources->on_vkResetFences(vkEnc, VK_SUCCESS, device, fenceCount, pFences);
    return vkResetFences_VkResult_return;
}
static VkResult entry_vkGetFenceStatus(
    VkDevice device,
    VkFence fence)
{
    AEMU_SCOPED_TRACE("vkGetFenceStatus");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetFenceStatus_VkResult_return = (VkResult)0;
    vkGetFenceStatus_VkResult_return = vkEnc->vkGetFenceStatus(device, fence, true /* do lock */);
    return vkGetFenceStatus_VkResult_return;
}
static VkResult entry_vkWaitForFences(
    VkDevice device,
    uint32_t fenceCount,
    const VkFence* pFences,
    VkBool32 waitAll,
    uint64_t timeout)
{
    AEMU_SCOPED_TRACE("vkWaitForFences");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkWaitForFences_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkWaitForFences_VkResult_return = resources->on_vkWaitForFences(vkEnc, VK_SUCCESS, device, fenceCount, pFences, waitAll, timeout);
    return vkWaitForFences_VkResult_return;
}
static VkResult entry_vkCreateSemaphore(
    VkDevice device,
    const VkSemaphoreCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSemaphore* pSemaphore)
{
    AEMU_SCOPED_TRACE("vkCreateSemaphore");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateSemaphore_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateSemaphore_VkResult_return = resources->on_vkCreateSemaphore(vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pSemaphore);
    return vkCreateSemaphore_VkResult_return;
}
static void entry_vkDestroySemaphore(
    VkDevice device,
    VkSemaphore semaphore,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroySemaphore");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkDestroySemaphore(vkEnc, device, semaphore, pAllocator);
}
static VkResult entry_vkCreateEvent(
    VkDevice device,
    const VkEventCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkEvent* pEvent)
{
    AEMU_SCOPED_TRACE("vkCreateEvent");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateEvent_VkResult_return = (VkResult)0;
    vkCreateEvent_VkResult_return = vkEnc->vkCreateEvent(device, pCreateInfo, pAllocator, pEvent, true /* do lock */);
    return vkCreateEvent_VkResult_return;
}
static void entry_vkDestroyEvent(
    VkDevice device,
    VkEvent event,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyEvent");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyEvent(device, event, pAllocator, true /* do lock */);
}
static VkResult entry_vkGetEventStatus(
    VkDevice device,
    VkEvent event)
{
    AEMU_SCOPED_TRACE("vkGetEventStatus");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetEventStatus_VkResult_return = (VkResult)0;
    vkGetEventStatus_VkResult_return = vkEnc->vkGetEventStatus(device, event, true /* do lock */);
    return vkGetEventStatus_VkResult_return;
}
static VkResult entry_vkSetEvent(
    VkDevice device,
    VkEvent event)
{
    AEMU_SCOPED_TRACE("vkSetEvent");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkSetEvent_VkResult_return = (VkResult)0;
    vkSetEvent_VkResult_return = vkEnc->vkSetEvent(device, event, true /* do lock */);
    return vkSetEvent_VkResult_return;
}
static VkResult entry_vkResetEvent(
    VkDevice device,
    VkEvent event)
{
    AEMU_SCOPED_TRACE("vkResetEvent");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkResetEvent_VkResult_return = (VkResult)0;
    vkResetEvent_VkResult_return = vkEnc->vkResetEvent(device, event, true /* do lock */);
    return vkResetEvent_VkResult_return;
}
static VkResult entry_vkCreateQueryPool(
    VkDevice device,
    const VkQueryPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkQueryPool* pQueryPool)
{
    AEMU_SCOPED_TRACE("vkCreateQueryPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateQueryPool_VkResult_return = (VkResult)0;
    vkCreateQueryPool_VkResult_return = vkEnc->vkCreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool, true /* do lock */);
    return vkCreateQueryPool_VkResult_return;
}
static void entry_vkDestroyQueryPool(
    VkDevice device,
    VkQueryPool queryPool,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyQueryPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyQueryPool(device, queryPool, pAllocator, true /* do lock */);
}
static VkResult entry_vkGetQueryPoolResults(
    VkDevice device,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    size_t dataSize,
    void* pData,
    VkDeviceSize stride,
    VkQueryResultFlags flags)
{
    AEMU_SCOPED_TRACE("vkGetQueryPoolResults");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetQueryPoolResults_VkResult_return = (VkResult)0;
    vkGetQueryPoolResults_VkResult_return = vkEnc->vkGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags, true /* do lock */);
    return vkGetQueryPoolResults_VkResult_return;
}
static VkResult entry_vkCreateBuffer(
    VkDevice device,
    const VkBufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer)
{
    AEMU_SCOPED_TRACE("vkCreateBuffer");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateBuffer_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateBuffer_VkResult_return = resources->on_vkCreateBuffer(vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pBuffer);
    return vkCreateBuffer_VkResult_return;
}
static void entry_vkDestroyBuffer(
    VkDevice device,
    VkBuffer buffer,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyBuffer");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkDestroyBuffer(vkEnc, device, buffer, pAllocator);
}
static VkResult entry_vkCreateBufferView(
    VkDevice device,
    const VkBufferViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBufferView* pView)
{
    AEMU_SCOPED_TRACE("vkCreateBufferView");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateBufferView_VkResult_return = (VkResult)0;
    vkCreateBufferView_VkResult_return = vkEnc->vkCreateBufferView(device, pCreateInfo, pAllocator, pView, true /* do lock */);
    return vkCreateBufferView_VkResult_return;
}
static void entry_vkDestroyBufferView(
    VkDevice device,
    VkBufferView bufferView,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyBufferView");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyBufferView(device, bufferView, pAllocator, true /* do lock */);
}
static VkResult entry_vkCreateImage(
    VkDevice device,
    const VkImageCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage* pImage)
{
    AEMU_SCOPED_TRACE("vkCreateImage");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateImage_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateImage_VkResult_return = resources->on_vkCreateImage(vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pImage);
    return vkCreateImage_VkResult_return;
}
static void entry_vkDestroyImage(
    VkDevice device,
    VkImage image,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyImage");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkDestroyImage(vkEnc, device, image, pAllocator);
}
static void entry_vkGetImageSubresourceLayout(
    VkDevice device,
    VkImage image,
    const VkImageSubresource* pSubresource,
    VkSubresourceLayout* pLayout)
{
    AEMU_SCOPED_TRACE("vkGetImageSubresourceLayout");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetImageSubresourceLayout(device, image, pSubresource, pLayout, true /* do lock */);
}
static VkResult entry_vkCreateImageView(
    VkDevice device,
    const VkImageViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImageView* pView)
{
    AEMU_SCOPED_TRACE("vkCreateImageView");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateImageView_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateImageView_VkResult_return = resources->on_vkCreateImageView(vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pView);
    return vkCreateImageView_VkResult_return;
}
static void entry_vkDestroyImageView(
    VkDevice device,
    VkImageView imageView,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyImageView");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyImageView(device, imageView, pAllocator, true /* do lock */);
}
static VkResult entry_vkCreateShaderModule(
    VkDevice device,
    const VkShaderModuleCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkShaderModule* pShaderModule)
{
    AEMU_SCOPED_TRACE("vkCreateShaderModule");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateShaderModule_VkResult_return = (VkResult)0;
    vkCreateShaderModule_VkResult_return = vkEnc->vkCreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule, true /* do lock */);
    return vkCreateShaderModule_VkResult_return;
}
static void entry_vkDestroyShaderModule(
    VkDevice device,
    VkShaderModule shaderModule,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyShaderModule");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyShaderModule(device, shaderModule, pAllocator, true /* do lock */);
}
static VkResult entry_vkCreatePipelineCache(
    VkDevice device,
    const VkPipelineCacheCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPipelineCache* pPipelineCache)
{
    AEMU_SCOPED_TRACE("vkCreatePipelineCache");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreatePipelineCache_VkResult_return = (VkResult)0;
    vkCreatePipelineCache_VkResult_return = vkEnc->vkCreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache, true /* do lock */);
    return vkCreatePipelineCache_VkResult_return;
}
static void entry_vkDestroyPipelineCache(
    VkDevice device,
    VkPipelineCache pipelineCache,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyPipelineCache");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyPipelineCache(device, pipelineCache, pAllocator, true /* do lock */);
}
static VkResult entry_vkGetPipelineCacheData(
    VkDevice device,
    VkPipelineCache pipelineCache,
    size_t* pDataSize,
    void* pData)
{
    AEMU_SCOPED_TRACE("vkGetPipelineCacheData");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPipelineCacheData_VkResult_return = (VkResult)0;
    vkGetPipelineCacheData_VkResult_return = vkEnc->vkGetPipelineCacheData(device, pipelineCache, pDataSize, pData, true /* do lock */);
    return vkGetPipelineCacheData_VkResult_return;
}
static VkResult entry_vkMergePipelineCaches(
    VkDevice device,
    VkPipelineCache dstCache,
    uint32_t srcCacheCount,
    const VkPipelineCache* pSrcCaches)
{
    AEMU_SCOPED_TRACE("vkMergePipelineCaches");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkMergePipelineCaches_VkResult_return = (VkResult)0;
    vkMergePipelineCaches_VkResult_return = vkEnc->vkMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches, true /* do lock */);
    return vkMergePipelineCaches_VkResult_return;
}
static VkResult entry_vkCreateGraphicsPipelines(
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkGraphicsPipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines)
{
    AEMU_SCOPED_TRACE("vkCreateGraphicsPipelines");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateGraphicsPipelines_VkResult_return = (VkResult)0;
    vkCreateGraphicsPipelines_VkResult_return = vkEnc->vkCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines, true /* do lock */);
    return vkCreateGraphicsPipelines_VkResult_return;
}
static VkResult entry_vkCreateComputePipelines(
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkComputePipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines)
{
    AEMU_SCOPED_TRACE("vkCreateComputePipelines");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateComputePipelines_VkResult_return = (VkResult)0;
    vkCreateComputePipelines_VkResult_return = vkEnc->vkCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines, true /* do lock */);
    return vkCreateComputePipelines_VkResult_return;
}
static void entry_vkDestroyPipeline(
    VkDevice device,
    VkPipeline pipeline,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyPipeline");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyPipeline(device, pipeline, pAllocator, true /* do lock */);
}
static VkResult entry_vkCreatePipelineLayout(
    VkDevice device,
    const VkPipelineLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPipelineLayout* pPipelineLayout)
{
    AEMU_SCOPED_TRACE("vkCreatePipelineLayout");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreatePipelineLayout_VkResult_return = (VkResult)0;
    vkCreatePipelineLayout_VkResult_return = vkEnc->vkCreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout, true /* do lock */);
    return vkCreatePipelineLayout_VkResult_return;
}
static void entry_vkDestroyPipelineLayout(
    VkDevice device,
    VkPipelineLayout pipelineLayout,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyPipelineLayout");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyPipelineLayout(device, pipelineLayout, pAllocator, true /* do lock */);
}
static VkResult entry_vkCreateSampler(
    VkDevice device,
    const VkSamplerCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSampler* pSampler)
{
    AEMU_SCOPED_TRACE("vkCreateSampler");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateSampler_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateSampler_VkResult_return = resources->on_vkCreateSampler(vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pSampler);
    return vkCreateSampler_VkResult_return;
}
static void entry_vkDestroySampler(
    VkDevice device,
    VkSampler sampler,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroySampler");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroySampler(device, sampler, pAllocator, true /* do lock */);
}
static VkResult entry_vkCreateDescriptorSetLayout(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorSetLayout* pSetLayout)
{
    AEMU_SCOPED_TRACE("vkCreateDescriptorSetLayout");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDescriptorSetLayout_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateDescriptorSetLayout_VkResult_return = resources->on_vkCreateDescriptorSetLayout(vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pSetLayout);
    return vkCreateDescriptorSetLayout_VkResult_return;
}
static void entry_vkDestroyDescriptorSetLayout(
    VkDevice device,
    VkDescriptorSetLayout descriptorSetLayout,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyDescriptorSetLayout");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkDestroyDescriptorSetLayout(vkEnc, device, descriptorSetLayout, pAllocator);
}
static VkResult entry_vkCreateDescriptorPool(
    VkDevice device,
    const VkDescriptorPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorPool* pDescriptorPool)
{
    AEMU_SCOPED_TRACE("vkCreateDescriptorPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDescriptorPool_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateDescriptorPool_VkResult_return = resources->on_vkCreateDescriptorPool(vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pDescriptorPool);
    return vkCreateDescriptorPool_VkResult_return;
}
static void entry_vkDestroyDescriptorPool(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyDescriptorPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkDestroyDescriptorPool(vkEnc, device, descriptorPool, pAllocator);
}
static VkResult entry_vkResetDescriptorPool(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    VkDescriptorPoolResetFlags flags)
{
    AEMU_SCOPED_TRACE("vkResetDescriptorPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkResetDescriptorPool_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkResetDescriptorPool_VkResult_return = resources->on_vkResetDescriptorPool(vkEnc, VK_SUCCESS, device, descriptorPool, flags);
    return vkResetDescriptorPool_VkResult_return;
}
static VkResult entry_vkAllocateDescriptorSets(
    VkDevice device,
    const VkDescriptorSetAllocateInfo* pAllocateInfo,
    VkDescriptorSet* pDescriptorSets)
{
    AEMU_SCOPED_TRACE("vkAllocateDescriptorSets");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAllocateDescriptorSets_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkAllocateDescriptorSets_VkResult_return = resources->on_vkAllocateDescriptorSets(vkEnc, VK_SUCCESS, device, pAllocateInfo, pDescriptorSets);
    return vkAllocateDescriptorSets_VkResult_return;
}
static VkResult entry_vkFreeDescriptorSets(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    uint32_t descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets)
{
    AEMU_SCOPED_TRACE("vkFreeDescriptorSets");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkFreeDescriptorSets_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkFreeDescriptorSets_VkResult_return = resources->on_vkFreeDescriptorSets(vkEnc, VK_SUCCESS, device, descriptorPool, descriptorSetCount, pDescriptorSets);
    return vkFreeDescriptorSets_VkResult_return;
}
static void entry_vkUpdateDescriptorSets(
    VkDevice device,
    uint32_t descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites,
    uint32_t descriptorCopyCount,
    const VkCopyDescriptorSet* pDescriptorCopies)
{
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSets");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkUpdateDescriptorSets(vkEnc, device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
}
static VkResult entry_vkCreateFramebuffer(
    VkDevice device,
    const VkFramebufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFramebuffer* pFramebuffer)
{
    AEMU_SCOPED_TRACE("vkCreateFramebuffer");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateFramebuffer_VkResult_return = (VkResult)0;
    vkCreateFramebuffer_VkResult_return = vkEnc->vkCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer, true /* do lock */);
    return vkCreateFramebuffer_VkResult_return;
}
static void entry_vkDestroyFramebuffer(
    VkDevice device,
    VkFramebuffer framebuffer,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyFramebuffer");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyFramebuffer(device, framebuffer, pAllocator, true /* do lock */);
}
static VkResult entry_vkCreateRenderPass(
    VkDevice device,
    const VkRenderPassCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass)
{
    AEMU_SCOPED_TRACE("vkCreateRenderPass");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateRenderPass_VkResult_return = (VkResult)0;
    vkCreateRenderPass_VkResult_return = vkEnc->vkCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass, true /* do lock */);
    return vkCreateRenderPass_VkResult_return;
}
static void entry_vkDestroyRenderPass(
    VkDevice device,
    VkRenderPass renderPass,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyRenderPass");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyRenderPass(device, renderPass, pAllocator, true /* do lock */);
}
static void entry_vkGetRenderAreaGranularity(
    VkDevice device,
    VkRenderPass renderPass,
    VkExtent2D* pGranularity)
{
    AEMU_SCOPED_TRACE("vkGetRenderAreaGranularity");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetRenderAreaGranularity(device, renderPass, pGranularity, true /* do lock */);
}
static VkResult entry_vkCreateCommandPool(
    VkDevice device,
    const VkCommandPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkCommandPool* pCommandPool)
{
    AEMU_SCOPED_TRACE("vkCreateCommandPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateCommandPool_VkResult_return = (VkResult)0;
    vkCreateCommandPool_VkResult_return = vkEnc->vkCreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool, true /* do lock */);
    return vkCreateCommandPool_VkResult_return;
}
static void entry_vkDestroyCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyCommandPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyCommandPool(device, commandPool, pAllocator, true /* do lock */);
}
static VkResult entry_vkResetCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolResetFlags flags)
{
    AEMU_SCOPED_TRACE("vkResetCommandPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkResetCommandPool_VkResult_return = (VkResult)0;
    vkResetCommandPool_VkResult_return = vkEnc->vkResetCommandPool(device, commandPool, flags, true /* do lock */);
    if (vkResetCommandPool_VkResult_return == VK_SUCCESS) {
        ResourceTracker::get()->resetCommandPoolStagingInfo(commandPool);
    }
    return vkResetCommandPool_VkResult_return;
}
static VkResult entry_vkAllocateCommandBuffers(
    VkDevice device,
    const VkCommandBufferAllocateInfo* pAllocateInfo,
    VkCommandBuffer* pCommandBuffers)
{
    AEMU_SCOPED_TRACE("vkAllocateCommandBuffers");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAllocateCommandBuffers_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkAllocateCommandBuffers_VkResult_return = resources->on_vkAllocateCommandBuffers(vkEnc, VK_SUCCESS, device, pAllocateInfo, pCommandBuffers);
    if (vkAllocateCommandBuffers_VkResult_return == VK_SUCCESS) {
        ResourceTracker::get()->addToCommandPool(pAllocateInfo->commandPool, pAllocateInfo->commandBufferCount, pCommandBuffers);
    }
    return vkAllocateCommandBuffers_VkResult_return;
}
static void entry_vkFreeCommandBuffers(
    VkDevice device,
    VkCommandPool commandPool,
    uint32_t commandBufferCount,
    const VkCommandBuffer* pCommandBuffers)
{
    AEMU_SCOPED_TRACE("vkFreeCommandBuffers");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers, true /* do lock */);
}
static VkResult entry_vkBeginCommandBuffer(
    VkCommandBuffer commandBuffer,
    const VkCommandBufferBeginInfo* pBeginInfo)
{
    AEMU_SCOPED_TRACE("vkBeginCommandBuffer");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    VkResult vkBeginCommandBuffer_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkBeginCommandBuffer_VkResult_return = resources->on_vkBeginCommandBuffer(vkEnc, VK_SUCCESS, commandBuffer, pBeginInfo);
    return vkBeginCommandBuffer_VkResult_return;
}
static VkResult entry_vkEndCommandBuffer(
    VkCommandBuffer commandBuffer)
{
    AEMU_SCOPED_TRACE("vkEndCommandBuffer");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    VkResult vkEndCommandBuffer_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkEndCommandBuffer_VkResult_return = resources->on_vkEndCommandBuffer(vkEnc, VK_SUCCESS, commandBuffer);
    return vkEndCommandBuffer_VkResult_return;
}
static VkResult entry_vkResetCommandBuffer(
    VkCommandBuffer commandBuffer,
    VkCommandBufferResetFlags flags)
{
    AEMU_SCOPED_TRACE("vkResetCommandBuffer");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    VkResult vkResetCommandBuffer_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkResetCommandBuffer_VkResult_return = resources->on_vkResetCommandBuffer(vkEnc, VK_SUCCESS, commandBuffer, flags);
    return vkResetCommandBuffer_VkResult_return;
}
static void entry_vkCmdBindPipeline(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipeline pipeline)
{
    AEMU_SCOPED_TRACE("vkCmdBindPipeline");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline, true /* do lock */);
}
static void entry_vkCmdSetViewport(
    VkCommandBuffer commandBuffer,
    uint32_t firstViewport,
    uint32_t viewportCount,
    const VkViewport* pViewports)
{
    AEMU_SCOPED_TRACE("vkCmdSetViewport");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports, true /* do lock */);
}
static void entry_vkCmdSetScissor(
    VkCommandBuffer commandBuffer,
    uint32_t firstScissor,
    uint32_t scissorCount,
    const VkRect2D* pScissors)
{
    AEMU_SCOPED_TRACE("vkCmdSetScissor");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors, true /* do lock */);
}
static void entry_vkCmdSetLineWidth(
    VkCommandBuffer commandBuffer,
    float lineWidth)
{
    AEMU_SCOPED_TRACE("vkCmdSetLineWidth");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetLineWidth(commandBuffer, lineWidth, true /* do lock */);
}
static void entry_vkCmdSetDepthBias(
    VkCommandBuffer commandBuffer,
    float depthBiasConstantFactor,
    float depthBiasClamp,
    float depthBiasSlopeFactor)
{
    AEMU_SCOPED_TRACE("vkCmdSetDepthBias");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor, true /* do lock */);
}
static void entry_vkCmdSetBlendConstants(
    VkCommandBuffer commandBuffer,
    const float blendConstants[4])
{
    AEMU_SCOPED_TRACE("vkCmdSetBlendConstants");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetBlendConstants(commandBuffer, blendConstants, true /* do lock */);
}
static void entry_vkCmdSetDepthBounds(
    VkCommandBuffer commandBuffer,
    float minDepthBounds,
    float maxDepthBounds)
{
    AEMU_SCOPED_TRACE("vkCmdSetDepthBounds");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds, true /* do lock */);
}
static void entry_vkCmdSetStencilCompareMask(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t compareMask)
{
    AEMU_SCOPED_TRACE("vkCmdSetStencilCompareMask");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask, true /* do lock */);
}
static void entry_vkCmdSetStencilWriteMask(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t writeMask)
{
    AEMU_SCOPED_TRACE("vkCmdSetStencilWriteMask");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask, true /* do lock */);
}
static void entry_vkCmdSetStencilReference(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t reference)
{
    AEMU_SCOPED_TRACE("vkCmdSetStencilReference");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetStencilReference(commandBuffer, faceMask, reference, true /* do lock */);
}
static void entry_vkCmdBindDescriptorSets(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipelineLayout layout,
    uint32_t firstSet,
    uint32_t descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets,
    uint32_t dynamicOffsetCount,
    const uint32_t* pDynamicOffsets)
{
    AEMU_SCOPED_TRACE("vkCmdBindDescriptorSets");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    auto resources = ResourceTracker::get();
    resources->on_vkCmdBindDescriptorSets(vkEnc, commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
}
static void entry_vkCmdBindIndexBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkIndexType indexType)
{
    AEMU_SCOPED_TRACE("vkCmdBindIndexBuffer");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType, true /* do lock */);
}
static void entry_vkCmdBindVertexBuffers(
    VkCommandBuffer commandBuffer,
    uint32_t firstBinding,
    uint32_t bindingCount,
    const VkBuffer* pBuffers,
    const VkDeviceSize* pOffsets)
{
    AEMU_SCOPED_TRACE("vkCmdBindVertexBuffers");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, true /* do lock */);
}
static void entry_vkCmdDraw(
    VkCommandBuffer commandBuffer,
    uint32_t vertexCount,
    uint32_t instanceCount,
    uint32_t firstVertex,
    uint32_t firstInstance)
{
    AEMU_SCOPED_TRACE("vkCmdDraw");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance, true /* do lock */);
}
static void entry_vkCmdDrawIndexed(
    VkCommandBuffer commandBuffer,
    uint32_t indexCount,
    uint32_t instanceCount,
    uint32_t firstIndex,
    int32_t vertexOffset,
    uint32_t firstInstance)
{
    AEMU_SCOPED_TRACE("vkCmdDrawIndexed");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance, true /* do lock */);
}
static void entry_vkCmdDrawIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t drawCount,
    uint32_t stride)
{
    AEMU_SCOPED_TRACE("vkCmdDrawIndirect");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride, true /* do lock */);
}
static void entry_vkCmdDrawIndexedIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t drawCount,
    uint32_t stride)
{
    AEMU_SCOPED_TRACE("vkCmdDrawIndexedIndirect");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride, true /* do lock */);
}
static void entry_vkCmdDispatch(
    VkCommandBuffer commandBuffer,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ)
{
    AEMU_SCOPED_TRACE("vkCmdDispatch");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ, true /* do lock */);
}
static void entry_vkCmdDispatchIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset)
{
    AEMU_SCOPED_TRACE("vkCmdDispatchIndirect");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDispatchIndirect(commandBuffer, buffer, offset, true /* do lock */);
}
static void entry_vkCmdCopyBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer srcBuffer,
    VkBuffer dstBuffer,
    uint32_t regionCount,
    const VkBufferCopy* pRegions)
{
    AEMU_SCOPED_TRACE("vkCmdCopyBuffer");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions, true /* do lock */);
}
static void entry_vkCmdCopyImage(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageCopy* pRegions)
{
    AEMU_SCOPED_TRACE("vkCmdCopyImage");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, true /* do lock */);
}
static void entry_vkCmdBlitImage(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageBlit* pRegions,
    VkFilter filter)
{
    AEMU_SCOPED_TRACE("vkCmdBlitImage");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter, true /* do lock */);
}
static void entry_vkCmdCopyBufferToImage(
    VkCommandBuffer commandBuffer,
    VkBuffer srcBuffer,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkBufferImageCopy* pRegions)
{
    AEMU_SCOPED_TRACE("vkCmdCopyBufferToImage");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions, true /* do lock */);
}
static void entry_vkCmdCopyImageToBuffer(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkBuffer dstBuffer,
    uint32_t regionCount,
    const VkBufferImageCopy* pRegions)
{
    AEMU_SCOPED_TRACE("vkCmdCopyImageToBuffer");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions, true /* do lock */);
}
static void entry_vkCmdUpdateBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize dataSize,
    const void* pData)
{
    AEMU_SCOPED_TRACE("vkCmdUpdateBuffer");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData, true /* do lock */);
}
static void entry_vkCmdFillBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize size,
    uint32_t data)
{
    AEMU_SCOPED_TRACE("vkCmdFillBuffer");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data, true /* do lock */);
}
static void entry_vkCmdClearColorImage(
    VkCommandBuffer commandBuffer,
    VkImage image,
    VkImageLayout imageLayout,
    const VkClearColorValue* pColor,
    uint32_t rangeCount,
    const VkImageSubresourceRange* pRanges)
{
    AEMU_SCOPED_TRACE("vkCmdClearColorImage");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges, true /* do lock */);
}
static void entry_vkCmdClearDepthStencilImage(
    VkCommandBuffer commandBuffer,
    VkImage image,
    VkImageLayout imageLayout,
    const VkClearDepthStencilValue* pDepthStencil,
    uint32_t rangeCount,
    const VkImageSubresourceRange* pRanges)
{
    AEMU_SCOPED_TRACE("vkCmdClearDepthStencilImage");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges, true /* do lock */);
}
static void entry_vkCmdClearAttachments(
    VkCommandBuffer commandBuffer,
    uint32_t attachmentCount,
    const VkClearAttachment* pAttachments,
    uint32_t rectCount,
    const VkClearRect* pRects)
{
    AEMU_SCOPED_TRACE("vkCmdClearAttachments");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects, true /* do lock */);
}
static void entry_vkCmdResolveImage(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageResolve* pRegions)
{
    AEMU_SCOPED_TRACE("vkCmdResolveImage");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, true /* do lock */);
}
static void entry_vkCmdSetEvent(
    VkCommandBuffer commandBuffer,
    VkEvent event,
    VkPipelineStageFlags stageMask)
{
    AEMU_SCOPED_TRACE("vkCmdSetEvent");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetEvent(commandBuffer, event, stageMask, true /* do lock */);
}
static void entry_vkCmdResetEvent(
    VkCommandBuffer commandBuffer,
    VkEvent event,
    VkPipelineStageFlags stageMask)
{
    AEMU_SCOPED_TRACE("vkCmdResetEvent");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdResetEvent(commandBuffer, event, stageMask, true /* do lock */);
}
static void entry_vkCmdWaitEvents(
    VkCommandBuffer commandBuffer,
    uint32_t eventCount,
    const VkEvent* pEvents,
    VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask,
    uint32_t memoryBarrierCount,
    const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount,
    const VkImageMemoryBarrier* pImageMemoryBarriers)
{
    AEMU_SCOPED_TRACE("vkCmdWaitEvents");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers, true /* do lock */);
}
static void entry_vkCmdPipelineBarrier(
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask,
    VkDependencyFlags dependencyFlags,
    uint32_t memoryBarrierCount,
    const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount,
    const VkImageMemoryBarrier* pImageMemoryBarriers)
{
    AEMU_SCOPED_TRACE("vkCmdPipelineBarrier");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers, true /* do lock */);
}
static void entry_vkCmdBeginQuery(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query,
    VkQueryControlFlags flags)
{
    AEMU_SCOPED_TRACE("vkCmdBeginQuery");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBeginQuery(commandBuffer, queryPool, query, flags, true /* do lock */);
}
static void entry_vkCmdEndQuery(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query)
{
    AEMU_SCOPED_TRACE("vkCmdEndQuery");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdEndQuery(commandBuffer, queryPool, query, true /* do lock */);
}
static void entry_vkCmdResetQueryPool(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount)
{
    AEMU_SCOPED_TRACE("vkCmdResetQueryPool");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount, true /* do lock */);
}
static void entry_vkCmdWriteTimestamp(
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkQueryPool queryPool,
    uint32_t query)
{
    AEMU_SCOPED_TRACE("vkCmdWriteTimestamp");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query, true /* do lock */);
}
static void entry_vkCmdCopyQueryPoolResults(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize stride,
    VkQueryResultFlags flags)
{
    AEMU_SCOPED_TRACE("vkCmdCopyQueryPoolResults");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags, true /* do lock */);
}
static void entry_vkCmdPushConstants(
    VkCommandBuffer commandBuffer,
    VkPipelineLayout layout,
    VkShaderStageFlags stageFlags,
    uint32_t offset,
    uint32_t size,
    const void* pValues)
{
    AEMU_SCOPED_TRACE("vkCmdPushConstants");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues, true /* do lock */);
}
static void entry_vkCmdBeginRenderPass(
    VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    VkSubpassContents contents)
{
    AEMU_SCOPED_TRACE("vkCmdBeginRenderPass");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents, true /* do lock */);
}
static void entry_vkCmdNextSubpass(
    VkCommandBuffer commandBuffer,
    VkSubpassContents contents)
{
    AEMU_SCOPED_TRACE("vkCmdNextSubpass");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdNextSubpass(commandBuffer, contents, true /* do lock */);
}
static void entry_vkCmdEndRenderPass(
    VkCommandBuffer commandBuffer)
{
    AEMU_SCOPED_TRACE("vkCmdEndRenderPass");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdEndRenderPass(commandBuffer, true /* do lock */);
}
static void entry_vkCmdExecuteCommands(
    VkCommandBuffer commandBuffer,
    uint32_t commandBufferCount,
    const VkCommandBuffer* pCommandBuffers)
{
    AEMU_SCOPED_TRACE("vkCmdExecuteCommands");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    auto resources = ResourceTracker::get();
    resources->on_vkCmdExecuteCommands(vkEnc, commandBuffer, commandBufferCount, pCommandBuffers);
}
#endif
#ifdef VK_VERSION_1_1
static VkResult entry_vkEnumerateInstanceVersion(
    uint32_t* pApiVersion)
{
    AEMU_SCOPED_TRACE("vkEnumerateInstanceVersion");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkEnumerateInstanceVersion_VkResult_return = (VkResult)0;
    vkEnumerateInstanceVersion_VkResult_return = vkEnc->vkEnumerateInstanceVersion(pApiVersion, true /* do lock */);
    return vkEnumerateInstanceVersion_VkResult_return;
}
static VkResult entry_vkBindBufferMemory2(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos)
{
    AEMU_SCOPED_TRACE("vkBindBufferMemory2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindBufferMemory2_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkBindBufferMemory2_VkResult_return = resources->on_vkBindBufferMemory2(vkEnc, VK_SUCCESS, device, bindInfoCount, pBindInfos);
    return vkBindBufferMemory2_VkResult_return;
}
static VkResult dynCheck_entry_vkBindBufferMemory2(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos)
{
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1)
    {
        sOnInvalidDynamicallyCheckedCall("vkBindBufferMemory2", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkBindBufferMemory2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindBufferMemory2_VkResult_return = (VkResult)0;
    vkBindBufferMemory2_VkResult_return = resources->on_vkBindBufferMemory2(vkEnc, VK_SUCCESS, device, bindInfoCount, pBindInfos);
    return vkBindBufferMemory2_VkResult_return;
}
static VkResult entry_vkBindImageMemory2(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos)
{
    AEMU_SCOPED_TRACE("vkBindImageMemory2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindImageMemory2_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkBindImageMemory2_VkResult_return = resources->on_vkBindImageMemory2(vkEnc, VK_SUCCESS, device, bindInfoCount, pBindInfos);
    return vkBindImageMemory2_VkResult_return;
}
static VkResult dynCheck_entry_vkBindImageMemory2(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos)
{
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1)
    {
        sOnInvalidDynamicallyCheckedCall("vkBindImageMemory2", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkBindImageMemory2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindImageMemory2_VkResult_return = (VkResult)0;
    vkBindImageMemory2_VkResult_return = resources->on_vkBindImageMemory2(vkEnc, VK_SUCCESS, device, bindInfoCount, pBindInfos);
    return vkBindImageMemory2_VkResult_return;
}
static void entry_vkGetDeviceGroupPeerMemoryFeatures(
    VkDevice device,
    uint32_t heapIndex,
    uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{
    AEMU_SCOPED_TRACE("vkGetDeviceGroupPeerMemoryFeatures");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures, true /* do lock */);
}
static void dynCheck_entry_vkGetDeviceGroupPeerMemoryFeatures(
    VkDevice device,
    uint32_t heapIndex,
    uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1)
    {
        sOnInvalidDynamicallyCheckedCall("vkGetDeviceGroupPeerMemoryFeatures", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkGetDeviceGroupPeerMemoryFeatures");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures, true /* do lock */);
}
static void entry_vkCmdSetDeviceMask(
    VkCommandBuffer commandBuffer,
    uint32_t deviceMask)
{
    AEMU_SCOPED_TRACE("vkCmdSetDeviceMask");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetDeviceMask(commandBuffer, deviceMask, true /* do lock */);
}
static void entry_vkCmdDispatchBase(
    VkCommandBuffer commandBuffer,
    uint32_t baseGroupX,
    uint32_t baseGroupY,
    uint32_t baseGroupZ,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ)
{
    AEMU_SCOPED_TRACE("vkCmdDispatchBase");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ, true /* do lock */);
}
static VkResult entry_vkEnumeratePhysicalDeviceGroups(
    VkInstance instance,
    uint32_t* pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties)
{
    AEMU_SCOPED_TRACE("vkEnumeratePhysicalDeviceGroups");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkEnumeratePhysicalDeviceGroups_VkResult_return = (VkResult)0;
    vkEnumeratePhysicalDeviceGroups_VkResult_return = vkEnc->vkEnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties, true /* do lock */);
    return vkEnumeratePhysicalDeviceGroups_VkResult_return;
}
static void entry_vkGetImageMemoryRequirements2(
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkGetImageMemoryRequirements2(vkEnc, device, pInfo, pMemoryRequirements);
}
static void dynCheck_entry_vkGetImageMemoryRequirements2(
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1)
    {
        sOnInvalidDynamicallyCheckedCall("vkGetImageMemoryRequirements2", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    resources->on_vkGetImageMemoryRequirements2(vkEnc, device, pInfo, pMemoryRequirements);
}
static void entry_vkGetBufferMemoryRequirements2(
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkGetBufferMemoryRequirements2(vkEnc, device, pInfo, pMemoryRequirements);
}
static void dynCheck_entry_vkGetBufferMemoryRequirements2(
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1)
    {
        sOnInvalidDynamicallyCheckedCall("vkGetBufferMemoryRequirements2", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    resources->on_vkGetBufferMemoryRequirements2(vkEnc, device, pInfo, pMemoryRequirements);
}
static void entry_vkGetImageSparseMemoryRequirements2(
    VkDevice device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements, true /* do lock */);
}
static void dynCheck_entry_vkGetImageSparseMemoryRequirements2(
    VkDevice device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1)
    {
        sOnInvalidDynamicallyCheckedCall("vkGetImageSparseMemoryRequirements2", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceFeatures2(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures2* pFeatures)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFeatures2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceFeatures2(physicalDevice, pFeatures, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceProperties2(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties2* pProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceProperties2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceProperties2(physicalDevice, pProperties, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceFormatProperties2(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties2* pFormatProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFormatProperties2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties, true /* do lock */);
}
static VkResult entry_vkGetPhysicalDeviceImageFormatProperties2(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceImageFormatProperties2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = resources->on_vkGetPhysicalDeviceImageFormatProperties2(vkEnc, VK_SUCCESS, physicalDevice, pImageFormatInfo, pImageFormatProperties);
    return vkGetPhysicalDeviceImageFormatProperties2_VkResult_return;
}
static void entry_vkGetPhysicalDeviceQueueFamilyProperties2(
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyProperties2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceMemoryProperties2(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMemoryProperties2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceSparseImageFormatProperties2(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSparseImageFormatProperties2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties, true /* do lock */);
}
static void entry_vkTrimCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolTrimFlags flags)
{
    AEMU_SCOPED_TRACE("vkTrimCommandPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkTrimCommandPool(device, commandPool, flags, true /* do lock */);
}
static void dynCheck_entry_vkTrimCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolTrimFlags flags)
{
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1)
    {
        sOnInvalidDynamicallyCheckedCall("vkTrimCommandPool", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkTrimCommandPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkTrimCommandPool(device, commandPool, flags, true /* do lock */);
}
static void entry_vkGetDeviceQueue2(
    VkDevice device,
    const VkDeviceQueueInfo2* pQueueInfo,
    VkQueue* pQueue)
{
    AEMU_SCOPED_TRACE("vkGetDeviceQueue2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceQueue2(device, pQueueInfo, pQueue, true /* do lock */);
}
static void dynCheck_entry_vkGetDeviceQueue2(
    VkDevice device,
    const VkDeviceQueueInfo2* pQueueInfo,
    VkQueue* pQueue)
{
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1)
    {
        sOnInvalidDynamicallyCheckedCall("vkGetDeviceQueue2", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkGetDeviceQueue2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceQueue2(device, pQueueInfo, pQueue, true /* do lock */);
}
static VkResult entry_vkCreateSamplerYcbcrConversion(
    VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion)
{
    AEMU_SCOPED_TRACE("vkCreateSamplerYcbcrConversion");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateSamplerYcbcrConversion_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateSamplerYcbcrConversion_VkResult_return = resources->on_vkCreateSamplerYcbcrConversion(vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pYcbcrConversion);
    return vkCreateSamplerYcbcrConversion_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateSamplerYcbcrConversion(
    VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion)
{
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1)
    {
        sOnInvalidDynamicallyCheckedCall("vkCreateSamplerYcbcrConversion", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkCreateSamplerYcbcrConversion");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateSamplerYcbcrConversion_VkResult_return = (VkResult)0;
    vkCreateSamplerYcbcrConversion_VkResult_return = resources->on_vkCreateSamplerYcbcrConversion(vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pYcbcrConversion);
    return vkCreateSamplerYcbcrConversion_VkResult_return;
}
static void entry_vkDestroySamplerYcbcrConversion(
    VkDevice device,
    VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroySamplerYcbcrConversion");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkDestroySamplerYcbcrConversion(vkEnc, device, ycbcrConversion, pAllocator);
}
static void dynCheck_entry_vkDestroySamplerYcbcrConversion(
    VkDevice device,
    VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator)
{
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1)
    {
        sOnInvalidDynamicallyCheckedCall("vkDestroySamplerYcbcrConversion", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkDestroySamplerYcbcrConversion");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    resources->on_vkDestroySamplerYcbcrConversion(vkEnc, device, ycbcrConversion, pAllocator);
}
static VkResult entry_vkCreateDescriptorUpdateTemplate(
    VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{
    AEMU_SCOPED_TRACE("vkCreateDescriptorUpdateTemplate");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDescriptorUpdateTemplate_VkResult_return = (VkResult)0;
    vkCreateDescriptorUpdateTemplate_VkResult_return = vkEnc->vkCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate, true /* do lock */);
    return vkCreateDescriptorUpdateTemplate_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateDescriptorUpdateTemplate(
    VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1)
    {
        sOnInvalidDynamicallyCheckedCall("vkCreateDescriptorUpdateTemplate", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkCreateDescriptorUpdateTemplate");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDescriptorUpdateTemplate_VkResult_return = (VkResult)0;
    vkCreateDescriptorUpdateTemplate_VkResult_return = vkEnc->vkCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate, true /* do lock */);
    return vkCreateDescriptorUpdateTemplate_VkResult_return;
}
static void entry_vkDestroyDescriptorUpdateTemplate(
    VkDevice device,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyDescriptorUpdateTemplate");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator, true /* do lock */);
}
static void dynCheck_entry_vkDestroyDescriptorUpdateTemplate(
    VkDevice device,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator)
{
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1)
    {
        sOnInvalidDynamicallyCheckedCall("vkDestroyDescriptorUpdateTemplate", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkDestroyDescriptorUpdateTemplate");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator, true /* do lock */);
}
static void entry_vkUpdateDescriptorSetWithTemplate(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const void* pData)
{
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplate");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkUpdateDescriptorSetWithTemplate(vkEnc, device, descriptorSet, descriptorUpdateTemplate, pData);
}
static void dynCheck_entry_vkUpdateDescriptorSetWithTemplate(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const void* pData)
{
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1)
    {
        sOnInvalidDynamicallyCheckedCall("vkUpdateDescriptorSetWithTemplate", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplate");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    resources->on_vkUpdateDescriptorSetWithTemplate(vkEnc, device, descriptorSet, descriptorUpdateTemplate, pData);
}
static void entry_vkGetPhysicalDeviceExternalBufferProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalBufferProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceExternalFenceProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalFenceProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkGetPhysicalDeviceExternalFenceProperties(vkEnc, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
}
static void entry_vkGetPhysicalDeviceExternalSemaphoreProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalSemaphoreProperties");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties, true /* do lock */);
}
static void entry_vkGetDescriptorSetLayoutSupport(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport)
{
    AEMU_SCOPED_TRACE("vkGetDescriptorSetLayoutSupport");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport, true /* do lock */);
}
static void dynCheck_entry_vkGetDescriptorSetLayoutSupport(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport)
{
    auto resources = ResourceTracker::get();
    if (resources->getApiVersionFromDevice(device) < VK_API_VERSION_1_1)
    {
        sOnInvalidDynamicallyCheckedCall("vkGetDescriptorSetLayoutSupport", "VK_VERSION_1_1");
    }
    AEMU_SCOPED_TRACE("vkGetDescriptorSetLayoutSupport");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport, true /* do lock */);
}
#endif
#ifdef VK_VERSION_1_2
static void entry_vkCmdDrawIndirectCount(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    AEMU_SCOPED_TRACE("vkCmdDrawIndirectCount");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride, true /* do lock */);
}
static void entry_vkCmdDrawIndexedIndirectCount(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    AEMU_SCOPED_TRACE("vkCmdDrawIndexedIndirectCount");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride, true /* do lock */);
}
static VkResult entry_vkCreateRenderPass2(
    VkDevice device,
    const VkRenderPassCreateInfo2* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass)
{
    AEMU_SCOPED_TRACE("vkCreateRenderPass2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateRenderPass2_VkResult_return = (VkResult)0;
    vkCreateRenderPass2_VkResult_return = vkEnc->vkCreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass, true /* do lock */);
    return vkCreateRenderPass2_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateRenderPass2(
    VkDevice device,
    const VkRenderPassCreateInfo2* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_2"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCreateRenderPass2", "VK_VERSION_1_2");
    }
    AEMU_SCOPED_TRACE("vkCreateRenderPass2");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateRenderPass2_VkResult_return = (VkResult)0;
    vkCreateRenderPass2_VkResult_return = vkEnc->vkCreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass, true /* do lock */);
    return vkCreateRenderPass2_VkResult_return;
}
static void entry_vkCmdBeginRenderPass2(
    VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    const VkSubpassBeginInfo* pSubpassBeginInfo)
{
    AEMU_SCOPED_TRACE("vkCmdBeginRenderPass2");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo, true /* do lock */);
}
static void entry_vkCmdNextSubpass2(
    VkCommandBuffer commandBuffer,
    const VkSubpassBeginInfo* pSubpassBeginInfo,
    const VkSubpassEndInfo* pSubpassEndInfo)
{
    AEMU_SCOPED_TRACE("vkCmdNextSubpass2");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo, true /* do lock */);
}
static void entry_vkCmdEndRenderPass2(
    VkCommandBuffer commandBuffer,
    const VkSubpassEndInfo* pSubpassEndInfo)
{
    AEMU_SCOPED_TRACE("vkCmdEndRenderPass2");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdEndRenderPass2(commandBuffer, pSubpassEndInfo, true /* do lock */);
}
static void entry_vkResetQueryPool(
    VkDevice device,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount)
{
    AEMU_SCOPED_TRACE("vkResetQueryPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkResetQueryPool(device, queryPool, firstQuery, queryCount, true /* do lock */);
}
static void dynCheck_entry_vkResetQueryPool(
    VkDevice device,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_2"))
    {
        sOnInvalidDynamicallyCheckedCall("vkResetQueryPool", "VK_VERSION_1_2");
    }
    AEMU_SCOPED_TRACE("vkResetQueryPool");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkResetQueryPool(device, queryPool, firstQuery, queryCount, true /* do lock */);
}
static VkResult entry_vkGetSemaphoreCounterValue(
    VkDevice device,
    VkSemaphore semaphore,
    uint64_t* pValue)
{
    AEMU_SCOPED_TRACE("vkGetSemaphoreCounterValue");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSemaphoreCounterValue_VkResult_return = (VkResult)0;
    vkGetSemaphoreCounterValue_VkResult_return = vkEnc->vkGetSemaphoreCounterValue(device, semaphore, pValue, true /* do lock */);
    return vkGetSemaphoreCounterValue_VkResult_return;
}
static VkResult dynCheck_entry_vkGetSemaphoreCounterValue(
    VkDevice device,
    VkSemaphore semaphore,
    uint64_t* pValue)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_2"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetSemaphoreCounterValue", "VK_VERSION_1_2");
    }
    AEMU_SCOPED_TRACE("vkGetSemaphoreCounterValue");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSemaphoreCounterValue_VkResult_return = (VkResult)0;
    vkGetSemaphoreCounterValue_VkResult_return = vkEnc->vkGetSemaphoreCounterValue(device, semaphore, pValue, true /* do lock */);
    return vkGetSemaphoreCounterValue_VkResult_return;
}
static VkResult entry_vkWaitSemaphores(
    VkDevice device,
    const VkSemaphoreWaitInfo* pWaitInfo,
    uint64_t timeout)
{
    AEMU_SCOPED_TRACE("vkWaitSemaphores");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkWaitSemaphores_VkResult_return = (VkResult)0;
    vkWaitSemaphores_VkResult_return = vkEnc->vkWaitSemaphores(device, pWaitInfo, timeout, true /* do lock */);
    return vkWaitSemaphores_VkResult_return;
}
static VkResult dynCheck_entry_vkWaitSemaphores(
    VkDevice device,
    const VkSemaphoreWaitInfo* pWaitInfo,
    uint64_t timeout)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_2"))
    {
        sOnInvalidDynamicallyCheckedCall("vkWaitSemaphores", "VK_VERSION_1_2");
    }
    AEMU_SCOPED_TRACE("vkWaitSemaphores");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkWaitSemaphores_VkResult_return = (VkResult)0;
    vkWaitSemaphores_VkResult_return = vkEnc->vkWaitSemaphores(device, pWaitInfo, timeout, true /* do lock */);
    return vkWaitSemaphores_VkResult_return;
}
static VkResult entry_vkSignalSemaphore(
    VkDevice device,
    const VkSemaphoreSignalInfo* pSignalInfo)
{
    AEMU_SCOPED_TRACE("vkSignalSemaphore");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkSignalSemaphore_VkResult_return = (VkResult)0;
    vkSignalSemaphore_VkResult_return = vkEnc->vkSignalSemaphore(device, pSignalInfo, true /* do lock */);
    return vkSignalSemaphore_VkResult_return;
}
static VkResult dynCheck_entry_vkSignalSemaphore(
    VkDevice device,
    const VkSemaphoreSignalInfo* pSignalInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_2"))
    {
        sOnInvalidDynamicallyCheckedCall("vkSignalSemaphore", "VK_VERSION_1_2");
    }
    AEMU_SCOPED_TRACE("vkSignalSemaphore");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkSignalSemaphore_VkResult_return = (VkResult)0;
    vkSignalSemaphore_VkResult_return = vkEnc->vkSignalSemaphore(device, pSignalInfo, true /* do lock */);
    return vkSignalSemaphore_VkResult_return;
}
static VkDeviceAddress entry_vkGetBufferDeviceAddress(
    VkDevice device,
    const VkBufferDeviceAddressInfo* pInfo)
{
    AEMU_SCOPED_TRACE("vkGetBufferDeviceAddress");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkDeviceAddress vkGetBufferDeviceAddress_VkDeviceAddress_return = (VkDeviceAddress)0;
    vkGetBufferDeviceAddress_VkDeviceAddress_return = vkEnc->vkGetBufferDeviceAddress(device, pInfo, true /* do lock */);
    return vkGetBufferDeviceAddress_VkDeviceAddress_return;
}
static VkDeviceAddress dynCheck_entry_vkGetBufferDeviceAddress(
    VkDevice device,
    const VkBufferDeviceAddressInfo* pInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_2"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetBufferDeviceAddress", "VK_VERSION_1_2");
    }
    AEMU_SCOPED_TRACE("vkGetBufferDeviceAddress");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkDeviceAddress vkGetBufferDeviceAddress_VkDeviceAddress_return = (VkDeviceAddress)0;
    vkGetBufferDeviceAddress_VkDeviceAddress_return = vkEnc->vkGetBufferDeviceAddress(device, pInfo, true /* do lock */);
    return vkGetBufferDeviceAddress_VkDeviceAddress_return;
}
static uint64_t entry_vkGetBufferOpaqueCaptureAddress(
    VkDevice device,
    const VkBufferDeviceAddressInfo* pInfo)
{
    AEMU_SCOPED_TRACE("vkGetBufferOpaqueCaptureAddress");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint64_t vkGetBufferOpaqueCaptureAddress_uint64_t_return = (uint64_t)0;
    vkGetBufferOpaqueCaptureAddress_uint64_t_return = vkEnc->vkGetBufferOpaqueCaptureAddress(device, pInfo, true /* do lock */);
    return vkGetBufferOpaqueCaptureAddress_uint64_t_return;
}
static uint64_t dynCheck_entry_vkGetBufferOpaqueCaptureAddress(
    VkDevice device,
    const VkBufferDeviceAddressInfo* pInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_2"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetBufferOpaqueCaptureAddress", "VK_VERSION_1_2");
    }
    AEMU_SCOPED_TRACE("vkGetBufferOpaqueCaptureAddress");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint64_t vkGetBufferOpaqueCaptureAddress_uint64_t_return = (uint64_t)0;
    vkGetBufferOpaqueCaptureAddress_uint64_t_return = vkEnc->vkGetBufferOpaqueCaptureAddress(device, pInfo, true /* do lock */);
    return vkGetBufferOpaqueCaptureAddress_uint64_t_return;
}
static uint64_t entry_vkGetDeviceMemoryOpaqueCaptureAddress(
    VkDevice device,
    const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo)
{
    AEMU_SCOPED_TRACE("vkGetDeviceMemoryOpaqueCaptureAddress");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint64_t vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return = (uint64_t)0;
    vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return = vkEnc->vkGetDeviceMemoryOpaqueCaptureAddress(device, pInfo, true /* do lock */);
    return vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return;
}
static uint64_t dynCheck_entry_vkGetDeviceMemoryOpaqueCaptureAddress(
    VkDevice device,
    const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_VERSION_1_2"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetDeviceMemoryOpaqueCaptureAddress", "VK_VERSION_1_2");
    }
    AEMU_SCOPED_TRACE("vkGetDeviceMemoryOpaqueCaptureAddress");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint64_t vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return = (uint64_t)0;
    vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return = vkEnc->vkGetDeviceMemoryOpaqueCaptureAddress(device, pInfo, true /* do lock */);
    return vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return;
}
#endif
#ifdef VK_KHR_surface
static void entry_vkDestroySurfaceKHR(
    VkInstance instance,
    VkSurfaceKHR surface,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroySurfaceKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroySurfaceKHR(instance, surface, pAllocator, true /* do lock */);
}
static VkResult entry_vkGetPhysicalDeviceSurfaceSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    VkSurfaceKHR surface,
    VkBool32* pSupported)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceSupportKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = vkEnc->vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported, true /* do lock */);
    return vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return;
}
static VkResult entry_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    VkSurfaceCapabilitiesKHR* pSurfaceCapabilities)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = vkEnc->vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities, true /* do lock */);
    return vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return;
}
static VkResult entry_vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pSurfaceFormatCount,
    VkSurfaceFormatKHR* pSurfaceFormats)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceFormatsKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = vkEnc->vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats, true /* do lock */);
    return vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return;
}
static VkResult entry_vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pPresentModeCount,
    VkPresentModeKHR* pPresentModes)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfacePresentModesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = vkEnc->vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes, true /* do lock */);
    return vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_swapchain
static VkResult entry_vkCreateSwapchainKHR(
    VkDevice device,
    const VkSwapchainCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSwapchainKHR* pSwapchain)
{
    AEMU_SCOPED_TRACE("vkCreateSwapchainKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateSwapchainKHR_VkResult_return = (VkResult)0;
    vkCreateSwapchainKHR_VkResult_return = vkEnc->vkCreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain, true /* do lock */);
    return vkCreateSwapchainKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateSwapchainKHR(
    VkDevice device,
    const VkSwapchainCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSwapchainKHR* pSwapchain)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_swapchain"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCreateSwapchainKHR", "VK_KHR_swapchain");
    }
    AEMU_SCOPED_TRACE("vkCreateSwapchainKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateSwapchainKHR_VkResult_return = (VkResult)0;
    vkCreateSwapchainKHR_VkResult_return = vkEnc->vkCreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain, true /* do lock */);
    return vkCreateSwapchainKHR_VkResult_return;
}
static void entry_vkDestroySwapchainKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroySwapchainKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroySwapchainKHR(device, swapchain, pAllocator, true /* do lock */);
}
static void dynCheck_entry_vkDestroySwapchainKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    const VkAllocationCallbacks* pAllocator)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_swapchain"))
    {
        sOnInvalidDynamicallyCheckedCall("vkDestroySwapchainKHR", "VK_KHR_swapchain");
    }
    AEMU_SCOPED_TRACE("vkDestroySwapchainKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroySwapchainKHR(device, swapchain, pAllocator, true /* do lock */);
}
static VkResult entry_vkGetSwapchainImagesKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t* pSwapchainImageCount,
    VkImage* pSwapchainImages)
{
    AEMU_SCOPED_TRACE("vkGetSwapchainImagesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSwapchainImagesKHR_VkResult_return = (VkResult)0;
    vkGetSwapchainImagesKHR_VkResult_return = vkEnc->vkGetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages, true /* do lock */);
    return vkGetSwapchainImagesKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetSwapchainImagesKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t* pSwapchainImageCount,
    VkImage* pSwapchainImages)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_swapchain"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetSwapchainImagesKHR", "VK_KHR_swapchain");
    }
    AEMU_SCOPED_TRACE("vkGetSwapchainImagesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSwapchainImagesKHR_VkResult_return = (VkResult)0;
    vkGetSwapchainImagesKHR_VkResult_return = vkEnc->vkGetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages, true /* do lock */);
    return vkGetSwapchainImagesKHR_VkResult_return;
}
static VkResult entry_vkAcquireNextImageKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint64_t timeout,
    VkSemaphore semaphore,
    VkFence fence,
    uint32_t* pImageIndex)
{
    AEMU_SCOPED_TRACE("vkAcquireNextImageKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAcquireNextImageKHR_VkResult_return = (VkResult)0;
    vkAcquireNextImageKHR_VkResult_return = vkEnc->vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex, true /* do lock */);
    return vkAcquireNextImageKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkAcquireNextImageKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint64_t timeout,
    VkSemaphore semaphore,
    VkFence fence,
    uint32_t* pImageIndex)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_swapchain"))
    {
        sOnInvalidDynamicallyCheckedCall("vkAcquireNextImageKHR", "VK_KHR_swapchain");
    }
    AEMU_SCOPED_TRACE("vkAcquireNextImageKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAcquireNextImageKHR_VkResult_return = (VkResult)0;
    vkAcquireNextImageKHR_VkResult_return = vkEnc->vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex, true /* do lock */);
    return vkAcquireNextImageKHR_VkResult_return;
}
static VkResult entry_vkQueuePresentKHR(
    VkQueue queue,
    const VkPresentInfoKHR* pPresentInfo)
{
    AEMU_SCOPED_TRACE("vkQueuePresentKHR");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    VkResult vkQueuePresentKHR_VkResult_return = (VkResult)0;
    vkQueuePresentKHR_VkResult_return = vkEnc->vkQueuePresentKHR(queue, pPresentInfo, true /* do lock */);
    return vkQueuePresentKHR_VkResult_return;
}
static VkResult entry_vkGetDeviceGroupPresentCapabilitiesKHR(
    VkDevice device,
    VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities)
{
    AEMU_SCOPED_TRACE("vkGetDeviceGroupPresentCapabilitiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = (VkResult)0;
    vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = vkEnc->vkGetDeviceGroupPresentCapabilitiesKHR(device, pDeviceGroupPresentCapabilities, true /* do lock */);
    return vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetDeviceGroupPresentCapabilitiesKHR(
    VkDevice device,
    VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_swapchain"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetDeviceGroupPresentCapabilitiesKHR", "VK_KHR_swapchain");
    }
    AEMU_SCOPED_TRACE("vkGetDeviceGroupPresentCapabilitiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = (VkResult)0;
    vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = vkEnc->vkGetDeviceGroupPresentCapabilitiesKHR(device, pDeviceGroupPresentCapabilities, true /* do lock */);
    return vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return;
}
static VkResult entry_vkGetDeviceGroupSurfacePresentModesKHR(
    VkDevice device,
    VkSurfaceKHR surface,
    VkDeviceGroupPresentModeFlagsKHR* pModes)
{
    AEMU_SCOPED_TRACE("vkGetDeviceGroupSurfacePresentModesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = (VkResult)0;
    vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = vkEnc->vkGetDeviceGroupSurfacePresentModesKHR(device, surface, pModes, true /* do lock */);
    return vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetDeviceGroupSurfacePresentModesKHR(
    VkDevice device,
    VkSurfaceKHR surface,
    VkDeviceGroupPresentModeFlagsKHR* pModes)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_swapchain"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetDeviceGroupSurfacePresentModesKHR", "VK_KHR_swapchain");
    }
    AEMU_SCOPED_TRACE("vkGetDeviceGroupSurfacePresentModesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = (VkResult)0;
    vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = vkEnc->vkGetDeviceGroupSurfacePresentModesKHR(device, surface, pModes, true /* do lock */);
    return vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return;
}
static VkResult entry_vkGetPhysicalDevicePresentRectanglesKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pRectCount,
    VkRect2D* pRects)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDevicePresentRectanglesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = (VkResult)0;
    vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = vkEnc->vkGetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects, true /* do lock */);
    return vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return;
}
static VkResult entry_vkAcquireNextImage2KHR(
    VkDevice device,
    const VkAcquireNextImageInfoKHR* pAcquireInfo,
    uint32_t* pImageIndex)
{
    AEMU_SCOPED_TRACE("vkAcquireNextImage2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAcquireNextImage2KHR_VkResult_return = (VkResult)0;
    vkAcquireNextImage2KHR_VkResult_return = vkEnc->vkAcquireNextImage2KHR(device, pAcquireInfo, pImageIndex, true /* do lock */);
    return vkAcquireNextImage2KHR_VkResult_return;
}
static VkResult dynCheck_entry_vkAcquireNextImage2KHR(
    VkDevice device,
    const VkAcquireNextImageInfoKHR* pAcquireInfo,
    uint32_t* pImageIndex)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_swapchain"))
    {
        sOnInvalidDynamicallyCheckedCall("vkAcquireNextImage2KHR", "VK_KHR_swapchain");
    }
    AEMU_SCOPED_TRACE("vkAcquireNextImage2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAcquireNextImage2KHR_VkResult_return = (VkResult)0;
    vkAcquireNextImage2KHR_VkResult_return = vkEnc->vkAcquireNextImage2KHR(device, pAcquireInfo, pImageIndex, true /* do lock */);
    return vkAcquireNextImage2KHR_VkResult_return;
}
#endif
#ifdef VK_KHR_display
static VkResult entry_vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPropertiesKHR* pProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceDisplayPropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = vkEnc->vkGetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties, true /* do lock */);
    return vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return;
}
static VkResult entry_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPlanePropertiesKHR* pProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceDisplayPlanePropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = vkEnc->vkGetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties, true /* do lock */);
    return vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return;
}
static VkResult entry_vkGetDisplayPlaneSupportedDisplaysKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t planeIndex,
    uint32_t* pDisplayCount,
    VkDisplayKHR* pDisplays)
{
    AEMU_SCOPED_TRACE("vkGetDisplayPlaneSupportedDisplaysKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = (VkResult)0;
    vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = vkEnc->vkGetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays, true /* do lock */);
    return vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return;
}
static VkResult entry_vkGetDisplayModePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    uint32_t* pPropertyCount,
    VkDisplayModePropertiesKHR* pProperties)
{
    AEMU_SCOPED_TRACE("vkGetDisplayModePropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetDisplayModePropertiesKHR_VkResult_return = (VkResult)0;
    vkGetDisplayModePropertiesKHR_VkResult_return = vkEnc->vkGetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties, true /* do lock */);
    return vkGetDisplayModePropertiesKHR_VkResult_return;
}
static VkResult entry_vkCreateDisplayModeKHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    const VkDisplayModeCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDisplayModeKHR* pMode)
{
    AEMU_SCOPED_TRACE("vkCreateDisplayModeKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDisplayModeKHR_VkResult_return = (VkResult)0;
    vkCreateDisplayModeKHR_VkResult_return = vkEnc->vkCreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode, true /* do lock */);
    return vkCreateDisplayModeKHR_VkResult_return;
}
static VkResult entry_vkGetDisplayPlaneCapabilitiesKHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayModeKHR mode,
    uint32_t planeIndex,
    VkDisplayPlaneCapabilitiesKHR* pCapabilities)
{
    AEMU_SCOPED_TRACE("vkGetDisplayPlaneCapabilitiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = (VkResult)0;
    vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = vkEnc->vkGetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities, true /* do lock */);
    return vkGetDisplayPlaneCapabilitiesKHR_VkResult_return;
}
static VkResult entry_vkCreateDisplayPlaneSurfaceKHR(
    VkInstance instance,
    const VkDisplaySurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AEMU_SCOPED_TRACE("vkCreateDisplayPlaneSurfaceKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDisplayPlaneSurfaceKHR_VkResult_return = (VkResult)0;
    vkCreateDisplayPlaneSurfaceKHR_VkResult_return = vkEnc->vkCreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, true /* do lock */);
    return vkCreateDisplayPlaneSurfaceKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_display_swapchain
static VkResult entry_vkCreateSharedSwapchainsKHR(
    VkDevice device,
    uint32_t swapchainCount,
    const VkSwapchainCreateInfoKHR* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkSwapchainKHR* pSwapchains)
{
    AEMU_SCOPED_TRACE("vkCreateSharedSwapchainsKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateSharedSwapchainsKHR_VkResult_return = (VkResult)0;
    vkCreateSharedSwapchainsKHR_VkResult_return = vkEnc->vkCreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains, true /* do lock */);
    return vkCreateSharedSwapchainsKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateSharedSwapchainsKHR(
    VkDevice device,
    uint32_t swapchainCount,
    const VkSwapchainCreateInfoKHR* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkSwapchainKHR* pSwapchains)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_display_swapchain"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCreateSharedSwapchainsKHR", "VK_KHR_display_swapchain");
    }
    AEMU_SCOPED_TRACE("vkCreateSharedSwapchainsKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateSharedSwapchainsKHR_VkResult_return = (VkResult)0;
    vkCreateSharedSwapchainsKHR_VkResult_return = vkEnc->vkCreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains, true /* do lock */);
    return vkCreateSharedSwapchainsKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_xlib_surface
static VkResult entry_vkCreateXlibSurfaceKHR(
    VkInstance instance,
    const VkXlibSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AEMU_SCOPED_TRACE("vkCreateXlibSurfaceKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateXlibSurfaceKHR_VkResult_return = (VkResult)0;
    vkCreateXlibSurfaceKHR_VkResult_return = vkEnc->vkCreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, true /* do lock */);
    return vkCreateXlibSurfaceKHR_VkResult_return;
}
static VkBool32 entry_vkGetPhysicalDeviceXlibPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    Display* dpy,
    VisualID visualID)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceXlibPresentationSupportKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = vkEnc->vkGetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID, true /* do lock */);
    return vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return;
}
#endif
#ifdef VK_KHR_xcb_surface
static VkResult entry_vkCreateXcbSurfaceKHR(
    VkInstance instance,
    const VkXcbSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AEMU_SCOPED_TRACE("vkCreateXcbSurfaceKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateXcbSurfaceKHR_VkResult_return = (VkResult)0;
    vkCreateXcbSurfaceKHR_VkResult_return = vkEnc->vkCreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, true /* do lock */);
    return vkCreateXcbSurfaceKHR_VkResult_return;
}
static VkBool32 entry_vkGetPhysicalDeviceXcbPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    xcb_connection_t* connection,
    xcb_visualid_t visual_id)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceXcbPresentationSupportKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return = vkEnc->vkGetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id, true /* do lock */);
    return vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return;
}
#endif
#ifdef VK_KHR_wayland_surface
static VkResult entry_vkCreateWaylandSurfaceKHR(
    VkInstance instance,
    const VkWaylandSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AEMU_SCOPED_TRACE("vkCreateWaylandSurfaceKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateWaylandSurfaceKHR_VkResult_return = (VkResult)0;
    vkCreateWaylandSurfaceKHR_VkResult_return = vkEnc->vkCreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, true /* do lock */);
    return vkCreateWaylandSurfaceKHR_VkResult_return;
}
static VkBool32 entry_vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    wl_display* display)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceWaylandPresentationSupportKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkBool32 vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = vkEnc->vkGetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display, true /* do lock */);
    return vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return;
}
#endif
#ifdef VK_KHR_android_surface
static VkResult entry_vkCreateAndroidSurfaceKHR(
    VkInstance instance,
    const VkAndroidSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AEMU_SCOPED_TRACE("vkCreateAndroidSurfaceKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateAndroidSurfaceKHR_VkResult_return = (VkResult)0;
    vkCreateAndroidSurfaceKHR_VkResult_return = vkEnc->vkCreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, true /* do lock */);
    return vkCreateAndroidSurfaceKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_win32_surface
static VkResult entry_vkCreateWin32SurfaceKHR(
    VkInstance instance,
    const VkWin32SurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AEMU_SCOPED_TRACE("vkCreateWin32SurfaceKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateWin32SurfaceKHR_VkResult_return = (VkResult)0;
    vkCreateWin32SurfaceKHR_VkResult_return = vkEnc->vkCreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, true /* do lock */);
    return vkCreateWin32SurfaceKHR_VkResult_return;
}
static VkBool32 entry_vkGetPhysicalDeviceWin32PresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceWin32PresentationSupportKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkBool32 vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = (VkBool32)0;
    vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = vkEnc->vkGetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex, true /* do lock */);
    return vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return;
}
#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
static void entry_vkGetPhysicalDeviceFeatures2KHR(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures2* pFeatures)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFeatures2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties2* pProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceProperties2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceProperties2KHR(physicalDevice, pProperties, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties2* pFormatProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFormatProperties2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties, true /* do lock */);
}
static VkResult entry_vkGetPhysicalDeviceImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceImageFormatProperties2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = resources->on_vkGetPhysicalDeviceImageFormatProperties2KHR(vkEnc, VK_SUCCESS, physicalDevice, pImageFormatInfo, pImageFormatProperties);
    return vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return;
}
static void entry_vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyProperties2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceMemoryProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMemoryProperties2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSparseImageFormatProperties2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties, true /* do lock */);
}
#endif
#ifdef VK_KHR_device_group
static void entry_vkGetDeviceGroupPeerMemoryFeaturesKHR(
    VkDevice device,
    uint32_t heapIndex,
    uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{
    AEMU_SCOPED_TRACE("vkGetDeviceGroupPeerMemoryFeaturesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures, true /* do lock */);
}
static void dynCheck_entry_vkGetDeviceGroupPeerMemoryFeaturesKHR(
    VkDevice device,
    uint32_t heapIndex,
    uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_device_group"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetDeviceGroupPeerMemoryFeaturesKHR", "VK_KHR_device_group");
    }
    AEMU_SCOPED_TRACE("vkGetDeviceGroupPeerMemoryFeaturesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures, true /* do lock */);
}
static void entry_vkCmdSetDeviceMaskKHR(
    VkCommandBuffer commandBuffer,
    uint32_t deviceMask)
{
    AEMU_SCOPED_TRACE("vkCmdSetDeviceMaskKHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetDeviceMaskKHR(commandBuffer, deviceMask, true /* do lock */);
}
static void entry_vkCmdDispatchBaseKHR(
    VkCommandBuffer commandBuffer,
    uint32_t baseGroupX,
    uint32_t baseGroupY,
    uint32_t baseGroupZ,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ)
{
    AEMU_SCOPED_TRACE("vkCmdDispatchBaseKHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ, true /* do lock */);
}
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
static void entry_vkTrimCommandPoolKHR(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolTrimFlags flags)
{
    AEMU_SCOPED_TRACE("vkTrimCommandPoolKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkTrimCommandPoolKHR(device, commandPool, flags, true /* do lock */);
}
static void dynCheck_entry_vkTrimCommandPoolKHR(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolTrimFlags flags)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_maintenance1"))
    {
        sOnInvalidDynamicallyCheckedCall("vkTrimCommandPoolKHR", "VK_KHR_maintenance1");
    }
    AEMU_SCOPED_TRACE("vkTrimCommandPoolKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkTrimCommandPoolKHR(device, commandPool, flags, true /* do lock */);
}
#endif
#ifdef VK_KHR_device_group_creation
static VkResult entry_vkEnumeratePhysicalDeviceGroupsKHR(
    VkInstance instance,
    uint32_t* pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties)
{
    AEMU_SCOPED_TRACE("vkEnumeratePhysicalDeviceGroupsKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = (VkResult)0;
    vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = vkEnc->vkEnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties, true /* do lock */);
    return vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_external_memory_capabilities
static void entry_vkGetPhysicalDeviceExternalBufferPropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalBufferPropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, pExternalBufferProperties, true /* do lock */);
}
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
static VkResult entry_vkGetMemoryWin32HandleKHR(
    VkDevice device,
    const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    AEMU_SCOPED_TRACE("vkGetMemoryWin32HandleKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryWin32HandleKHR_VkResult_return = (VkResult)0;
    vkGetMemoryWin32HandleKHR_VkResult_return = vkEnc->vkGetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle, true /* do lock */);
    return vkGetMemoryWin32HandleKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetMemoryWin32HandleKHR(
    VkDevice device,
    const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_external_memory_win32"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetMemoryWin32HandleKHR", "VK_KHR_external_memory_win32");
    }
    AEMU_SCOPED_TRACE("vkGetMemoryWin32HandleKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryWin32HandleKHR_VkResult_return = (VkResult)0;
    vkGetMemoryWin32HandleKHR_VkResult_return = vkEnc->vkGetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle, true /* do lock */);
    return vkGetMemoryWin32HandleKHR_VkResult_return;
}
static VkResult entry_vkGetMemoryWin32HandlePropertiesKHR(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    HANDLE handle,
    VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties)
{
    AEMU_SCOPED_TRACE("vkGetMemoryWin32HandlePropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = (VkResult)0;
    vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = vkEnc->vkGetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties, true /* do lock */);
    return vkGetMemoryWin32HandlePropertiesKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetMemoryWin32HandlePropertiesKHR(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    HANDLE handle,
    VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_external_memory_win32"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetMemoryWin32HandlePropertiesKHR", "VK_KHR_external_memory_win32");
    }
    AEMU_SCOPED_TRACE("vkGetMemoryWin32HandlePropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = (VkResult)0;
    vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = vkEnc->vkGetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties, true /* do lock */);
    return vkGetMemoryWin32HandlePropertiesKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_external_memory_fd
static VkResult entry_vkGetMemoryFdKHR(
    VkDevice device,
    const VkMemoryGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    AEMU_SCOPED_TRACE("vkGetMemoryFdKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryFdKHR_VkResult_return = (VkResult)0;
    vkGetMemoryFdKHR_VkResult_return = vkEnc->vkGetMemoryFdKHR(device, pGetFdInfo, pFd, true /* do lock */);
    return vkGetMemoryFdKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetMemoryFdKHR(
    VkDevice device,
    const VkMemoryGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_external_memory_fd"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetMemoryFdKHR", "VK_KHR_external_memory_fd");
    }
    AEMU_SCOPED_TRACE("vkGetMemoryFdKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryFdKHR_VkResult_return = (VkResult)0;
    vkGetMemoryFdKHR_VkResult_return = vkEnc->vkGetMemoryFdKHR(device, pGetFdInfo, pFd, true /* do lock */);
    return vkGetMemoryFdKHR_VkResult_return;
}
static VkResult entry_vkGetMemoryFdPropertiesKHR(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    int fd,
    VkMemoryFdPropertiesKHR* pMemoryFdProperties)
{
    AEMU_SCOPED_TRACE("vkGetMemoryFdPropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryFdPropertiesKHR_VkResult_return = (VkResult)0;
    vkGetMemoryFdPropertiesKHR_VkResult_return = vkEnc->vkGetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties, true /* do lock */);
    return vkGetMemoryFdPropertiesKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetMemoryFdPropertiesKHR(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    int fd,
    VkMemoryFdPropertiesKHR* pMemoryFdProperties)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_external_memory_fd"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetMemoryFdPropertiesKHR", "VK_KHR_external_memory_fd");
    }
    AEMU_SCOPED_TRACE("vkGetMemoryFdPropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryFdPropertiesKHR_VkResult_return = (VkResult)0;
    vkGetMemoryFdPropertiesKHR_VkResult_return = vkEnc->vkGetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties, true /* do lock */);
    return vkGetMemoryFdPropertiesKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_win32_keyed_mutex
#endif
#ifdef VK_KHR_external_semaphore_capabilities
static void entry_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalSemaphorePropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties, true /* do lock */);
}
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
static VkResult entry_vkImportSemaphoreWin32HandleKHR(
    VkDevice device,
    const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo)
{
    AEMU_SCOPED_TRACE("vkImportSemaphoreWin32HandleKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkImportSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
    vkImportSemaphoreWin32HandleKHR_VkResult_return = vkEnc->vkImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo, true /* do lock */);
    return vkImportSemaphoreWin32HandleKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkImportSemaphoreWin32HandleKHR(
    VkDevice device,
    const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_external_semaphore_win32"))
    {
        sOnInvalidDynamicallyCheckedCall("vkImportSemaphoreWin32HandleKHR", "VK_KHR_external_semaphore_win32");
    }
    AEMU_SCOPED_TRACE("vkImportSemaphoreWin32HandleKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkImportSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
    vkImportSemaphoreWin32HandleKHR_VkResult_return = vkEnc->vkImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo, true /* do lock */);
    return vkImportSemaphoreWin32HandleKHR_VkResult_return;
}
static VkResult entry_vkGetSemaphoreWin32HandleKHR(
    VkDevice device,
    const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    AEMU_SCOPED_TRACE("vkGetSemaphoreWin32HandleKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
    vkGetSemaphoreWin32HandleKHR_VkResult_return = vkEnc->vkGetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle, true /* do lock */);
    return vkGetSemaphoreWin32HandleKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetSemaphoreWin32HandleKHR(
    VkDevice device,
    const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_external_semaphore_win32"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetSemaphoreWin32HandleKHR", "VK_KHR_external_semaphore_win32");
    }
    AEMU_SCOPED_TRACE("vkGetSemaphoreWin32HandleKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
    vkGetSemaphoreWin32HandleKHR_VkResult_return = vkEnc->vkGetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle, true /* do lock */);
    return vkGetSemaphoreWin32HandleKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_external_semaphore_fd
static VkResult entry_vkImportSemaphoreFdKHR(
    VkDevice device,
    const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo)
{
    AEMU_SCOPED_TRACE("vkImportSemaphoreFdKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkImportSemaphoreFdKHR_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkImportSemaphoreFdKHR_VkResult_return = resources->on_vkImportSemaphoreFdKHR(vkEnc, VK_SUCCESS, device, pImportSemaphoreFdInfo);
    return vkImportSemaphoreFdKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkImportSemaphoreFdKHR(
    VkDevice device,
    const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_external_semaphore_fd"))
    {
        sOnInvalidDynamicallyCheckedCall("vkImportSemaphoreFdKHR", "VK_KHR_external_semaphore_fd");
    }
    AEMU_SCOPED_TRACE("vkImportSemaphoreFdKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkImportSemaphoreFdKHR_VkResult_return = (VkResult)0;
    vkImportSemaphoreFdKHR_VkResult_return = resources->on_vkImportSemaphoreFdKHR(vkEnc, VK_SUCCESS, device, pImportSemaphoreFdInfo);
    return vkImportSemaphoreFdKHR_VkResult_return;
}
static VkResult entry_vkGetSemaphoreFdKHR(
    VkDevice device,
    const VkSemaphoreGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    AEMU_SCOPED_TRACE("vkGetSemaphoreFdKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSemaphoreFdKHR_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkGetSemaphoreFdKHR_VkResult_return = resources->on_vkGetSemaphoreFdKHR(vkEnc, VK_SUCCESS, device, pGetFdInfo, pFd);
    return vkGetSemaphoreFdKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetSemaphoreFdKHR(
    VkDevice device,
    const VkSemaphoreGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_external_semaphore_fd"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetSemaphoreFdKHR", "VK_KHR_external_semaphore_fd");
    }
    AEMU_SCOPED_TRACE("vkGetSemaphoreFdKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSemaphoreFdKHR_VkResult_return = (VkResult)0;
    vkGetSemaphoreFdKHR_VkResult_return = resources->on_vkGetSemaphoreFdKHR(vkEnc, VK_SUCCESS, device, pGetFdInfo, pFd);
    return vkGetSemaphoreFdKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_push_descriptor
static void entry_vkCmdPushDescriptorSetKHR(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipelineLayout layout,
    uint32_t set,
    uint32_t descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites)
{
    AEMU_SCOPED_TRACE("vkCmdPushDescriptorSetKHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites, true /* do lock */);
}
static void entry_vkCmdPushDescriptorSetWithTemplateKHR(
    VkCommandBuffer commandBuffer,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    VkPipelineLayout layout,
    uint32_t set,
    const void* pData)
{
    AEMU_SCOPED_TRACE("vkCmdPushDescriptorSetWithTemplateKHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData, true /* do lock */);
}
#endif
#ifdef VK_KHR_shader_float16_int8
#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
#endif
#ifdef VK_KHR_descriptor_update_template
static VkResult entry_vkCreateDescriptorUpdateTemplateKHR(
    VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{
    AEMU_SCOPED_TRACE("vkCreateDescriptorUpdateTemplateKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDescriptorUpdateTemplateKHR_VkResult_return = (VkResult)0;
    vkCreateDescriptorUpdateTemplateKHR_VkResult_return = vkEnc->vkCreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate, true /* do lock */);
    return vkCreateDescriptorUpdateTemplateKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateDescriptorUpdateTemplateKHR(
    VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_descriptor_update_template"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCreateDescriptorUpdateTemplateKHR", "VK_KHR_descriptor_update_template");
    }
    AEMU_SCOPED_TRACE("vkCreateDescriptorUpdateTemplateKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDescriptorUpdateTemplateKHR_VkResult_return = (VkResult)0;
    vkCreateDescriptorUpdateTemplateKHR_VkResult_return = vkEnc->vkCreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate, true /* do lock */);
    return vkCreateDescriptorUpdateTemplateKHR_VkResult_return;
}
static void entry_vkDestroyDescriptorUpdateTemplateKHR(
    VkDevice device,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyDescriptorUpdateTemplateKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator, true /* do lock */);
}
static void dynCheck_entry_vkDestroyDescriptorUpdateTemplateKHR(
    VkDevice device,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_descriptor_update_template"))
    {
        sOnInvalidDynamicallyCheckedCall("vkDestroyDescriptorUpdateTemplateKHR", "VK_KHR_descriptor_update_template");
    }
    AEMU_SCOPED_TRACE("vkDestroyDescriptorUpdateTemplateKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator, true /* do lock */);
}
static void entry_vkUpdateDescriptorSetWithTemplateKHR(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const void* pData)
{
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplateKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkUpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData, true /* do lock */);
}
static void dynCheck_entry_vkUpdateDescriptorSetWithTemplateKHR(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const void* pData)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_descriptor_update_template"))
    {
        sOnInvalidDynamicallyCheckedCall("vkUpdateDescriptorSetWithTemplateKHR", "VK_KHR_descriptor_update_template");
    }
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplateKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkUpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData, true /* do lock */);
}
#endif
#ifdef VK_KHR_imageless_framebuffer
#endif
#ifdef VK_KHR_create_renderpass2
static VkResult entry_vkCreateRenderPass2KHR(
    VkDevice device,
    const VkRenderPassCreateInfo2* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass)
{
    AEMU_SCOPED_TRACE("vkCreateRenderPass2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateRenderPass2KHR_VkResult_return = (VkResult)0;
    vkCreateRenderPass2KHR_VkResult_return = vkEnc->vkCreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass, true /* do lock */);
    return vkCreateRenderPass2KHR_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateRenderPass2KHR(
    VkDevice device,
    const VkRenderPassCreateInfo2* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_create_renderpass2"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCreateRenderPass2KHR", "VK_KHR_create_renderpass2");
    }
    AEMU_SCOPED_TRACE("vkCreateRenderPass2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateRenderPass2KHR_VkResult_return = (VkResult)0;
    vkCreateRenderPass2KHR_VkResult_return = vkEnc->vkCreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass, true /* do lock */);
    return vkCreateRenderPass2KHR_VkResult_return;
}
static void entry_vkCmdBeginRenderPass2KHR(
    VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    const VkSubpassBeginInfo* pSubpassBeginInfo)
{
    AEMU_SCOPED_TRACE("vkCmdBeginRenderPass2KHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo, true /* do lock */);
}
static void entry_vkCmdNextSubpass2KHR(
    VkCommandBuffer commandBuffer,
    const VkSubpassBeginInfo* pSubpassBeginInfo,
    const VkSubpassEndInfo* pSubpassEndInfo)
{
    AEMU_SCOPED_TRACE("vkCmdNextSubpass2KHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo, true /* do lock */);
}
static void entry_vkCmdEndRenderPass2KHR(
    VkCommandBuffer commandBuffer,
    const VkSubpassEndInfo* pSubpassEndInfo)
{
    AEMU_SCOPED_TRACE("vkCmdEndRenderPass2KHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo, true /* do lock */);
}
#endif
#ifdef VK_KHR_shared_presentable_image
static VkResult entry_vkGetSwapchainStatusKHR(
    VkDevice device,
    VkSwapchainKHR swapchain)
{
    AEMU_SCOPED_TRACE("vkGetSwapchainStatusKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSwapchainStatusKHR_VkResult_return = (VkResult)0;
    vkGetSwapchainStatusKHR_VkResult_return = vkEnc->vkGetSwapchainStatusKHR(device, swapchain, true /* do lock */);
    return vkGetSwapchainStatusKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetSwapchainStatusKHR(
    VkDevice device,
    VkSwapchainKHR swapchain)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_shared_presentable_image"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetSwapchainStatusKHR", "VK_KHR_shared_presentable_image");
    }
    AEMU_SCOPED_TRACE("vkGetSwapchainStatusKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSwapchainStatusKHR_VkResult_return = (VkResult)0;
    vkGetSwapchainStatusKHR_VkResult_return = vkEnc->vkGetSwapchainStatusKHR(device, swapchain, true /* do lock */);
    return vkGetSwapchainStatusKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_external_fence_capabilities
static void entry_vkGetPhysicalDeviceExternalFencePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalFencePropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkGetPhysicalDeviceExternalFencePropertiesKHR(vkEnc, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
}
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
static VkResult entry_vkImportFenceWin32HandleKHR(
    VkDevice device,
    const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo)
{
    AEMU_SCOPED_TRACE("vkImportFenceWin32HandleKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkImportFenceWin32HandleKHR_VkResult_return = (VkResult)0;
    vkImportFenceWin32HandleKHR_VkResult_return = vkEnc->vkImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo, true /* do lock */);
    return vkImportFenceWin32HandleKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkImportFenceWin32HandleKHR(
    VkDevice device,
    const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_external_fence_win32"))
    {
        sOnInvalidDynamicallyCheckedCall("vkImportFenceWin32HandleKHR", "VK_KHR_external_fence_win32");
    }
    AEMU_SCOPED_TRACE("vkImportFenceWin32HandleKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkImportFenceWin32HandleKHR_VkResult_return = (VkResult)0;
    vkImportFenceWin32HandleKHR_VkResult_return = vkEnc->vkImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo, true /* do lock */);
    return vkImportFenceWin32HandleKHR_VkResult_return;
}
static VkResult entry_vkGetFenceWin32HandleKHR(
    VkDevice device,
    const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    AEMU_SCOPED_TRACE("vkGetFenceWin32HandleKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetFenceWin32HandleKHR_VkResult_return = (VkResult)0;
    vkGetFenceWin32HandleKHR_VkResult_return = vkEnc->vkGetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle, true /* do lock */);
    return vkGetFenceWin32HandleKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetFenceWin32HandleKHR(
    VkDevice device,
    const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_external_fence_win32"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetFenceWin32HandleKHR", "VK_KHR_external_fence_win32");
    }
    AEMU_SCOPED_TRACE("vkGetFenceWin32HandleKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetFenceWin32HandleKHR_VkResult_return = (VkResult)0;
    vkGetFenceWin32HandleKHR_VkResult_return = vkEnc->vkGetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle, true /* do lock */);
    return vkGetFenceWin32HandleKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_external_fence_fd
static VkResult entry_vkImportFenceFdKHR(
    VkDevice device,
    const VkImportFenceFdInfoKHR* pImportFenceFdInfo)
{
    AEMU_SCOPED_TRACE("vkImportFenceFdKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkImportFenceFdKHR_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkImportFenceFdKHR_VkResult_return = resources->on_vkImportFenceFdKHR(vkEnc, VK_SUCCESS, device, pImportFenceFdInfo);
    return vkImportFenceFdKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkImportFenceFdKHR(
    VkDevice device,
    const VkImportFenceFdInfoKHR* pImportFenceFdInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_external_fence_fd"))
    {
        sOnInvalidDynamicallyCheckedCall("vkImportFenceFdKHR", "VK_KHR_external_fence_fd");
    }
    AEMU_SCOPED_TRACE("vkImportFenceFdKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkImportFenceFdKHR_VkResult_return = (VkResult)0;
    vkImportFenceFdKHR_VkResult_return = resources->on_vkImportFenceFdKHR(vkEnc, VK_SUCCESS, device, pImportFenceFdInfo);
    return vkImportFenceFdKHR_VkResult_return;
}
static VkResult entry_vkGetFenceFdKHR(
    VkDevice device,
    const VkFenceGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    AEMU_SCOPED_TRACE("vkGetFenceFdKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetFenceFdKHR_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkGetFenceFdKHR_VkResult_return = resources->on_vkGetFenceFdKHR(vkEnc, VK_SUCCESS, device, pGetFdInfo, pFd);
    return vkGetFenceFdKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetFenceFdKHR(
    VkDevice device,
    const VkFenceGetFdInfoKHR* pGetFdInfo,
    int* pFd)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_external_fence_fd"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetFenceFdKHR", "VK_KHR_external_fence_fd");
    }
    AEMU_SCOPED_TRACE("vkGetFenceFdKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetFenceFdKHR_VkResult_return = (VkResult)0;
    vkGetFenceFdKHR_VkResult_return = resources->on_vkGetFenceFdKHR(vkEnc, VK_SUCCESS, device, pGetFdInfo, pFd);
    return vkGetFenceFdKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_performance_query
static VkResult entry_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    uint32_t* pCounterCount,
    VkPerformanceCounterKHR* pCounters,
    VkPerformanceCounterDescriptionKHR* pCounterDescriptions)
{
    AEMU_SCOPED_TRACE("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR_VkResult_return = (VkResult)0;
    vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR_VkResult_return = vkEnc->vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions, true /* do lock */);
    return vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR_VkResult_return;
}
static void entry_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(
    VkPhysicalDevice physicalDevice,
    const VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo,
    uint32_t* pNumPasses)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses, true /* do lock */);
}
static VkResult entry_vkAcquireProfilingLockKHR(
    VkDevice device,
    const VkAcquireProfilingLockInfoKHR* pInfo)
{
    AEMU_SCOPED_TRACE("vkAcquireProfilingLockKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAcquireProfilingLockKHR_VkResult_return = (VkResult)0;
    vkAcquireProfilingLockKHR_VkResult_return = vkEnc->vkAcquireProfilingLockKHR(device, pInfo, true /* do lock */);
    return vkAcquireProfilingLockKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkAcquireProfilingLockKHR(
    VkDevice device,
    const VkAcquireProfilingLockInfoKHR* pInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_performance_query"))
    {
        sOnInvalidDynamicallyCheckedCall("vkAcquireProfilingLockKHR", "VK_KHR_performance_query");
    }
    AEMU_SCOPED_TRACE("vkAcquireProfilingLockKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAcquireProfilingLockKHR_VkResult_return = (VkResult)0;
    vkAcquireProfilingLockKHR_VkResult_return = vkEnc->vkAcquireProfilingLockKHR(device, pInfo, true /* do lock */);
    return vkAcquireProfilingLockKHR_VkResult_return;
}
static void entry_vkReleaseProfilingLockKHR(
    VkDevice device)
{
    AEMU_SCOPED_TRACE("vkReleaseProfilingLockKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkReleaseProfilingLockKHR(device, true /* do lock */);
}
static void dynCheck_entry_vkReleaseProfilingLockKHR(
    VkDevice device)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_performance_query"))
    {
        sOnInvalidDynamicallyCheckedCall("vkReleaseProfilingLockKHR", "VK_KHR_performance_query");
    }
    AEMU_SCOPED_TRACE("vkReleaseProfilingLockKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkReleaseProfilingLockKHR(device, true /* do lock */);
}
#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
static VkResult entry_vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    VkSurfaceCapabilities2KHR* pSurfaceCapabilities)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceCapabilities2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = vkEnc->vkGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities, true /* do lock */);
    return vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return;
}
static VkResult entry_vkGetPhysicalDeviceSurfaceFormats2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    uint32_t* pSurfaceFormatCount,
    VkSurfaceFormat2KHR* pSurfaceFormats)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceFormats2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = vkEnc->vkGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats, true /* do lock */);
    return vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return;
}
#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
static VkResult entry_vkGetPhysicalDeviceDisplayProperties2KHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayProperties2KHR* pProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceDisplayProperties2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = vkEnc->vkGetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties, true /* do lock */);
    return vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return;
}
static VkResult entry_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPlaneProperties2KHR* pProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceDisplayPlaneProperties2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = vkEnc->vkGetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties, true /* do lock */);
    return vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return;
}
static VkResult entry_vkGetDisplayModeProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    uint32_t* pPropertyCount,
    VkDisplayModeProperties2KHR* pProperties)
{
    AEMU_SCOPED_TRACE("vkGetDisplayModeProperties2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetDisplayModeProperties2KHR_VkResult_return = (VkResult)0;
    vkGetDisplayModeProperties2KHR_VkResult_return = vkEnc->vkGetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties, true /* do lock */);
    return vkGetDisplayModeProperties2KHR_VkResult_return;
}
static VkResult entry_vkGetDisplayPlaneCapabilities2KHR(
    VkPhysicalDevice physicalDevice,
    const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo,
    VkDisplayPlaneCapabilities2KHR* pCapabilities)
{
    AEMU_SCOPED_TRACE("vkGetDisplayPlaneCapabilities2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetDisplayPlaneCapabilities2KHR_VkResult_return = (VkResult)0;
    vkGetDisplayPlaneCapabilities2KHR_VkResult_return = vkEnc->vkGetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, pCapabilities, true /* do lock */);
    return vkGetDisplayPlaneCapabilities2KHR_VkResult_return;
}
#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
static void entry_vkGetImageMemoryRequirements2KHR(
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkGetImageMemoryRequirements2KHR(vkEnc, device, pInfo, pMemoryRequirements);
}
static void dynCheck_entry_vkGetImageMemoryRequirements2KHR(
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_get_memory_requirements2"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetImageMemoryRequirements2KHR", "VK_KHR_get_memory_requirements2");
    }
    AEMU_SCOPED_TRACE("vkGetImageMemoryRequirements2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    resources->on_vkGetImageMemoryRequirements2KHR(vkEnc, device, pInfo, pMemoryRequirements);
}
static void entry_vkGetBufferMemoryRequirements2KHR(
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkGetBufferMemoryRequirements2KHR(vkEnc, device, pInfo, pMemoryRequirements);
}
static void dynCheck_entry_vkGetBufferMemoryRequirements2KHR(
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_get_memory_requirements2"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetBufferMemoryRequirements2KHR", "VK_KHR_get_memory_requirements2");
    }
    AEMU_SCOPED_TRACE("vkGetBufferMemoryRequirements2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    resources->on_vkGetBufferMemoryRequirements2KHR(vkEnc, device, pInfo, pMemoryRequirements);
}
static void entry_vkGetImageSparseMemoryRequirements2KHR(
    VkDevice device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements, true /* do lock */);
}
static void dynCheck_entry_vkGetImageSparseMemoryRequirements2KHR(
    VkDevice device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_get_memory_requirements2"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetImageSparseMemoryRequirements2KHR", "VK_KHR_get_memory_requirements2");
    }
    AEMU_SCOPED_TRACE("vkGetImageSparseMemoryRequirements2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements, true /* do lock */);
}
#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
static VkResult entry_vkCreateSamplerYcbcrConversionKHR(
    VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion)
{
    AEMU_SCOPED_TRACE("vkCreateSamplerYcbcrConversionKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateSamplerYcbcrConversionKHR_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkCreateSamplerYcbcrConversionKHR_VkResult_return = resources->on_vkCreateSamplerYcbcrConversionKHR(vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pYcbcrConversion);
    return vkCreateSamplerYcbcrConversionKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateSamplerYcbcrConversionKHR(
    VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_sampler_ycbcr_conversion"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCreateSamplerYcbcrConversionKHR", "VK_KHR_sampler_ycbcr_conversion");
    }
    AEMU_SCOPED_TRACE("vkCreateSamplerYcbcrConversionKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateSamplerYcbcrConversionKHR_VkResult_return = (VkResult)0;
    vkCreateSamplerYcbcrConversionKHR_VkResult_return = resources->on_vkCreateSamplerYcbcrConversionKHR(vkEnc, VK_SUCCESS, device, pCreateInfo, pAllocator, pYcbcrConversion);
    return vkCreateSamplerYcbcrConversionKHR_VkResult_return;
}
static void entry_vkDestroySamplerYcbcrConversionKHR(
    VkDevice device,
    VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroySamplerYcbcrConversionKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    auto resources = ResourceTracker::get();
    resources->on_vkDestroySamplerYcbcrConversionKHR(vkEnc, device, ycbcrConversion, pAllocator);
}
static void dynCheck_entry_vkDestroySamplerYcbcrConversionKHR(
    VkDevice device,
    VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_sampler_ycbcr_conversion"))
    {
        sOnInvalidDynamicallyCheckedCall("vkDestroySamplerYcbcrConversionKHR", "VK_KHR_sampler_ycbcr_conversion");
    }
    AEMU_SCOPED_TRACE("vkDestroySamplerYcbcrConversionKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    resources->on_vkDestroySamplerYcbcrConversionKHR(vkEnc, device, ycbcrConversion, pAllocator);
}
#endif
#ifdef VK_KHR_bind_memory2
static VkResult entry_vkBindBufferMemory2KHR(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos)
{
    AEMU_SCOPED_TRACE("vkBindBufferMemory2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindBufferMemory2KHR_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkBindBufferMemory2KHR_VkResult_return = resources->on_vkBindBufferMemory2KHR(vkEnc, VK_SUCCESS, device, bindInfoCount, pBindInfos);
    return vkBindBufferMemory2KHR_VkResult_return;
}
static VkResult dynCheck_entry_vkBindBufferMemory2KHR(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_bind_memory2"))
    {
        sOnInvalidDynamicallyCheckedCall("vkBindBufferMemory2KHR", "VK_KHR_bind_memory2");
    }
    AEMU_SCOPED_TRACE("vkBindBufferMemory2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindBufferMemory2KHR_VkResult_return = (VkResult)0;
    vkBindBufferMemory2KHR_VkResult_return = resources->on_vkBindBufferMemory2KHR(vkEnc, VK_SUCCESS, device, bindInfoCount, pBindInfos);
    return vkBindBufferMemory2KHR_VkResult_return;
}
static VkResult entry_vkBindImageMemory2KHR(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos)
{
    AEMU_SCOPED_TRACE("vkBindImageMemory2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindImageMemory2KHR_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkBindImageMemory2KHR_VkResult_return = resources->on_vkBindImageMemory2KHR(vkEnc, VK_SUCCESS, device, bindInfoCount, pBindInfos);
    return vkBindImageMemory2KHR_VkResult_return;
}
static VkResult dynCheck_entry_vkBindImageMemory2KHR(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_bind_memory2"))
    {
        sOnInvalidDynamicallyCheckedCall("vkBindImageMemory2KHR", "VK_KHR_bind_memory2");
    }
    AEMU_SCOPED_TRACE("vkBindImageMemory2KHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindImageMemory2KHR_VkResult_return = (VkResult)0;
    vkBindImageMemory2KHR_VkResult_return = resources->on_vkBindImageMemory2KHR(vkEnc, VK_SUCCESS, device, bindInfoCount, pBindInfos);
    return vkBindImageMemory2KHR_VkResult_return;
}
#endif
#ifdef VK_KHR_portability_subset
#endif
#ifdef VK_KHR_maintenance3
static void entry_vkGetDescriptorSetLayoutSupportKHR(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport)
{
    AEMU_SCOPED_TRACE("vkGetDescriptorSetLayoutSupportKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDescriptorSetLayoutSupportKHR(device, pCreateInfo, pSupport, true /* do lock */);
}
static void dynCheck_entry_vkGetDescriptorSetLayoutSupportKHR(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_maintenance3"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetDescriptorSetLayoutSupportKHR", "VK_KHR_maintenance3");
    }
    AEMU_SCOPED_TRACE("vkGetDescriptorSetLayoutSupportKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDescriptorSetLayoutSupportKHR(device, pCreateInfo, pSupport, true /* do lock */);
}
#endif
#ifdef VK_KHR_draw_indirect_count
static void entry_vkCmdDrawIndirectCountKHR(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    AEMU_SCOPED_TRACE("vkCmdDrawIndirectCountKHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride, true /* do lock */);
}
static void entry_vkCmdDrawIndexedIndirectCountKHR(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    AEMU_SCOPED_TRACE("vkCmdDrawIndexedIndirectCountKHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride, true /* do lock */);
}
#endif
#ifdef VK_KHR_shader_subgroup_extended_types
#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_KHR_shader_atomic_int64
#endif
#ifdef VK_KHR_shader_clock
#endif
#ifdef VK_KHR_driver_properties
#endif
#ifdef VK_KHR_shader_float_controls
#endif
#ifdef VK_KHR_depth_stencil_resolve
#endif
#ifdef VK_KHR_swapchain_mutable_format
#endif
#ifdef VK_KHR_timeline_semaphore
static VkResult entry_vkGetSemaphoreCounterValueKHR(
    VkDevice device,
    VkSemaphore semaphore,
    uint64_t* pValue)
{
    AEMU_SCOPED_TRACE("vkGetSemaphoreCounterValueKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSemaphoreCounterValueKHR_VkResult_return = (VkResult)0;
    vkGetSemaphoreCounterValueKHR_VkResult_return = vkEnc->vkGetSemaphoreCounterValueKHR(device, semaphore, pValue, true /* do lock */);
    return vkGetSemaphoreCounterValueKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetSemaphoreCounterValueKHR(
    VkDevice device,
    VkSemaphore semaphore,
    uint64_t* pValue)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_timeline_semaphore"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetSemaphoreCounterValueKHR", "VK_KHR_timeline_semaphore");
    }
    AEMU_SCOPED_TRACE("vkGetSemaphoreCounterValueKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSemaphoreCounterValueKHR_VkResult_return = (VkResult)0;
    vkGetSemaphoreCounterValueKHR_VkResult_return = vkEnc->vkGetSemaphoreCounterValueKHR(device, semaphore, pValue, true /* do lock */);
    return vkGetSemaphoreCounterValueKHR_VkResult_return;
}
static VkResult entry_vkWaitSemaphoresKHR(
    VkDevice device,
    const VkSemaphoreWaitInfo* pWaitInfo,
    uint64_t timeout)
{
    AEMU_SCOPED_TRACE("vkWaitSemaphoresKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkWaitSemaphoresKHR_VkResult_return = (VkResult)0;
    vkWaitSemaphoresKHR_VkResult_return = vkEnc->vkWaitSemaphoresKHR(device, pWaitInfo, timeout, true /* do lock */);
    return vkWaitSemaphoresKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkWaitSemaphoresKHR(
    VkDevice device,
    const VkSemaphoreWaitInfo* pWaitInfo,
    uint64_t timeout)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_timeline_semaphore"))
    {
        sOnInvalidDynamicallyCheckedCall("vkWaitSemaphoresKHR", "VK_KHR_timeline_semaphore");
    }
    AEMU_SCOPED_TRACE("vkWaitSemaphoresKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkWaitSemaphoresKHR_VkResult_return = (VkResult)0;
    vkWaitSemaphoresKHR_VkResult_return = vkEnc->vkWaitSemaphoresKHR(device, pWaitInfo, timeout, true /* do lock */);
    return vkWaitSemaphoresKHR_VkResult_return;
}
static VkResult entry_vkSignalSemaphoreKHR(
    VkDevice device,
    const VkSemaphoreSignalInfo* pSignalInfo)
{
    AEMU_SCOPED_TRACE("vkSignalSemaphoreKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkSignalSemaphoreKHR_VkResult_return = (VkResult)0;
    vkSignalSemaphoreKHR_VkResult_return = vkEnc->vkSignalSemaphoreKHR(device, pSignalInfo, true /* do lock */);
    return vkSignalSemaphoreKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkSignalSemaphoreKHR(
    VkDevice device,
    const VkSemaphoreSignalInfo* pSignalInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_timeline_semaphore"))
    {
        sOnInvalidDynamicallyCheckedCall("vkSignalSemaphoreKHR", "VK_KHR_timeline_semaphore");
    }
    AEMU_SCOPED_TRACE("vkSignalSemaphoreKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkSignalSemaphoreKHR_VkResult_return = (VkResult)0;
    vkSignalSemaphoreKHR_VkResult_return = vkEnc->vkSignalSemaphoreKHR(device, pSignalInfo, true /* do lock */);
    return vkSignalSemaphoreKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_vulkan_memory_model
#endif
#ifdef VK_KHR_shader_terminate_invocation
#endif
#ifdef VK_KHR_fragment_shading_rate
static VkResult entry_vkGetPhysicalDeviceFragmentShadingRatesKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pFragmentShadingRateCount,
    VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceFragmentShadingRatesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceFragmentShadingRatesKHR_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceFragmentShadingRatesKHR_VkResult_return = vkEnc->vkGetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates, true /* do lock */);
    return vkGetPhysicalDeviceFragmentShadingRatesKHR_VkResult_return;
}
static void entry_vkCmdSetFragmentShadingRateKHR(
    VkCommandBuffer commandBuffer,
    const VkExtent2D* pFragmentSize,
    const VkFragmentShadingRateCombinerOpKHR combinerOps[2])
{
    AEMU_SCOPED_TRACE("vkCmdSetFragmentShadingRateKHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetFragmentShadingRateKHR(commandBuffer, pFragmentSize, combinerOps, true /* do lock */);
}
#endif
#ifdef VK_KHR_spirv_1_4
#endif
#ifdef VK_KHR_surface_protected_capabilities
#endif
#ifdef VK_KHR_separate_depth_stencil_layouts
#endif
#ifdef VK_KHR_uniform_buffer_standard_layout
#endif
#ifdef VK_KHR_buffer_device_address
static VkDeviceAddress entry_vkGetBufferDeviceAddressKHR(
    VkDevice device,
    const VkBufferDeviceAddressInfo* pInfo)
{
    AEMU_SCOPED_TRACE("vkGetBufferDeviceAddressKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkDeviceAddress vkGetBufferDeviceAddressKHR_VkDeviceAddress_return = (VkDeviceAddress)0;
    vkGetBufferDeviceAddressKHR_VkDeviceAddress_return = vkEnc->vkGetBufferDeviceAddressKHR(device, pInfo, true /* do lock */);
    return vkGetBufferDeviceAddressKHR_VkDeviceAddress_return;
}
static VkDeviceAddress dynCheck_entry_vkGetBufferDeviceAddressKHR(
    VkDevice device,
    const VkBufferDeviceAddressInfo* pInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_buffer_device_address"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetBufferDeviceAddressKHR", "VK_KHR_buffer_device_address");
    }
    AEMU_SCOPED_TRACE("vkGetBufferDeviceAddressKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkDeviceAddress vkGetBufferDeviceAddressKHR_VkDeviceAddress_return = (VkDeviceAddress)0;
    vkGetBufferDeviceAddressKHR_VkDeviceAddress_return = vkEnc->vkGetBufferDeviceAddressKHR(device, pInfo, true /* do lock */);
    return vkGetBufferDeviceAddressKHR_VkDeviceAddress_return;
}
static uint64_t entry_vkGetBufferOpaqueCaptureAddressKHR(
    VkDevice device,
    const VkBufferDeviceAddressInfo* pInfo)
{
    AEMU_SCOPED_TRACE("vkGetBufferOpaqueCaptureAddressKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint64_t vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return = (uint64_t)0;
    vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return = vkEnc->vkGetBufferOpaqueCaptureAddressKHR(device, pInfo, true /* do lock */);
    return vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return;
}
static uint64_t dynCheck_entry_vkGetBufferOpaqueCaptureAddressKHR(
    VkDevice device,
    const VkBufferDeviceAddressInfo* pInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_buffer_device_address"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetBufferOpaqueCaptureAddressKHR", "VK_KHR_buffer_device_address");
    }
    AEMU_SCOPED_TRACE("vkGetBufferOpaqueCaptureAddressKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint64_t vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return = (uint64_t)0;
    vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return = vkEnc->vkGetBufferOpaqueCaptureAddressKHR(device, pInfo, true /* do lock */);
    return vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return;
}
static uint64_t entry_vkGetDeviceMemoryOpaqueCaptureAddressKHR(
    VkDevice device,
    const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo)
{
    AEMU_SCOPED_TRACE("vkGetDeviceMemoryOpaqueCaptureAddressKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint64_t vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return = (uint64_t)0;
    vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return = vkEnc->vkGetDeviceMemoryOpaqueCaptureAddressKHR(device, pInfo, true /* do lock */);
    return vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return;
}
static uint64_t dynCheck_entry_vkGetDeviceMemoryOpaqueCaptureAddressKHR(
    VkDevice device,
    const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_buffer_device_address"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetDeviceMemoryOpaqueCaptureAddressKHR", "VK_KHR_buffer_device_address");
    }
    AEMU_SCOPED_TRACE("vkGetDeviceMemoryOpaqueCaptureAddressKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint64_t vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return = (uint64_t)0;
    vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return = vkEnc->vkGetDeviceMemoryOpaqueCaptureAddressKHR(device, pInfo, true /* do lock */);
    return vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return;
}
#endif
#ifdef VK_KHR_deferred_host_operations
static VkResult entry_vkCreateDeferredOperationKHR(
    VkDevice device,
    const VkAllocationCallbacks* pAllocator,
    VkDeferredOperationKHR* pDeferredOperation)
{
    AEMU_SCOPED_TRACE("vkCreateDeferredOperationKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDeferredOperationKHR_VkResult_return = (VkResult)0;
    vkCreateDeferredOperationKHR_VkResult_return = vkEnc->vkCreateDeferredOperationKHR(device, pAllocator, pDeferredOperation, true /* do lock */);
    return vkCreateDeferredOperationKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateDeferredOperationKHR(
    VkDevice device,
    const VkAllocationCallbacks* pAllocator,
    VkDeferredOperationKHR* pDeferredOperation)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_deferred_host_operations"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCreateDeferredOperationKHR", "VK_KHR_deferred_host_operations");
    }
    AEMU_SCOPED_TRACE("vkCreateDeferredOperationKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDeferredOperationKHR_VkResult_return = (VkResult)0;
    vkCreateDeferredOperationKHR_VkResult_return = vkEnc->vkCreateDeferredOperationKHR(device, pAllocator, pDeferredOperation, true /* do lock */);
    return vkCreateDeferredOperationKHR_VkResult_return;
}
static void entry_vkDestroyDeferredOperationKHR(
    VkDevice device,
    VkDeferredOperationKHR operation,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyDeferredOperationKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyDeferredOperationKHR(device, operation, pAllocator, true /* do lock */);
}
static void dynCheck_entry_vkDestroyDeferredOperationKHR(
    VkDevice device,
    VkDeferredOperationKHR operation,
    const VkAllocationCallbacks* pAllocator)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_deferred_host_operations"))
    {
        sOnInvalidDynamicallyCheckedCall("vkDestroyDeferredOperationKHR", "VK_KHR_deferred_host_operations");
    }
    AEMU_SCOPED_TRACE("vkDestroyDeferredOperationKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyDeferredOperationKHR(device, operation, pAllocator, true /* do lock */);
}
static uint32_t entry_vkGetDeferredOperationMaxConcurrencyKHR(
    VkDevice device,
    VkDeferredOperationKHR operation)
{
    AEMU_SCOPED_TRACE("vkGetDeferredOperationMaxConcurrencyKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint32_t vkGetDeferredOperationMaxConcurrencyKHR_uint32_t_return = (uint32_t)0;
    vkGetDeferredOperationMaxConcurrencyKHR_uint32_t_return = vkEnc->vkGetDeferredOperationMaxConcurrencyKHR(device, operation, true /* do lock */);
    return vkGetDeferredOperationMaxConcurrencyKHR_uint32_t_return;
}
static uint32_t dynCheck_entry_vkGetDeferredOperationMaxConcurrencyKHR(
    VkDevice device,
    VkDeferredOperationKHR operation)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_deferred_host_operations"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetDeferredOperationMaxConcurrencyKHR", "VK_KHR_deferred_host_operations");
    }
    AEMU_SCOPED_TRACE("vkGetDeferredOperationMaxConcurrencyKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint32_t vkGetDeferredOperationMaxConcurrencyKHR_uint32_t_return = (uint32_t)0;
    vkGetDeferredOperationMaxConcurrencyKHR_uint32_t_return = vkEnc->vkGetDeferredOperationMaxConcurrencyKHR(device, operation, true /* do lock */);
    return vkGetDeferredOperationMaxConcurrencyKHR_uint32_t_return;
}
static VkResult entry_vkGetDeferredOperationResultKHR(
    VkDevice device,
    VkDeferredOperationKHR operation)
{
    AEMU_SCOPED_TRACE("vkGetDeferredOperationResultKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetDeferredOperationResultKHR_VkResult_return = (VkResult)0;
    vkGetDeferredOperationResultKHR_VkResult_return = vkEnc->vkGetDeferredOperationResultKHR(device, operation, true /* do lock */);
    return vkGetDeferredOperationResultKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetDeferredOperationResultKHR(
    VkDevice device,
    VkDeferredOperationKHR operation)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_deferred_host_operations"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetDeferredOperationResultKHR", "VK_KHR_deferred_host_operations");
    }
    AEMU_SCOPED_TRACE("vkGetDeferredOperationResultKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetDeferredOperationResultKHR_VkResult_return = (VkResult)0;
    vkGetDeferredOperationResultKHR_VkResult_return = vkEnc->vkGetDeferredOperationResultKHR(device, operation, true /* do lock */);
    return vkGetDeferredOperationResultKHR_VkResult_return;
}
static VkResult entry_vkDeferredOperationJoinKHR(
    VkDevice device,
    VkDeferredOperationKHR operation)
{
    AEMU_SCOPED_TRACE("vkDeferredOperationJoinKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkDeferredOperationJoinKHR_VkResult_return = (VkResult)0;
    vkDeferredOperationJoinKHR_VkResult_return = vkEnc->vkDeferredOperationJoinKHR(device, operation, true /* do lock */);
    return vkDeferredOperationJoinKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkDeferredOperationJoinKHR(
    VkDevice device,
    VkDeferredOperationKHR operation)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_deferred_host_operations"))
    {
        sOnInvalidDynamicallyCheckedCall("vkDeferredOperationJoinKHR", "VK_KHR_deferred_host_operations");
    }
    AEMU_SCOPED_TRACE("vkDeferredOperationJoinKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkDeferredOperationJoinKHR_VkResult_return = (VkResult)0;
    vkDeferredOperationJoinKHR_VkResult_return = vkEnc->vkDeferredOperationJoinKHR(device, operation, true /* do lock */);
    return vkDeferredOperationJoinKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_pipeline_executable_properties
static VkResult entry_vkGetPipelineExecutablePropertiesKHR(
    VkDevice device,
    const VkPipelineInfoKHR* pPipelineInfo,
    uint32_t* pExecutableCount,
    VkPipelineExecutablePropertiesKHR* pProperties)
{
    AEMU_SCOPED_TRACE("vkGetPipelineExecutablePropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPipelineExecutablePropertiesKHR_VkResult_return = (VkResult)0;
    vkGetPipelineExecutablePropertiesKHR_VkResult_return = vkEnc->vkGetPipelineExecutablePropertiesKHR(device, pPipelineInfo, pExecutableCount, pProperties, true /* do lock */);
    return vkGetPipelineExecutablePropertiesKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetPipelineExecutablePropertiesKHR(
    VkDevice device,
    const VkPipelineInfoKHR* pPipelineInfo,
    uint32_t* pExecutableCount,
    VkPipelineExecutablePropertiesKHR* pProperties)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_pipeline_executable_properties"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetPipelineExecutablePropertiesKHR", "VK_KHR_pipeline_executable_properties");
    }
    AEMU_SCOPED_TRACE("vkGetPipelineExecutablePropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPipelineExecutablePropertiesKHR_VkResult_return = (VkResult)0;
    vkGetPipelineExecutablePropertiesKHR_VkResult_return = vkEnc->vkGetPipelineExecutablePropertiesKHR(device, pPipelineInfo, pExecutableCount, pProperties, true /* do lock */);
    return vkGetPipelineExecutablePropertiesKHR_VkResult_return;
}
static VkResult entry_vkGetPipelineExecutableStatisticsKHR(
    VkDevice device,
    const VkPipelineExecutableInfoKHR* pExecutableInfo,
    uint32_t* pStatisticCount,
    VkPipelineExecutableStatisticKHR* pStatistics)
{
    AEMU_SCOPED_TRACE("vkGetPipelineExecutableStatisticsKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPipelineExecutableStatisticsKHR_VkResult_return = (VkResult)0;
    vkGetPipelineExecutableStatisticsKHR_VkResult_return = vkEnc->vkGetPipelineExecutableStatisticsKHR(device, pExecutableInfo, pStatisticCount, pStatistics, true /* do lock */);
    return vkGetPipelineExecutableStatisticsKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetPipelineExecutableStatisticsKHR(
    VkDevice device,
    const VkPipelineExecutableInfoKHR* pExecutableInfo,
    uint32_t* pStatisticCount,
    VkPipelineExecutableStatisticKHR* pStatistics)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_pipeline_executable_properties"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetPipelineExecutableStatisticsKHR", "VK_KHR_pipeline_executable_properties");
    }
    AEMU_SCOPED_TRACE("vkGetPipelineExecutableStatisticsKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPipelineExecutableStatisticsKHR_VkResult_return = (VkResult)0;
    vkGetPipelineExecutableStatisticsKHR_VkResult_return = vkEnc->vkGetPipelineExecutableStatisticsKHR(device, pExecutableInfo, pStatisticCount, pStatistics, true /* do lock */);
    return vkGetPipelineExecutableStatisticsKHR_VkResult_return;
}
static VkResult entry_vkGetPipelineExecutableInternalRepresentationsKHR(
    VkDevice device,
    const VkPipelineExecutableInfoKHR* pExecutableInfo,
    uint32_t* pInternalRepresentationCount,
    VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations)
{
    AEMU_SCOPED_TRACE("vkGetPipelineExecutableInternalRepresentationsKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return = (VkResult)0;
    vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return = vkEnc->vkGetPipelineExecutableInternalRepresentationsKHR(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations, true /* do lock */);
    return vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetPipelineExecutableInternalRepresentationsKHR(
    VkDevice device,
    const VkPipelineExecutableInfoKHR* pExecutableInfo,
    uint32_t* pInternalRepresentationCount,
    VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_pipeline_executable_properties"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetPipelineExecutableInternalRepresentationsKHR", "VK_KHR_pipeline_executable_properties");
    }
    AEMU_SCOPED_TRACE("vkGetPipelineExecutableInternalRepresentationsKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return = (VkResult)0;
    vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return = vkEnc->vkGetPipelineExecutableInternalRepresentationsKHR(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations, true /* do lock */);
    return vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return;
}
#endif
#ifdef VK_KHR_pipeline_library
#endif
#ifdef VK_KHR_shader_non_semantic_info
#endif
#ifdef VK_KHR_copy_commands2
static void entry_vkCmdCopyBuffer2KHR(
    VkCommandBuffer commandBuffer,
    const VkCopyBufferInfo2KHR* pCopyBufferInfo)
{
    AEMU_SCOPED_TRACE("vkCmdCopyBuffer2KHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyBuffer2KHR(commandBuffer, pCopyBufferInfo, true /* do lock */);
}
static void entry_vkCmdCopyImage2KHR(
    VkCommandBuffer commandBuffer,
    const VkCopyImageInfo2KHR* pCopyImageInfo)
{
    AEMU_SCOPED_TRACE("vkCmdCopyImage2KHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyImage2KHR(commandBuffer, pCopyImageInfo, true /* do lock */);
}
static void entry_vkCmdCopyBufferToImage2KHR(
    VkCommandBuffer commandBuffer,
    const VkCopyBufferToImageInfo2KHR* pCopyBufferToImageInfo)
{
    AEMU_SCOPED_TRACE("vkCmdCopyBufferToImage2KHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyBufferToImage2KHR(commandBuffer, pCopyBufferToImageInfo, true /* do lock */);
}
static void entry_vkCmdCopyImageToBuffer2KHR(
    VkCommandBuffer commandBuffer,
    const VkCopyImageToBufferInfo2KHR* pCopyImageToBufferInfo)
{
    AEMU_SCOPED_TRACE("vkCmdCopyImageToBuffer2KHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyImageToBuffer2KHR(commandBuffer, pCopyImageToBufferInfo, true /* do lock */);
}
static void entry_vkCmdBlitImage2KHR(
    VkCommandBuffer commandBuffer,
    const VkBlitImageInfo2KHR* pBlitImageInfo)
{
    AEMU_SCOPED_TRACE("vkCmdBlitImage2KHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBlitImage2KHR(commandBuffer, pBlitImageInfo, true /* do lock */);
}
static void entry_vkCmdResolveImage2KHR(
    VkCommandBuffer commandBuffer,
    const VkResolveImageInfo2KHR* pResolveImageInfo)
{
    AEMU_SCOPED_TRACE("vkCmdResolveImage2KHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdResolveImage2KHR(commandBuffer, pResolveImageInfo, true /* do lock */);
}
#endif
#ifdef VK_ANDROID_native_buffer
static VkResult entry_vkGetSwapchainGrallocUsageANDROID(
    VkDevice device,
    VkFormat format,
    VkImageUsageFlags imageUsage,
    int* grallocUsage)
{
    AEMU_SCOPED_TRACE("vkGetSwapchainGrallocUsageANDROID");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSwapchainGrallocUsageANDROID_VkResult_return = (VkResult)0;
    vkGetSwapchainGrallocUsageANDROID_VkResult_return = vkEnc->vkGetSwapchainGrallocUsageANDROID(device, format, imageUsage, grallocUsage, true /* do lock */);
    return vkGetSwapchainGrallocUsageANDROID_VkResult_return;
}
static VkResult dynCheck_entry_vkGetSwapchainGrallocUsageANDROID(
    VkDevice device,
    VkFormat format,
    VkImageUsageFlags imageUsage,
    int* grallocUsage)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_ANDROID_native_buffer"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetSwapchainGrallocUsageANDROID", "VK_ANDROID_native_buffer");
    }
    AEMU_SCOPED_TRACE("vkGetSwapchainGrallocUsageANDROID");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSwapchainGrallocUsageANDROID_VkResult_return = (VkResult)0;
    vkGetSwapchainGrallocUsageANDROID_VkResult_return = vkEnc->vkGetSwapchainGrallocUsageANDROID(device, format, imageUsage, grallocUsage, true /* do lock */);
    return vkGetSwapchainGrallocUsageANDROID_VkResult_return;
}
static VkResult entry_vkAcquireImageANDROID(
    VkDevice device,
    VkImage image,
    int nativeFenceFd,
    VkSemaphore semaphore,
    VkFence fence)
{
    AEMU_SCOPED_TRACE("vkAcquireImageANDROID");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAcquireImageANDROID_VkResult_return = (VkResult)0;
    vkAcquireImageANDROID_VkResult_return = vkEnc->vkAcquireImageANDROID(device, image, nativeFenceFd, semaphore, fence, true /* do lock */);
    return vkAcquireImageANDROID_VkResult_return;
}
static VkResult dynCheck_entry_vkAcquireImageANDROID(
    VkDevice device,
    VkImage image,
    int nativeFenceFd,
    VkSemaphore semaphore,
    VkFence fence)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_ANDROID_native_buffer"))
    {
        sOnInvalidDynamicallyCheckedCall("vkAcquireImageANDROID", "VK_ANDROID_native_buffer");
    }
    AEMU_SCOPED_TRACE("vkAcquireImageANDROID");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAcquireImageANDROID_VkResult_return = (VkResult)0;
    vkAcquireImageANDROID_VkResult_return = vkEnc->vkAcquireImageANDROID(device, image, nativeFenceFd, semaphore, fence, true /* do lock */);
    return vkAcquireImageANDROID_VkResult_return;
}
static VkResult entry_vkQueueSignalReleaseImageANDROID(
    VkQueue queue,
    uint32_t waitSemaphoreCount,
    const VkSemaphore* pWaitSemaphores,
    VkImage image,
    int* pNativeFenceFd)
{
    AEMU_SCOPED_TRACE("vkQueueSignalReleaseImageANDROID");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    VkResult vkQueueSignalReleaseImageANDROID_VkResult_return = (VkResult)0;
    vkQueueSignalReleaseImageANDROID_VkResult_return = vkEnc->vkQueueSignalReleaseImageANDROID(queue, waitSemaphoreCount, pWaitSemaphores, image, pNativeFenceFd, true /* do lock */);
    return vkQueueSignalReleaseImageANDROID_VkResult_return;
}
#endif
#ifdef VK_EXT_debug_report
static VkResult entry_vkCreateDebugReportCallbackEXT(
    VkInstance instance,
    const VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDebugReportCallbackEXT* pCallback)
{
    AEMU_SCOPED_TRACE("vkCreateDebugReportCallbackEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDebugReportCallbackEXT_VkResult_return = (VkResult)0;
    vkCreateDebugReportCallbackEXT_VkResult_return = vkEnc->vkCreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback, true /* do lock */);
    return vkCreateDebugReportCallbackEXT_VkResult_return;
}
static void entry_vkDestroyDebugReportCallbackEXT(
    VkInstance instance,
    VkDebugReportCallbackEXT callback,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyDebugReportCallbackEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyDebugReportCallbackEXT(instance, callback, pAllocator, true /* do lock */);
}
static void entry_vkDebugReportMessageEXT(
    VkInstance instance,
    VkDebugReportFlagsEXT flags,
    VkDebugReportObjectTypeEXT objectType,
    uint64_t object,
    size_t location,
    int32_t messageCode,
    const char* pLayerPrefix,
    const char* pMessage)
{
    AEMU_SCOPED_TRACE("vkDebugReportMessageEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage, true /* do lock */);
}
#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
static VkResult entry_vkDebugMarkerSetObjectTagEXT(
    VkDevice device,
    const VkDebugMarkerObjectTagInfoEXT* pTagInfo)
{
    AEMU_SCOPED_TRACE("vkDebugMarkerSetObjectTagEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkDebugMarkerSetObjectTagEXT_VkResult_return = (VkResult)0;
    vkDebugMarkerSetObjectTagEXT_VkResult_return = vkEnc->vkDebugMarkerSetObjectTagEXT(device, pTagInfo, true /* do lock */);
    return vkDebugMarkerSetObjectTagEXT_VkResult_return;
}
static VkResult dynCheck_entry_vkDebugMarkerSetObjectTagEXT(
    VkDevice device,
    const VkDebugMarkerObjectTagInfoEXT* pTagInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_debug_marker"))
    {
        sOnInvalidDynamicallyCheckedCall("vkDebugMarkerSetObjectTagEXT", "VK_EXT_debug_marker");
    }
    AEMU_SCOPED_TRACE("vkDebugMarkerSetObjectTagEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkDebugMarkerSetObjectTagEXT_VkResult_return = (VkResult)0;
    vkDebugMarkerSetObjectTagEXT_VkResult_return = vkEnc->vkDebugMarkerSetObjectTagEXT(device, pTagInfo, true /* do lock */);
    return vkDebugMarkerSetObjectTagEXT_VkResult_return;
}
static VkResult entry_vkDebugMarkerSetObjectNameEXT(
    VkDevice device,
    const VkDebugMarkerObjectNameInfoEXT* pNameInfo)
{
    AEMU_SCOPED_TRACE("vkDebugMarkerSetObjectNameEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkDebugMarkerSetObjectNameEXT_VkResult_return = (VkResult)0;
    vkDebugMarkerSetObjectNameEXT_VkResult_return = vkEnc->vkDebugMarkerSetObjectNameEXT(device, pNameInfo, true /* do lock */);
    return vkDebugMarkerSetObjectNameEXT_VkResult_return;
}
static VkResult dynCheck_entry_vkDebugMarkerSetObjectNameEXT(
    VkDevice device,
    const VkDebugMarkerObjectNameInfoEXT* pNameInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_debug_marker"))
    {
        sOnInvalidDynamicallyCheckedCall("vkDebugMarkerSetObjectNameEXT", "VK_EXT_debug_marker");
    }
    AEMU_SCOPED_TRACE("vkDebugMarkerSetObjectNameEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkDebugMarkerSetObjectNameEXT_VkResult_return = (VkResult)0;
    vkDebugMarkerSetObjectNameEXT_VkResult_return = vkEnc->vkDebugMarkerSetObjectNameEXT(device, pNameInfo, true /* do lock */);
    return vkDebugMarkerSetObjectNameEXT_VkResult_return;
}
static void entry_vkCmdDebugMarkerBeginEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugMarkerMarkerInfoEXT* pMarkerInfo)
{
    AEMU_SCOPED_TRACE("vkCmdDebugMarkerBeginEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo, true /* do lock */);
}
static void entry_vkCmdDebugMarkerEndEXT(
    VkCommandBuffer commandBuffer)
{
    AEMU_SCOPED_TRACE("vkCmdDebugMarkerEndEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDebugMarkerEndEXT(commandBuffer, true /* do lock */);
}
static void entry_vkCmdDebugMarkerInsertEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugMarkerMarkerInfoEXT* pMarkerInfo)
{
    AEMU_SCOPED_TRACE("vkCmdDebugMarkerInsertEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo, true /* do lock */);
}
#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
#endif
#ifdef VK_EXT_transform_feedback
static void entry_vkCmdBindTransformFeedbackBuffersEXT(
    VkCommandBuffer commandBuffer,
    uint32_t firstBinding,
    uint32_t bindingCount,
    const VkBuffer* pBuffers,
    const VkDeviceSize* pOffsets,
    const VkDeviceSize* pSizes)
{
    AEMU_SCOPED_TRACE("vkCmdBindTransformFeedbackBuffersEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, true /* do lock */);
}
static void entry_vkCmdBeginTransformFeedbackEXT(
    VkCommandBuffer commandBuffer,
    uint32_t firstCounterBuffer,
    uint32_t counterBufferCount,
    const VkBuffer* pCounterBuffers,
    const VkDeviceSize* pCounterBufferOffsets)
{
    AEMU_SCOPED_TRACE("vkCmdBeginTransformFeedbackEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets, true /* do lock */);
}
static void entry_vkCmdEndTransformFeedbackEXT(
    VkCommandBuffer commandBuffer,
    uint32_t firstCounterBuffer,
    uint32_t counterBufferCount,
    const VkBuffer* pCounterBuffers,
    const VkDeviceSize* pCounterBufferOffsets)
{
    AEMU_SCOPED_TRACE("vkCmdEndTransformFeedbackEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets, true /* do lock */);
}
static void entry_vkCmdBeginQueryIndexedEXT(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query,
    VkQueryControlFlags flags,
    uint32_t index)
{
    AEMU_SCOPED_TRACE("vkCmdBeginQueryIndexedEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index, true /* do lock */);
}
static void entry_vkCmdEndQueryIndexedEXT(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query,
    uint32_t index)
{
    AEMU_SCOPED_TRACE("vkCmdEndQueryIndexedEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index, true /* do lock */);
}
static void entry_vkCmdDrawIndirectByteCountEXT(
    VkCommandBuffer commandBuffer,
    uint32_t instanceCount,
    uint32_t firstInstance,
    VkBuffer counterBuffer,
    VkDeviceSize counterBufferOffset,
    uint32_t counterOffset,
    uint32_t vertexStride)
{
    AEMU_SCOPED_TRACE("vkCmdDrawIndirectByteCountEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride, true /* do lock */);
}
#endif
#ifdef VK_NVX_image_view_handle
static uint32_t entry_vkGetImageViewHandleNVX(
    VkDevice device,
    const VkImageViewHandleInfoNVX* pInfo)
{
    AEMU_SCOPED_TRACE("vkGetImageViewHandleNVX");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint32_t vkGetImageViewHandleNVX_uint32_t_return = (uint32_t)0;
    vkGetImageViewHandleNVX_uint32_t_return = vkEnc->vkGetImageViewHandleNVX(device, pInfo, true /* do lock */);
    return vkGetImageViewHandleNVX_uint32_t_return;
}
static uint32_t dynCheck_entry_vkGetImageViewHandleNVX(
    VkDevice device,
    const VkImageViewHandleInfoNVX* pInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_NVX_image_view_handle"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetImageViewHandleNVX", "VK_NVX_image_view_handle");
    }
    AEMU_SCOPED_TRACE("vkGetImageViewHandleNVX");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    uint32_t vkGetImageViewHandleNVX_uint32_t_return = (uint32_t)0;
    vkGetImageViewHandleNVX_uint32_t_return = vkEnc->vkGetImageViewHandleNVX(device, pInfo, true /* do lock */);
    return vkGetImageViewHandleNVX_uint32_t_return;
}
static VkResult entry_vkGetImageViewAddressNVX(
    VkDevice device,
    VkImageView imageView,
    VkImageViewAddressPropertiesNVX* pProperties)
{
    AEMU_SCOPED_TRACE("vkGetImageViewAddressNVX");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetImageViewAddressNVX_VkResult_return = (VkResult)0;
    vkGetImageViewAddressNVX_VkResult_return = vkEnc->vkGetImageViewAddressNVX(device, imageView, pProperties, true /* do lock */);
    return vkGetImageViewAddressNVX_VkResult_return;
}
static VkResult dynCheck_entry_vkGetImageViewAddressNVX(
    VkDevice device,
    VkImageView imageView,
    VkImageViewAddressPropertiesNVX* pProperties)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_NVX_image_view_handle"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetImageViewAddressNVX", "VK_NVX_image_view_handle");
    }
    AEMU_SCOPED_TRACE("vkGetImageViewAddressNVX");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetImageViewAddressNVX_VkResult_return = (VkResult)0;
    vkGetImageViewAddressNVX_VkResult_return = vkEnc->vkGetImageViewAddressNVX(device, imageView, pProperties, true /* do lock */);
    return vkGetImageViewAddressNVX_VkResult_return;
}
#endif
#ifdef VK_AMD_draw_indirect_count
static void entry_vkCmdDrawIndirectCountAMD(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    AEMU_SCOPED_TRACE("vkCmdDrawIndirectCountAMD");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride, true /* do lock */);
}
static void entry_vkCmdDrawIndexedIndirectCountAMD(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    AEMU_SCOPED_TRACE("vkCmdDrawIndexedIndirectCountAMD");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride, true /* do lock */);
}
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
#endif
#ifdef VK_AMD_shader_info
static VkResult entry_vkGetShaderInfoAMD(
    VkDevice device,
    VkPipeline pipeline,
    VkShaderStageFlagBits shaderStage,
    VkShaderInfoTypeAMD infoType,
    size_t* pInfoSize,
    void* pInfo)
{
    AEMU_SCOPED_TRACE("vkGetShaderInfoAMD");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetShaderInfoAMD_VkResult_return = (VkResult)0;
    vkGetShaderInfoAMD_VkResult_return = vkEnc->vkGetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo, true /* do lock */);
    return vkGetShaderInfoAMD_VkResult_return;
}
static VkResult dynCheck_entry_vkGetShaderInfoAMD(
    VkDevice device,
    VkPipeline pipeline,
    VkShaderStageFlagBits shaderStage,
    VkShaderInfoTypeAMD infoType,
    size_t* pInfoSize,
    void* pInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_AMD_shader_info"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetShaderInfoAMD", "VK_AMD_shader_info");
    }
    AEMU_SCOPED_TRACE("vkGetShaderInfoAMD");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetShaderInfoAMD_VkResult_return = (VkResult)0;
    vkGetShaderInfoAMD_VkResult_return = vkEnc->vkGetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo, true /* do lock */);
    return vkGetShaderInfoAMD_VkResult_return;
}
#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_GGP_stream_descriptor_surface
static VkResult entry_vkCreateStreamDescriptorSurfaceGGP(
    VkInstance instance,
    const VkStreamDescriptorSurfaceCreateInfoGGP* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AEMU_SCOPED_TRACE("vkCreateStreamDescriptorSurfaceGGP");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateStreamDescriptorSurfaceGGP_VkResult_return = (VkResult)0;
    vkCreateStreamDescriptorSurfaceGGP_VkResult_return = vkEnc->vkCreateStreamDescriptorSurfaceGGP(instance, pCreateInfo, pAllocator, pSurface, true /* do lock */);
    return vkCreateStreamDescriptorSurfaceGGP_VkResult_return;
}
#endif
#ifdef VK_NV_corner_sampled_image
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
static VkResult entry_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkImageTiling tiling,
    VkImageUsageFlags usage,
    VkImageCreateFlags flags,
    VkExternalMemoryHandleTypeFlagsNV externalHandleType,
    VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceExternalImageFormatPropertiesNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = vkEnc->vkGetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties, true /* do lock */);
    return vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return;
}
#endif
#ifdef VK_NV_external_memory
#endif
#ifdef VK_NV_external_memory_win32
static VkResult entry_vkGetMemoryWin32HandleNV(
    VkDevice device,
    VkDeviceMemory memory,
    VkExternalMemoryHandleTypeFlagsNV handleType,
    HANDLE* pHandle)
{
    AEMU_SCOPED_TRACE("vkGetMemoryWin32HandleNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryWin32HandleNV_VkResult_return = (VkResult)0;
    vkGetMemoryWin32HandleNV_VkResult_return = vkEnc->vkGetMemoryWin32HandleNV(device, memory, handleType, pHandle, true /* do lock */);
    return vkGetMemoryWin32HandleNV_VkResult_return;
}
static VkResult dynCheck_entry_vkGetMemoryWin32HandleNV(
    VkDevice device,
    VkDeviceMemory memory,
    VkExternalMemoryHandleTypeFlagsNV handleType,
    HANDLE* pHandle)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_NV_external_memory_win32"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetMemoryWin32HandleNV", "VK_NV_external_memory_win32");
    }
    AEMU_SCOPED_TRACE("vkGetMemoryWin32HandleNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryWin32HandleNV_VkResult_return = (VkResult)0;
    vkGetMemoryWin32HandleNV_VkResult_return = vkEnc->vkGetMemoryWin32HandleNV(device, memory, handleType, pHandle, true /* do lock */);
    return vkGetMemoryWin32HandleNV_VkResult_return;
}
#endif
#ifdef VK_NV_win32_keyed_mutex
#endif
#ifdef VK_EXT_validation_flags
#endif
#ifdef VK_NN_vi_surface
static VkResult entry_vkCreateViSurfaceNN(
    VkInstance instance,
    const VkViSurfaceCreateInfoNN* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AEMU_SCOPED_TRACE("vkCreateViSurfaceNN");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateViSurfaceNN_VkResult_return = (VkResult)0;
    vkCreateViSurfaceNN_VkResult_return = vkEnc->vkCreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface, true /* do lock */);
    return vkCreateViSurfaceNN_VkResult_return;
}
#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
#endif
#ifdef VK_EXT_astc_decode_mode
#endif
#ifdef VK_EXT_conditional_rendering
static void entry_vkCmdBeginConditionalRenderingEXT(
    VkCommandBuffer commandBuffer,
    const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin)
{
    AEMU_SCOPED_TRACE("vkCmdBeginConditionalRenderingEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin, true /* do lock */);
}
static void entry_vkCmdEndConditionalRenderingEXT(
    VkCommandBuffer commandBuffer)
{
    AEMU_SCOPED_TRACE("vkCmdEndConditionalRenderingEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdEndConditionalRenderingEXT(commandBuffer, true /* do lock */);
}
#endif
#ifdef VK_NV_clip_space_w_scaling
static void entry_vkCmdSetViewportWScalingNV(
    VkCommandBuffer commandBuffer,
    uint32_t firstViewport,
    uint32_t viewportCount,
    const VkViewportWScalingNV* pViewportWScalings)
{
    AEMU_SCOPED_TRACE("vkCmdSetViewportWScalingNV");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings, true /* do lock */);
}
#endif
#ifdef VK_EXT_direct_mode_display
static VkResult entry_vkReleaseDisplayEXT(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display)
{
    AEMU_SCOPED_TRACE("vkReleaseDisplayEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkReleaseDisplayEXT_VkResult_return = (VkResult)0;
    vkReleaseDisplayEXT_VkResult_return = vkEnc->vkReleaseDisplayEXT(physicalDevice, display, true /* do lock */);
    return vkReleaseDisplayEXT_VkResult_return;
}
#endif
#ifdef VK_EXT_acquire_xlib_display
static VkResult entry_vkAcquireXlibDisplayEXT(
    VkPhysicalDevice physicalDevice,
    Display* dpy,
    VkDisplayKHR display)
{
    AEMU_SCOPED_TRACE("vkAcquireXlibDisplayEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAcquireXlibDisplayEXT_VkResult_return = (VkResult)0;
    vkAcquireXlibDisplayEXT_VkResult_return = vkEnc->vkAcquireXlibDisplayEXT(physicalDevice, dpy, display, true /* do lock */);
    return vkAcquireXlibDisplayEXT_VkResult_return;
}
static VkResult entry_vkGetRandROutputDisplayEXT(
    VkPhysicalDevice physicalDevice,
    Display* dpy,
    RROutput rrOutput,
    VkDisplayKHR* pDisplay)
{
    AEMU_SCOPED_TRACE("vkGetRandROutputDisplayEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetRandROutputDisplayEXT_VkResult_return = (VkResult)0;
    vkGetRandROutputDisplayEXT_VkResult_return = vkEnc->vkGetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay, true /* do lock */);
    return vkGetRandROutputDisplayEXT_VkResult_return;
}
#endif
#ifdef VK_EXT_display_surface_counter
static VkResult entry_vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    VkSurfaceCapabilities2EXT* pSurfaceCapabilities)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfaceCapabilities2EXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = vkEnc->vkGetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities, true /* do lock */);
    return vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return;
}
#endif
#ifdef VK_EXT_display_control
static VkResult entry_vkDisplayPowerControlEXT(
    VkDevice device,
    VkDisplayKHR display,
    const VkDisplayPowerInfoEXT* pDisplayPowerInfo)
{
    AEMU_SCOPED_TRACE("vkDisplayPowerControlEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkDisplayPowerControlEXT_VkResult_return = (VkResult)0;
    vkDisplayPowerControlEXT_VkResult_return = vkEnc->vkDisplayPowerControlEXT(device, display, pDisplayPowerInfo, true /* do lock */);
    return vkDisplayPowerControlEXT_VkResult_return;
}
static VkResult dynCheck_entry_vkDisplayPowerControlEXT(
    VkDevice device,
    VkDisplayKHR display,
    const VkDisplayPowerInfoEXT* pDisplayPowerInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_display_control"))
    {
        sOnInvalidDynamicallyCheckedCall("vkDisplayPowerControlEXT", "VK_EXT_display_control");
    }
    AEMU_SCOPED_TRACE("vkDisplayPowerControlEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkDisplayPowerControlEXT_VkResult_return = (VkResult)0;
    vkDisplayPowerControlEXT_VkResult_return = vkEnc->vkDisplayPowerControlEXT(device, display, pDisplayPowerInfo, true /* do lock */);
    return vkDisplayPowerControlEXT_VkResult_return;
}
static VkResult entry_vkRegisterDeviceEventEXT(
    VkDevice device,
    const VkDeviceEventInfoEXT* pDeviceEventInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    AEMU_SCOPED_TRACE("vkRegisterDeviceEventEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkRegisterDeviceEventEXT_VkResult_return = (VkResult)0;
    vkRegisterDeviceEventEXT_VkResult_return = vkEnc->vkRegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence, true /* do lock */);
    return vkRegisterDeviceEventEXT_VkResult_return;
}
static VkResult dynCheck_entry_vkRegisterDeviceEventEXT(
    VkDevice device,
    const VkDeviceEventInfoEXT* pDeviceEventInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_display_control"))
    {
        sOnInvalidDynamicallyCheckedCall("vkRegisterDeviceEventEXT", "VK_EXT_display_control");
    }
    AEMU_SCOPED_TRACE("vkRegisterDeviceEventEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkRegisterDeviceEventEXT_VkResult_return = (VkResult)0;
    vkRegisterDeviceEventEXT_VkResult_return = vkEnc->vkRegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence, true /* do lock */);
    return vkRegisterDeviceEventEXT_VkResult_return;
}
static VkResult entry_vkRegisterDisplayEventEXT(
    VkDevice device,
    VkDisplayKHR display,
    const VkDisplayEventInfoEXT* pDisplayEventInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    AEMU_SCOPED_TRACE("vkRegisterDisplayEventEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkRegisterDisplayEventEXT_VkResult_return = (VkResult)0;
    vkRegisterDisplayEventEXT_VkResult_return = vkEnc->vkRegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence, true /* do lock */);
    return vkRegisterDisplayEventEXT_VkResult_return;
}
static VkResult dynCheck_entry_vkRegisterDisplayEventEXT(
    VkDevice device,
    VkDisplayKHR display,
    const VkDisplayEventInfoEXT* pDisplayEventInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_display_control"))
    {
        sOnInvalidDynamicallyCheckedCall("vkRegisterDisplayEventEXT", "VK_EXT_display_control");
    }
    AEMU_SCOPED_TRACE("vkRegisterDisplayEventEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkRegisterDisplayEventEXT_VkResult_return = (VkResult)0;
    vkRegisterDisplayEventEXT_VkResult_return = vkEnc->vkRegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence, true /* do lock */);
    return vkRegisterDisplayEventEXT_VkResult_return;
}
static VkResult entry_vkGetSwapchainCounterEXT(
    VkDevice device,
    VkSwapchainKHR swapchain,
    VkSurfaceCounterFlagBitsEXT counter,
    uint64_t* pCounterValue)
{
    AEMU_SCOPED_TRACE("vkGetSwapchainCounterEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSwapchainCounterEXT_VkResult_return = (VkResult)0;
    vkGetSwapchainCounterEXT_VkResult_return = vkEnc->vkGetSwapchainCounterEXT(device, swapchain, counter, pCounterValue, true /* do lock */);
    return vkGetSwapchainCounterEXT_VkResult_return;
}
static VkResult dynCheck_entry_vkGetSwapchainCounterEXT(
    VkDevice device,
    VkSwapchainKHR swapchain,
    VkSurfaceCounterFlagBitsEXT counter,
    uint64_t* pCounterValue)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_display_control"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetSwapchainCounterEXT", "VK_EXT_display_control");
    }
    AEMU_SCOPED_TRACE("vkGetSwapchainCounterEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetSwapchainCounterEXT_VkResult_return = (VkResult)0;
    vkGetSwapchainCounterEXT_VkResult_return = vkEnc->vkGetSwapchainCounterEXT(device, swapchain, counter, pCounterValue, true /* do lock */);
    return vkGetSwapchainCounterEXT_VkResult_return;
}
#endif
#ifdef VK_GOOGLE_display_timing
static VkResult entry_vkGetRefreshCycleDurationGOOGLE(
    VkDevice device,
    VkSwapchainKHR swapchain,
    VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties)
{
    AEMU_SCOPED_TRACE("vkGetRefreshCycleDurationGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetRefreshCycleDurationGOOGLE_VkResult_return = (VkResult)0;
    vkGetRefreshCycleDurationGOOGLE_VkResult_return = vkEnc->vkGetRefreshCycleDurationGOOGLE(device, swapchain, pDisplayTimingProperties, true /* do lock */);
    return vkGetRefreshCycleDurationGOOGLE_VkResult_return;
}
static VkResult dynCheck_entry_vkGetRefreshCycleDurationGOOGLE(
    VkDevice device,
    VkSwapchainKHR swapchain,
    VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_display_timing"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetRefreshCycleDurationGOOGLE", "VK_GOOGLE_display_timing");
    }
    AEMU_SCOPED_TRACE("vkGetRefreshCycleDurationGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetRefreshCycleDurationGOOGLE_VkResult_return = (VkResult)0;
    vkGetRefreshCycleDurationGOOGLE_VkResult_return = vkEnc->vkGetRefreshCycleDurationGOOGLE(device, swapchain, pDisplayTimingProperties, true /* do lock */);
    return vkGetRefreshCycleDurationGOOGLE_VkResult_return;
}
static VkResult entry_vkGetPastPresentationTimingGOOGLE(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t* pPresentationTimingCount,
    VkPastPresentationTimingGOOGLE* pPresentationTimings)
{
    AEMU_SCOPED_TRACE("vkGetPastPresentationTimingGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPastPresentationTimingGOOGLE_VkResult_return = (VkResult)0;
    vkGetPastPresentationTimingGOOGLE_VkResult_return = vkEnc->vkGetPastPresentationTimingGOOGLE(device, swapchain, pPresentationTimingCount, pPresentationTimings, true /* do lock */);
    return vkGetPastPresentationTimingGOOGLE_VkResult_return;
}
static VkResult dynCheck_entry_vkGetPastPresentationTimingGOOGLE(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t* pPresentationTimingCount,
    VkPastPresentationTimingGOOGLE* pPresentationTimings)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_display_timing"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetPastPresentationTimingGOOGLE", "VK_GOOGLE_display_timing");
    }
    AEMU_SCOPED_TRACE("vkGetPastPresentationTimingGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPastPresentationTimingGOOGLE_VkResult_return = (VkResult)0;
    vkGetPastPresentationTimingGOOGLE_VkResult_return = vkEnc->vkGetPastPresentationTimingGOOGLE(device, swapchain, pPresentationTimingCount, pPresentationTimings, true /* do lock */);
    return vkGetPastPresentationTimingGOOGLE_VkResult_return;
}
#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
#endif
#ifdef VK_NV_viewport_swizzle
#endif
#ifdef VK_EXT_discard_rectangles
static void entry_vkCmdSetDiscardRectangleEXT(
    VkCommandBuffer commandBuffer,
    uint32_t firstDiscardRectangle,
    uint32_t discardRectangleCount,
    const VkRect2D* pDiscardRectangles)
{
    AEMU_SCOPED_TRACE("vkCmdSetDiscardRectangleEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles, true /* do lock */);
}
#endif
#ifdef VK_EXT_conservative_rasterization
#endif
#ifdef VK_EXT_depth_clip_enable
#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
static void entry_vkSetHdrMetadataEXT(
    VkDevice device,
    uint32_t swapchainCount,
    const VkSwapchainKHR* pSwapchains,
    const VkHdrMetadataEXT* pMetadata)
{
    AEMU_SCOPED_TRACE("vkSetHdrMetadataEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkSetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata, true /* do lock */);
}
static void dynCheck_entry_vkSetHdrMetadataEXT(
    VkDevice device,
    uint32_t swapchainCount,
    const VkSwapchainKHR* pSwapchains,
    const VkHdrMetadataEXT* pMetadata)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_hdr_metadata"))
    {
        sOnInvalidDynamicallyCheckedCall("vkSetHdrMetadataEXT", "VK_EXT_hdr_metadata");
    }
    AEMU_SCOPED_TRACE("vkSetHdrMetadataEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkSetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata, true /* do lock */);
}
#endif
#ifdef VK_MVK_ios_surface
static VkResult entry_vkCreateIOSSurfaceMVK(
    VkInstance instance,
    const VkIOSSurfaceCreateInfoMVK* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AEMU_SCOPED_TRACE("vkCreateIOSSurfaceMVK");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateIOSSurfaceMVK_VkResult_return = (VkResult)0;
    vkCreateIOSSurfaceMVK_VkResult_return = vkEnc->vkCreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface, true /* do lock */);
    return vkCreateIOSSurfaceMVK_VkResult_return;
}
#endif
#ifdef VK_MVK_macos_surface
static VkResult entry_vkCreateMacOSSurfaceMVK(
    VkInstance instance,
    const VkMacOSSurfaceCreateInfoMVK* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AEMU_SCOPED_TRACE("vkCreateMacOSSurfaceMVK");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateMacOSSurfaceMVK_VkResult_return = (VkResult)0;
    vkCreateMacOSSurfaceMVK_VkResult_return = vkEnc->vkCreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface, true /* do lock */);
    return vkCreateMacOSSurfaceMVK_VkResult_return;
}
#endif
#ifdef VK_MVK_moltenvk
static void entry_vkGetMTLDeviceMVK(
    VkPhysicalDevice physicalDevice,
    void** pMTLDevice)
{
    AEMU_SCOPED_TRACE("vkGetMTLDeviceMVK");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetMTLDeviceMVK(physicalDevice, pMTLDevice, true /* do lock */);
}
static VkResult entry_vkSetMTLTextureMVK(
    VkImage image,
    void* mtlTexture)
{
    AEMU_SCOPED_TRACE("vkSetMTLTextureMVK");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkSetMTLTextureMVK_VkResult_return = (VkResult)0;
    vkSetMTLTextureMVK_VkResult_return = vkEnc->vkSetMTLTextureMVK(image, mtlTexture, true /* do lock */);
    return vkSetMTLTextureMVK_VkResult_return;
}
static void entry_vkGetMTLTextureMVK(
    VkImage image,
    void** pMTLTexture)
{
    AEMU_SCOPED_TRACE("vkGetMTLTextureMVK");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetMTLTextureMVK(image, pMTLTexture, true /* do lock */);
}
static void entry_vkGetMTLBufferMVK(
    VkBuffer buffer,
    void** pMTLBuffer)
{
    AEMU_SCOPED_TRACE("vkGetMTLBufferMVK");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetMTLBufferMVK(buffer, pMTLBuffer, true /* do lock */);
}
static VkResult entry_vkUseIOSurfaceMVK(
    VkImage image,
    void* ioSurface)
{
    AEMU_SCOPED_TRACE("vkUseIOSurfaceMVK");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkUseIOSurfaceMVK_VkResult_return = (VkResult)0;
    vkUseIOSurfaceMVK_VkResult_return = vkEnc->vkUseIOSurfaceMVK(image, ioSurface, true /* do lock */);
    return vkUseIOSurfaceMVK_VkResult_return;
}
static void entry_vkGetIOSurfaceMVK(
    VkImage image,
    void** pIOSurface)
{
    AEMU_SCOPED_TRACE("vkGetIOSurfaceMVK");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetIOSurfaceMVK(image, pIOSurface, true /* do lock */);
}
#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
static VkResult entry_vkSetDebugUtilsObjectNameEXT(
    VkDevice device,
    const VkDebugUtilsObjectNameInfoEXT* pNameInfo)
{
    AEMU_SCOPED_TRACE("vkSetDebugUtilsObjectNameEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkSetDebugUtilsObjectNameEXT_VkResult_return = (VkResult)0;
    vkSetDebugUtilsObjectNameEXT_VkResult_return = vkEnc->vkSetDebugUtilsObjectNameEXT(device, pNameInfo, true /* do lock */);
    return vkSetDebugUtilsObjectNameEXT_VkResult_return;
}
static VkResult dynCheck_entry_vkSetDebugUtilsObjectNameEXT(
    VkDevice device,
    const VkDebugUtilsObjectNameInfoEXT* pNameInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_debug_utils"))
    {
        sOnInvalidDynamicallyCheckedCall("vkSetDebugUtilsObjectNameEXT", "VK_EXT_debug_utils");
    }
    AEMU_SCOPED_TRACE("vkSetDebugUtilsObjectNameEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkSetDebugUtilsObjectNameEXT_VkResult_return = (VkResult)0;
    vkSetDebugUtilsObjectNameEXT_VkResult_return = vkEnc->vkSetDebugUtilsObjectNameEXT(device, pNameInfo, true /* do lock */);
    return vkSetDebugUtilsObjectNameEXT_VkResult_return;
}
static VkResult entry_vkSetDebugUtilsObjectTagEXT(
    VkDevice device,
    const VkDebugUtilsObjectTagInfoEXT* pTagInfo)
{
    AEMU_SCOPED_TRACE("vkSetDebugUtilsObjectTagEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkSetDebugUtilsObjectTagEXT_VkResult_return = (VkResult)0;
    vkSetDebugUtilsObjectTagEXT_VkResult_return = vkEnc->vkSetDebugUtilsObjectTagEXT(device, pTagInfo, true /* do lock */);
    return vkSetDebugUtilsObjectTagEXT_VkResult_return;
}
static VkResult dynCheck_entry_vkSetDebugUtilsObjectTagEXT(
    VkDevice device,
    const VkDebugUtilsObjectTagInfoEXT* pTagInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_debug_utils"))
    {
        sOnInvalidDynamicallyCheckedCall("vkSetDebugUtilsObjectTagEXT", "VK_EXT_debug_utils");
    }
    AEMU_SCOPED_TRACE("vkSetDebugUtilsObjectTagEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkSetDebugUtilsObjectTagEXT_VkResult_return = (VkResult)0;
    vkSetDebugUtilsObjectTagEXT_VkResult_return = vkEnc->vkSetDebugUtilsObjectTagEXT(device, pTagInfo, true /* do lock */);
    return vkSetDebugUtilsObjectTagEXT_VkResult_return;
}
static void entry_vkQueueBeginDebugUtilsLabelEXT(
    VkQueue queue,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    AEMU_SCOPED_TRACE("vkQueueBeginDebugUtilsLabelEXT");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    vkEnc->vkQueueBeginDebugUtilsLabelEXT(queue, pLabelInfo, true /* do lock */);
}
static void entry_vkQueueEndDebugUtilsLabelEXT(
    VkQueue queue)
{
    AEMU_SCOPED_TRACE("vkQueueEndDebugUtilsLabelEXT");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    vkEnc->vkQueueEndDebugUtilsLabelEXT(queue, true /* do lock */);
}
static void entry_vkQueueInsertDebugUtilsLabelEXT(
    VkQueue queue,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    AEMU_SCOPED_TRACE("vkQueueInsertDebugUtilsLabelEXT");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    vkEnc->vkQueueInsertDebugUtilsLabelEXT(queue, pLabelInfo, true /* do lock */);
}
static void entry_vkCmdBeginDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    AEMU_SCOPED_TRACE("vkCmdBeginDebugUtilsLabelEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo, true /* do lock */);
}
static void entry_vkCmdEndDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer)
{
    AEMU_SCOPED_TRACE("vkCmdEndDebugUtilsLabelEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdEndDebugUtilsLabelEXT(commandBuffer, true /* do lock */);
}
static void entry_vkCmdInsertDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugUtilsLabelEXT* pLabelInfo)
{
    AEMU_SCOPED_TRACE("vkCmdInsertDebugUtilsLabelEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo, true /* do lock */);
}
static VkResult entry_vkCreateDebugUtilsMessengerEXT(
    VkInstance instance,
    const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDebugUtilsMessengerEXT* pMessenger)
{
    AEMU_SCOPED_TRACE("vkCreateDebugUtilsMessengerEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDebugUtilsMessengerEXT_VkResult_return = (VkResult)0;
    vkCreateDebugUtilsMessengerEXT_VkResult_return = vkEnc->vkCreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger, true /* do lock */);
    return vkCreateDebugUtilsMessengerEXT_VkResult_return;
}
static void entry_vkDestroyDebugUtilsMessengerEXT(
    VkInstance instance,
    VkDebugUtilsMessengerEXT messenger,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyDebugUtilsMessengerEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator, true /* do lock */);
}
static void entry_vkSubmitDebugUtilsMessageEXT(
    VkInstance instance,
    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT messageTypes,
    const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData)
{
    AEMU_SCOPED_TRACE("vkSubmitDebugUtilsMessageEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkSubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData, true /* do lock */);
}
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
static VkResult entry_vkGetAndroidHardwareBufferPropertiesANDROID(
    VkDevice device,
    const AHardwareBuffer* buffer,
    VkAndroidHardwareBufferPropertiesANDROID* pProperties)
{
    AEMU_SCOPED_TRACE("vkGetAndroidHardwareBufferPropertiesANDROID");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = resources->on_vkGetAndroidHardwareBufferPropertiesANDROID(vkEnc, VK_SUCCESS, device, buffer, pProperties);
    return vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return;
}
static VkResult dynCheck_entry_vkGetAndroidHardwareBufferPropertiesANDROID(
    VkDevice device,
    const AHardwareBuffer* buffer,
    VkAndroidHardwareBufferPropertiesANDROID* pProperties)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_ANDROID_external_memory_android_hardware_buffer"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetAndroidHardwareBufferPropertiesANDROID", "VK_ANDROID_external_memory_android_hardware_buffer");
    }
    AEMU_SCOPED_TRACE("vkGetAndroidHardwareBufferPropertiesANDROID");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = (VkResult)0;
    vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = resources->on_vkGetAndroidHardwareBufferPropertiesANDROID(vkEnc, VK_SUCCESS, device, buffer, pProperties);
    return vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return;
}
static VkResult entry_vkGetMemoryAndroidHardwareBufferANDROID(
    VkDevice device,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo,
    AHardwareBuffer** pBuffer)
{
    AEMU_SCOPED_TRACE("vkGetMemoryAndroidHardwareBufferANDROID");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = (VkResult)0;
    auto resources = ResourceTracker::get();
    vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = resources->on_vkGetMemoryAndroidHardwareBufferANDROID(vkEnc, VK_SUCCESS, device, pInfo, pBuffer);
    return vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return;
}
static VkResult dynCheck_entry_vkGetMemoryAndroidHardwareBufferANDROID(
    VkDevice device,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo,
    AHardwareBuffer** pBuffer)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_ANDROID_external_memory_android_hardware_buffer"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetMemoryAndroidHardwareBufferANDROID", "VK_ANDROID_external_memory_android_hardware_buffer");
    }
    AEMU_SCOPED_TRACE("vkGetMemoryAndroidHardwareBufferANDROID");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = (VkResult)0;
    vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = resources->on_vkGetMemoryAndroidHardwareBufferANDROID(vkEnc, VK_SUCCESS, device, pInfo, pBuffer);
    return vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return;
}
#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_inline_uniform_block
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
static void entry_vkCmdSetSampleLocationsEXT(
    VkCommandBuffer commandBuffer,
    const VkSampleLocationsInfoEXT* pSampleLocationsInfo)
{
    AEMU_SCOPED_TRACE("vkCmdSetSampleLocationsEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo, true /* do lock */);
}
static void entry_vkGetPhysicalDeviceMultisamplePropertiesEXT(
    VkPhysicalDevice physicalDevice,
    VkSampleCountFlagBits samples,
    VkMultisamplePropertiesEXT* pMultisampleProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceMultisamplePropertiesEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties, true /* do lock */);
}
#endif
#ifdef VK_EXT_blend_operation_advanced
#endif
#ifdef VK_NV_fragment_coverage_to_color
#endif
#ifdef VK_NV_framebuffer_mixed_samples
#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_NV_shader_sm_builtins
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_image_drm_format_modifier
static VkResult entry_vkGetImageDrmFormatModifierPropertiesEXT(
    VkDevice device,
    VkImage image,
    VkImageDrmFormatModifierPropertiesEXT* pProperties)
{
    AEMU_SCOPED_TRACE("vkGetImageDrmFormatModifierPropertiesEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return = (VkResult)0;
    vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return = vkEnc->vkGetImageDrmFormatModifierPropertiesEXT(device, image, pProperties, true /* do lock */);
    return vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return;
}
static VkResult dynCheck_entry_vkGetImageDrmFormatModifierPropertiesEXT(
    VkDevice device,
    VkImage image,
    VkImageDrmFormatModifierPropertiesEXT* pProperties)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_image_drm_format_modifier"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetImageDrmFormatModifierPropertiesEXT", "VK_EXT_image_drm_format_modifier");
    }
    AEMU_SCOPED_TRACE("vkGetImageDrmFormatModifierPropertiesEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return = (VkResult)0;
    vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return = vkEnc->vkGetImageDrmFormatModifierPropertiesEXT(device, image, pProperties, true /* do lock */);
    return vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return;
}
#endif
#ifdef VK_EXT_validation_cache
static VkResult entry_vkCreateValidationCacheEXT(
    VkDevice device,
    const VkValidationCacheCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkValidationCacheEXT* pValidationCache)
{
    AEMU_SCOPED_TRACE("vkCreateValidationCacheEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateValidationCacheEXT_VkResult_return = (VkResult)0;
    vkCreateValidationCacheEXT_VkResult_return = vkEnc->vkCreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache, true /* do lock */);
    return vkCreateValidationCacheEXT_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateValidationCacheEXT(
    VkDevice device,
    const VkValidationCacheCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkValidationCacheEXT* pValidationCache)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_validation_cache"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCreateValidationCacheEXT", "VK_EXT_validation_cache");
    }
    AEMU_SCOPED_TRACE("vkCreateValidationCacheEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateValidationCacheEXT_VkResult_return = (VkResult)0;
    vkCreateValidationCacheEXT_VkResult_return = vkEnc->vkCreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache, true /* do lock */);
    return vkCreateValidationCacheEXT_VkResult_return;
}
static void entry_vkDestroyValidationCacheEXT(
    VkDevice device,
    VkValidationCacheEXT validationCache,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyValidationCacheEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyValidationCacheEXT(device, validationCache, pAllocator, true /* do lock */);
}
static void dynCheck_entry_vkDestroyValidationCacheEXT(
    VkDevice device,
    VkValidationCacheEXT validationCache,
    const VkAllocationCallbacks* pAllocator)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_validation_cache"))
    {
        sOnInvalidDynamicallyCheckedCall("vkDestroyValidationCacheEXT", "VK_EXT_validation_cache");
    }
    AEMU_SCOPED_TRACE("vkDestroyValidationCacheEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyValidationCacheEXT(device, validationCache, pAllocator, true /* do lock */);
}
static VkResult entry_vkMergeValidationCachesEXT(
    VkDevice device,
    VkValidationCacheEXT dstCache,
    uint32_t srcCacheCount,
    const VkValidationCacheEXT* pSrcCaches)
{
    AEMU_SCOPED_TRACE("vkMergeValidationCachesEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkMergeValidationCachesEXT_VkResult_return = (VkResult)0;
    vkMergeValidationCachesEXT_VkResult_return = vkEnc->vkMergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches, true /* do lock */);
    return vkMergeValidationCachesEXT_VkResult_return;
}
static VkResult dynCheck_entry_vkMergeValidationCachesEXT(
    VkDevice device,
    VkValidationCacheEXT dstCache,
    uint32_t srcCacheCount,
    const VkValidationCacheEXT* pSrcCaches)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_validation_cache"))
    {
        sOnInvalidDynamicallyCheckedCall("vkMergeValidationCachesEXT", "VK_EXT_validation_cache");
    }
    AEMU_SCOPED_TRACE("vkMergeValidationCachesEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkMergeValidationCachesEXT_VkResult_return = (VkResult)0;
    vkMergeValidationCachesEXT_VkResult_return = vkEnc->vkMergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches, true /* do lock */);
    return vkMergeValidationCachesEXT_VkResult_return;
}
static VkResult entry_vkGetValidationCacheDataEXT(
    VkDevice device,
    VkValidationCacheEXT validationCache,
    size_t* pDataSize,
    void* pData)
{
    AEMU_SCOPED_TRACE("vkGetValidationCacheDataEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetValidationCacheDataEXT_VkResult_return = (VkResult)0;
    vkGetValidationCacheDataEXT_VkResult_return = vkEnc->vkGetValidationCacheDataEXT(device, validationCache, pDataSize, pData, true /* do lock */);
    return vkGetValidationCacheDataEXT_VkResult_return;
}
static VkResult dynCheck_entry_vkGetValidationCacheDataEXT(
    VkDevice device,
    VkValidationCacheEXT validationCache,
    size_t* pDataSize,
    void* pData)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_validation_cache"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetValidationCacheDataEXT", "VK_EXT_validation_cache");
    }
    AEMU_SCOPED_TRACE("vkGetValidationCacheDataEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetValidationCacheDataEXT_VkResult_return = (VkResult)0;
    vkGetValidationCacheDataEXT_VkResult_return = vkEnc->vkGetValidationCacheDataEXT(device, validationCache, pDataSize, pData, true /* do lock */);
    return vkGetValidationCacheDataEXT_VkResult_return;
}
#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_NV_shading_rate_image
static void entry_vkCmdBindShadingRateImageNV(
    VkCommandBuffer commandBuffer,
    VkImageView imageView,
    VkImageLayout imageLayout)
{
    AEMU_SCOPED_TRACE("vkCmdBindShadingRateImageNV");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBindShadingRateImageNV(commandBuffer, imageView, imageLayout, true /* do lock */);
}
static void entry_vkCmdSetViewportShadingRatePaletteNV(
    VkCommandBuffer commandBuffer,
    uint32_t firstViewport,
    uint32_t viewportCount,
    const VkShadingRatePaletteNV* pShadingRatePalettes)
{
    AEMU_SCOPED_TRACE("vkCmdSetViewportShadingRatePaletteNV");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes, true /* do lock */);
}
static void entry_vkCmdSetCoarseSampleOrderNV(
    VkCommandBuffer commandBuffer,
    VkCoarseSampleOrderTypeNV sampleOrderType,
    uint32_t customSampleOrderCount,
    const VkCoarseSampleOrderCustomNV* pCustomSampleOrders)
{
    AEMU_SCOPED_TRACE("vkCmdSetCoarseSampleOrderNV");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders, true /* do lock */);
}
#endif
#ifdef VK_NV_ray_tracing
static VkResult entry_vkCreateAccelerationStructureNV(
    VkDevice device,
    const VkAccelerationStructureCreateInfoNV* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkAccelerationStructureNV* pAccelerationStructure)
{
    AEMU_SCOPED_TRACE("vkCreateAccelerationStructureNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateAccelerationStructureNV_VkResult_return = (VkResult)0;
    vkCreateAccelerationStructureNV_VkResult_return = vkEnc->vkCreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure, true /* do lock */);
    return vkCreateAccelerationStructureNV_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateAccelerationStructureNV(
    VkDevice device,
    const VkAccelerationStructureCreateInfoNV* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkAccelerationStructureNV* pAccelerationStructure)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_NV_ray_tracing"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCreateAccelerationStructureNV", "VK_NV_ray_tracing");
    }
    AEMU_SCOPED_TRACE("vkCreateAccelerationStructureNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateAccelerationStructureNV_VkResult_return = (VkResult)0;
    vkCreateAccelerationStructureNV_VkResult_return = vkEnc->vkCreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure, true /* do lock */);
    return vkCreateAccelerationStructureNV_VkResult_return;
}
static void entry_vkDestroyAccelerationStructureNV(
    VkDevice device,
    VkAccelerationStructureNV accelerationStructure,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyAccelerationStructureNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyAccelerationStructureNV(device, accelerationStructure, pAllocator, true /* do lock */);
}
static void dynCheck_entry_vkDestroyAccelerationStructureNV(
    VkDevice device,
    VkAccelerationStructureNV accelerationStructure,
    const VkAllocationCallbacks* pAllocator)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_NV_ray_tracing"))
    {
        sOnInvalidDynamicallyCheckedCall("vkDestroyAccelerationStructureNV", "VK_NV_ray_tracing");
    }
    AEMU_SCOPED_TRACE("vkDestroyAccelerationStructureNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyAccelerationStructureNV(device, accelerationStructure, pAllocator, true /* do lock */);
}
static void entry_vkGetAccelerationStructureMemoryRequirementsNV(
    VkDevice device,
    const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo,
    VkMemoryRequirements2KHR* pMemoryRequirements)
{
    AEMU_SCOPED_TRACE("vkGetAccelerationStructureMemoryRequirementsNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetAccelerationStructureMemoryRequirementsNV(device, pInfo, pMemoryRequirements, true /* do lock */);
}
static void dynCheck_entry_vkGetAccelerationStructureMemoryRequirementsNV(
    VkDevice device,
    const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo,
    VkMemoryRequirements2KHR* pMemoryRequirements)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_NV_ray_tracing"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetAccelerationStructureMemoryRequirementsNV", "VK_NV_ray_tracing");
    }
    AEMU_SCOPED_TRACE("vkGetAccelerationStructureMemoryRequirementsNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetAccelerationStructureMemoryRequirementsNV(device, pInfo, pMemoryRequirements, true /* do lock */);
}
static VkResult entry_vkBindAccelerationStructureMemoryNV(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindAccelerationStructureMemoryInfoNV* pBindInfos)
{
    AEMU_SCOPED_TRACE("vkBindAccelerationStructureMemoryNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindAccelerationStructureMemoryNV_VkResult_return = (VkResult)0;
    vkBindAccelerationStructureMemoryNV_VkResult_return = vkEnc->vkBindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos, true /* do lock */);
    return vkBindAccelerationStructureMemoryNV_VkResult_return;
}
static VkResult dynCheck_entry_vkBindAccelerationStructureMemoryNV(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindAccelerationStructureMemoryInfoNV* pBindInfos)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_NV_ray_tracing"))
    {
        sOnInvalidDynamicallyCheckedCall("vkBindAccelerationStructureMemoryNV", "VK_NV_ray_tracing");
    }
    AEMU_SCOPED_TRACE("vkBindAccelerationStructureMemoryNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBindAccelerationStructureMemoryNV_VkResult_return = (VkResult)0;
    vkBindAccelerationStructureMemoryNV_VkResult_return = vkEnc->vkBindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos, true /* do lock */);
    return vkBindAccelerationStructureMemoryNV_VkResult_return;
}
static void entry_vkCmdBuildAccelerationStructureNV(
    VkCommandBuffer commandBuffer,
    const VkAccelerationStructureInfoNV* pInfo,
    VkBuffer instanceData,
    VkDeviceSize instanceOffset,
    VkBool32 update,
    VkAccelerationStructureNV dst,
    VkAccelerationStructureNV src,
    VkBuffer scratch,
    VkDeviceSize scratchOffset)
{
    AEMU_SCOPED_TRACE("vkCmdBuildAccelerationStructureNV");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset, true /* do lock */);
}
static void entry_vkCmdCopyAccelerationStructureNV(
    VkCommandBuffer commandBuffer,
    VkAccelerationStructureNV dst,
    VkAccelerationStructureNV src,
    VkCopyAccelerationStructureModeKHR mode)
{
    AEMU_SCOPED_TRACE("vkCmdCopyAccelerationStructureNV");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyAccelerationStructureNV(commandBuffer, dst, src, mode, true /* do lock */);
}
static void entry_vkCmdTraceRaysNV(
    VkCommandBuffer commandBuffer,
    VkBuffer raygenShaderBindingTableBuffer,
    VkDeviceSize raygenShaderBindingOffset,
    VkBuffer missShaderBindingTableBuffer,
    VkDeviceSize missShaderBindingOffset,
    VkDeviceSize missShaderBindingStride,
    VkBuffer hitShaderBindingTableBuffer,
    VkDeviceSize hitShaderBindingOffset,
    VkDeviceSize hitShaderBindingStride,
    VkBuffer callableShaderBindingTableBuffer,
    VkDeviceSize callableShaderBindingOffset,
    VkDeviceSize callableShaderBindingStride,
    uint32_t width,
    uint32_t height,
    uint32_t depth)
{
    AEMU_SCOPED_TRACE("vkCmdTraceRaysNV");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdTraceRaysNV(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth, true /* do lock */);
}
static VkResult entry_vkCreateRayTracingPipelinesNV(
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkRayTracingPipelineCreateInfoNV* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines)
{
    AEMU_SCOPED_TRACE("vkCreateRayTracingPipelinesNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateRayTracingPipelinesNV_VkResult_return = (VkResult)0;
    vkCreateRayTracingPipelinesNV_VkResult_return = vkEnc->vkCreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines, true /* do lock */);
    return vkCreateRayTracingPipelinesNV_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateRayTracingPipelinesNV(
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkRayTracingPipelineCreateInfoNV* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_NV_ray_tracing"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCreateRayTracingPipelinesNV", "VK_NV_ray_tracing");
    }
    AEMU_SCOPED_TRACE("vkCreateRayTracingPipelinesNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateRayTracingPipelinesNV_VkResult_return = (VkResult)0;
    vkCreateRayTracingPipelinesNV_VkResult_return = vkEnc->vkCreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines, true /* do lock */);
    return vkCreateRayTracingPipelinesNV_VkResult_return;
}
static VkResult entry_vkGetRayTracingShaderGroupHandlesKHR(
    VkDevice device,
    VkPipeline pipeline,
    uint32_t firstGroup,
    uint32_t groupCount,
    size_t dataSize,
    void* pData)
{
    AEMU_SCOPED_TRACE("vkGetRayTracingShaderGroupHandlesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetRayTracingShaderGroupHandlesKHR_VkResult_return = (VkResult)0;
    vkGetRayTracingShaderGroupHandlesKHR_VkResult_return = vkEnc->vkGetRayTracingShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData, true /* do lock */);
    return vkGetRayTracingShaderGroupHandlesKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetRayTracingShaderGroupHandlesKHR(
    VkDevice device,
    VkPipeline pipeline,
    uint32_t firstGroup,
    uint32_t groupCount,
    size_t dataSize,
    void* pData)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_NV_ray_tracing"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetRayTracingShaderGroupHandlesKHR", "VK_NV_ray_tracing");
    }
    AEMU_SCOPED_TRACE("vkGetRayTracingShaderGroupHandlesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetRayTracingShaderGroupHandlesKHR_VkResult_return = (VkResult)0;
    vkGetRayTracingShaderGroupHandlesKHR_VkResult_return = vkEnc->vkGetRayTracingShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData, true /* do lock */);
    return vkGetRayTracingShaderGroupHandlesKHR_VkResult_return;
}
static VkResult entry_vkGetRayTracingShaderGroupHandlesNV(
    VkDevice device,
    VkPipeline pipeline,
    uint32_t firstGroup,
    uint32_t groupCount,
    size_t dataSize,
    void* pData)
{
    AEMU_SCOPED_TRACE("vkGetRayTracingShaderGroupHandlesNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetRayTracingShaderGroupHandlesNV_VkResult_return = (VkResult)0;
    vkGetRayTracingShaderGroupHandlesNV_VkResult_return = vkEnc->vkGetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, dataSize, pData, true /* do lock */);
    return vkGetRayTracingShaderGroupHandlesNV_VkResult_return;
}
static VkResult dynCheck_entry_vkGetRayTracingShaderGroupHandlesNV(
    VkDevice device,
    VkPipeline pipeline,
    uint32_t firstGroup,
    uint32_t groupCount,
    size_t dataSize,
    void* pData)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_NV_ray_tracing"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetRayTracingShaderGroupHandlesNV", "VK_NV_ray_tracing");
    }
    AEMU_SCOPED_TRACE("vkGetRayTracingShaderGroupHandlesNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetRayTracingShaderGroupHandlesNV_VkResult_return = (VkResult)0;
    vkGetRayTracingShaderGroupHandlesNV_VkResult_return = vkEnc->vkGetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, dataSize, pData, true /* do lock */);
    return vkGetRayTracingShaderGroupHandlesNV_VkResult_return;
}
static VkResult entry_vkGetAccelerationStructureHandleNV(
    VkDevice device,
    VkAccelerationStructureNV accelerationStructure,
    size_t dataSize,
    void* pData)
{
    AEMU_SCOPED_TRACE("vkGetAccelerationStructureHandleNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetAccelerationStructureHandleNV_VkResult_return = (VkResult)0;
    vkGetAccelerationStructureHandleNV_VkResult_return = vkEnc->vkGetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData, true /* do lock */);
    return vkGetAccelerationStructureHandleNV_VkResult_return;
}
static VkResult dynCheck_entry_vkGetAccelerationStructureHandleNV(
    VkDevice device,
    VkAccelerationStructureNV accelerationStructure,
    size_t dataSize,
    void* pData)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_NV_ray_tracing"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetAccelerationStructureHandleNV", "VK_NV_ray_tracing");
    }
    AEMU_SCOPED_TRACE("vkGetAccelerationStructureHandleNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetAccelerationStructureHandleNV_VkResult_return = (VkResult)0;
    vkGetAccelerationStructureHandleNV_VkResult_return = vkEnc->vkGetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData, true /* do lock */);
    return vkGetAccelerationStructureHandleNV_VkResult_return;
}
static void entry_vkCmdWriteAccelerationStructuresPropertiesNV(
    VkCommandBuffer commandBuffer,
    uint32_t accelerationStructureCount,
    const VkAccelerationStructureNV* pAccelerationStructures,
    VkQueryType queryType,
    VkQueryPool queryPool,
    uint32_t firstQuery)
{
    AEMU_SCOPED_TRACE("vkCmdWriteAccelerationStructuresPropertiesNV");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery, true /* do lock */);
}
static VkResult entry_vkCompileDeferredNV(
    VkDevice device,
    VkPipeline pipeline,
    uint32_t shader)
{
    AEMU_SCOPED_TRACE("vkCompileDeferredNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCompileDeferredNV_VkResult_return = (VkResult)0;
    vkCompileDeferredNV_VkResult_return = vkEnc->vkCompileDeferredNV(device, pipeline, shader, true /* do lock */);
    return vkCompileDeferredNV_VkResult_return;
}
static VkResult dynCheck_entry_vkCompileDeferredNV(
    VkDevice device,
    VkPipeline pipeline,
    uint32_t shader)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_NV_ray_tracing"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCompileDeferredNV", "VK_NV_ray_tracing");
    }
    AEMU_SCOPED_TRACE("vkCompileDeferredNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCompileDeferredNV_VkResult_return = (VkResult)0;
    vkCompileDeferredNV_VkResult_return = vkEnc->vkCompileDeferredNV(device, pipeline, shader, true /* do lock */);
    return vkCompileDeferredNV_VkResult_return;
}
#endif
#ifdef VK_NV_representative_fragment_test
#endif
#ifdef VK_EXT_filter_cubic
#endif
#ifdef VK_QCOM_render_pass_shader_resolve
#endif
#ifdef VK_EXT_global_priority
#endif
#ifdef VK_EXT_external_memory_host
static VkResult entry_vkGetMemoryHostPointerPropertiesEXT(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    const void* pHostPointer,
    VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties)
{
    AEMU_SCOPED_TRACE("vkGetMemoryHostPointerPropertiesEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryHostPointerPropertiesEXT_VkResult_return = (VkResult)0;
    vkGetMemoryHostPointerPropertiesEXT_VkResult_return = vkEnc->vkGetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties, true /* do lock */);
    return vkGetMemoryHostPointerPropertiesEXT_VkResult_return;
}
static VkResult dynCheck_entry_vkGetMemoryHostPointerPropertiesEXT(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    const void* pHostPointer,
    VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_external_memory_host"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetMemoryHostPointerPropertiesEXT", "VK_EXT_external_memory_host");
    }
    AEMU_SCOPED_TRACE("vkGetMemoryHostPointerPropertiesEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryHostPointerPropertiesEXT_VkResult_return = (VkResult)0;
    vkGetMemoryHostPointerPropertiesEXT_VkResult_return = vkEnc->vkGetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties, true /* do lock */);
    return vkGetMemoryHostPointerPropertiesEXT_VkResult_return;
}
#endif
#ifdef VK_AMD_buffer_marker
static void entry_vkCmdWriteBufferMarkerAMD(
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    uint32_t marker)
{
    AEMU_SCOPED_TRACE("vkCmdWriteBufferMarkerAMD");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker, true /* do lock */);
}
#endif
#ifdef VK_AMD_pipeline_compiler_control
#endif
#ifdef VK_EXT_calibrated_timestamps
static VkResult entry_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(
    VkPhysicalDevice physicalDevice,
    uint32_t* pTimeDomainCount,
    VkTimeDomainEXT* pTimeDomains)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceCalibrateableTimeDomainsEXT_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceCalibrateableTimeDomainsEXT_VkResult_return = vkEnc->vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains, true /* do lock */);
    return vkGetPhysicalDeviceCalibrateableTimeDomainsEXT_VkResult_return;
}
static VkResult entry_vkGetCalibratedTimestampsEXT(
    VkDevice device,
    uint32_t timestampCount,
    const VkCalibratedTimestampInfoEXT* pTimestampInfos,
    uint64_t* pTimestamps,
    uint64_t* pMaxDeviation)
{
    AEMU_SCOPED_TRACE("vkGetCalibratedTimestampsEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetCalibratedTimestampsEXT_VkResult_return = (VkResult)0;
    vkGetCalibratedTimestampsEXT_VkResult_return = vkEnc->vkGetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation, true /* do lock */);
    return vkGetCalibratedTimestampsEXT_VkResult_return;
}
static VkResult dynCheck_entry_vkGetCalibratedTimestampsEXT(
    VkDevice device,
    uint32_t timestampCount,
    const VkCalibratedTimestampInfoEXT* pTimestampInfos,
    uint64_t* pTimestamps,
    uint64_t* pMaxDeviation)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_calibrated_timestamps"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetCalibratedTimestampsEXT", "VK_EXT_calibrated_timestamps");
    }
    AEMU_SCOPED_TRACE("vkGetCalibratedTimestampsEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetCalibratedTimestampsEXT_VkResult_return = (VkResult)0;
    vkGetCalibratedTimestampsEXT_VkResult_return = vkEnc->vkGetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation, true /* do lock */);
    return vkGetCalibratedTimestampsEXT_VkResult_return;
}
#endif
#ifdef VK_AMD_shader_core_properties
#endif
#ifdef VK_AMD_memory_overallocation_behavior
#endif
#ifdef VK_EXT_vertex_attribute_divisor
#endif
#ifdef VK_GGP_frame_token
#endif
#ifdef VK_EXT_pipeline_creation_feedback
#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_compute_shader_derivatives
#endif
#ifdef VK_NV_mesh_shader
static void entry_vkCmdDrawMeshTasksNV(
    VkCommandBuffer commandBuffer,
    uint32_t taskCount,
    uint32_t firstTask)
{
    AEMU_SCOPED_TRACE("vkCmdDrawMeshTasksNV");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawMeshTasksNV(commandBuffer, taskCount, firstTask, true /* do lock */);
}
static void entry_vkCmdDrawMeshTasksIndirectNV(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t drawCount,
    uint32_t stride)
{
    AEMU_SCOPED_TRACE("vkCmdDrawMeshTasksIndirectNV");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawMeshTasksIndirectNV(commandBuffer, buffer, offset, drawCount, stride, true /* do lock */);
}
static void entry_vkCmdDrawMeshTasksIndirectCountNV(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride)
{
    AEMU_SCOPED_TRACE("vkCmdDrawMeshTasksIndirectCountNV");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdDrawMeshTasksIndirectCountNV(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride, true /* do lock */);
}
#endif
#ifdef VK_NV_fragment_shader_barycentric
#endif
#ifdef VK_NV_shader_image_footprint
#endif
#ifdef VK_NV_scissor_exclusive
static void entry_vkCmdSetExclusiveScissorNV(
    VkCommandBuffer commandBuffer,
    uint32_t firstExclusiveScissor,
    uint32_t exclusiveScissorCount,
    const VkRect2D* pExclusiveScissors)
{
    AEMU_SCOPED_TRACE("vkCmdSetExclusiveScissorNV");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors, true /* do lock */);
}
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
static void entry_vkCmdSetCheckpointNV(
    VkCommandBuffer commandBuffer,
    const void* pCheckpointMarker)
{
    AEMU_SCOPED_TRACE("vkCmdSetCheckpointNV");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetCheckpointNV(commandBuffer, pCheckpointMarker, true /* do lock */);
}
static void entry_vkGetQueueCheckpointDataNV(
    VkQueue queue,
    uint32_t* pCheckpointDataCount,
    VkCheckpointDataNV* pCheckpointData)
{
    AEMU_SCOPED_TRACE("vkGetQueueCheckpointDataNV");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    vkEnc->vkGetQueueCheckpointDataNV(queue, pCheckpointDataCount, pCheckpointData, true /* do lock */);
}
#endif
#ifdef VK_INTEL_shader_integer_functions2
#endif
#ifdef VK_INTEL_performance_query
static VkResult entry_vkInitializePerformanceApiINTEL(
    VkDevice device,
    const VkInitializePerformanceApiInfoINTEL* pInitializeInfo)
{
    AEMU_SCOPED_TRACE("vkInitializePerformanceApiINTEL");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkInitializePerformanceApiINTEL_VkResult_return = (VkResult)0;
    vkInitializePerformanceApiINTEL_VkResult_return = vkEnc->vkInitializePerformanceApiINTEL(device, pInitializeInfo, true /* do lock */);
    return vkInitializePerformanceApiINTEL_VkResult_return;
}
static VkResult dynCheck_entry_vkInitializePerformanceApiINTEL(
    VkDevice device,
    const VkInitializePerformanceApiInfoINTEL* pInitializeInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_INTEL_performance_query"))
    {
        sOnInvalidDynamicallyCheckedCall("vkInitializePerformanceApiINTEL", "VK_INTEL_performance_query");
    }
    AEMU_SCOPED_TRACE("vkInitializePerformanceApiINTEL");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkInitializePerformanceApiINTEL_VkResult_return = (VkResult)0;
    vkInitializePerformanceApiINTEL_VkResult_return = vkEnc->vkInitializePerformanceApiINTEL(device, pInitializeInfo, true /* do lock */);
    return vkInitializePerformanceApiINTEL_VkResult_return;
}
static void entry_vkUninitializePerformanceApiINTEL(
    VkDevice device)
{
    AEMU_SCOPED_TRACE("vkUninitializePerformanceApiINTEL");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkUninitializePerformanceApiINTEL(device, true /* do lock */);
}
static void dynCheck_entry_vkUninitializePerformanceApiINTEL(
    VkDevice device)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_INTEL_performance_query"))
    {
        sOnInvalidDynamicallyCheckedCall("vkUninitializePerformanceApiINTEL", "VK_INTEL_performance_query");
    }
    AEMU_SCOPED_TRACE("vkUninitializePerformanceApiINTEL");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkUninitializePerformanceApiINTEL(device, true /* do lock */);
}
static VkResult entry_vkCmdSetPerformanceMarkerINTEL(
    VkCommandBuffer commandBuffer,
    const VkPerformanceMarkerInfoINTEL* pMarkerInfo)
{
    AEMU_SCOPED_TRACE("vkCmdSetPerformanceMarkerINTEL");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    VkResult vkCmdSetPerformanceMarkerINTEL_VkResult_return = (VkResult)0;
    vkCmdSetPerformanceMarkerINTEL_VkResult_return = vkEnc->vkCmdSetPerformanceMarkerINTEL(commandBuffer, pMarkerInfo, true /* do lock */);
    return vkCmdSetPerformanceMarkerINTEL_VkResult_return;
}
static VkResult entry_vkCmdSetPerformanceStreamMarkerINTEL(
    VkCommandBuffer commandBuffer,
    const VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo)
{
    AEMU_SCOPED_TRACE("vkCmdSetPerformanceStreamMarkerINTEL");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    VkResult vkCmdSetPerformanceStreamMarkerINTEL_VkResult_return = (VkResult)0;
    vkCmdSetPerformanceStreamMarkerINTEL_VkResult_return = vkEnc->vkCmdSetPerformanceStreamMarkerINTEL(commandBuffer, pMarkerInfo, true /* do lock */);
    return vkCmdSetPerformanceStreamMarkerINTEL_VkResult_return;
}
static VkResult entry_vkCmdSetPerformanceOverrideINTEL(
    VkCommandBuffer commandBuffer,
    const VkPerformanceOverrideInfoINTEL* pOverrideInfo)
{
    AEMU_SCOPED_TRACE("vkCmdSetPerformanceOverrideINTEL");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    VkResult vkCmdSetPerformanceOverrideINTEL_VkResult_return = (VkResult)0;
    vkCmdSetPerformanceOverrideINTEL_VkResult_return = vkEnc->vkCmdSetPerformanceOverrideINTEL(commandBuffer, pOverrideInfo, true /* do lock */);
    return vkCmdSetPerformanceOverrideINTEL_VkResult_return;
}
static VkResult entry_vkAcquirePerformanceConfigurationINTEL(
    VkDevice device,
    const VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo,
    VkPerformanceConfigurationINTEL* pConfiguration)
{
    AEMU_SCOPED_TRACE("vkAcquirePerformanceConfigurationINTEL");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAcquirePerformanceConfigurationINTEL_VkResult_return = (VkResult)0;
    vkAcquirePerformanceConfigurationINTEL_VkResult_return = vkEnc->vkAcquirePerformanceConfigurationINTEL(device, pAcquireInfo, pConfiguration, true /* do lock */);
    return vkAcquirePerformanceConfigurationINTEL_VkResult_return;
}
static VkResult dynCheck_entry_vkAcquirePerformanceConfigurationINTEL(
    VkDevice device,
    const VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo,
    VkPerformanceConfigurationINTEL* pConfiguration)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_INTEL_performance_query"))
    {
        sOnInvalidDynamicallyCheckedCall("vkAcquirePerformanceConfigurationINTEL", "VK_INTEL_performance_query");
    }
    AEMU_SCOPED_TRACE("vkAcquirePerformanceConfigurationINTEL");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAcquirePerformanceConfigurationINTEL_VkResult_return = (VkResult)0;
    vkAcquirePerformanceConfigurationINTEL_VkResult_return = vkEnc->vkAcquirePerformanceConfigurationINTEL(device, pAcquireInfo, pConfiguration, true /* do lock */);
    return vkAcquirePerformanceConfigurationINTEL_VkResult_return;
}
static VkResult entry_vkReleasePerformanceConfigurationINTEL(
    VkDevice device,
    VkPerformanceConfigurationINTEL configuration)
{
    AEMU_SCOPED_TRACE("vkReleasePerformanceConfigurationINTEL");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkReleasePerformanceConfigurationINTEL_VkResult_return = (VkResult)0;
    vkReleasePerformanceConfigurationINTEL_VkResult_return = vkEnc->vkReleasePerformanceConfigurationINTEL(device, configuration, true /* do lock */);
    return vkReleasePerformanceConfigurationINTEL_VkResult_return;
}
static VkResult dynCheck_entry_vkReleasePerformanceConfigurationINTEL(
    VkDevice device,
    VkPerformanceConfigurationINTEL configuration)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_INTEL_performance_query"))
    {
        sOnInvalidDynamicallyCheckedCall("vkReleasePerformanceConfigurationINTEL", "VK_INTEL_performance_query");
    }
    AEMU_SCOPED_TRACE("vkReleasePerformanceConfigurationINTEL");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkReleasePerformanceConfigurationINTEL_VkResult_return = (VkResult)0;
    vkReleasePerformanceConfigurationINTEL_VkResult_return = vkEnc->vkReleasePerformanceConfigurationINTEL(device, configuration, true /* do lock */);
    return vkReleasePerformanceConfigurationINTEL_VkResult_return;
}
static VkResult entry_vkQueueSetPerformanceConfigurationINTEL(
    VkQueue queue,
    VkPerformanceConfigurationINTEL configuration)
{
    AEMU_SCOPED_TRACE("vkQueueSetPerformanceConfigurationINTEL");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    VkResult vkQueueSetPerformanceConfigurationINTEL_VkResult_return = (VkResult)0;
    vkQueueSetPerformanceConfigurationINTEL_VkResult_return = vkEnc->vkQueueSetPerformanceConfigurationINTEL(queue, configuration, true /* do lock */);
    return vkQueueSetPerformanceConfigurationINTEL_VkResult_return;
}
static VkResult entry_vkGetPerformanceParameterINTEL(
    VkDevice device,
    VkPerformanceParameterTypeINTEL parameter,
    VkPerformanceValueINTEL* pValue)
{
    AEMU_SCOPED_TRACE("vkGetPerformanceParameterINTEL");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPerformanceParameterINTEL_VkResult_return = (VkResult)0;
    vkGetPerformanceParameterINTEL_VkResult_return = vkEnc->vkGetPerformanceParameterINTEL(device, parameter, pValue, true /* do lock */);
    return vkGetPerformanceParameterINTEL_VkResult_return;
}
static VkResult dynCheck_entry_vkGetPerformanceParameterINTEL(
    VkDevice device,
    VkPerformanceParameterTypeINTEL parameter,
    VkPerformanceValueINTEL* pValue)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_INTEL_performance_query"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetPerformanceParameterINTEL", "VK_INTEL_performance_query");
    }
    AEMU_SCOPED_TRACE("vkGetPerformanceParameterINTEL");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPerformanceParameterINTEL_VkResult_return = (VkResult)0;
    vkGetPerformanceParameterINTEL_VkResult_return = vkEnc->vkGetPerformanceParameterINTEL(device, parameter, pValue, true /* do lock */);
    return vkGetPerformanceParameterINTEL_VkResult_return;
}
#endif
#ifdef VK_EXT_pci_bus_info
#endif
#ifdef VK_AMD_display_native_hdr
static void entry_vkSetLocalDimmingAMD(
    VkDevice device,
    VkSwapchainKHR swapChain,
    VkBool32 localDimmingEnable)
{
    AEMU_SCOPED_TRACE("vkSetLocalDimmingAMD");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkSetLocalDimmingAMD(device, swapChain, localDimmingEnable, true /* do lock */);
}
static void dynCheck_entry_vkSetLocalDimmingAMD(
    VkDevice device,
    VkSwapchainKHR swapChain,
    VkBool32 localDimmingEnable)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_AMD_display_native_hdr"))
    {
        sOnInvalidDynamicallyCheckedCall("vkSetLocalDimmingAMD", "VK_AMD_display_native_hdr");
    }
    AEMU_SCOPED_TRACE("vkSetLocalDimmingAMD");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkSetLocalDimmingAMD(device, swapChain, localDimmingEnable, true /* do lock */);
}
#endif
#ifdef VK_FUCHSIA_imagepipe_surface
static VkResult entry_vkCreateImagePipeSurfaceFUCHSIA(
    VkInstance instance,
    const VkImagePipeSurfaceCreateInfoFUCHSIA* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AEMU_SCOPED_TRACE("vkCreateImagePipeSurfaceFUCHSIA");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateImagePipeSurfaceFUCHSIA_VkResult_return = (VkResult)0;
    vkCreateImagePipeSurfaceFUCHSIA_VkResult_return = vkEnc->vkCreateImagePipeSurfaceFUCHSIA(instance, pCreateInfo, pAllocator, pSurface, true /* do lock */);
    return vkCreateImagePipeSurfaceFUCHSIA_VkResult_return;
}
#endif
#ifdef VK_EXT_metal_surface
static VkResult entry_vkCreateMetalSurfaceEXT(
    VkInstance instance,
    const VkMetalSurfaceCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AEMU_SCOPED_TRACE("vkCreateMetalSurfaceEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateMetalSurfaceEXT_VkResult_return = (VkResult)0;
    vkCreateMetalSurfaceEXT_VkResult_return = vkEnc->vkCreateMetalSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface, true /* do lock */);
    return vkCreateMetalSurfaceEXT_VkResult_return;
}
#endif
#ifdef VK_EXT_fragment_density_map
#endif
#ifdef VK_EXT_scalar_block_layout
#endif
#ifdef VK_GOOGLE_hlsl_functionality1
#endif
#ifdef VK_GOOGLE_decorate_string
#endif
#ifdef VK_EXT_subgroup_size_control
#endif
#ifdef VK_AMD_shader_core_properties2
#endif
#ifdef VK_AMD_device_coherent_memory
#endif
#ifdef VK_EXT_shader_image_atomic_int64
#endif
#ifdef VK_EXT_memory_budget
#endif
#ifdef VK_EXT_memory_priority
#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
#endif
#ifdef VK_EXT_buffer_device_address
static VkDeviceAddress entry_vkGetBufferDeviceAddressEXT(
    VkDevice device,
    const VkBufferDeviceAddressInfo* pInfo)
{
    AEMU_SCOPED_TRACE("vkGetBufferDeviceAddressEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkDeviceAddress vkGetBufferDeviceAddressEXT_VkDeviceAddress_return = (VkDeviceAddress)0;
    vkGetBufferDeviceAddressEXT_VkDeviceAddress_return = vkEnc->vkGetBufferDeviceAddressEXT(device, pInfo, true /* do lock */);
    return vkGetBufferDeviceAddressEXT_VkDeviceAddress_return;
}
static VkDeviceAddress dynCheck_entry_vkGetBufferDeviceAddressEXT(
    VkDevice device,
    const VkBufferDeviceAddressInfo* pInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_buffer_device_address"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetBufferDeviceAddressEXT", "VK_EXT_buffer_device_address");
    }
    AEMU_SCOPED_TRACE("vkGetBufferDeviceAddressEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkDeviceAddress vkGetBufferDeviceAddressEXT_VkDeviceAddress_return = (VkDeviceAddress)0;
    vkGetBufferDeviceAddressEXT_VkDeviceAddress_return = vkEnc->vkGetBufferDeviceAddressEXT(device, pInfo, true /* do lock */);
    return vkGetBufferDeviceAddressEXT_VkDeviceAddress_return;
}
#endif
#ifdef VK_EXT_tooling_info
static VkResult entry_vkGetPhysicalDeviceToolPropertiesEXT(
    VkPhysicalDevice physicalDevice,
    uint32_t* pToolCount,
    VkPhysicalDeviceToolPropertiesEXT* pToolProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceToolPropertiesEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return = vkEnc->vkGetPhysicalDeviceToolPropertiesEXT(physicalDevice, pToolCount, pToolProperties, true /* do lock */);
    return vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return;
}
#endif
#ifdef VK_EXT_separate_stencil_usage
#endif
#ifdef VK_EXT_validation_features
#endif
#ifdef VK_NV_cooperative_matrix
static VkResult entry_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkCooperativeMatrixPropertiesNV* pProperties)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceCooperativeMatrixPropertiesNV_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceCooperativeMatrixPropertiesNV_VkResult_return = vkEnc->vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties, true /* do lock */);
    return vkGetPhysicalDeviceCooperativeMatrixPropertiesNV_VkResult_return;
}
#endif
#ifdef VK_NV_coverage_reduction_mode
static VkResult entry_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(
    VkPhysicalDevice physicalDevice,
    uint32_t* pCombinationCount,
    VkFramebufferMixedSamplesCombinationNV* pCombinations)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV_VkResult_return = vkEnc->vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount, pCombinations, true /* do lock */);
    return vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV_VkResult_return;
}
#endif
#ifdef VK_EXT_fragment_shader_interlock
#endif
#ifdef VK_EXT_ycbcr_image_arrays
#endif
#ifdef VK_EXT_full_screen_exclusive
static VkResult entry_vkGetPhysicalDeviceSurfacePresentModes2EXT(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    uint32_t* pPresentModeCount,
    VkPresentModeKHR* pPresentModes)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceSurfacePresentModes2EXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetPhysicalDeviceSurfacePresentModes2EXT_VkResult_return = (VkResult)0;
    vkGetPhysicalDeviceSurfacePresentModes2EXT_VkResult_return = vkEnc->vkGetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes, true /* do lock */);
    return vkGetPhysicalDeviceSurfacePresentModes2EXT_VkResult_return;
}
static VkResult entry_vkAcquireFullScreenExclusiveModeEXT(
    VkDevice device,
    VkSwapchainKHR swapchain)
{
    AEMU_SCOPED_TRACE("vkAcquireFullScreenExclusiveModeEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAcquireFullScreenExclusiveModeEXT_VkResult_return = (VkResult)0;
    vkAcquireFullScreenExclusiveModeEXT_VkResult_return = vkEnc->vkAcquireFullScreenExclusiveModeEXT(device, swapchain, true /* do lock */);
    return vkAcquireFullScreenExclusiveModeEXT_VkResult_return;
}
static VkResult dynCheck_entry_vkAcquireFullScreenExclusiveModeEXT(
    VkDevice device,
    VkSwapchainKHR swapchain)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_full_screen_exclusive"))
    {
        sOnInvalidDynamicallyCheckedCall("vkAcquireFullScreenExclusiveModeEXT", "VK_EXT_full_screen_exclusive");
    }
    AEMU_SCOPED_TRACE("vkAcquireFullScreenExclusiveModeEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkAcquireFullScreenExclusiveModeEXT_VkResult_return = (VkResult)0;
    vkAcquireFullScreenExclusiveModeEXT_VkResult_return = vkEnc->vkAcquireFullScreenExclusiveModeEXT(device, swapchain, true /* do lock */);
    return vkAcquireFullScreenExclusiveModeEXT_VkResult_return;
}
static VkResult entry_vkReleaseFullScreenExclusiveModeEXT(
    VkDevice device,
    VkSwapchainKHR swapchain)
{
    AEMU_SCOPED_TRACE("vkReleaseFullScreenExclusiveModeEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkReleaseFullScreenExclusiveModeEXT_VkResult_return = (VkResult)0;
    vkReleaseFullScreenExclusiveModeEXT_VkResult_return = vkEnc->vkReleaseFullScreenExclusiveModeEXT(device, swapchain, true /* do lock */);
    return vkReleaseFullScreenExclusiveModeEXT_VkResult_return;
}
static VkResult dynCheck_entry_vkReleaseFullScreenExclusiveModeEXT(
    VkDevice device,
    VkSwapchainKHR swapchain)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_full_screen_exclusive"))
    {
        sOnInvalidDynamicallyCheckedCall("vkReleaseFullScreenExclusiveModeEXT", "VK_EXT_full_screen_exclusive");
    }
    AEMU_SCOPED_TRACE("vkReleaseFullScreenExclusiveModeEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkReleaseFullScreenExclusiveModeEXT_VkResult_return = (VkResult)0;
    vkReleaseFullScreenExclusiveModeEXT_VkResult_return = vkEnc->vkReleaseFullScreenExclusiveModeEXT(device, swapchain, true /* do lock */);
    return vkReleaseFullScreenExclusiveModeEXT_VkResult_return;
}
static VkResult entry_vkGetDeviceGroupSurfacePresentModes2EXT(
    VkDevice device,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    VkDeviceGroupPresentModeFlagsKHR* pModes)
{
    AEMU_SCOPED_TRACE("vkGetDeviceGroupSurfacePresentModes2EXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetDeviceGroupSurfacePresentModes2EXT_VkResult_return = (VkResult)0;
    vkGetDeviceGroupSurfacePresentModes2EXT_VkResult_return = vkEnc->vkGetDeviceGroupSurfacePresentModes2EXT(device, pSurfaceInfo, pModes, true /* do lock */);
    return vkGetDeviceGroupSurfacePresentModes2EXT_VkResult_return;
}
static VkResult dynCheck_entry_vkGetDeviceGroupSurfacePresentModes2EXT(
    VkDevice device,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    VkDeviceGroupPresentModeFlagsKHR* pModes)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_full_screen_exclusive"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetDeviceGroupSurfacePresentModes2EXT", "VK_EXT_full_screen_exclusive");
    }
    AEMU_SCOPED_TRACE("vkGetDeviceGroupSurfacePresentModes2EXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetDeviceGroupSurfacePresentModes2EXT_VkResult_return = (VkResult)0;
    vkGetDeviceGroupSurfacePresentModes2EXT_VkResult_return = vkEnc->vkGetDeviceGroupSurfacePresentModes2EXT(device, pSurfaceInfo, pModes, true /* do lock */);
    return vkGetDeviceGroupSurfacePresentModes2EXT_VkResult_return;
}
#endif
#ifdef VK_EXT_headless_surface
static VkResult entry_vkCreateHeadlessSurfaceEXT(
    VkInstance instance,
    const VkHeadlessSurfaceCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AEMU_SCOPED_TRACE("vkCreateHeadlessSurfaceEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateHeadlessSurfaceEXT_VkResult_return = (VkResult)0;
    vkCreateHeadlessSurfaceEXT_VkResult_return = vkEnc->vkCreateHeadlessSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface, true /* do lock */);
    return vkCreateHeadlessSurfaceEXT_VkResult_return;
}
#endif
#ifdef VK_EXT_line_rasterization
static void entry_vkCmdSetLineStippleEXT(
    VkCommandBuffer commandBuffer,
    uint32_t lineStippleFactor,
    uint16_t lineStipplePattern)
{
    AEMU_SCOPED_TRACE("vkCmdSetLineStippleEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern, true /* do lock */);
}
#endif
#ifdef VK_EXT_shader_atomic_float
#endif
#ifdef VK_EXT_host_query_reset
static void entry_vkResetQueryPoolEXT(
    VkDevice device,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount)
{
    AEMU_SCOPED_TRACE("vkResetQueryPoolEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkResetQueryPoolEXT(device, queryPool, firstQuery, queryCount, true /* do lock */);
}
static void dynCheck_entry_vkResetQueryPoolEXT(
    VkDevice device,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_host_query_reset"))
    {
        sOnInvalidDynamicallyCheckedCall("vkResetQueryPoolEXT", "VK_EXT_host_query_reset");
    }
    AEMU_SCOPED_TRACE("vkResetQueryPoolEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkResetQueryPoolEXT(device, queryPool, firstQuery, queryCount, true /* do lock */);
}
#endif
#ifdef VK_EXT_index_type_uint8
#endif
#ifdef VK_EXT_extended_dynamic_state
static void entry_vkCmdSetCullModeEXT(
    VkCommandBuffer commandBuffer,
    VkCullModeFlags cullMode)
{
    AEMU_SCOPED_TRACE("vkCmdSetCullModeEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetCullModeEXT(commandBuffer, cullMode, true /* do lock */);
}
static void entry_vkCmdSetFrontFaceEXT(
    VkCommandBuffer commandBuffer,
    VkFrontFace frontFace)
{
    AEMU_SCOPED_TRACE("vkCmdSetFrontFaceEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetFrontFaceEXT(commandBuffer, frontFace, true /* do lock */);
}
static void entry_vkCmdSetPrimitiveTopologyEXT(
    VkCommandBuffer commandBuffer,
    VkPrimitiveTopology primitiveTopology)
{
    AEMU_SCOPED_TRACE("vkCmdSetPrimitiveTopologyEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetPrimitiveTopologyEXT(commandBuffer, primitiveTopology, true /* do lock */);
}
static void entry_vkCmdSetViewportWithCountEXT(
    VkCommandBuffer commandBuffer,
    uint32_t viewportCount,
    const VkViewport* pViewports)
{
    AEMU_SCOPED_TRACE("vkCmdSetViewportWithCountEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetViewportWithCountEXT(commandBuffer, viewportCount, pViewports, true /* do lock */);
}
static void entry_vkCmdSetScissorWithCountEXT(
    VkCommandBuffer commandBuffer,
    uint32_t scissorCount,
    const VkRect2D* pScissors)
{
    AEMU_SCOPED_TRACE("vkCmdSetScissorWithCountEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetScissorWithCountEXT(commandBuffer, scissorCount, pScissors, true /* do lock */);
}
static void entry_vkCmdBindVertexBuffers2EXT(
    VkCommandBuffer commandBuffer,
    uint32_t firstBinding,
    uint32_t bindingCount,
    const VkBuffer* pBuffers,
    const VkDeviceSize* pOffsets,
    const VkDeviceSize* pSizes,
    const VkDeviceSize* pStrides)
{
    AEMU_SCOPED_TRACE("vkCmdBindVertexBuffers2EXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBindVertexBuffers2EXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides, true /* do lock */);
}
static void entry_vkCmdSetDepthTestEnableEXT(
    VkCommandBuffer commandBuffer,
    VkBool32 depthTestEnable)
{
    AEMU_SCOPED_TRACE("vkCmdSetDepthTestEnableEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetDepthTestEnableEXT(commandBuffer, depthTestEnable, true /* do lock */);
}
static void entry_vkCmdSetDepthWriteEnableEXT(
    VkCommandBuffer commandBuffer,
    VkBool32 depthWriteEnable)
{
    AEMU_SCOPED_TRACE("vkCmdSetDepthWriteEnableEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetDepthWriteEnableEXT(commandBuffer, depthWriteEnable, true /* do lock */);
}
static void entry_vkCmdSetDepthCompareOpEXT(
    VkCommandBuffer commandBuffer,
    VkCompareOp depthCompareOp)
{
    AEMU_SCOPED_TRACE("vkCmdSetDepthCompareOpEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetDepthCompareOpEXT(commandBuffer, depthCompareOp, true /* do lock */);
}
static void entry_vkCmdSetDepthBoundsTestEnableEXT(
    VkCommandBuffer commandBuffer,
    VkBool32 depthBoundsTestEnable)
{
    AEMU_SCOPED_TRACE("vkCmdSetDepthBoundsTestEnableEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetDepthBoundsTestEnableEXT(commandBuffer, depthBoundsTestEnable, true /* do lock */);
}
static void entry_vkCmdSetStencilTestEnableEXT(
    VkCommandBuffer commandBuffer,
    VkBool32 stencilTestEnable)
{
    AEMU_SCOPED_TRACE("vkCmdSetStencilTestEnableEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetStencilTestEnableEXT(commandBuffer, stencilTestEnable, true /* do lock */);
}
static void entry_vkCmdSetStencilOpEXT(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    VkStencilOp failOp,
    VkStencilOp passOp,
    VkStencilOp depthFailOp,
    VkCompareOp compareOp)
{
    AEMU_SCOPED_TRACE("vkCmdSetStencilOpEXT");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetStencilOpEXT(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp, true /* do lock */);
}
#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
#endif
#ifdef VK_NV_device_generated_commands
static void entry_vkGetGeneratedCommandsMemoryRequirementsNV(
    VkDevice device,
    const VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    AEMU_SCOPED_TRACE("vkGetGeneratedCommandsMemoryRequirementsNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetGeneratedCommandsMemoryRequirementsNV(device, pInfo, pMemoryRequirements, true /* do lock */);
}
static void dynCheck_entry_vkGetGeneratedCommandsMemoryRequirementsNV(
    VkDevice device,
    const VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo,
    VkMemoryRequirements2* pMemoryRequirements)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_NV_device_generated_commands"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetGeneratedCommandsMemoryRequirementsNV", "VK_NV_device_generated_commands");
    }
    AEMU_SCOPED_TRACE("vkGetGeneratedCommandsMemoryRequirementsNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetGeneratedCommandsMemoryRequirementsNV(device, pInfo, pMemoryRequirements, true /* do lock */);
}
static void entry_vkCmdPreprocessGeneratedCommandsNV(
    VkCommandBuffer commandBuffer,
    const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo)
{
    AEMU_SCOPED_TRACE("vkCmdPreprocessGeneratedCommandsNV");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdPreprocessGeneratedCommandsNV(commandBuffer, pGeneratedCommandsInfo, true /* do lock */);
}
static void entry_vkCmdExecuteGeneratedCommandsNV(
    VkCommandBuffer commandBuffer,
    VkBool32 isPreprocessed,
    const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo)
{
    AEMU_SCOPED_TRACE("vkCmdExecuteGeneratedCommandsNV");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdExecuteGeneratedCommandsNV(commandBuffer, isPreprocessed, pGeneratedCommandsInfo, true /* do lock */);
}
static void entry_vkCmdBindPipelineShaderGroupNV(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipeline pipeline,
    uint32_t groupIndex)
{
    AEMU_SCOPED_TRACE("vkCmdBindPipelineShaderGroupNV");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBindPipelineShaderGroupNV(commandBuffer, pipelineBindPoint, pipeline, groupIndex, true /* do lock */);
}
static VkResult entry_vkCreateIndirectCommandsLayoutNV(
    VkDevice device,
    const VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkIndirectCommandsLayoutNV* pIndirectCommandsLayout)
{
    AEMU_SCOPED_TRACE("vkCreateIndirectCommandsLayoutNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateIndirectCommandsLayoutNV_VkResult_return = (VkResult)0;
    vkCreateIndirectCommandsLayoutNV_VkResult_return = vkEnc->vkCreateIndirectCommandsLayoutNV(device, pCreateInfo, pAllocator, pIndirectCommandsLayout, true /* do lock */);
    return vkCreateIndirectCommandsLayoutNV_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateIndirectCommandsLayoutNV(
    VkDevice device,
    const VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkIndirectCommandsLayoutNV* pIndirectCommandsLayout)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_NV_device_generated_commands"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCreateIndirectCommandsLayoutNV", "VK_NV_device_generated_commands");
    }
    AEMU_SCOPED_TRACE("vkCreateIndirectCommandsLayoutNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateIndirectCommandsLayoutNV_VkResult_return = (VkResult)0;
    vkCreateIndirectCommandsLayoutNV_VkResult_return = vkEnc->vkCreateIndirectCommandsLayoutNV(device, pCreateInfo, pAllocator, pIndirectCommandsLayout, true /* do lock */);
    return vkCreateIndirectCommandsLayoutNV_VkResult_return;
}
static void entry_vkDestroyIndirectCommandsLayoutNV(
    VkDevice device,
    VkIndirectCommandsLayoutNV indirectCommandsLayout,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyIndirectCommandsLayoutNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyIndirectCommandsLayoutNV(device, indirectCommandsLayout, pAllocator, true /* do lock */);
}
static void dynCheck_entry_vkDestroyIndirectCommandsLayoutNV(
    VkDevice device,
    VkIndirectCommandsLayoutNV indirectCommandsLayout,
    const VkAllocationCallbacks* pAllocator)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_NV_device_generated_commands"))
    {
        sOnInvalidDynamicallyCheckedCall("vkDestroyIndirectCommandsLayoutNV", "VK_NV_device_generated_commands");
    }
    AEMU_SCOPED_TRACE("vkDestroyIndirectCommandsLayoutNV");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyIndirectCommandsLayoutNV(device, indirectCommandsLayout, pAllocator, true /* do lock */);
}
#endif
#ifdef VK_EXT_texel_buffer_alignment
#endif
#ifdef VK_QCOM_render_pass_transform
#endif
#ifdef VK_EXT_device_memory_report
#endif
#ifdef VK_EXT_robustness2
#endif
#ifdef VK_EXT_custom_border_color
#endif
#ifdef VK_GOOGLE_user_type
#endif
#ifdef VK_EXT_private_data
static VkResult entry_vkCreatePrivateDataSlotEXT(
    VkDevice device,
    const VkPrivateDataSlotCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPrivateDataSlotEXT* pPrivateDataSlot)
{
    AEMU_SCOPED_TRACE("vkCreatePrivateDataSlotEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreatePrivateDataSlotEXT_VkResult_return = (VkResult)0;
    vkCreatePrivateDataSlotEXT_VkResult_return = vkEnc->vkCreatePrivateDataSlotEXT(device, pCreateInfo, pAllocator, pPrivateDataSlot, true /* do lock */);
    return vkCreatePrivateDataSlotEXT_VkResult_return;
}
static VkResult dynCheck_entry_vkCreatePrivateDataSlotEXT(
    VkDevice device,
    const VkPrivateDataSlotCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPrivateDataSlotEXT* pPrivateDataSlot)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_private_data"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCreatePrivateDataSlotEXT", "VK_EXT_private_data");
    }
    AEMU_SCOPED_TRACE("vkCreatePrivateDataSlotEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreatePrivateDataSlotEXT_VkResult_return = (VkResult)0;
    vkCreatePrivateDataSlotEXT_VkResult_return = vkEnc->vkCreatePrivateDataSlotEXT(device, pCreateInfo, pAllocator, pPrivateDataSlot, true /* do lock */);
    return vkCreatePrivateDataSlotEXT_VkResult_return;
}
static void entry_vkDestroyPrivateDataSlotEXT(
    VkDevice device,
    VkPrivateDataSlotEXT privateDataSlot,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyPrivateDataSlotEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyPrivateDataSlotEXT(device, privateDataSlot, pAllocator, true /* do lock */);
}
static void dynCheck_entry_vkDestroyPrivateDataSlotEXT(
    VkDevice device,
    VkPrivateDataSlotEXT privateDataSlot,
    const VkAllocationCallbacks* pAllocator)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_private_data"))
    {
        sOnInvalidDynamicallyCheckedCall("vkDestroyPrivateDataSlotEXT", "VK_EXT_private_data");
    }
    AEMU_SCOPED_TRACE("vkDestroyPrivateDataSlotEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyPrivateDataSlotEXT(device, privateDataSlot, pAllocator, true /* do lock */);
}
static VkResult entry_vkSetPrivateDataEXT(
    VkDevice device,
    VkObjectType objectType,
    uint64_t objectHandle,
    VkPrivateDataSlotEXT privateDataSlot,
    uint64_t data)
{
    AEMU_SCOPED_TRACE("vkSetPrivateDataEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkSetPrivateDataEXT_VkResult_return = (VkResult)0;
    vkSetPrivateDataEXT_VkResult_return = vkEnc->vkSetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, data, true /* do lock */);
    return vkSetPrivateDataEXT_VkResult_return;
}
static VkResult dynCheck_entry_vkSetPrivateDataEXT(
    VkDevice device,
    VkObjectType objectType,
    uint64_t objectHandle,
    VkPrivateDataSlotEXT privateDataSlot,
    uint64_t data)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_private_data"))
    {
        sOnInvalidDynamicallyCheckedCall("vkSetPrivateDataEXT", "VK_EXT_private_data");
    }
    AEMU_SCOPED_TRACE("vkSetPrivateDataEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkSetPrivateDataEXT_VkResult_return = (VkResult)0;
    vkSetPrivateDataEXT_VkResult_return = vkEnc->vkSetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, data, true /* do lock */);
    return vkSetPrivateDataEXT_VkResult_return;
}
static void entry_vkGetPrivateDataEXT(
    VkDevice device,
    VkObjectType objectType,
    uint64_t objectHandle,
    VkPrivateDataSlotEXT privateDataSlot,
    uint64_t* pData)
{
    AEMU_SCOPED_TRACE("vkGetPrivateDataEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, pData, true /* do lock */);
}
static void dynCheck_entry_vkGetPrivateDataEXT(
    VkDevice device,
    VkObjectType objectType,
    uint64_t objectHandle,
    VkPrivateDataSlotEXT privateDataSlot,
    uint64_t* pData)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_EXT_private_data"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetPrivateDataEXT", "VK_EXT_private_data");
    }
    AEMU_SCOPED_TRACE("vkGetPrivateDataEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, pData, true /* do lock */);
}
#endif
#ifdef VK_EXT_pipeline_creation_cache_control
#endif
#ifdef VK_NV_device_diagnostics_config
#endif
#ifdef VK_QCOM_render_pass_store_ops
#endif
#ifdef VK_NV_fragment_shading_rate_enums
static void entry_vkCmdSetFragmentShadingRateEnumNV(
    VkCommandBuffer commandBuffer,
    VkFragmentShadingRateNV shadingRate,
    const VkFragmentShadingRateCombinerOpKHR combinerOps[2])
{
    AEMU_SCOPED_TRACE("vkCmdSetFragmentShadingRateEnumNV");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetFragmentShadingRateEnumNV(commandBuffer, shadingRate, combinerOps, true /* do lock */);
}
#endif
#ifdef VK_EXT_fragment_density_map2
#endif
#ifdef VK_QCOM_rotated_copy_commands
#endif
#ifdef VK_EXT_image_robustness
#endif
#ifdef VK_EXT_4444_formats
#endif
#ifdef VK_EXT_directfb_surface
static VkResult entry_vkCreateDirectFBSurfaceEXT(
    VkInstance instance,
    const VkDirectFBSurfaceCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface)
{
    AEMU_SCOPED_TRACE("vkCreateDirectFBSurfaceEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateDirectFBSurfaceEXT_VkResult_return = (VkResult)0;
    vkCreateDirectFBSurfaceEXT_VkResult_return = vkEnc->vkCreateDirectFBSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface, true /* do lock */);
    return vkCreateDirectFBSurfaceEXT_VkResult_return;
}
static VkBool32 entry_vkGetPhysicalDeviceDirectFBPresentationSupportEXT(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    IDirectFB* dfb)
{
    AEMU_SCOPED_TRACE("vkGetPhysicalDeviceDirectFBPresentationSupportEXT");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkBool32 vkGetPhysicalDeviceDirectFBPresentationSupportEXT_VkBool32_return = (VkBool32)0;
    vkGetPhysicalDeviceDirectFBPresentationSupportEXT_VkBool32_return = vkEnc->vkGetPhysicalDeviceDirectFBPresentationSupportEXT(physicalDevice, queueFamilyIndex, dfb, true /* do lock */);
    return vkGetPhysicalDeviceDirectFBPresentationSupportEXT_VkBool32_return;
}
#endif
#ifdef VK_GOOGLE_gfxstream
static VkResult entry_vkRegisterImageColorBufferGOOGLE(
    VkDevice device,
    VkImage image,
    uint32_t colorBuffer)
{
    AEMU_SCOPED_TRACE("vkRegisterImageColorBufferGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkRegisterImageColorBufferGOOGLE_VkResult_return = (VkResult)0;
    vkRegisterImageColorBufferGOOGLE_VkResult_return = vkEnc->vkRegisterImageColorBufferGOOGLE(device, image, colorBuffer, true /* do lock */);
    return vkRegisterImageColorBufferGOOGLE_VkResult_return;
}
static VkResult dynCheck_entry_vkRegisterImageColorBufferGOOGLE(
    VkDevice device,
    VkImage image,
    uint32_t colorBuffer)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream"))
    {
        sOnInvalidDynamicallyCheckedCall("vkRegisterImageColorBufferGOOGLE", "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkRegisterImageColorBufferGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkRegisterImageColorBufferGOOGLE_VkResult_return = (VkResult)0;
    vkRegisterImageColorBufferGOOGLE_VkResult_return = vkEnc->vkRegisterImageColorBufferGOOGLE(device, image, colorBuffer, true /* do lock */);
    return vkRegisterImageColorBufferGOOGLE_VkResult_return;
}
static VkResult entry_vkRegisterBufferColorBufferGOOGLE(
    VkDevice device,
    VkBuffer buffer,
    uint32_t colorBuffer)
{
    AEMU_SCOPED_TRACE("vkRegisterBufferColorBufferGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkRegisterBufferColorBufferGOOGLE_VkResult_return = (VkResult)0;
    vkRegisterBufferColorBufferGOOGLE_VkResult_return = vkEnc->vkRegisterBufferColorBufferGOOGLE(device, buffer, colorBuffer, true /* do lock */);
    return vkRegisterBufferColorBufferGOOGLE_VkResult_return;
}
static VkResult dynCheck_entry_vkRegisterBufferColorBufferGOOGLE(
    VkDevice device,
    VkBuffer buffer,
    uint32_t colorBuffer)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream"))
    {
        sOnInvalidDynamicallyCheckedCall("vkRegisterBufferColorBufferGOOGLE", "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkRegisterBufferColorBufferGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkRegisterBufferColorBufferGOOGLE_VkResult_return = (VkResult)0;
    vkRegisterBufferColorBufferGOOGLE_VkResult_return = vkEnc->vkRegisterBufferColorBufferGOOGLE(device, buffer, colorBuffer, true /* do lock */);
    return vkRegisterBufferColorBufferGOOGLE_VkResult_return;
}
static VkResult entry_vkMapMemoryIntoAddressSpaceGOOGLE(
    VkDevice device,
    VkDeviceMemory memory,
    uint64_t* pAddress)
{
    AEMU_SCOPED_TRACE("vkMapMemoryIntoAddressSpaceGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = (VkResult)0;
    vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = vkEnc->vkMapMemoryIntoAddressSpaceGOOGLE(device, memory, pAddress, true /* do lock */);
    return vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return;
}
static VkResult dynCheck_entry_vkMapMemoryIntoAddressSpaceGOOGLE(
    VkDevice device,
    VkDeviceMemory memory,
    uint64_t* pAddress)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream"))
    {
        sOnInvalidDynamicallyCheckedCall("vkMapMemoryIntoAddressSpaceGOOGLE", "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkMapMemoryIntoAddressSpaceGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = (VkResult)0;
    vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = vkEnc->vkMapMemoryIntoAddressSpaceGOOGLE(device, memory, pAddress, true /* do lock */);
    return vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return;
}
static void entry_vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    uint32_t imageInfoCount,
    uint32_t bufferInfoCount,
    uint32_t bufferViewCount,
    const uint32_t* pImageInfoEntryIndices,
    const uint32_t* pBufferInfoEntryIndices,
    const uint32_t* pBufferViewEntryIndices,
    const VkDescriptorImageInfo* pImageInfos,
    const VkDescriptorBufferInfo* pBufferInfos,
    const VkBufferView* pBufferViews)
{
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplateSizedGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkUpdateDescriptorSetWithTemplateSizedGOOGLE(device, descriptorSet, descriptorUpdateTemplate, imageInfoCount, bufferInfoCount, bufferViewCount, pImageInfoEntryIndices, pBufferInfoEntryIndices, pBufferViewEntryIndices, pImageInfos, pBufferInfos, pBufferViews, true /* do lock */);
}
static void dynCheck_entry_vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    uint32_t imageInfoCount,
    uint32_t bufferInfoCount,
    uint32_t bufferViewCount,
    const uint32_t* pImageInfoEntryIndices,
    const uint32_t* pBufferInfoEntryIndices,
    const uint32_t* pBufferViewEntryIndices,
    const VkDescriptorImageInfo* pImageInfos,
    const VkDescriptorBufferInfo* pBufferInfos,
    const VkBufferView* pBufferViews)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream"))
    {
        sOnInvalidDynamicallyCheckedCall("vkUpdateDescriptorSetWithTemplateSizedGOOGLE", "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkUpdateDescriptorSetWithTemplateSizedGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkUpdateDescriptorSetWithTemplateSizedGOOGLE(device, descriptorSet, descriptorUpdateTemplate, imageInfoCount, bufferInfoCount, bufferViewCount, pImageInfoEntryIndices, pBufferInfoEntryIndices, pBufferViewEntryIndices, pImageInfos, pBufferInfos, pBufferViews, true /* do lock */);
}
static void entry_vkBeginCommandBufferAsyncGOOGLE(
    VkCommandBuffer commandBuffer,
    const VkCommandBufferBeginInfo* pBeginInfo)
{
    AEMU_SCOPED_TRACE("vkBeginCommandBufferAsyncGOOGLE");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkBeginCommandBufferAsyncGOOGLE(commandBuffer, pBeginInfo, true /* do lock */);
}
static void entry_vkEndCommandBufferAsyncGOOGLE(
    VkCommandBuffer commandBuffer)
{
    AEMU_SCOPED_TRACE("vkEndCommandBufferAsyncGOOGLE");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkEndCommandBufferAsyncGOOGLE(commandBuffer, true /* do lock */);
}
static void entry_vkResetCommandBufferAsyncGOOGLE(
    VkCommandBuffer commandBuffer,
    VkCommandBufferResetFlags flags)
{
    AEMU_SCOPED_TRACE("vkResetCommandBufferAsyncGOOGLE");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkResetCommandBufferAsyncGOOGLE(commandBuffer, flags, true /* do lock */);
}
static void entry_vkCommandBufferHostSyncGOOGLE(
    VkCommandBuffer commandBuffer,
    uint32_t needHostSync,
    uint32_t sequenceNumber)
{
    AEMU_SCOPED_TRACE("vkCommandBufferHostSyncGOOGLE");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCommandBufferHostSyncGOOGLE(commandBuffer, needHostSync, sequenceNumber, true /* do lock */);
}
static VkResult entry_vkCreateImageWithRequirementsGOOGLE(
    VkDevice device,
    const VkImageCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage* pImage,
    VkMemoryRequirements* pMemoryRequirements)
{
    AEMU_SCOPED_TRACE("vkCreateImageWithRequirementsGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateImageWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
    vkCreateImageWithRequirementsGOOGLE_VkResult_return = vkEnc->vkCreateImageWithRequirementsGOOGLE(device, pCreateInfo, pAllocator, pImage, pMemoryRequirements, true /* do lock */);
    return vkCreateImageWithRequirementsGOOGLE_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateImageWithRequirementsGOOGLE(
    VkDevice device,
    const VkImageCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage* pImage,
    VkMemoryRequirements* pMemoryRequirements)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCreateImageWithRequirementsGOOGLE", "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkCreateImageWithRequirementsGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateImageWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
    vkCreateImageWithRequirementsGOOGLE_VkResult_return = vkEnc->vkCreateImageWithRequirementsGOOGLE(device, pCreateInfo, pAllocator, pImage, pMemoryRequirements, true /* do lock */);
    return vkCreateImageWithRequirementsGOOGLE_VkResult_return;
}
static VkResult entry_vkCreateBufferWithRequirementsGOOGLE(
    VkDevice device,
    const VkBufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer,
    VkMemoryRequirements* pMemoryRequirements)
{
    AEMU_SCOPED_TRACE("vkCreateBufferWithRequirementsGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateBufferWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
    vkCreateBufferWithRequirementsGOOGLE_VkResult_return = vkEnc->vkCreateBufferWithRequirementsGOOGLE(device, pCreateInfo, pAllocator, pBuffer, pMemoryRequirements, true /* do lock */);
    return vkCreateBufferWithRequirementsGOOGLE_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateBufferWithRequirementsGOOGLE(
    VkDevice device,
    const VkBufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer,
    VkMemoryRequirements* pMemoryRequirements)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCreateBufferWithRequirementsGOOGLE", "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkCreateBufferWithRequirementsGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateBufferWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
    vkCreateBufferWithRequirementsGOOGLE_VkResult_return = vkEnc->vkCreateBufferWithRequirementsGOOGLE(device, pCreateInfo, pAllocator, pBuffer, pMemoryRequirements, true /* do lock */);
    return vkCreateBufferWithRequirementsGOOGLE_VkResult_return;
}
static VkResult entry_vkGetMemoryHostAddressInfoGOOGLE(
    VkDevice device,
    VkDeviceMemory memory,
    uint64_t* pAddress,
    uint64_t* pSize,
    uint64_t* pHostmemId)
{
    AEMU_SCOPED_TRACE("vkGetMemoryHostAddressInfoGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = (VkResult)0;
    vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = vkEnc->vkGetMemoryHostAddressInfoGOOGLE(device, memory, pAddress, pSize, pHostmemId, true /* do lock */);
    return vkGetMemoryHostAddressInfoGOOGLE_VkResult_return;
}
static VkResult dynCheck_entry_vkGetMemoryHostAddressInfoGOOGLE(
    VkDevice device,
    VkDeviceMemory memory,
    uint64_t* pAddress,
    uint64_t* pSize,
    uint64_t* pHostmemId)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetMemoryHostAddressInfoGOOGLE", "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkGetMemoryHostAddressInfoGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = (VkResult)0;
    vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = vkEnc->vkGetMemoryHostAddressInfoGOOGLE(device, memory, pAddress, pSize, pHostmemId, true /* do lock */);
    return vkGetMemoryHostAddressInfoGOOGLE_VkResult_return;
}
static VkResult entry_vkFreeMemorySyncGOOGLE(
    VkDevice device,
    VkDeviceMemory memory,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkFreeMemorySyncGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkFreeMemorySyncGOOGLE_VkResult_return = (VkResult)0;
    vkFreeMemorySyncGOOGLE_VkResult_return = vkEnc->vkFreeMemorySyncGOOGLE(device, memory, pAllocator, true /* do lock */);
    return vkFreeMemorySyncGOOGLE_VkResult_return;
}
static VkResult dynCheck_entry_vkFreeMemorySyncGOOGLE(
    VkDevice device,
    VkDeviceMemory memory,
    const VkAllocationCallbacks* pAllocator)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream"))
    {
        sOnInvalidDynamicallyCheckedCall("vkFreeMemorySyncGOOGLE", "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkFreeMemorySyncGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkFreeMemorySyncGOOGLE_VkResult_return = (VkResult)0;
    vkFreeMemorySyncGOOGLE_VkResult_return = vkEnc->vkFreeMemorySyncGOOGLE(device, memory, pAllocator, true /* do lock */);
    return vkFreeMemorySyncGOOGLE_VkResult_return;
}
static void entry_vkQueueHostSyncGOOGLE(
    VkQueue queue,
    uint32_t needHostSync,
    uint32_t sequenceNumber)
{
    AEMU_SCOPED_TRACE("vkQueueHostSyncGOOGLE");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    vkEnc->vkQueueHostSyncGOOGLE(queue, needHostSync, sequenceNumber, true /* do lock */);
}
static void entry_vkQueueSubmitAsyncGOOGLE(
    VkQueue queue,
    uint32_t submitCount,
    const VkSubmitInfo* pSubmits,
    VkFence fence)
{
    AEMU_SCOPED_TRACE("vkQueueSubmitAsyncGOOGLE");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    vkEnc->vkQueueSubmitAsyncGOOGLE(queue, submitCount, pSubmits, fence, true /* do lock */);
}
static void entry_vkQueueWaitIdleAsyncGOOGLE(
    VkQueue queue)
{
    AEMU_SCOPED_TRACE("vkQueueWaitIdleAsyncGOOGLE");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    vkEnc->vkQueueWaitIdleAsyncGOOGLE(queue, true /* do lock */);
}
static void entry_vkQueueBindSparseAsyncGOOGLE(
    VkQueue queue,
    uint32_t bindInfoCount,
    const VkBindSparseInfo* pBindInfo,
    VkFence fence)
{
    AEMU_SCOPED_TRACE("vkQueueBindSparseAsyncGOOGLE");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    vkEnc->vkQueueBindSparseAsyncGOOGLE(queue, bindInfoCount, pBindInfo, fence, true /* do lock */);
}
static void entry_vkGetLinearImageLayoutGOOGLE(
    VkDevice device,
    VkFormat format,
    VkDeviceSize* pOffset,
    VkDeviceSize* pRowPitchAlignment)
{
    AEMU_SCOPED_TRACE("vkGetLinearImageLayoutGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetLinearImageLayoutGOOGLE(device, format, pOffset, pRowPitchAlignment, true /* do lock */);
}
static void dynCheck_entry_vkGetLinearImageLayoutGOOGLE(
    VkDevice device,
    VkFormat format,
    VkDeviceSize* pOffset,
    VkDeviceSize* pRowPitchAlignment)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetLinearImageLayoutGOOGLE", "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkGetLinearImageLayoutGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetLinearImageLayoutGOOGLE(device, format, pOffset, pRowPitchAlignment, true /* do lock */);
}
static void entry_vkQueueFlushCommandsGOOGLE(
    VkQueue queue,
    VkCommandBuffer commandBuffer,
    VkDeviceSize dataSize,
    const void* pData)
{
    AEMU_SCOPED_TRACE("vkQueueFlushCommandsGOOGLE");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    vkEnc->vkQueueFlushCommandsGOOGLE(queue, commandBuffer, dataSize, pData, true /* do lock */);
}
static void entry_vkQueueCommitDescriptorSetUpdatesGOOGLE(
    VkQueue queue,
    uint32_t descriptorPoolCount,
    const VkDescriptorPool* pDescriptorPools,
    uint32_t descriptorSetCount,
    const VkDescriptorSetLayout* pSetLayouts,
    const uint64_t* pDescriptorSetPoolIds,
    const uint32_t* pDescriptorSetWhichPool,
    const uint32_t* pDescriptorSetPendingAllocation,
    const uint32_t* pDescriptorWriteStartingIndices,
    uint32_t pendingDescriptorWriteCount,
    const VkWriteDescriptorSet* pPendingDescriptorWrites)
{
    AEMU_SCOPED_TRACE("vkQueueCommitDescriptorSetUpdatesGOOGLE");
    auto vkEnc = ResourceTracker::getQueueEncoder(queue);
    vkEnc->vkQueueCommitDescriptorSetUpdatesGOOGLE(queue, descriptorPoolCount, pDescriptorPools, descriptorSetCount, pSetLayouts, pDescriptorSetPoolIds, pDescriptorSetWhichPool, pDescriptorSetPendingAllocation, pDescriptorWriteStartingIndices, pendingDescriptorWriteCount, pPendingDescriptorWrites, true /* do lock */);
}
static void entry_vkCollectDescriptorPoolIdsGOOGLE(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    uint32_t* pPoolIdCount,
    uint64_t* pPoolIds)
{
    AEMU_SCOPED_TRACE("vkCollectDescriptorPoolIdsGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkCollectDescriptorPoolIdsGOOGLE(device, descriptorPool, pPoolIdCount, pPoolIds, true /* do lock */);
}
static void dynCheck_entry_vkCollectDescriptorPoolIdsGOOGLE(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    uint32_t* pPoolIdCount,
    uint64_t* pPoolIds)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCollectDescriptorPoolIdsGOOGLE", "VK_GOOGLE_gfxstream");
    }
    AEMU_SCOPED_TRACE("vkCollectDescriptorPoolIdsGOOGLE");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkCollectDescriptorPoolIdsGOOGLE(device, descriptorPool, pPoolIdCount, pPoolIds, true /* do lock */);
}
#endif
#ifdef VK_KHR_acceleration_structure
static VkResult entry_vkCreateAccelerationStructureKHR(
    VkDevice device,
    const VkAccelerationStructureCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkAccelerationStructureKHR* pAccelerationStructure)
{
    AEMU_SCOPED_TRACE("vkCreateAccelerationStructureKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateAccelerationStructureKHR_VkResult_return = (VkResult)0;
    vkCreateAccelerationStructureKHR_VkResult_return = vkEnc->vkCreateAccelerationStructureKHR(device, pCreateInfo, pAllocator, pAccelerationStructure, true /* do lock */);
    return vkCreateAccelerationStructureKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateAccelerationStructureKHR(
    VkDevice device,
    const VkAccelerationStructureCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkAccelerationStructureKHR* pAccelerationStructure)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCreateAccelerationStructureKHR", "VK_KHR_acceleration_structure");
    }
    AEMU_SCOPED_TRACE("vkCreateAccelerationStructureKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateAccelerationStructureKHR_VkResult_return = (VkResult)0;
    vkCreateAccelerationStructureKHR_VkResult_return = vkEnc->vkCreateAccelerationStructureKHR(device, pCreateInfo, pAllocator, pAccelerationStructure, true /* do lock */);
    return vkCreateAccelerationStructureKHR_VkResult_return;
}
static void entry_vkDestroyAccelerationStructureKHR(
    VkDevice device,
    VkAccelerationStructureKHR accelerationStructure,
    const VkAllocationCallbacks* pAllocator)
{
    AEMU_SCOPED_TRACE("vkDestroyAccelerationStructureKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyAccelerationStructureKHR(device, accelerationStructure, pAllocator, true /* do lock */);
}
static void dynCheck_entry_vkDestroyAccelerationStructureKHR(
    VkDevice device,
    VkAccelerationStructureKHR accelerationStructure,
    const VkAllocationCallbacks* pAllocator)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure"))
    {
        sOnInvalidDynamicallyCheckedCall("vkDestroyAccelerationStructureKHR", "VK_KHR_acceleration_structure");
    }
    AEMU_SCOPED_TRACE("vkDestroyAccelerationStructureKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkDestroyAccelerationStructureKHR(device, accelerationStructure, pAllocator, true /* do lock */);
}
static void entry_vkCmdBuildAccelerationStructuresKHR(
    VkCommandBuffer commandBuffer,
    uint32_t infoCount,
    const VkAccelerationStructureBuildGeometryInfoKHR* pInfos,
    const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos)
{
    AEMU_SCOPED_TRACE("vkCmdBuildAccelerationStructuresKHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBuildAccelerationStructuresKHR(commandBuffer, infoCount, pInfos, ppBuildRangeInfos, true /* do lock */);
}
static void entry_vkCmdBuildAccelerationStructuresIndirectKHR(
    VkCommandBuffer commandBuffer,
    uint32_t infoCount,
    const VkAccelerationStructureBuildGeometryInfoKHR* pInfos,
    const VkDeviceAddress* pIndirectDeviceAddresses,
    const uint32_t* pIndirectStrides,
    const uint32_t* const* ppMaxPrimitiveCounts)
{
    AEMU_SCOPED_TRACE("vkCmdBuildAccelerationStructuresIndirectKHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdBuildAccelerationStructuresIndirectKHR(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts, true /* do lock */);
}
static VkResult entry_vkBuildAccelerationStructuresKHR(
    VkDevice device,
    VkDeferredOperationKHR deferredOperation,
    uint32_t infoCount,
    const VkAccelerationStructureBuildGeometryInfoKHR* pInfos,
    const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos)
{
    AEMU_SCOPED_TRACE("vkBuildAccelerationStructuresKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBuildAccelerationStructuresKHR_VkResult_return = (VkResult)0;
    vkBuildAccelerationStructuresKHR_VkResult_return = vkEnc->vkBuildAccelerationStructuresKHR(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos, true /* do lock */);
    return vkBuildAccelerationStructuresKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkBuildAccelerationStructuresKHR(
    VkDevice device,
    VkDeferredOperationKHR deferredOperation,
    uint32_t infoCount,
    const VkAccelerationStructureBuildGeometryInfoKHR* pInfos,
    const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure"))
    {
        sOnInvalidDynamicallyCheckedCall("vkBuildAccelerationStructuresKHR", "VK_KHR_acceleration_structure");
    }
    AEMU_SCOPED_TRACE("vkBuildAccelerationStructuresKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkBuildAccelerationStructuresKHR_VkResult_return = (VkResult)0;
    vkBuildAccelerationStructuresKHR_VkResult_return = vkEnc->vkBuildAccelerationStructuresKHR(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos, true /* do lock */);
    return vkBuildAccelerationStructuresKHR_VkResult_return;
}
static VkResult entry_vkCopyAccelerationStructureKHR(
    VkDevice device,
    VkDeferredOperationKHR deferredOperation,
    const VkCopyAccelerationStructureInfoKHR* pInfo)
{
    AEMU_SCOPED_TRACE("vkCopyAccelerationStructureKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCopyAccelerationStructureKHR_VkResult_return = (VkResult)0;
    vkCopyAccelerationStructureKHR_VkResult_return = vkEnc->vkCopyAccelerationStructureKHR(device, deferredOperation, pInfo, true /* do lock */);
    return vkCopyAccelerationStructureKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkCopyAccelerationStructureKHR(
    VkDevice device,
    VkDeferredOperationKHR deferredOperation,
    const VkCopyAccelerationStructureInfoKHR* pInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCopyAccelerationStructureKHR", "VK_KHR_acceleration_structure");
    }
    AEMU_SCOPED_TRACE("vkCopyAccelerationStructureKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCopyAccelerationStructureKHR_VkResult_return = (VkResult)0;
    vkCopyAccelerationStructureKHR_VkResult_return = vkEnc->vkCopyAccelerationStructureKHR(device, deferredOperation, pInfo, true /* do lock */);
    return vkCopyAccelerationStructureKHR_VkResult_return;
}
static VkResult entry_vkCopyAccelerationStructureToMemoryKHR(
    VkDevice device,
    VkDeferredOperationKHR deferredOperation,
    const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo)
{
    AEMU_SCOPED_TRACE("vkCopyAccelerationStructureToMemoryKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCopyAccelerationStructureToMemoryKHR_VkResult_return = (VkResult)0;
    vkCopyAccelerationStructureToMemoryKHR_VkResult_return = vkEnc->vkCopyAccelerationStructureToMemoryKHR(device, deferredOperation, pInfo, true /* do lock */);
    return vkCopyAccelerationStructureToMemoryKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkCopyAccelerationStructureToMemoryKHR(
    VkDevice device,
    VkDeferredOperationKHR deferredOperation,
    const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCopyAccelerationStructureToMemoryKHR", "VK_KHR_acceleration_structure");
    }
    AEMU_SCOPED_TRACE("vkCopyAccelerationStructureToMemoryKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCopyAccelerationStructureToMemoryKHR_VkResult_return = (VkResult)0;
    vkCopyAccelerationStructureToMemoryKHR_VkResult_return = vkEnc->vkCopyAccelerationStructureToMemoryKHR(device, deferredOperation, pInfo, true /* do lock */);
    return vkCopyAccelerationStructureToMemoryKHR_VkResult_return;
}
static VkResult entry_vkCopyMemoryToAccelerationStructureKHR(
    VkDevice device,
    VkDeferredOperationKHR deferredOperation,
    const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo)
{
    AEMU_SCOPED_TRACE("vkCopyMemoryToAccelerationStructureKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCopyMemoryToAccelerationStructureKHR_VkResult_return = (VkResult)0;
    vkCopyMemoryToAccelerationStructureKHR_VkResult_return = vkEnc->vkCopyMemoryToAccelerationStructureKHR(device, deferredOperation, pInfo, true /* do lock */);
    return vkCopyMemoryToAccelerationStructureKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkCopyMemoryToAccelerationStructureKHR(
    VkDevice device,
    VkDeferredOperationKHR deferredOperation,
    const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCopyMemoryToAccelerationStructureKHR", "VK_KHR_acceleration_structure");
    }
    AEMU_SCOPED_TRACE("vkCopyMemoryToAccelerationStructureKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCopyMemoryToAccelerationStructureKHR_VkResult_return = (VkResult)0;
    vkCopyMemoryToAccelerationStructureKHR_VkResult_return = vkEnc->vkCopyMemoryToAccelerationStructureKHR(device, deferredOperation, pInfo, true /* do lock */);
    return vkCopyMemoryToAccelerationStructureKHR_VkResult_return;
}
static VkResult entry_vkWriteAccelerationStructuresPropertiesKHR(
    VkDevice device,
    uint32_t accelerationStructureCount,
    const VkAccelerationStructureKHR* pAccelerationStructures,
    VkQueryType queryType,
    size_t dataSize,
    void* pData,
    size_t stride)
{
    AEMU_SCOPED_TRACE("vkWriteAccelerationStructuresPropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkWriteAccelerationStructuresPropertiesKHR_VkResult_return = (VkResult)0;
    vkWriteAccelerationStructuresPropertiesKHR_VkResult_return = vkEnc->vkWriteAccelerationStructuresPropertiesKHR(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride, true /* do lock */);
    return vkWriteAccelerationStructuresPropertiesKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkWriteAccelerationStructuresPropertiesKHR(
    VkDevice device,
    uint32_t accelerationStructureCount,
    const VkAccelerationStructureKHR* pAccelerationStructures,
    VkQueryType queryType,
    size_t dataSize,
    void* pData,
    size_t stride)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure"))
    {
        sOnInvalidDynamicallyCheckedCall("vkWriteAccelerationStructuresPropertiesKHR", "VK_KHR_acceleration_structure");
    }
    AEMU_SCOPED_TRACE("vkWriteAccelerationStructuresPropertiesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkWriteAccelerationStructuresPropertiesKHR_VkResult_return = (VkResult)0;
    vkWriteAccelerationStructuresPropertiesKHR_VkResult_return = vkEnc->vkWriteAccelerationStructuresPropertiesKHR(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride, true /* do lock */);
    return vkWriteAccelerationStructuresPropertiesKHR_VkResult_return;
}
static void entry_vkCmdCopyAccelerationStructureKHR(
    VkCommandBuffer commandBuffer,
    const VkCopyAccelerationStructureInfoKHR* pInfo)
{
    AEMU_SCOPED_TRACE("vkCmdCopyAccelerationStructureKHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyAccelerationStructureKHR(commandBuffer, pInfo, true /* do lock */);
}
static void entry_vkCmdCopyAccelerationStructureToMemoryKHR(
    VkCommandBuffer commandBuffer,
    const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo)
{
    AEMU_SCOPED_TRACE("vkCmdCopyAccelerationStructureToMemoryKHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyAccelerationStructureToMemoryKHR(commandBuffer, pInfo, true /* do lock */);
}
static void entry_vkCmdCopyMemoryToAccelerationStructureKHR(
    VkCommandBuffer commandBuffer,
    const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo)
{
    AEMU_SCOPED_TRACE("vkCmdCopyMemoryToAccelerationStructureKHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdCopyMemoryToAccelerationStructureKHR(commandBuffer, pInfo, true /* do lock */);
}
static VkDeviceAddress entry_vkGetAccelerationStructureDeviceAddressKHR(
    VkDevice device,
    const VkAccelerationStructureDeviceAddressInfoKHR* pInfo)
{
    AEMU_SCOPED_TRACE("vkGetAccelerationStructureDeviceAddressKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkDeviceAddress vkGetAccelerationStructureDeviceAddressKHR_VkDeviceAddress_return = (VkDeviceAddress)0;
    vkGetAccelerationStructureDeviceAddressKHR_VkDeviceAddress_return = vkEnc->vkGetAccelerationStructureDeviceAddressKHR(device, pInfo, true /* do lock */);
    return vkGetAccelerationStructureDeviceAddressKHR_VkDeviceAddress_return;
}
static VkDeviceAddress dynCheck_entry_vkGetAccelerationStructureDeviceAddressKHR(
    VkDevice device,
    const VkAccelerationStructureDeviceAddressInfoKHR* pInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetAccelerationStructureDeviceAddressKHR", "VK_KHR_acceleration_structure");
    }
    AEMU_SCOPED_TRACE("vkGetAccelerationStructureDeviceAddressKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkDeviceAddress vkGetAccelerationStructureDeviceAddressKHR_VkDeviceAddress_return = (VkDeviceAddress)0;
    vkGetAccelerationStructureDeviceAddressKHR_VkDeviceAddress_return = vkEnc->vkGetAccelerationStructureDeviceAddressKHR(device, pInfo, true /* do lock */);
    return vkGetAccelerationStructureDeviceAddressKHR_VkDeviceAddress_return;
}
static void entry_vkCmdWriteAccelerationStructuresPropertiesKHR(
    VkCommandBuffer commandBuffer,
    uint32_t accelerationStructureCount,
    const VkAccelerationStructureKHR* pAccelerationStructures,
    VkQueryType queryType,
    VkQueryPool queryPool,
    uint32_t firstQuery)
{
    AEMU_SCOPED_TRACE("vkCmdWriteAccelerationStructuresPropertiesKHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdWriteAccelerationStructuresPropertiesKHR(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery, true /* do lock */);
}
static void entry_vkGetDeviceAccelerationStructureCompatibilityKHR(
    VkDevice device,
    const VkAccelerationStructureVersionInfoKHR* pVersionInfo,
    VkAccelerationStructureCompatibilityKHR* pCompatibility)
{
    AEMU_SCOPED_TRACE("vkGetDeviceAccelerationStructureCompatibilityKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceAccelerationStructureCompatibilityKHR(device, pVersionInfo, pCompatibility, true /* do lock */);
}
static void dynCheck_entry_vkGetDeviceAccelerationStructureCompatibilityKHR(
    VkDevice device,
    const VkAccelerationStructureVersionInfoKHR* pVersionInfo,
    VkAccelerationStructureCompatibilityKHR* pCompatibility)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetDeviceAccelerationStructureCompatibilityKHR", "VK_KHR_acceleration_structure");
    }
    AEMU_SCOPED_TRACE("vkGetDeviceAccelerationStructureCompatibilityKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetDeviceAccelerationStructureCompatibilityKHR(device, pVersionInfo, pCompatibility, true /* do lock */);
}
static void entry_vkGetAccelerationStructureBuildSizesKHR(
    VkDevice device,
    VkAccelerationStructureBuildTypeKHR buildType,
    const VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo,
    const uint32_t* pMaxPrimitiveCounts,
    VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo)
{
    AEMU_SCOPED_TRACE("vkGetAccelerationStructureBuildSizesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetAccelerationStructureBuildSizesKHR(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo, true /* do lock */);
}
static void dynCheck_entry_vkGetAccelerationStructureBuildSizesKHR(
    VkDevice device,
    VkAccelerationStructureBuildTypeKHR buildType,
    const VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo,
    const uint32_t* pMaxPrimitiveCounts,
    VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetAccelerationStructureBuildSizesKHR", "VK_KHR_acceleration_structure");
    }
    AEMU_SCOPED_TRACE("vkGetAccelerationStructureBuildSizesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    vkEnc->vkGetAccelerationStructureBuildSizesKHR(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo, true /* do lock */);
}
#endif
#ifdef VK_KHR_ray_tracing_pipeline
static void entry_vkCmdTraceRaysKHR(
    VkCommandBuffer commandBuffer,
    const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable,
    uint32_t width,
    uint32_t height,
    uint32_t depth)
{
    AEMU_SCOPED_TRACE("vkCmdTraceRaysKHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdTraceRaysKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth, true /* do lock */);
}
static VkResult entry_vkCreateRayTracingPipelinesKHR(
    VkDevice device,
    VkDeferredOperationKHR deferredOperation,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkRayTracingPipelineCreateInfoKHR* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines)
{
    AEMU_SCOPED_TRACE("vkCreateRayTracingPipelinesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateRayTracingPipelinesKHR_VkResult_return = (VkResult)0;
    vkCreateRayTracingPipelinesKHR_VkResult_return = vkEnc->vkCreateRayTracingPipelinesKHR(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines, true /* do lock */);
    return vkCreateRayTracingPipelinesKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkCreateRayTracingPipelinesKHR(
    VkDevice device,
    VkDeferredOperationKHR deferredOperation,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkRayTracingPipelineCreateInfoKHR* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_ray_tracing_pipeline"))
    {
        sOnInvalidDynamicallyCheckedCall("vkCreateRayTracingPipelinesKHR", "VK_KHR_ray_tracing_pipeline");
    }
    AEMU_SCOPED_TRACE("vkCreateRayTracingPipelinesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkCreateRayTracingPipelinesKHR_VkResult_return = (VkResult)0;
    vkCreateRayTracingPipelinesKHR_VkResult_return = vkEnc->vkCreateRayTracingPipelinesKHR(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines, true /* do lock */);
    return vkCreateRayTracingPipelinesKHR_VkResult_return;
}
static VkResult entry_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(
    VkDevice device,
    VkPipeline pipeline,
    uint32_t firstGroup,
    uint32_t groupCount,
    size_t dataSize,
    void* pData)
{
    AEMU_SCOPED_TRACE("vkGetRayTracingCaptureReplayShaderGroupHandlesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return = (VkResult)0;
    vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return = vkEnc->vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData, true /* do lock */);
    return vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return;
}
static VkResult dynCheck_entry_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(
    VkDevice device,
    VkPipeline pipeline,
    uint32_t firstGroup,
    uint32_t groupCount,
    size_t dataSize,
    void* pData)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_ray_tracing_pipeline"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetRayTracingCaptureReplayShaderGroupHandlesKHR", "VK_KHR_ray_tracing_pipeline");
    }
    AEMU_SCOPED_TRACE("vkGetRayTracingCaptureReplayShaderGroupHandlesKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkResult vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return = (VkResult)0;
    vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return = vkEnc->vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData, true /* do lock */);
    return vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return;
}
static void entry_vkCmdTraceRaysIndirectKHR(
    VkCommandBuffer commandBuffer,
    const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable,
    VkDeviceAddress indirectDeviceAddress)
{
    AEMU_SCOPED_TRACE("vkCmdTraceRaysIndirectKHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdTraceRaysIndirectKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress, true /* do lock */);
}
static VkDeviceSize entry_vkGetRayTracingShaderGroupStackSizeKHR(
    VkDevice device,
    VkPipeline pipeline,
    uint32_t group,
    VkShaderGroupShaderKHR groupShader)
{
    AEMU_SCOPED_TRACE("vkGetRayTracingShaderGroupStackSizeKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkDeviceSize vkGetRayTracingShaderGroupStackSizeKHR_VkDeviceSize_return = (VkDeviceSize)0;
    vkGetRayTracingShaderGroupStackSizeKHR_VkDeviceSize_return = vkEnc->vkGetRayTracingShaderGroupStackSizeKHR(device, pipeline, group, groupShader, true /* do lock */);
    return vkGetRayTracingShaderGroupStackSizeKHR_VkDeviceSize_return;
}
static VkDeviceSize dynCheck_entry_vkGetRayTracingShaderGroupStackSizeKHR(
    VkDevice device,
    VkPipeline pipeline,
    uint32_t group,
    VkShaderGroupShaderKHR groupShader)
{
    auto resources = ResourceTracker::get();
    if (!resources->hasDeviceExtension(device, "VK_KHR_ray_tracing_pipeline"))
    {
        sOnInvalidDynamicallyCheckedCall("vkGetRayTracingShaderGroupStackSizeKHR", "VK_KHR_ray_tracing_pipeline");
    }
    AEMU_SCOPED_TRACE("vkGetRayTracingShaderGroupStackSizeKHR");
    auto vkEnc = ResourceTracker::getThreadLocalEncoder();
    VkDeviceSize vkGetRayTracingShaderGroupStackSizeKHR_VkDeviceSize_return = (VkDeviceSize)0;
    vkGetRayTracingShaderGroupStackSizeKHR_VkDeviceSize_return = vkEnc->vkGetRayTracingShaderGroupStackSizeKHR(device, pipeline, group, groupShader, true /* do lock */);
    return vkGetRayTracingShaderGroupStackSizeKHR_VkDeviceSize_return;
}
static void entry_vkCmdSetRayTracingPipelineStackSizeKHR(
    VkCommandBuffer commandBuffer,
    uint32_t pipelineStackSize)
{
    AEMU_SCOPED_TRACE("vkCmdSetRayTracingPipelineStackSizeKHR");
    auto vkEnc = ResourceTracker::getCommandBufferEncoder(commandBuffer);
    vkEnc->vkCmdSetRayTracingPipelineStackSizeKHR(commandBuffer, pipelineStackSize, true /* do lock */);
}
#endif
#ifdef VK_KHR_ray_query
#endif
void* goldfish_vulkan_get_proc_address(const char* name){
#ifdef VK_VERSION_1_0
    if (!strcmp(name, "vkCreateInstance"))
    {
        return (void*)entry_vkCreateInstance;
    }
    if (!strcmp(name, "vkDestroyInstance"))
    {
        return (void*)entry_vkDestroyInstance;
    }
    if (!strcmp(name, "vkEnumeratePhysicalDevices"))
    {
        return (void*)entry_vkEnumeratePhysicalDevices;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFeatures"))
    {
        return (void*)entry_vkGetPhysicalDeviceFeatures;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFormatProperties"))
    {
        return (void*)entry_vkGetPhysicalDeviceFormatProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceImageFormatProperties"))
    {
        return (void*)entry_vkGetPhysicalDeviceImageFormatProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceProperties"))
    {
        return (void*)entry_vkGetPhysicalDeviceProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyProperties"))
    {
        return (void*)entry_vkGetPhysicalDeviceQueueFamilyProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMemoryProperties"))
    {
        return (void*)entry_vkGetPhysicalDeviceMemoryProperties;
    }
    if (!strcmp(name, "vkGetInstanceProcAddr"))
    {
        return (void*)entry_vkGetInstanceProcAddr;
    }
    if (!strcmp(name, "vkGetDeviceProcAddr"))
    {
        return (void*)entry_vkGetDeviceProcAddr;
    }
    if (!strcmp(name, "vkCreateDevice"))
    {
        return (void*)entry_vkCreateDevice;
    }
    if (!strcmp(name, "vkDestroyDevice"))
    {
        return (void*)entry_vkDestroyDevice;
    }
    if (!strcmp(name, "vkEnumerateInstanceExtensionProperties"))
    {
        return (void*)entry_vkEnumerateInstanceExtensionProperties;
    }
    if (!strcmp(name, "vkEnumerateDeviceExtensionProperties"))
    {
        return (void*)entry_vkEnumerateDeviceExtensionProperties;
    }
    if (!strcmp(name, "vkEnumerateInstanceLayerProperties"))
    {
        return (void*)entry_vkEnumerateInstanceLayerProperties;
    }
    if (!strcmp(name, "vkEnumerateDeviceLayerProperties"))
    {
        return (void*)entry_vkEnumerateDeviceLayerProperties;
    }
    if (!strcmp(name, "vkGetDeviceQueue"))
    {
        return (void*)entry_vkGetDeviceQueue;
    }
    if (!strcmp(name, "vkQueueSubmit"))
    {
        return (void*)entry_vkQueueSubmit;
    }
    if (!strcmp(name, "vkQueueWaitIdle"))
    {
        return (void*)entry_vkQueueWaitIdle;
    }
    if (!strcmp(name, "vkDeviceWaitIdle"))
    {
        return (void*)entry_vkDeviceWaitIdle;
    }
    if (!strcmp(name, "vkAllocateMemory"))
    {
        return (void*)entry_vkAllocateMemory;
    }
    if (!strcmp(name, "vkFreeMemory"))
    {
        return (void*)entry_vkFreeMemory;
    }
    if (!strcmp(name, "vkMapMemory"))
    {
        return (void*)entry_vkMapMemory;
    }
    if (!strcmp(name, "vkUnmapMemory"))
    {
        return (void*)entry_vkUnmapMemory;
    }
    if (!strcmp(name, "vkFlushMappedMemoryRanges"))
    {
        return (void*)entry_vkFlushMappedMemoryRanges;
    }
    if (!strcmp(name, "vkInvalidateMappedMemoryRanges"))
    {
        return (void*)entry_vkInvalidateMappedMemoryRanges;
    }
    if (!strcmp(name, "vkGetDeviceMemoryCommitment"))
    {
        return (void*)entry_vkGetDeviceMemoryCommitment;
    }
    if (!strcmp(name, "vkBindBufferMemory"))
    {
        return (void*)entry_vkBindBufferMemory;
    }
    if (!strcmp(name, "vkBindImageMemory"))
    {
        return (void*)entry_vkBindImageMemory;
    }
    if (!strcmp(name, "vkGetBufferMemoryRequirements"))
    {
        return (void*)entry_vkGetBufferMemoryRequirements;
    }
    if (!strcmp(name, "vkGetImageMemoryRequirements"))
    {
        return (void*)entry_vkGetImageMemoryRequirements;
    }
    if (!strcmp(name, "vkGetImageSparseMemoryRequirements"))
    {
        return (void*)entry_vkGetImageSparseMemoryRequirements;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSparseImageFormatProperties"))
    {
        return (void*)entry_vkGetPhysicalDeviceSparseImageFormatProperties;
    }
    if (!strcmp(name, "vkQueueBindSparse"))
    {
        return (void*)entry_vkQueueBindSparse;
    }
    if (!strcmp(name, "vkCreateFence"))
    {
        return (void*)entry_vkCreateFence;
    }
    if (!strcmp(name, "vkDestroyFence"))
    {
        return (void*)entry_vkDestroyFence;
    }
    if (!strcmp(name, "vkResetFences"))
    {
        return (void*)entry_vkResetFences;
    }
    if (!strcmp(name, "vkGetFenceStatus"))
    {
        return (void*)entry_vkGetFenceStatus;
    }
    if (!strcmp(name, "vkWaitForFences"))
    {
        return (void*)entry_vkWaitForFences;
    }
    if (!strcmp(name, "vkCreateSemaphore"))
    {
        return (void*)entry_vkCreateSemaphore;
    }
    if (!strcmp(name, "vkDestroySemaphore"))
    {
        return (void*)entry_vkDestroySemaphore;
    }
    if (!strcmp(name, "vkCreateEvent"))
    {
        return (void*)entry_vkCreateEvent;
    }
    if (!strcmp(name, "vkDestroyEvent"))
    {
        return (void*)entry_vkDestroyEvent;
    }
    if (!strcmp(name, "vkGetEventStatus"))
    {
        return (void*)entry_vkGetEventStatus;
    }
    if (!strcmp(name, "vkSetEvent"))
    {
        return (void*)entry_vkSetEvent;
    }
    if (!strcmp(name, "vkResetEvent"))
    {
        return (void*)entry_vkResetEvent;
    }
    if (!strcmp(name, "vkCreateQueryPool"))
    {
        return (void*)entry_vkCreateQueryPool;
    }
    if (!strcmp(name, "vkDestroyQueryPool"))
    {
        return (void*)entry_vkDestroyQueryPool;
    }
    if (!strcmp(name, "vkGetQueryPoolResults"))
    {
        return (void*)entry_vkGetQueryPoolResults;
    }
    if (!strcmp(name, "vkCreateBuffer"))
    {
        return (void*)entry_vkCreateBuffer;
    }
    if (!strcmp(name, "vkDestroyBuffer"))
    {
        return (void*)entry_vkDestroyBuffer;
    }
    if (!strcmp(name, "vkCreateBufferView"))
    {
        return (void*)entry_vkCreateBufferView;
    }
    if (!strcmp(name, "vkDestroyBufferView"))
    {
        return (void*)entry_vkDestroyBufferView;
    }
    if (!strcmp(name, "vkCreateImage"))
    {
        return (void*)entry_vkCreateImage;
    }
    if (!strcmp(name, "vkDestroyImage"))
    {
        return (void*)entry_vkDestroyImage;
    }
    if (!strcmp(name, "vkGetImageSubresourceLayout"))
    {
        return (void*)entry_vkGetImageSubresourceLayout;
    }
    if (!strcmp(name, "vkCreateImageView"))
    {
        return (void*)entry_vkCreateImageView;
    }
    if (!strcmp(name, "vkDestroyImageView"))
    {
        return (void*)entry_vkDestroyImageView;
    }
    if (!strcmp(name, "vkCreateShaderModule"))
    {
        return (void*)entry_vkCreateShaderModule;
    }
    if (!strcmp(name, "vkDestroyShaderModule"))
    {
        return (void*)entry_vkDestroyShaderModule;
    }
    if (!strcmp(name, "vkCreatePipelineCache"))
    {
        return (void*)entry_vkCreatePipelineCache;
    }
    if (!strcmp(name, "vkDestroyPipelineCache"))
    {
        return (void*)entry_vkDestroyPipelineCache;
    }
    if (!strcmp(name, "vkGetPipelineCacheData"))
    {
        return (void*)entry_vkGetPipelineCacheData;
    }
    if (!strcmp(name, "vkMergePipelineCaches"))
    {
        return (void*)entry_vkMergePipelineCaches;
    }
    if (!strcmp(name, "vkCreateGraphicsPipelines"))
    {
        return (void*)entry_vkCreateGraphicsPipelines;
    }
    if (!strcmp(name, "vkCreateComputePipelines"))
    {
        return (void*)entry_vkCreateComputePipelines;
    }
    if (!strcmp(name, "vkDestroyPipeline"))
    {
        return (void*)entry_vkDestroyPipeline;
    }
    if (!strcmp(name, "vkCreatePipelineLayout"))
    {
        return (void*)entry_vkCreatePipelineLayout;
    }
    if (!strcmp(name, "vkDestroyPipelineLayout"))
    {
        return (void*)entry_vkDestroyPipelineLayout;
    }
    if (!strcmp(name, "vkCreateSampler"))
    {
        return (void*)entry_vkCreateSampler;
    }
    if (!strcmp(name, "vkDestroySampler"))
    {
        return (void*)entry_vkDestroySampler;
    }
    if (!strcmp(name, "vkCreateDescriptorSetLayout"))
    {
        return (void*)entry_vkCreateDescriptorSetLayout;
    }
    if (!strcmp(name, "vkDestroyDescriptorSetLayout"))
    {
        return (void*)entry_vkDestroyDescriptorSetLayout;
    }
    if (!strcmp(name, "vkCreateDescriptorPool"))
    {
        return (void*)entry_vkCreateDescriptorPool;
    }
    if (!strcmp(name, "vkDestroyDescriptorPool"))
    {
        return (void*)entry_vkDestroyDescriptorPool;
    }
    if (!strcmp(name, "vkResetDescriptorPool"))
    {
        return (void*)entry_vkResetDescriptorPool;
    }
    if (!strcmp(name, "vkAllocateDescriptorSets"))
    {
        return (void*)entry_vkAllocateDescriptorSets;
    }
    if (!strcmp(name, "vkFreeDescriptorSets"))
    {
        return (void*)entry_vkFreeDescriptorSets;
    }
    if (!strcmp(name, "vkUpdateDescriptorSets"))
    {
        return (void*)entry_vkUpdateDescriptorSets;
    }
    if (!strcmp(name, "vkCreateFramebuffer"))
    {
        return (void*)entry_vkCreateFramebuffer;
    }
    if (!strcmp(name, "vkDestroyFramebuffer"))
    {
        return (void*)entry_vkDestroyFramebuffer;
    }
    if (!strcmp(name, "vkCreateRenderPass"))
    {
        return (void*)entry_vkCreateRenderPass;
    }
    if (!strcmp(name, "vkDestroyRenderPass"))
    {
        return (void*)entry_vkDestroyRenderPass;
    }
    if (!strcmp(name, "vkGetRenderAreaGranularity"))
    {
        return (void*)entry_vkGetRenderAreaGranularity;
    }
    if (!strcmp(name, "vkCreateCommandPool"))
    {
        return (void*)entry_vkCreateCommandPool;
    }
    if (!strcmp(name, "vkDestroyCommandPool"))
    {
        return (void*)entry_vkDestroyCommandPool;
    }
    if (!strcmp(name, "vkResetCommandPool"))
    {
        return (void*)entry_vkResetCommandPool;
    }
    if (!strcmp(name, "vkAllocateCommandBuffers"))
    {
        return (void*)entry_vkAllocateCommandBuffers;
    }
    if (!strcmp(name, "vkFreeCommandBuffers"))
    {
        return (void*)entry_vkFreeCommandBuffers;
    }
    if (!strcmp(name, "vkBeginCommandBuffer"))
    {
        return (void*)entry_vkBeginCommandBuffer;
    }
    if (!strcmp(name, "vkEndCommandBuffer"))
    {
        return (void*)entry_vkEndCommandBuffer;
    }
    if (!strcmp(name, "vkResetCommandBuffer"))
    {
        return (void*)entry_vkResetCommandBuffer;
    }
    if (!strcmp(name, "vkCmdBindPipeline"))
    {
        return (void*)entry_vkCmdBindPipeline;
    }
    if (!strcmp(name, "vkCmdSetViewport"))
    {
        return (void*)entry_vkCmdSetViewport;
    }
    if (!strcmp(name, "vkCmdSetScissor"))
    {
        return (void*)entry_vkCmdSetScissor;
    }
    if (!strcmp(name, "vkCmdSetLineWidth"))
    {
        return (void*)entry_vkCmdSetLineWidth;
    }
    if (!strcmp(name, "vkCmdSetDepthBias"))
    {
        return (void*)entry_vkCmdSetDepthBias;
    }
    if (!strcmp(name, "vkCmdSetBlendConstants"))
    {
        return (void*)entry_vkCmdSetBlendConstants;
    }
    if (!strcmp(name, "vkCmdSetDepthBounds"))
    {
        return (void*)entry_vkCmdSetDepthBounds;
    }
    if (!strcmp(name, "vkCmdSetStencilCompareMask"))
    {
        return (void*)entry_vkCmdSetStencilCompareMask;
    }
    if (!strcmp(name, "vkCmdSetStencilWriteMask"))
    {
        return (void*)entry_vkCmdSetStencilWriteMask;
    }
    if (!strcmp(name, "vkCmdSetStencilReference"))
    {
        return (void*)entry_vkCmdSetStencilReference;
    }
    if (!strcmp(name, "vkCmdBindDescriptorSets"))
    {
        return (void*)entry_vkCmdBindDescriptorSets;
    }
    if (!strcmp(name, "vkCmdBindIndexBuffer"))
    {
        return (void*)entry_vkCmdBindIndexBuffer;
    }
    if (!strcmp(name, "vkCmdBindVertexBuffers"))
    {
        return (void*)entry_vkCmdBindVertexBuffers;
    }
    if (!strcmp(name, "vkCmdDraw"))
    {
        return (void*)entry_vkCmdDraw;
    }
    if (!strcmp(name, "vkCmdDrawIndexed"))
    {
        return (void*)entry_vkCmdDrawIndexed;
    }
    if (!strcmp(name, "vkCmdDrawIndirect"))
    {
        return (void*)entry_vkCmdDrawIndirect;
    }
    if (!strcmp(name, "vkCmdDrawIndexedIndirect"))
    {
        return (void*)entry_vkCmdDrawIndexedIndirect;
    }
    if (!strcmp(name, "vkCmdDispatch"))
    {
        return (void*)entry_vkCmdDispatch;
    }
    if (!strcmp(name, "vkCmdDispatchIndirect"))
    {
        return (void*)entry_vkCmdDispatchIndirect;
    }
    if (!strcmp(name, "vkCmdCopyBuffer"))
    {
        return (void*)entry_vkCmdCopyBuffer;
    }
    if (!strcmp(name, "vkCmdCopyImage"))
    {
        return (void*)entry_vkCmdCopyImage;
    }
    if (!strcmp(name, "vkCmdBlitImage"))
    {
        return (void*)entry_vkCmdBlitImage;
    }
    if (!strcmp(name, "vkCmdCopyBufferToImage"))
    {
        return (void*)entry_vkCmdCopyBufferToImage;
    }
    if (!strcmp(name, "vkCmdCopyImageToBuffer"))
    {
        return (void*)entry_vkCmdCopyImageToBuffer;
    }
    if (!strcmp(name, "vkCmdUpdateBuffer"))
    {
        return (void*)entry_vkCmdUpdateBuffer;
    }
    if (!strcmp(name, "vkCmdFillBuffer"))
    {
        return (void*)entry_vkCmdFillBuffer;
    }
    if (!strcmp(name, "vkCmdClearColorImage"))
    {
        return (void*)entry_vkCmdClearColorImage;
    }
    if (!strcmp(name, "vkCmdClearDepthStencilImage"))
    {
        return (void*)entry_vkCmdClearDepthStencilImage;
    }
    if (!strcmp(name, "vkCmdClearAttachments"))
    {
        return (void*)entry_vkCmdClearAttachments;
    }
    if (!strcmp(name, "vkCmdResolveImage"))
    {
        return (void*)entry_vkCmdResolveImage;
    }
    if (!strcmp(name, "vkCmdSetEvent"))
    {
        return (void*)entry_vkCmdSetEvent;
    }
    if (!strcmp(name, "vkCmdResetEvent"))
    {
        return (void*)entry_vkCmdResetEvent;
    }
    if (!strcmp(name, "vkCmdWaitEvents"))
    {
        return (void*)entry_vkCmdWaitEvents;
    }
    if (!strcmp(name, "vkCmdPipelineBarrier"))
    {
        return (void*)entry_vkCmdPipelineBarrier;
    }
    if (!strcmp(name, "vkCmdBeginQuery"))
    {
        return (void*)entry_vkCmdBeginQuery;
    }
    if (!strcmp(name, "vkCmdEndQuery"))
    {
        return (void*)entry_vkCmdEndQuery;
    }
    if (!strcmp(name, "vkCmdResetQueryPool"))
    {
        return (void*)entry_vkCmdResetQueryPool;
    }
    if (!strcmp(name, "vkCmdWriteTimestamp"))
    {
        return (void*)entry_vkCmdWriteTimestamp;
    }
    if (!strcmp(name, "vkCmdCopyQueryPoolResults"))
    {
        return (void*)entry_vkCmdCopyQueryPoolResults;
    }
    if (!strcmp(name, "vkCmdPushConstants"))
    {
        return (void*)entry_vkCmdPushConstants;
    }
    if (!strcmp(name, "vkCmdBeginRenderPass"))
    {
        return (void*)entry_vkCmdBeginRenderPass;
    }
    if (!strcmp(name, "vkCmdNextSubpass"))
    {
        return (void*)entry_vkCmdNextSubpass;
    }
    if (!strcmp(name, "vkCmdEndRenderPass"))
    {
        return (void*)entry_vkCmdEndRenderPass;
    }
    if (!strcmp(name, "vkCmdExecuteCommands"))
    {
        return (void*)entry_vkCmdExecuteCommands;
    }
#endif
#ifdef VK_VERSION_1_1
    if (!strcmp(name, "vkEnumerateInstanceVersion"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkBindBufferMemory2"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkBindImageMemory2"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDeviceGroupPeerMemoryFeatures"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetDeviceMask"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdDispatchBase"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkEnumeratePhysicalDeviceGroups"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetImageMemoryRequirements2"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetBufferMemoryRequirements2"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetImageSparseMemoryRequirements2"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFeatures2"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceProperties2"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFormatProperties2"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceImageFormatProperties2"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyProperties2"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMemoryProperties2"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSparseImageFormatProperties2"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkTrimCommandPool"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDeviceQueue2"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCreateSamplerYcbcrConversion"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkDestroySamplerYcbcrConversion"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCreateDescriptorUpdateTemplate"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkDestroyDescriptorUpdateTemplate"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkUpdateDescriptorSetWithTemplate"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceExternalBufferProperties"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceExternalFenceProperties"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceExternalSemaphoreProperties"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDescriptorSetLayoutSupport"))
    {
        return nullptr;
    }
#endif
#ifdef VK_VERSION_1_2
    if (!strcmp(name, "vkCmdDrawIndirectCount"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdDrawIndexedIndirectCount"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCreateRenderPass2"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdBeginRenderPass2"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdNextSubpass2"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdEndRenderPass2"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkResetQueryPool"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetSemaphoreCounterValue"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkWaitSemaphores"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkSignalSemaphore"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetBufferDeviceAddress"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetBufferOpaqueCaptureAddress"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDeviceMemoryOpaqueCaptureAddress"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_surface
    if (!strcmp(name, "vkDestroySurfaceKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSurfaceSupportKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSurfaceFormatsKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSurfacePresentModesKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_swapchain
    if (!strcmp(name, "vkCreateSwapchainKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkDestroySwapchainKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetSwapchainImagesKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkAcquireNextImageKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkQueuePresentKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDeviceGroupPresentCapabilitiesKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDeviceGroupSurfacePresentModesKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDevicePresentRectanglesKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkAcquireNextImage2KHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_display
    if (!strcmp(name, "vkGetPhysicalDeviceDisplayPropertiesKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDisplayPlaneSupportedDisplaysKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDisplayModePropertiesKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCreateDisplayModeKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDisplayPlaneCapabilitiesKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCreateDisplayPlaneSurfaceKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_display_swapchain
    if (!strcmp(name, "vkCreateSharedSwapchainsKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_xlib_surface
    if (!strcmp(name, "vkCreateXlibSurfaceKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceXlibPresentationSupportKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_xcb_surface
    if (!strcmp(name, "vkCreateXcbSurfaceKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceXcbPresentationSupportKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_wayland_surface
    if (!strcmp(name, "vkCreateWaylandSurfaceKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceWaylandPresentationSupportKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_android_surface
    if (!strcmp(name, "vkCreateAndroidSurfaceKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_win32_surface
    if (!strcmp(name, "vkCreateWin32SurfaceKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceWin32PresentationSupportKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_get_physical_device_properties2
    if (!strcmp(name, "vkGetPhysicalDeviceFeatures2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceProperties2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFormatProperties2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceImageFormatProperties2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyProperties2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMemoryProperties2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_device_group
    if (!strcmp(name, "vkGetDeviceGroupPeerMemoryFeaturesKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetDeviceMaskKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdDispatchBaseKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_maintenance1
    if (!strcmp(name, "vkTrimCommandPoolKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_device_group_creation
    if (!strcmp(name, "vkEnumeratePhysicalDeviceGroupsKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_external_memory_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalBufferPropertiesKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_external_memory_win32
    if (!strcmp(name, "vkGetMemoryWin32HandleKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetMemoryWin32HandlePropertiesKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_external_memory_fd
    if (!strcmp(name, "vkGetMemoryFdKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetMemoryFdPropertiesKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_external_semaphore_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_external_semaphore_win32
    if (!strcmp(name, "vkImportSemaphoreWin32HandleKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetSemaphoreWin32HandleKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_external_semaphore_fd
    if (!strcmp(name, "vkImportSemaphoreFdKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetSemaphoreFdKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_push_descriptor
    if (!strcmp(name, "vkCmdPushDescriptorSetKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdPushDescriptorSetWithTemplateKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_descriptor_update_template
    if (!strcmp(name, "vkCreateDescriptorUpdateTemplateKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkDestroyDescriptorUpdateTemplateKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkUpdateDescriptorSetWithTemplateKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_create_renderpass2
    if (!strcmp(name, "vkCreateRenderPass2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdBeginRenderPass2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdNextSubpass2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdEndRenderPass2KHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_shared_presentable_image
    if (!strcmp(name, "vkGetSwapchainStatusKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_external_fence_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalFencePropertiesKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_external_fence_win32
    if (!strcmp(name, "vkImportFenceWin32HandleKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetFenceWin32HandleKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_external_fence_fd
    if (!strcmp(name, "vkImportFenceFdKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetFenceFdKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_performance_query
    if (!strcmp(name, "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkAcquireProfilingLockKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkReleaseProfilingLockKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_get_surface_capabilities2
    if (!strcmp(name, "vkGetPhysicalDeviceSurfaceCapabilities2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSurfaceFormats2KHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_get_display_properties2
    if (!strcmp(name, "vkGetPhysicalDeviceDisplayProperties2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceDisplayPlaneProperties2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDisplayModeProperties2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDisplayPlaneCapabilities2KHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_get_memory_requirements2
    if (!strcmp(name, "vkGetImageMemoryRequirements2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetBufferMemoryRequirements2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetImageSparseMemoryRequirements2KHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
    if (!strcmp(name, "vkCreateSamplerYcbcrConversionKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkDestroySamplerYcbcrConversionKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_bind_memory2
    if (!strcmp(name, "vkBindBufferMemory2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkBindImageMemory2KHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_maintenance3
    if (!strcmp(name, "vkGetDescriptorSetLayoutSupportKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_draw_indirect_count
    if (!strcmp(name, "vkCmdDrawIndirectCountKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdDrawIndexedIndirectCountKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_timeline_semaphore
    if (!strcmp(name, "vkGetSemaphoreCounterValueKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkWaitSemaphoresKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkSignalSemaphoreKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_fragment_shading_rate
    if (!strcmp(name, "vkGetPhysicalDeviceFragmentShadingRatesKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetFragmentShadingRateKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_buffer_device_address
    if (!strcmp(name, "vkGetBufferDeviceAddressKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetBufferOpaqueCaptureAddressKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDeviceMemoryOpaqueCaptureAddressKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_deferred_host_operations
    if (!strcmp(name, "vkCreateDeferredOperationKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkDestroyDeferredOperationKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDeferredOperationMaxConcurrencyKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDeferredOperationResultKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkDeferredOperationJoinKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_pipeline_executable_properties
    if (!strcmp(name, "vkGetPipelineExecutablePropertiesKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPipelineExecutableStatisticsKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPipelineExecutableInternalRepresentationsKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_copy_commands2
    if (!strcmp(name, "vkCmdCopyBuffer2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdCopyImage2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdCopyBufferToImage2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdCopyImageToBuffer2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdBlitImage2KHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdResolveImage2KHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_ANDROID_native_buffer
    if (!strcmp(name, "vkGetSwapchainGrallocUsageANDROID"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkAcquireImageANDROID"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueSignalReleaseImageANDROID"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_debug_report
    if (!strcmp(name, "vkCreateDebugReportCallbackEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkDestroyDebugReportCallbackEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkDebugReportMessageEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_debug_marker
    if (!strcmp(name, "vkDebugMarkerSetObjectTagEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkDebugMarkerSetObjectNameEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdDebugMarkerBeginEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdDebugMarkerEndEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdDebugMarkerInsertEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_transform_feedback
    if (!strcmp(name, "vkCmdBindTransformFeedbackBuffersEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdBeginTransformFeedbackEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdEndTransformFeedbackEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdBeginQueryIndexedEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdEndQueryIndexedEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdDrawIndirectByteCountEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_NVX_image_view_handle
    if (!strcmp(name, "vkGetImageViewHandleNVX"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetImageViewAddressNVX"))
    {
        return nullptr;
    }
#endif
#ifdef VK_AMD_draw_indirect_count
    if (!strcmp(name, "vkCmdDrawIndirectCountAMD"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdDrawIndexedIndirectCountAMD"))
    {
        return nullptr;
    }
#endif
#ifdef VK_AMD_shader_info
    if (!strcmp(name, "vkGetShaderInfoAMD"))
    {
        return nullptr;
    }
#endif
#ifdef VK_GGP_stream_descriptor_surface
    if (!strcmp(name, "vkCreateStreamDescriptorSurfaceGGP"))
    {
        return nullptr;
    }
#endif
#ifdef VK_NV_external_memory_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV"))
    {
        return nullptr;
    }
#endif
#ifdef VK_NV_external_memory_win32
    if (!strcmp(name, "vkGetMemoryWin32HandleNV"))
    {
        return nullptr;
    }
#endif
#ifdef VK_NN_vi_surface
    if (!strcmp(name, "vkCreateViSurfaceNN"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_conditional_rendering
    if (!strcmp(name, "vkCmdBeginConditionalRenderingEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdEndConditionalRenderingEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_NV_clip_space_w_scaling
    if (!strcmp(name, "vkCmdSetViewportWScalingNV"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_direct_mode_display
    if (!strcmp(name, "vkReleaseDisplayEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_acquire_xlib_display
    if (!strcmp(name, "vkAcquireXlibDisplayEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetRandROutputDisplayEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_display_surface_counter
    if (!strcmp(name, "vkGetPhysicalDeviceSurfaceCapabilities2EXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_display_control
    if (!strcmp(name, "vkDisplayPowerControlEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkRegisterDeviceEventEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkRegisterDisplayEventEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetSwapchainCounterEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_GOOGLE_display_timing
    if (!strcmp(name, "vkGetRefreshCycleDurationGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPastPresentationTimingGOOGLE"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_discard_rectangles
    if (!strcmp(name, "vkCmdSetDiscardRectangleEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_hdr_metadata
    if (!strcmp(name, "vkSetHdrMetadataEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_MVK_ios_surface
    if (!strcmp(name, "vkCreateIOSSurfaceMVK"))
    {
        return nullptr;
    }
#endif
#ifdef VK_MVK_macos_surface
    if (!strcmp(name, "vkCreateMacOSSurfaceMVK"))
    {
        return nullptr;
    }
#endif
#ifdef VK_MVK_moltenvk
    if (!strcmp(name, "vkGetMTLDeviceMVK"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkSetMTLTextureMVK"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetMTLTextureMVK"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetMTLBufferMVK"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkUseIOSurfaceMVK"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetIOSurfaceMVK"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_debug_utils
    if (!strcmp(name, "vkSetDebugUtilsObjectNameEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkSetDebugUtilsObjectTagEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueBeginDebugUtilsLabelEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueEndDebugUtilsLabelEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueInsertDebugUtilsLabelEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdBeginDebugUtilsLabelEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdEndDebugUtilsLabelEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdInsertDebugUtilsLabelEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCreateDebugUtilsMessengerEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkDestroyDebugUtilsMessengerEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkSubmitDebugUtilsMessageEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    if (!strcmp(name, "vkGetAndroidHardwareBufferPropertiesANDROID"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetMemoryAndroidHardwareBufferANDROID"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_sample_locations
    if (!strcmp(name, "vkCmdSetSampleLocationsEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMultisamplePropertiesEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_image_drm_format_modifier
    if (!strcmp(name, "vkGetImageDrmFormatModifierPropertiesEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_validation_cache
    if (!strcmp(name, "vkCreateValidationCacheEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkDestroyValidationCacheEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkMergeValidationCachesEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetValidationCacheDataEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_NV_shading_rate_image
    if (!strcmp(name, "vkCmdBindShadingRateImageNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetViewportShadingRatePaletteNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetCoarseSampleOrderNV"))
    {
        return nullptr;
    }
#endif
#ifdef VK_NV_ray_tracing
    if (!strcmp(name, "vkCreateAccelerationStructureNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkDestroyAccelerationStructureNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetAccelerationStructureMemoryRequirementsNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkBindAccelerationStructureMemoryNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdBuildAccelerationStructureNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdCopyAccelerationStructureNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdTraceRaysNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCreateRayTracingPipelinesNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetRayTracingShaderGroupHandlesKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetRayTracingShaderGroupHandlesNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetAccelerationStructureHandleNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdWriteAccelerationStructuresPropertiesNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCompileDeferredNV"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_external_memory_host
    if (!strcmp(name, "vkGetMemoryHostPointerPropertiesEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_AMD_buffer_marker
    if (!strcmp(name, "vkCmdWriteBufferMarkerAMD"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_calibrated_timestamps
    if (!strcmp(name, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetCalibratedTimestampsEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_NV_mesh_shader
    if (!strcmp(name, "vkCmdDrawMeshTasksNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdDrawMeshTasksIndirectNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdDrawMeshTasksIndirectCountNV"))
    {
        return nullptr;
    }
#endif
#ifdef VK_NV_scissor_exclusive
    if (!strcmp(name, "vkCmdSetExclusiveScissorNV"))
    {
        return nullptr;
    }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
    if (!strcmp(name, "vkCmdSetCheckpointNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetQueueCheckpointDataNV"))
    {
        return nullptr;
    }
#endif
#ifdef VK_INTEL_performance_query
    if (!strcmp(name, "vkInitializePerformanceApiINTEL"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkUninitializePerformanceApiINTEL"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetPerformanceMarkerINTEL"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetPerformanceStreamMarkerINTEL"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetPerformanceOverrideINTEL"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkAcquirePerformanceConfigurationINTEL"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkReleasePerformanceConfigurationINTEL"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueSetPerformanceConfigurationINTEL"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPerformanceParameterINTEL"))
    {
        return nullptr;
    }
#endif
#ifdef VK_AMD_display_native_hdr
    if (!strcmp(name, "vkSetLocalDimmingAMD"))
    {
        return nullptr;
    }
#endif
#ifdef VK_FUCHSIA_imagepipe_surface
    if (!strcmp(name, "vkCreateImagePipeSurfaceFUCHSIA"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_metal_surface
    if (!strcmp(name, "vkCreateMetalSurfaceEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_buffer_device_address
    if (!strcmp(name, "vkGetBufferDeviceAddressEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_tooling_info
    if (!strcmp(name, "vkGetPhysicalDeviceToolPropertiesEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_NV_cooperative_matrix
    if (!strcmp(name, "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV"))
    {
        return nullptr;
    }
#endif
#ifdef VK_NV_coverage_reduction_mode
    if (!strcmp(name, "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_full_screen_exclusive
    if (!strcmp(name, "vkGetPhysicalDeviceSurfacePresentModes2EXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkAcquireFullScreenExclusiveModeEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkReleaseFullScreenExclusiveModeEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDeviceGroupSurfacePresentModes2EXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_headless_surface
    if (!strcmp(name, "vkCreateHeadlessSurfaceEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_line_rasterization
    if (!strcmp(name, "vkCmdSetLineStippleEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_host_query_reset
    if (!strcmp(name, "vkResetQueryPoolEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_extended_dynamic_state
    if (!strcmp(name, "vkCmdSetCullModeEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetFrontFaceEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetPrimitiveTopologyEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetViewportWithCountEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetScissorWithCountEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdBindVertexBuffers2EXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthTestEnableEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthWriteEnableEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthCompareOpEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthBoundsTestEnableEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetStencilTestEnableEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetStencilOpEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_NV_device_generated_commands
    if (!strcmp(name, "vkGetGeneratedCommandsMemoryRequirementsNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdPreprocessGeneratedCommandsNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdExecuteGeneratedCommandsNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdBindPipelineShaderGroupNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCreateIndirectCommandsLayoutNV"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkDestroyIndirectCommandsLayoutNV"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_private_data
    if (!strcmp(name, "vkCreatePrivateDataSlotEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkDestroyPrivateDataSlotEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkSetPrivateDataEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPrivateDataEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    if (!strcmp(name, "vkCmdSetFragmentShadingRateEnumNV"))
    {
        return nullptr;
    }
#endif
#ifdef VK_EXT_directfb_surface
    if (!strcmp(name, "vkCreateDirectFBSurfaceEXT"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceDirectFBPresentationSupportEXT"))
    {
        return nullptr;
    }
#endif
#ifdef VK_GOOGLE_gfxstream
    if (!strcmp(name, "vkRegisterImageColorBufferGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkRegisterBufferColorBufferGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkMapMemoryIntoAddressSpaceGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkUpdateDescriptorSetWithTemplateSizedGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkBeginCommandBufferAsyncGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkEndCommandBufferAsyncGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkResetCommandBufferAsyncGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCommandBufferHostSyncGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCreateImageWithRequirementsGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCreateBufferWithRequirementsGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetMemoryHostAddressInfoGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkFreeMemorySyncGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueHostSyncGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueSubmitAsyncGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueWaitIdleAsyncGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueBindSparseAsyncGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetLinearImageLayoutGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueFlushCommandsGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkQueueCommitDescriptorSetUpdatesGOOGLE"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCollectDescriptorPoolIdsGOOGLE"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_acceleration_structure
    if (!strcmp(name, "vkCreateAccelerationStructureKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkDestroyAccelerationStructureKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdBuildAccelerationStructuresKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdBuildAccelerationStructuresIndirectKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkBuildAccelerationStructuresKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCopyAccelerationStructureKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCopyAccelerationStructureToMemoryKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCopyMemoryToAccelerationStructureKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkWriteAccelerationStructuresPropertiesKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdCopyAccelerationStructureKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdCopyAccelerationStructureToMemoryKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdCopyMemoryToAccelerationStructureKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetAccelerationStructureDeviceAddressKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdWriteAccelerationStructuresPropertiesKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetDeviceAccelerationStructureCompatibilityKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetAccelerationStructureBuildSizesKHR"))
    {
        return nullptr;
    }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    if (!strcmp(name, "vkCmdTraceRaysKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCreateRayTracingPipelinesKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdTraceRaysIndirectKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetRayTracingShaderGroupStackSizeKHR"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkCmdSetRayTracingPipelineStackSizeKHR"))
    {
        return nullptr;
    }
#endif
    return nullptr;
}
void* goldfish_vulkan_get_instance_proc_address(VkInstance instance, const char* name){
    auto resources = ResourceTracker::get();
    bool has1_1OrHigher = resources->getApiVersionFromInstance(instance) >= VK_API_VERSION_1_1;
#ifdef VK_VERSION_1_0
    if (!strcmp(name, "vkCreateInstance"))
    {
        return (void*)entry_vkCreateInstance;
    }
    if (!strcmp(name, "vkDestroyInstance"))
    {
        return (void*)entry_vkDestroyInstance;
    }
    if (!strcmp(name, "vkEnumeratePhysicalDevices"))
    {
        return (void*)entry_vkEnumeratePhysicalDevices;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFeatures"))
    {
        return (void*)entry_vkGetPhysicalDeviceFeatures;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFormatProperties"))
    {
        return (void*)entry_vkGetPhysicalDeviceFormatProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceImageFormatProperties"))
    {
        return (void*)entry_vkGetPhysicalDeviceImageFormatProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceProperties"))
    {
        return (void*)entry_vkGetPhysicalDeviceProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyProperties"))
    {
        return (void*)entry_vkGetPhysicalDeviceQueueFamilyProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMemoryProperties"))
    {
        return (void*)entry_vkGetPhysicalDeviceMemoryProperties;
    }
    if (!strcmp(name, "vkGetInstanceProcAddr"))
    {
        return (void*)entry_vkGetInstanceProcAddr;
    }
    if (!strcmp(name, "vkGetDeviceProcAddr"))
    {
        return (void*)entry_vkGetDeviceProcAddr;
    }
    if (!strcmp(name, "vkCreateDevice"))
    {
        return (void*)entry_vkCreateDevice;
    }
    if (!strcmp(name, "vkDestroyDevice"))
    {
        return (void*)entry_vkDestroyDevice;
    }
    if (!strcmp(name, "vkEnumerateInstanceExtensionProperties"))
    {
        return (void*)entry_vkEnumerateInstanceExtensionProperties;
    }
    if (!strcmp(name, "vkEnumerateDeviceExtensionProperties"))
    {
        return (void*)entry_vkEnumerateDeviceExtensionProperties;
    }
    if (!strcmp(name, "vkEnumerateInstanceLayerProperties"))
    {
        return (void*)entry_vkEnumerateInstanceLayerProperties;
    }
    if (!strcmp(name, "vkEnumerateDeviceLayerProperties"))
    {
        return (void*)entry_vkEnumerateDeviceLayerProperties;
    }
    if (!strcmp(name, "vkGetDeviceQueue"))
    {
        return (void*)entry_vkGetDeviceQueue;
    }
    if (!strcmp(name, "vkQueueSubmit"))
    {
        return (void*)entry_vkQueueSubmit;
    }
    if (!strcmp(name, "vkQueueWaitIdle"))
    {
        return (void*)entry_vkQueueWaitIdle;
    }
    if (!strcmp(name, "vkDeviceWaitIdle"))
    {
        return (void*)entry_vkDeviceWaitIdle;
    }
    if (!strcmp(name, "vkAllocateMemory"))
    {
        return (void*)entry_vkAllocateMemory;
    }
    if (!strcmp(name, "vkFreeMemory"))
    {
        return (void*)entry_vkFreeMemory;
    }
    if (!strcmp(name, "vkMapMemory"))
    {
        return (void*)entry_vkMapMemory;
    }
    if (!strcmp(name, "vkUnmapMemory"))
    {
        return (void*)entry_vkUnmapMemory;
    }
    if (!strcmp(name, "vkFlushMappedMemoryRanges"))
    {
        return (void*)entry_vkFlushMappedMemoryRanges;
    }
    if (!strcmp(name, "vkInvalidateMappedMemoryRanges"))
    {
        return (void*)entry_vkInvalidateMappedMemoryRanges;
    }
    if (!strcmp(name, "vkGetDeviceMemoryCommitment"))
    {
        return (void*)entry_vkGetDeviceMemoryCommitment;
    }
    if (!strcmp(name, "vkBindBufferMemory"))
    {
        return (void*)entry_vkBindBufferMemory;
    }
    if (!strcmp(name, "vkBindImageMemory"))
    {
        return (void*)entry_vkBindImageMemory;
    }
    if (!strcmp(name, "vkGetBufferMemoryRequirements"))
    {
        return (void*)entry_vkGetBufferMemoryRequirements;
    }
    if (!strcmp(name, "vkGetImageMemoryRequirements"))
    {
        return (void*)entry_vkGetImageMemoryRequirements;
    }
    if (!strcmp(name, "vkGetImageSparseMemoryRequirements"))
    {
        return (void*)entry_vkGetImageSparseMemoryRequirements;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSparseImageFormatProperties"))
    {
        return (void*)entry_vkGetPhysicalDeviceSparseImageFormatProperties;
    }
    if (!strcmp(name, "vkQueueBindSparse"))
    {
        return (void*)entry_vkQueueBindSparse;
    }
    if (!strcmp(name, "vkCreateFence"))
    {
        return (void*)entry_vkCreateFence;
    }
    if (!strcmp(name, "vkDestroyFence"))
    {
        return (void*)entry_vkDestroyFence;
    }
    if (!strcmp(name, "vkResetFences"))
    {
        return (void*)entry_vkResetFences;
    }
    if (!strcmp(name, "vkGetFenceStatus"))
    {
        return (void*)entry_vkGetFenceStatus;
    }
    if (!strcmp(name, "vkWaitForFences"))
    {
        return (void*)entry_vkWaitForFences;
    }
    if (!strcmp(name, "vkCreateSemaphore"))
    {
        return (void*)entry_vkCreateSemaphore;
    }
    if (!strcmp(name, "vkDestroySemaphore"))
    {
        return (void*)entry_vkDestroySemaphore;
    }
    if (!strcmp(name, "vkCreateEvent"))
    {
        return (void*)entry_vkCreateEvent;
    }
    if (!strcmp(name, "vkDestroyEvent"))
    {
        return (void*)entry_vkDestroyEvent;
    }
    if (!strcmp(name, "vkGetEventStatus"))
    {
        return (void*)entry_vkGetEventStatus;
    }
    if (!strcmp(name, "vkSetEvent"))
    {
        return (void*)entry_vkSetEvent;
    }
    if (!strcmp(name, "vkResetEvent"))
    {
        return (void*)entry_vkResetEvent;
    }
    if (!strcmp(name, "vkCreateQueryPool"))
    {
        return (void*)entry_vkCreateQueryPool;
    }
    if (!strcmp(name, "vkDestroyQueryPool"))
    {
        return (void*)entry_vkDestroyQueryPool;
    }
    if (!strcmp(name, "vkGetQueryPoolResults"))
    {
        return (void*)entry_vkGetQueryPoolResults;
    }
    if (!strcmp(name, "vkCreateBuffer"))
    {
        return (void*)entry_vkCreateBuffer;
    }
    if (!strcmp(name, "vkDestroyBuffer"))
    {
        return (void*)entry_vkDestroyBuffer;
    }
    if (!strcmp(name, "vkCreateBufferView"))
    {
        return (void*)entry_vkCreateBufferView;
    }
    if (!strcmp(name, "vkDestroyBufferView"))
    {
        return (void*)entry_vkDestroyBufferView;
    }
    if (!strcmp(name, "vkCreateImage"))
    {
        return (void*)entry_vkCreateImage;
    }
    if (!strcmp(name, "vkDestroyImage"))
    {
        return (void*)entry_vkDestroyImage;
    }
    if (!strcmp(name, "vkGetImageSubresourceLayout"))
    {
        return (void*)entry_vkGetImageSubresourceLayout;
    }
    if (!strcmp(name, "vkCreateImageView"))
    {
        return (void*)entry_vkCreateImageView;
    }
    if (!strcmp(name, "vkDestroyImageView"))
    {
        return (void*)entry_vkDestroyImageView;
    }
    if (!strcmp(name, "vkCreateShaderModule"))
    {
        return (void*)entry_vkCreateShaderModule;
    }
    if (!strcmp(name, "vkDestroyShaderModule"))
    {
        return (void*)entry_vkDestroyShaderModule;
    }
    if (!strcmp(name, "vkCreatePipelineCache"))
    {
        return (void*)entry_vkCreatePipelineCache;
    }
    if (!strcmp(name, "vkDestroyPipelineCache"))
    {
        return (void*)entry_vkDestroyPipelineCache;
    }
    if (!strcmp(name, "vkGetPipelineCacheData"))
    {
        return (void*)entry_vkGetPipelineCacheData;
    }
    if (!strcmp(name, "vkMergePipelineCaches"))
    {
        return (void*)entry_vkMergePipelineCaches;
    }
    if (!strcmp(name, "vkCreateGraphicsPipelines"))
    {
        return (void*)entry_vkCreateGraphicsPipelines;
    }
    if (!strcmp(name, "vkCreateComputePipelines"))
    {
        return (void*)entry_vkCreateComputePipelines;
    }
    if (!strcmp(name, "vkDestroyPipeline"))
    {
        return (void*)entry_vkDestroyPipeline;
    }
    if (!strcmp(name, "vkCreatePipelineLayout"))
    {
        return (void*)entry_vkCreatePipelineLayout;
    }
    if (!strcmp(name, "vkDestroyPipelineLayout"))
    {
        return (void*)entry_vkDestroyPipelineLayout;
    }
    if (!strcmp(name, "vkCreateSampler"))
    {
        return (void*)entry_vkCreateSampler;
    }
    if (!strcmp(name, "vkDestroySampler"))
    {
        return (void*)entry_vkDestroySampler;
    }
    if (!strcmp(name, "vkCreateDescriptorSetLayout"))
    {
        return (void*)entry_vkCreateDescriptorSetLayout;
    }
    if (!strcmp(name, "vkDestroyDescriptorSetLayout"))
    {
        return (void*)entry_vkDestroyDescriptorSetLayout;
    }
    if (!strcmp(name, "vkCreateDescriptorPool"))
    {
        return (void*)entry_vkCreateDescriptorPool;
    }
    if (!strcmp(name, "vkDestroyDescriptorPool"))
    {
        return (void*)entry_vkDestroyDescriptorPool;
    }
    if (!strcmp(name, "vkResetDescriptorPool"))
    {
        return (void*)entry_vkResetDescriptorPool;
    }
    if (!strcmp(name, "vkAllocateDescriptorSets"))
    {
        return (void*)entry_vkAllocateDescriptorSets;
    }
    if (!strcmp(name, "vkFreeDescriptorSets"))
    {
        return (void*)entry_vkFreeDescriptorSets;
    }
    if (!strcmp(name, "vkUpdateDescriptorSets"))
    {
        return (void*)entry_vkUpdateDescriptorSets;
    }
    if (!strcmp(name, "vkCreateFramebuffer"))
    {
        return (void*)entry_vkCreateFramebuffer;
    }
    if (!strcmp(name, "vkDestroyFramebuffer"))
    {
        return (void*)entry_vkDestroyFramebuffer;
    }
    if (!strcmp(name, "vkCreateRenderPass"))
    {
        return (void*)entry_vkCreateRenderPass;
    }
    if (!strcmp(name, "vkDestroyRenderPass"))
    {
        return (void*)entry_vkDestroyRenderPass;
    }
    if (!strcmp(name, "vkGetRenderAreaGranularity"))
    {
        return (void*)entry_vkGetRenderAreaGranularity;
    }
    if (!strcmp(name, "vkCreateCommandPool"))
    {
        return (void*)entry_vkCreateCommandPool;
    }
    if (!strcmp(name, "vkDestroyCommandPool"))
    {
        return (void*)entry_vkDestroyCommandPool;
    }
    if (!strcmp(name, "vkResetCommandPool"))
    {
        return (void*)entry_vkResetCommandPool;
    }
    if (!strcmp(name, "vkAllocateCommandBuffers"))
    {
        return (void*)entry_vkAllocateCommandBuffers;
    }
    if (!strcmp(name, "vkFreeCommandBuffers"))
    {
        return (void*)entry_vkFreeCommandBuffers;
    }
    if (!strcmp(name, "vkBeginCommandBuffer"))
    {
        return (void*)entry_vkBeginCommandBuffer;
    }
    if (!strcmp(name, "vkEndCommandBuffer"))
    {
        return (void*)entry_vkEndCommandBuffer;
    }
    if (!strcmp(name, "vkResetCommandBuffer"))
    {
        return (void*)entry_vkResetCommandBuffer;
    }
    if (!strcmp(name, "vkCmdBindPipeline"))
    {
        return (void*)entry_vkCmdBindPipeline;
    }
    if (!strcmp(name, "vkCmdSetViewport"))
    {
        return (void*)entry_vkCmdSetViewport;
    }
    if (!strcmp(name, "vkCmdSetScissor"))
    {
        return (void*)entry_vkCmdSetScissor;
    }
    if (!strcmp(name, "vkCmdSetLineWidth"))
    {
        return (void*)entry_vkCmdSetLineWidth;
    }
    if (!strcmp(name, "vkCmdSetDepthBias"))
    {
        return (void*)entry_vkCmdSetDepthBias;
    }
    if (!strcmp(name, "vkCmdSetBlendConstants"))
    {
        return (void*)entry_vkCmdSetBlendConstants;
    }
    if (!strcmp(name, "vkCmdSetDepthBounds"))
    {
        return (void*)entry_vkCmdSetDepthBounds;
    }
    if (!strcmp(name, "vkCmdSetStencilCompareMask"))
    {
        return (void*)entry_vkCmdSetStencilCompareMask;
    }
    if (!strcmp(name, "vkCmdSetStencilWriteMask"))
    {
        return (void*)entry_vkCmdSetStencilWriteMask;
    }
    if (!strcmp(name, "vkCmdSetStencilReference"))
    {
        return (void*)entry_vkCmdSetStencilReference;
    }
    if (!strcmp(name, "vkCmdBindDescriptorSets"))
    {
        return (void*)entry_vkCmdBindDescriptorSets;
    }
    if (!strcmp(name, "vkCmdBindIndexBuffer"))
    {
        return (void*)entry_vkCmdBindIndexBuffer;
    }
    if (!strcmp(name, "vkCmdBindVertexBuffers"))
    {
        return (void*)entry_vkCmdBindVertexBuffers;
    }
    if (!strcmp(name, "vkCmdDraw"))
    {
        return (void*)entry_vkCmdDraw;
    }
    if (!strcmp(name, "vkCmdDrawIndexed"))
    {
        return (void*)entry_vkCmdDrawIndexed;
    }
    if (!strcmp(name, "vkCmdDrawIndirect"))
    {
        return (void*)entry_vkCmdDrawIndirect;
    }
    if (!strcmp(name, "vkCmdDrawIndexedIndirect"))
    {
        return (void*)entry_vkCmdDrawIndexedIndirect;
    }
    if (!strcmp(name, "vkCmdDispatch"))
    {
        return (void*)entry_vkCmdDispatch;
    }
    if (!strcmp(name, "vkCmdDispatchIndirect"))
    {
        return (void*)entry_vkCmdDispatchIndirect;
    }
    if (!strcmp(name, "vkCmdCopyBuffer"))
    {
        return (void*)entry_vkCmdCopyBuffer;
    }
    if (!strcmp(name, "vkCmdCopyImage"))
    {
        return (void*)entry_vkCmdCopyImage;
    }
    if (!strcmp(name, "vkCmdBlitImage"))
    {
        return (void*)entry_vkCmdBlitImage;
    }
    if (!strcmp(name, "vkCmdCopyBufferToImage"))
    {
        return (void*)entry_vkCmdCopyBufferToImage;
    }
    if (!strcmp(name, "vkCmdCopyImageToBuffer"))
    {
        return (void*)entry_vkCmdCopyImageToBuffer;
    }
    if (!strcmp(name, "vkCmdUpdateBuffer"))
    {
        return (void*)entry_vkCmdUpdateBuffer;
    }
    if (!strcmp(name, "vkCmdFillBuffer"))
    {
        return (void*)entry_vkCmdFillBuffer;
    }
    if (!strcmp(name, "vkCmdClearColorImage"))
    {
        return (void*)entry_vkCmdClearColorImage;
    }
    if (!strcmp(name, "vkCmdClearDepthStencilImage"))
    {
        return (void*)entry_vkCmdClearDepthStencilImage;
    }
    if (!strcmp(name, "vkCmdClearAttachments"))
    {
        return (void*)entry_vkCmdClearAttachments;
    }
    if (!strcmp(name, "vkCmdResolveImage"))
    {
        return (void*)entry_vkCmdResolveImage;
    }
    if (!strcmp(name, "vkCmdSetEvent"))
    {
        return (void*)entry_vkCmdSetEvent;
    }
    if (!strcmp(name, "vkCmdResetEvent"))
    {
        return (void*)entry_vkCmdResetEvent;
    }
    if (!strcmp(name, "vkCmdWaitEvents"))
    {
        return (void*)entry_vkCmdWaitEvents;
    }
    if (!strcmp(name, "vkCmdPipelineBarrier"))
    {
        return (void*)entry_vkCmdPipelineBarrier;
    }
    if (!strcmp(name, "vkCmdBeginQuery"))
    {
        return (void*)entry_vkCmdBeginQuery;
    }
    if (!strcmp(name, "vkCmdEndQuery"))
    {
        return (void*)entry_vkCmdEndQuery;
    }
    if (!strcmp(name, "vkCmdResetQueryPool"))
    {
        return (void*)entry_vkCmdResetQueryPool;
    }
    if (!strcmp(name, "vkCmdWriteTimestamp"))
    {
        return (void*)entry_vkCmdWriteTimestamp;
    }
    if (!strcmp(name, "vkCmdCopyQueryPoolResults"))
    {
        return (void*)entry_vkCmdCopyQueryPoolResults;
    }
    if (!strcmp(name, "vkCmdPushConstants"))
    {
        return (void*)entry_vkCmdPushConstants;
    }
    if (!strcmp(name, "vkCmdBeginRenderPass"))
    {
        return (void*)entry_vkCmdBeginRenderPass;
    }
    if (!strcmp(name, "vkCmdNextSubpass"))
    {
        return (void*)entry_vkCmdNextSubpass;
    }
    if (!strcmp(name, "vkCmdEndRenderPass"))
    {
        return (void*)entry_vkCmdEndRenderPass;
    }
    if (!strcmp(name, "vkCmdExecuteCommands"))
    {
        return (void*)entry_vkCmdExecuteCommands;
    }
#endif
#ifdef VK_VERSION_1_1
    if (!strcmp(name, "vkEnumerateInstanceVersion"))
    {
        return has1_1OrHigher ? (void*)entry_vkEnumerateInstanceVersion : nullptr;
    }
    if (!strcmp(name, "vkBindBufferMemory2"))
    {
        return (void*)dynCheck_entry_vkBindBufferMemory2;
    }
    if (!strcmp(name, "vkBindImageMemory2"))
    {
        return (void*)dynCheck_entry_vkBindImageMemory2;
    }
    if (!strcmp(name, "vkGetDeviceGroupPeerMemoryFeatures"))
    {
        return (void*)dynCheck_entry_vkGetDeviceGroupPeerMemoryFeatures;
    }
    if (!strcmp(name, "vkCmdSetDeviceMask"))
    {
        return has1_1OrHigher ? (void*)entry_vkCmdSetDeviceMask : nullptr;
    }
    if (!strcmp(name, "vkCmdDispatchBase"))
    {
        return has1_1OrHigher ? (void*)entry_vkCmdDispatchBase : nullptr;
    }
    if (!strcmp(name, "vkEnumeratePhysicalDeviceGroups"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetImageMemoryRequirements2"))
    {
        return (void*)dynCheck_entry_vkGetImageMemoryRequirements2;
    }
    if (!strcmp(name, "vkGetBufferMemoryRequirements2"))
    {
        return (void*)dynCheck_entry_vkGetBufferMemoryRequirements2;
    }
    if (!strcmp(name, "vkGetImageSparseMemoryRequirements2"))
    {
        return (void*)dynCheck_entry_vkGetImageSparseMemoryRequirements2;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFeatures2"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceFeatures2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceProperties2"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFormatProperties2"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceFormatProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceImageFormatProperties2"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceImageFormatProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyProperties2"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceQueueFamilyProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMemoryProperties2"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceMemoryProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSparseImageFormatProperties2"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceSparseImageFormatProperties2 : nullptr;
    }
    if (!strcmp(name, "vkTrimCommandPool"))
    {
        return (void*)dynCheck_entry_vkTrimCommandPool;
    }
    if (!strcmp(name, "vkGetDeviceQueue2"))
    {
        return (void*)dynCheck_entry_vkGetDeviceQueue2;
    }
    if (!strcmp(name, "vkCreateSamplerYcbcrConversion"))
    {
        return (void*)dynCheck_entry_vkCreateSamplerYcbcrConversion;
    }
    if (!strcmp(name, "vkDestroySamplerYcbcrConversion"))
    {
        return (void*)dynCheck_entry_vkDestroySamplerYcbcrConversion;
    }
    if (!strcmp(name, "vkCreateDescriptorUpdateTemplate"))
    {
        return (void*)dynCheck_entry_vkCreateDescriptorUpdateTemplate;
    }
    if (!strcmp(name, "vkDestroyDescriptorUpdateTemplate"))
    {
        return (void*)dynCheck_entry_vkDestroyDescriptorUpdateTemplate;
    }
    if (!strcmp(name, "vkUpdateDescriptorSetWithTemplate"))
    {
        return (void*)dynCheck_entry_vkUpdateDescriptorSetWithTemplate;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceExternalBufferProperties"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceExternalBufferProperties : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceExternalFenceProperties"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceExternalFenceProperties : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceExternalSemaphoreProperties"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceExternalSemaphoreProperties : nullptr;
    }
    if (!strcmp(name, "vkGetDescriptorSetLayoutSupport"))
    {
        return (void*)dynCheck_entry_vkGetDescriptorSetLayoutSupport;
    }
#endif
#ifdef VK_VERSION_1_2
    if (!strcmp(name, "vkCmdDrawIndirectCount"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkCmdDrawIndirectCount : nullptr;
    }
    if (!strcmp(name, "vkCmdDrawIndexedIndirectCount"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkCmdDrawIndexedIndirectCount : nullptr;
    }
    if (!strcmp(name, "vkCreateRenderPass2"))
    {
        return (void*)dynCheck_entry_vkCreateRenderPass2;
    }
    if (!strcmp(name, "vkCmdBeginRenderPass2"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkCmdBeginRenderPass2 : nullptr;
    }
    if (!strcmp(name, "vkCmdNextSubpass2"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkCmdNextSubpass2 : nullptr;
    }
    if (!strcmp(name, "vkCmdEndRenderPass2"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkCmdEndRenderPass2 : nullptr;
    }
    if (!strcmp(name, "vkResetQueryPool"))
    {
        return (void*)dynCheck_entry_vkResetQueryPool;
    }
    if (!strcmp(name, "vkGetSemaphoreCounterValue"))
    {
        return (void*)dynCheck_entry_vkGetSemaphoreCounterValue;
    }
    if (!strcmp(name, "vkWaitSemaphores"))
    {
        return (void*)dynCheck_entry_vkWaitSemaphores;
    }
    if (!strcmp(name, "vkSignalSemaphore"))
    {
        return (void*)dynCheck_entry_vkSignalSemaphore;
    }
    if (!strcmp(name, "vkGetBufferDeviceAddress"))
    {
        return (void*)dynCheck_entry_vkGetBufferDeviceAddress;
    }
    if (!strcmp(name, "vkGetBufferOpaqueCaptureAddress"))
    {
        return (void*)dynCheck_entry_vkGetBufferOpaqueCaptureAddress;
    }
    if (!strcmp(name, "vkGetDeviceMemoryOpaqueCaptureAddress"))
    {
        return (void*)dynCheck_entry_vkGetDeviceMemoryOpaqueCaptureAddress;
    }
#endif
#ifdef VK_KHR_surface
    if (!strcmp(name, "vkDestroySurfaceKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_surface");
        return hasExt ? (void*)entry_vkDestroySurfaceKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSurfaceSupportKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_surface");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSurfaceSupportKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_surface");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSurfaceCapabilitiesKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSurfaceFormatsKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_surface");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSurfaceFormatsKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSurfacePresentModesKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_surface");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSurfacePresentModesKHR : nullptr;
    }
#endif
#ifdef VK_KHR_swapchain
    if (!strcmp(name, "vkCreateSwapchainKHR"))
    {
        return (void*)dynCheck_entry_vkCreateSwapchainKHR;
    }
    if (!strcmp(name, "vkDestroySwapchainKHR"))
    {
        return (void*)dynCheck_entry_vkDestroySwapchainKHR;
    }
    if (!strcmp(name, "vkGetSwapchainImagesKHR"))
    {
        return (void*)dynCheck_entry_vkGetSwapchainImagesKHR;
    }
    if (!strcmp(name, "vkAcquireNextImageKHR"))
    {
        return (void*)dynCheck_entry_vkAcquireNextImageKHR;
    }
    if (!strcmp(name, "vkQueuePresentKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_swapchain");
        return hasExt ? (void*)entry_vkQueuePresentKHR : nullptr;
    }
    if (!strcmp(name, "vkGetDeviceGroupPresentCapabilitiesKHR"))
    {
        return (void*)dynCheck_entry_vkGetDeviceGroupPresentCapabilitiesKHR;
    }
    if (!strcmp(name, "vkGetDeviceGroupSurfacePresentModesKHR"))
    {
        return (void*)dynCheck_entry_vkGetDeviceGroupSurfacePresentModesKHR;
    }
    if (!strcmp(name, "vkGetPhysicalDevicePresentRectanglesKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_swapchain");
        return hasExt ? (void*)entry_vkGetPhysicalDevicePresentRectanglesKHR : nullptr;
    }
    if (!strcmp(name, "vkAcquireNextImage2KHR"))
    {
        return (void*)dynCheck_entry_vkAcquireNextImage2KHR;
    }
#endif
#ifdef VK_KHR_display
    if (!strcmp(name, "vkGetPhysicalDeviceDisplayPropertiesKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_display");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceDisplayPropertiesKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_display");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceDisplayPlanePropertiesKHR : nullptr;
    }
    if (!strcmp(name, "vkGetDisplayPlaneSupportedDisplaysKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_display");
        return hasExt ? (void*)entry_vkGetDisplayPlaneSupportedDisplaysKHR : nullptr;
    }
    if (!strcmp(name, "vkGetDisplayModePropertiesKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_display");
        return hasExt ? (void*)entry_vkGetDisplayModePropertiesKHR : nullptr;
    }
    if (!strcmp(name, "vkCreateDisplayModeKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_display");
        return hasExt ? (void*)entry_vkCreateDisplayModeKHR : nullptr;
    }
    if (!strcmp(name, "vkGetDisplayPlaneCapabilitiesKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_display");
        return hasExt ? (void*)entry_vkGetDisplayPlaneCapabilitiesKHR : nullptr;
    }
    if (!strcmp(name, "vkCreateDisplayPlaneSurfaceKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_display");
        return hasExt ? (void*)entry_vkCreateDisplayPlaneSurfaceKHR : nullptr;
    }
#endif
#ifdef VK_KHR_display_swapchain
    if (!strcmp(name, "vkCreateSharedSwapchainsKHR"))
    {
        return (void*)dynCheck_entry_vkCreateSharedSwapchainsKHR;
    }
#endif
#ifdef VK_KHR_xlib_surface
    if (!strcmp(name, "vkCreateXlibSurfaceKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_xlib_surface");
        return hasExt ? (void*)entry_vkCreateXlibSurfaceKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceXlibPresentationSupportKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_xlib_surface");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceXlibPresentationSupportKHR : nullptr;
    }
#endif
#ifdef VK_KHR_xcb_surface
    if (!strcmp(name, "vkCreateXcbSurfaceKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_xcb_surface");
        return hasExt ? (void*)entry_vkCreateXcbSurfaceKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceXcbPresentationSupportKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_xcb_surface");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceXcbPresentationSupportKHR : nullptr;
    }
#endif
#ifdef VK_KHR_wayland_surface
    if (!strcmp(name, "vkCreateWaylandSurfaceKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_wayland_surface");
        return hasExt ? (void*)entry_vkCreateWaylandSurfaceKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceWaylandPresentationSupportKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_wayland_surface");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceWaylandPresentationSupportKHR : nullptr;
    }
#endif
#ifdef VK_KHR_android_surface
    if (!strcmp(name, "vkCreateAndroidSurfaceKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_android_surface");
        return hasExt ? (void*)entry_vkCreateAndroidSurfaceKHR : nullptr;
    }
#endif
#ifdef VK_KHR_win32_surface
    if (!strcmp(name, "vkCreateWin32SurfaceKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_win32_surface");
        return hasExt ? (void*)entry_vkCreateWin32SurfaceKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceWin32PresentationSupportKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_win32_surface");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceWin32PresentationSupportKHR : nullptr;
    }
#endif
#ifdef VK_KHR_get_physical_device_properties2
    if (!strcmp(name, "vkGetPhysicalDeviceFeatures2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceFeatures2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceProperties2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFormatProperties2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceFormatProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceImageFormatProperties2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceImageFormatProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyProperties2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceQueueFamilyProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMemoryProperties2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceMemoryProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSparseImageFormatProperties2KHR : nullptr;
    }
#endif
#ifdef VK_KHR_device_group
    if (!strcmp(name, "vkGetDeviceGroupPeerMemoryFeaturesKHR"))
    {
        return (void*)dynCheck_entry_vkGetDeviceGroupPeerMemoryFeaturesKHR;
    }
    if (!strcmp(name, "vkCmdSetDeviceMaskKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_device_group");
        return hasExt ? (void*)entry_vkCmdSetDeviceMaskKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdDispatchBaseKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_device_group");
        return hasExt ? (void*)entry_vkCmdDispatchBaseKHR : nullptr;
    }
#endif
#ifdef VK_KHR_maintenance1
    if (!strcmp(name, "vkTrimCommandPoolKHR"))
    {
        return (void*)dynCheck_entry_vkTrimCommandPoolKHR;
    }
#endif
#ifdef VK_KHR_device_group_creation
    if (!strcmp(name, "vkEnumeratePhysicalDeviceGroupsKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_device_group_creation");
        return hasExt ? (void*)entry_vkEnumeratePhysicalDeviceGroupsKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_memory_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalBufferPropertiesKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_external_memory_capabilities");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceExternalBufferPropertiesKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_memory_win32
    if (!strcmp(name, "vkGetMemoryWin32HandleKHR"))
    {
        return (void*)dynCheck_entry_vkGetMemoryWin32HandleKHR;
    }
    if (!strcmp(name, "vkGetMemoryWin32HandlePropertiesKHR"))
    {
        return (void*)dynCheck_entry_vkGetMemoryWin32HandlePropertiesKHR;
    }
#endif
#ifdef VK_KHR_external_memory_fd
    if (!strcmp(name, "vkGetMemoryFdKHR"))
    {
        return (void*)dynCheck_entry_vkGetMemoryFdKHR;
    }
    if (!strcmp(name, "vkGetMemoryFdPropertiesKHR"))
    {
        return (void*)dynCheck_entry_vkGetMemoryFdPropertiesKHR;
    }
#endif
#ifdef VK_KHR_external_semaphore_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_external_semaphore_capabilities");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_semaphore_win32
    if (!strcmp(name, "vkImportSemaphoreWin32HandleKHR"))
    {
        return (void*)dynCheck_entry_vkImportSemaphoreWin32HandleKHR;
    }
    if (!strcmp(name, "vkGetSemaphoreWin32HandleKHR"))
    {
        return (void*)dynCheck_entry_vkGetSemaphoreWin32HandleKHR;
    }
#endif
#ifdef VK_KHR_external_semaphore_fd
    if (!strcmp(name, "vkImportSemaphoreFdKHR"))
    {
        return (void*)dynCheck_entry_vkImportSemaphoreFdKHR;
    }
    if (!strcmp(name, "vkGetSemaphoreFdKHR"))
    {
        return (void*)dynCheck_entry_vkGetSemaphoreFdKHR;
    }
#endif
#ifdef VK_KHR_push_descriptor
    if (!strcmp(name, "vkCmdPushDescriptorSetKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_push_descriptor");
        return hasExt ? (void*)entry_vkCmdPushDescriptorSetKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdPushDescriptorSetWithTemplateKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_push_descriptor");
        return hasExt ? (void*)entry_vkCmdPushDescriptorSetWithTemplateKHR : nullptr;
    }
#endif
#ifdef VK_KHR_descriptor_update_template
    if (!strcmp(name, "vkCreateDescriptorUpdateTemplateKHR"))
    {
        return (void*)dynCheck_entry_vkCreateDescriptorUpdateTemplateKHR;
    }
    if (!strcmp(name, "vkDestroyDescriptorUpdateTemplateKHR"))
    {
        return (void*)dynCheck_entry_vkDestroyDescriptorUpdateTemplateKHR;
    }
    if (!strcmp(name, "vkUpdateDescriptorSetWithTemplateKHR"))
    {
        return (void*)dynCheck_entry_vkUpdateDescriptorSetWithTemplateKHR;
    }
#endif
#ifdef VK_KHR_create_renderpass2
    if (!strcmp(name, "vkCreateRenderPass2KHR"))
    {
        return (void*)dynCheck_entry_vkCreateRenderPass2KHR;
    }
    if (!strcmp(name, "vkCmdBeginRenderPass2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_create_renderpass2");
        return hasExt ? (void*)entry_vkCmdBeginRenderPass2KHR : nullptr;
    }
    if (!strcmp(name, "vkCmdNextSubpass2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_create_renderpass2");
        return hasExt ? (void*)entry_vkCmdNextSubpass2KHR : nullptr;
    }
    if (!strcmp(name, "vkCmdEndRenderPass2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_create_renderpass2");
        return hasExt ? (void*)entry_vkCmdEndRenderPass2KHR : nullptr;
    }
#endif
#ifdef VK_KHR_shared_presentable_image
    if (!strcmp(name, "vkGetSwapchainStatusKHR"))
    {
        return (void*)dynCheck_entry_vkGetSwapchainStatusKHR;
    }
#endif
#ifdef VK_KHR_external_fence_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalFencePropertiesKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_external_fence_capabilities");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceExternalFencePropertiesKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_fence_win32
    if (!strcmp(name, "vkImportFenceWin32HandleKHR"))
    {
        return (void*)dynCheck_entry_vkImportFenceWin32HandleKHR;
    }
    if (!strcmp(name, "vkGetFenceWin32HandleKHR"))
    {
        return (void*)dynCheck_entry_vkGetFenceWin32HandleKHR;
    }
#endif
#ifdef VK_KHR_external_fence_fd
    if (!strcmp(name, "vkImportFenceFdKHR"))
    {
        return (void*)dynCheck_entry_vkImportFenceFdKHR;
    }
    if (!strcmp(name, "vkGetFenceFdKHR"))
    {
        return (void*)dynCheck_entry_vkGetFenceFdKHR;
    }
#endif
#ifdef VK_KHR_performance_query
    if (!strcmp(name, "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_performance_query");
        return hasExt ? (void*)entry_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_performance_query");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR : nullptr;
    }
    if (!strcmp(name, "vkAcquireProfilingLockKHR"))
    {
        return (void*)dynCheck_entry_vkAcquireProfilingLockKHR;
    }
    if (!strcmp(name, "vkReleaseProfilingLockKHR"))
    {
        return (void*)dynCheck_entry_vkReleaseProfilingLockKHR;
    }
#endif
#ifdef VK_KHR_get_surface_capabilities2
    if (!strcmp(name, "vkGetPhysicalDeviceSurfaceCapabilities2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_get_surface_capabilities2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSurfaceCapabilities2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSurfaceFormats2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_get_surface_capabilities2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSurfaceFormats2KHR : nullptr;
    }
#endif
#ifdef VK_KHR_get_display_properties2
    if (!strcmp(name, "vkGetPhysicalDeviceDisplayProperties2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_get_display_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceDisplayProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceDisplayPlaneProperties2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_get_display_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceDisplayPlaneProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetDisplayModeProperties2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_get_display_properties2");
        return hasExt ? (void*)entry_vkGetDisplayModeProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetDisplayPlaneCapabilities2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_get_display_properties2");
        return hasExt ? (void*)entry_vkGetDisplayPlaneCapabilities2KHR : nullptr;
    }
#endif
#ifdef VK_KHR_get_memory_requirements2
    if (!strcmp(name, "vkGetImageMemoryRequirements2KHR"))
    {
        return (void*)dynCheck_entry_vkGetImageMemoryRequirements2KHR;
    }
    if (!strcmp(name, "vkGetBufferMemoryRequirements2KHR"))
    {
        return (void*)dynCheck_entry_vkGetBufferMemoryRequirements2KHR;
    }
    if (!strcmp(name, "vkGetImageSparseMemoryRequirements2KHR"))
    {
        return (void*)dynCheck_entry_vkGetImageSparseMemoryRequirements2KHR;
    }
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
    if (!strcmp(name, "vkCreateSamplerYcbcrConversionKHR"))
    {
        return (void*)dynCheck_entry_vkCreateSamplerYcbcrConversionKHR;
    }
    if (!strcmp(name, "vkDestroySamplerYcbcrConversionKHR"))
    {
        return (void*)dynCheck_entry_vkDestroySamplerYcbcrConversionKHR;
    }
#endif
#ifdef VK_KHR_bind_memory2
    if (!strcmp(name, "vkBindBufferMemory2KHR"))
    {
        return (void*)dynCheck_entry_vkBindBufferMemory2KHR;
    }
    if (!strcmp(name, "vkBindImageMemory2KHR"))
    {
        return (void*)dynCheck_entry_vkBindImageMemory2KHR;
    }
#endif
#ifdef VK_KHR_maintenance3
    if (!strcmp(name, "vkGetDescriptorSetLayoutSupportKHR"))
    {
        return (void*)dynCheck_entry_vkGetDescriptorSetLayoutSupportKHR;
    }
#endif
#ifdef VK_KHR_draw_indirect_count
    if (!strcmp(name, "vkCmdDrawIndirectCountKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_draw_indirect_count");
        return hasExt ? (void*)entry_vkCmdDrawIndirectCountKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdDrawIndexedIndirectCountKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_draw_indirect_count");
        return hasExt ? (void*)entry_vkCmdDrawIndexedIndirectCountKHR : nullptr;
    }
#endif
#ifdef VK_KHR_timeline_semaphore
    if (!strcmp(name, "vkGetSemaphoreCounterValueKHR"))
    {
        return (void*)dynCheck_entry_vkGetSemaphoreCounterValueKHR;
    }
    if (!strcmp(name, "vkWaitSemaphoresKHR"))
    {
        return (void*)dynCheck_entry_vkWaitSemaphoresKHR;
    }
    if (!strcmp(name, "vkSignalSemaphoreKHR"))
    {
        return (void*)dynCheck_entry_vkSignalSemaphoreKHR;
    }
#endif
#ifdef VK_KHR_fragment_shading_rate
    if (!strcmp(name, "vkGetPhysicalDeviceFragmentShadingRatesKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_fragment_shading_rate");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceFragmentShadingRatesKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdSetFragmentShadingRateKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_fragment_shading_rate");
        return hasExt ? (void*)entry_vkCmdSetFragmentShadingRateKHR : nullptr;
    }
#endif
#ifdef VK_KHR_buffer_device_address
    if (!strcmp(name, "vkGetBufferDeviceAddressKHR"))
    {
        return (void*)dynCheck_entry_vkGetBufferDeviceAddressKHR;
    }
    if (!strcmp(name, "vkGetBufferOpaqueCaptureAddressKHR"))
    {
        return (void*)dynCheck_entry_vkGetBufferOpaqueCaptureAddressKHR;
    }
    if (!strcmp(name, "vkGetDeviceMemoryOpaqueCaptureAddressKHR"))
    {
        return (void*)dynCheck_entry_vkGetDeviceMemoryOpaqueCaptureAddressKHR;
    }
#endif
#ifdef VK_KHR_deferred_host_operations
    if (!strcmp(name, "vkCreateDeferredOperationKHR"))
    {
        return (void*)dynCheck_entry_vkCreateDeferredOperationKHR;
    }
    if (!strcmp(name, "vkDestroyDeferredOperationKHR"))
    {
        return (void*)dynCheck_entry_vkDestroyDeferredOperationKHR;
    }
    if (!strcmp(name, "vkGetDeferredOperationMaxConcurrencyKHR"))
    {
        return (void*)dynCheck_entry_vkGetDeferredOperationMaxConcurrencyKHR;
    }
    if (!strcmp(name, "vkGetDeferredOperationResultKHR"))
    {
        return (void*)dynCheck_entry_vkGetDeferredOperationResultKHR;
    }
    if (!strcmp(name, "vkDeferredOperationJoinKHR"))
    {
        return (void*)dynCheck_entry_vkDeferredOperationJoinKHR;
    }
#endif
#ifdef VK_KHR_pipeline_executable_properties
    if (!strcmp(name, "vkGetPipelineExecutablePropertiesKHR"))
    {
        return (void*)dynCheck_entry_vkGetPipelineExecutablePropertiesKHR;
    }
    if (!strcmp(name, "vkGetPipelineExecutableStatisticsKHR"))
    {
        return (void*)dynCheck_entry_vkGetPipelineExecutableStatisticsKHR;
    }
    if (!strcmp(name, "vkGetPipelineExecutableInternalRepresentationsKHR"))
    {
        return (void*)dynCheck_entry_vkGetPipelineExecutableInternalRepresentationsKHR;
    }
#endif
#ifdef VK_KHR_copy_commands2
    if (!strcmp(name, "vkCmdCopyBuffer2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_copy_commands2");
        return hasExt ? (void*)entry_vkCmdCopyBuffer2KHR : nullptr;
    }
    if (!strcmp(name, "vkCmdCopyImage2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_copy_commands2");
        return hasExt ? (void*)entry_vkCmdCopyImage2KHR : nullptr;
    }
    if (!strcmp(name, "vkCmdCopyBufferToImage2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_copy_commands2");
        return hasExt ? (void*)entry_vkCmdCopyBufferToImage2KHR : nullptr;
    }
    if (!strcmp(name, "vkCmdCopyImageToBuffer2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_copy_commands2");
        return hasExt ? (void*)entry_vkCmdCopyImageToBuffer2KHR : nullptr;
    }
    if (!strcmp(name, "vkCmdBlitImage2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_copy_commands2");
        return hasExt ? (void*)entry_vkCmdBlitImage2KHR : nullptr;
    }
    if (!strcmp(name, "vkCmdResolveImage2KHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_copy_commands2");
        return hasExt ? (void*)entry_vkCmdResolveImage2KHR : nullptr;
    }
#endif
#ifdef VK_ANDROID_native_buffer
    if (!strcmp(name, "vkGetSwapchainGrallocUsageANDROID"))
    {
        return (void*)dynCheck_entry_vkGetSwapchainGrallocUsageANDROID;
    }
    if (!strcmp(name, "vkAcquireImageANDROID"))
    {
        return (void*)dynCheck_entry_vkAcquireImageANDROID;
    }
    if (!strcmp(name, "vkQueueSignalReleaseImageANDROID"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_ANDROID_native_buffer");
        return hasExt ? (void*)entry_vkQueueSignalReleaseImageANDROID : nullptr;
    }
#endif
#ifdef VK_EXT_debug_report
    if (!strcmp(name, "vkCreateDebugReportCallbackEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_debug_report");
        return hasExt ? (void*)entry_vkCreateDebugReportCallbackEXT : nullptr;
    }
    if (!strcmp(name, "vkDestroyDebugReportCallbackEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_debug_report");
        return hasExt ? (void*)entry_vkDestroyDebugReportCallbackEXT : nullptr;
    }
    if (!strcmp(name, "vkDebugReportMessageEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_debug_report");
        return hasExt ? (void*)entry_vkDebugReportMessageEXT : nullptr;
    }
#endif
#ifdef VK_EXT_debug_marker
    if (!strcmp(name, "vkDebugMarkerSetObjectTagEXT"))
    {
        return (void*)dynCheck_entry_vkDebugMarkerSetObjectTagEXT;
    }
    if (!strcmp(name, "vkDebugMarkerSetObjectNameEXT"))
    {
        return (void*)dynCheck_entry_vkDebugMarkerSetObjectNameEXT;
    }
    if (!strcmp(name, "vkCmdDebugMarkerBeginEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_debug_marker");
        return hasExt ? (void*)entry_vkCmdDebugMarkerBeginEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdDebugMarkerEndEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_debug_marker");
        return hasExt ? (void*)entry_vkCmdDebugMarkerEndEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdDebugMarkerInsertEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_debug_marker");
        return hasExt ? (void*)entry_vkCmdDebugMarkerInsertEXT : nullptr;
    }
#endif
#ifdef VK_EXT_transform_feedback
    if (!strcmp(name, "vkCmdBindTransformFeedbackBuffersEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_transform_feedback");
        return hasExt ? (void*)entry_vkCmdBindTransformFeedbackBuffersEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdBeginTransformFeedbackEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_transform_feedback");
        return hasExt ? (void*)entry_vkCmdBeginTransformFeedbackEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdEndTransformFeedbackEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_transform_feedback");
        return hasExt ? (void*)entry_vkCmdEndTransformFeedbackEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdBeginQueryIndexedEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_transform_feedback");
        return hasExt ? (void*)entry_vkCmdBeginQueryIndexedEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdEndQueryIndexedEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_transform_feedback");
        return hasExt ? (void*)entry_vkCmdEndQueryIndexedEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdDrawIndirectByteCountEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_transform_feedback");
        return hasExt ? (void*)entry_vkCmdDrawIndirectByteCountEXT : nullptr;
    }
#endif
#ifdef VK_NVX_image_view_handle
    if (!strcmp(name, "vkGetImageViewHandleNVX"))
    {
        return (void*)dynCheck_entry_vkGetImageViewHandleNVX;
    }
    if (!strcmp(name, "vkGetImageViewAddressNVX"))
    {
        return (void*)dynCheck_entry_vkGetImageViewAddressNVX;
    }
#endif
#ifdef VK_AMD_draw_indirect_count
    if (!strcmp(name, "vkCmdDrawIndirectCountAMD"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_AMD_draw_indirect_count");
        return hasExt ? (void*)entry_vkCmdDrawIndirectCountAMD : nullptr;
    }
    if (!strcmp(name, "vkCmdDrawIndexedIndirectCountAMD"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_AMD_draw_indirect_count");
        return hasExt ? (void*)entry_vkCmdDrawIndexedIndirectCountAMD : nullptr;
    }
#endif
#ifdef VK_AMD_shader_info
    if (!strcmp(name, "vkGetShaderInfoAMD"))
    {
        return (void*)dynCheck_entry_vkGetShaderInfoAMD;
    }
#endif
#ifdef VK_GGP_stream_descriptor_surface
    if (!strcmp(name, "vkCreateStreamDescriptorSurfaceGGP"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GGP_stream_descriptor_surface");
        return hasExt ? (void*)entry_vkCreateStreamDescriptorSurfaceGGP : nullptr;
    }
#endif
#ifdef VK_NV_external_memory_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_external_memory_capabilities");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceExternalImageFormatPropertiesNV : nullptr;
    }
#endif
#ifdef VK_NV_external_memory_win32
    if (!strcmp(name, "vkGetMemoryWin32HandleNV"))
    {
        return (void*)dynCheck_entry_vkGetMemoryWin32HandleNV;
    }
#endif
#ifdef VK_NN_vi_surface
    if (!strcmp(name, "vkCreateViSurfaceNN"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NN_vi_surface");
        return hasExt ? (void*)entry_vkCreateViSurfaceNN : nullptr;
    }
#endif
#ifdef VK_EXT_conditional_rendering
    if (!strcmp(name, "vkCmdBeginConditionalRenderingEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_conditional_rendering");
        return hasExt ? (void*)entry_vkCmdBeginConditionalRenderingEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdEndConditionalRenderingEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_conditional_rendering");
        return hasExt ? (void*)entry_vkCmdEndConditionalRenderingEXT : nullptr;
    }
#endif
#ifdef VK_NV_clip_space_w_scaling
    if (!strcmp(name, "vkCmdSetViewportWScalingNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_clip_space_w_scaling");
        return hasExt ? (void*)entry_vkCmdSetViewportWScalingNV : nullptr;
    }
#endif
#ifdef VK_EXT_direct_mode_display
    if (!strcmp(name, "vkReleaseDisplayEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_direct_mode_display");
        return hasExt ? (void*)entry_vkReleaseDisplayEXT : nullptr;
    }
#endif
#ifdef VK_EXT_acquire_xlib_display
    if (!strcmp(name, "vkAcquireXlibDisplayEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_acquire_xlib_display");
        return hasExt ? (void*)entry_vkAcquireXlibDisplayEXT : nullptr;
    }
    if (!strcmp(name, "vkGetRandROutputDisplayEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_acquire_xlib_display");
        return hasExt ? (void*)entry_vkGetRandROutputDisplayEXT : nullptr;
    }
#endif
#ifdef VK_EXT_display_surface_counter
    if (!strcmp(name, "vkGetPhysicalDeviceSurfaceCapabilities2EXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_display_surface_counter");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSurfaceCapabilities2EXT : nullptr;
    }
#endif
#ifdef VK_EXT_display_control
    if (!strcmp(name, "vkDisplayPowerControlEXT"))
    {
        return (void*)dynCheck_entry_vkDisplayPowerControlEXT;
    }
    if (!strcmp(name, "vkRegisterDeviceEventEXT"))
    {
        return (void*)dynCheck_entry_vkRegisterDeviceEventEXT;
    }
    if (!strcmp(name, "vkRegisterDisplayEventEXT"))
    {
        return (void*)dynCheck_entry_vkRegisterDisplayEventEXT;
    }
    if (!strcmp(name, "vkGetSwapchainCounterEXT"))
    {
        return (void*)dynCheck_entry_vkGetSwapchainCounterEXT;
    }
#endif
#ifdef VK_GOOGLE_display_timing
    if (!strcmp(name, "vkGetRefreshCycleDurationGOOGLE"))
    {
        return (void*)dynCheck_entry_vkGetRefreshCycleDurationGOOGLE;
    }
    if (!strcmp(name, "vkGetPastPresentationTimingGOOGLE"))
    {
        return (void*)dynCheck_entry_vkGetPastPresentationTimingGOOGLE;
    }
#endif
#ifdef VK_EXT_discard_rectangles
    if (!strcmp(name, "vkCmdSetDiscardRectangleEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_discard_rectangles");
        return hasExt ? (void*)entry_vkCmdSetDiscardRectangleEXT : nullptr;
    }
#endif
#ifdef VK_EXT_hdr_metadata
    if (!strcmp(name, "vkSetHdrMetadataEXT"))
    {
        return (void*)dynCheck_entry_vkSetHdrMetadataEXT;
    }
#endif
#ifdef VK_MVK_ios_surface
    if (!strcmp(name, "vkCreateIOSSurfaceMVK"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_MVK_ios_surface");
        return hasExt ? (void*)entry_vkCreateIOSSurfaceMVK : nullptr;
    }
#endif
#ifdef VK_MVK_macos_surface
    if (!strcmp(name, "vkCreateMacOSSurfaceMVK"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_MVK_macos_surface");
        return hasExt ? (void*)entry_vkCreateMacOSSurfaceMVK : nullptr;
    }
#endif
#ifdef VK_MVK_moltenvk
    if (!strcmp(name, "vkGetMTLDeviceMVK"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_MVK_moltenvk");
        return hasExt ? (void*)entry_vkGetMTLDeviceMVK : nullptr;
    }
    if (!strcmp(name, "vkSetMTLTextureMVK"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_MVK_moltenvk");
        return hasExt ? (void*)entry_vkSetMTLTextureMVK : nullptr;
    }
    if (!strcmp(name, "vkGetMTLTextureMVK"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_MVK_moltenvk");
        return hasExt ? (void*)entry_vkGetMTLTextureMVK : nullptr;
    }
    if (!strcmp(name, "vkGetMTLBufferMVK"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_MVK_moltenvk");
        return hasExt ? (void*)entry_vkGetMTLBufferMVK : nullptr;
    }
    if (!strcmp(name, "vkUseIOSurfaceMVK"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_MVK_moltenvk");
        return hasExt ? (void*)entry_vkUseIOSurfaceMVK : nullptr;
    }
    if (!strcmp(name, "vkGetIOSurfaceMVK"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_MVK_moltenvk");
        return hasExt ? (void*)entry_vkGetIOSurfaceMVK : nullptr;
    }
#endif
#ifdef VK_EXT_debug_utils
    if (!strcmp(name, "vkSetDebugUtilsObjectNameEXT"))
    {
        return (void*)dynCheck_entry_vkSetDebugUtilsObjectNameEXT;
    }
    if (!strcmp(name, "vkSetDebugUtilsObjectTagEXT"))
    {
        return (void*)dynCheck_entry_vkSetDebugUtilsObjectTagEXT;
    }
    if (!strcmp(name, "vkQueueBeginDebugUtilsLabelEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkQueueBeginDebugUtilsLabelEXT : nullptr;
    }
    if (!strcmp(name, "vkQueueEndDebugUtilsLabelEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkQueueEndDebugUtilsLabelEXT : nullptr;
    }
    if (!strcmp(name, "vkQueueInsertDebugUtilsLabelEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkQueueInsertDebugUtilsLabelEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdBeginDebugUtilsLabelEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkCmdBeginDebugUtilsLabelEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdEndDebugUtilsLabelEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkCmdEndDebugUtilsLabelEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdInsertDebugUtilsLabelEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkCmdInsertDebugUtilsLabelEXT : nullptr;
    }
    if (!strcmp(name, "vkCreateDebugUtilsMessengerEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkCreateDebugUtilsMessengerEXT : nullptr;
    }
    if (!strcmp(name, "vkDestroyDebugUtilsMessengerEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkDestroyDebugUtilsMessengerEXT : nullptr;
    }
    if (!strcmp(name, "vkSubmitDebugUtilsMessageEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkSubmitDebugUtilsMessageEXT : nullptr;
    }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    if (!strcmp(name, "vkGetAndroidHardwareBufferPropertiesANDROID"))
    {
        return (void*)dynCheck_entry_vkGetAndroidHardwareBufferPropertiesANDROID;
    }
    if (!strcmp(name, "vkGetMemoryAndroidHardwareBufferANDROID"))
    {
        return (void*)dynCheck_entry_vkGetMemoryAndroidHardwareBufferANDROID;
    }
#endif
#ifdef VK_EXT_sample_locations
    if (!strcmp(name, "vkCmdSetSampleLocationsEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_sample_locations");
        return hasExt ? (void*)entry_vkCmdSetSampleLocationsEXT : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMultisamplePropertiesEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_sample_locations");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceMultisamplePropertiesEXT : nullptr;
    }
#endif
#ifdef VK_EXT_image_drm_format_modifier
    if (!strcmp(name, "vkGetImageDrmFormatModifierPropertiesEXT"))
    {
        return (void*)dynCheck_entry_vkGetImageDrmFormatModifierPropertiesEXT;
    }
#endif
#ifdef VK_EXT_validation_cache
    if (!strcmp(name, "vkCreateValidationCacheEXT"))
    {
        return (void*)dynCheck_entry_vkCreateValidationCacheEXT;
    }
    if (!strcmp(name, "vkDestroyValidationCacheEXT"))
    {
        return (void*)dynCheck_entry_vkDestroyValidationCacheEXT;
    }
    if (!strcmp(name, "vkMergeValidationCachesEXT"))
    {
        return (void*)dynCheck_entry_vkMergeValidationCachesEXT;
    }
    if (!strcmp(name, "vkGetValidationCacheDataEXT"))
    {
        return (void*)dynCheck_entry_vkGetValidationCacheDataEXT;
    }
#endif
#ifdef VK_NV_shading_rate_image
    if (!strcmp(name, "vkCmdBindShadingRateImageNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_shading_rate_image");
        return hasExt ? (void*)entry_vkCmdBindShadingRateImageNV : nullptr;
    }
    if (!strcmp(name, "vkCmdSetViewportShadingRatePaletteNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_shading_rate_image");
        return hasExt ? (void*)entry_vkCmdSetViewportShadingRatePaletteNV : nullptr;
    }
    if (!strcmp(name, "vkCmdSetCoarseSampleOrderNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_shading_rate_image");
        return hasExt ? (void*)entry_vkCmdSetCoarseSampleOrderNV : nullptr;
    }
#endif
#ifdef VK_NV_ray_tracing
    if (!strcmp(name, "vkCreateAccelerationStructureNV"))
    {
        return (void*)dynCheck_entry_vkCreateAccelerationStructureNV;
    }
    if (!strcmp(name, "vkDestroyAccelerationStructureNV"))
    {
        return (void*)dynCheck_entry_vkDestroyAccelerationStructureNV;
    }
    if (!strcmp(name, "vkGetAccelerationStructureMemoryRequirementsNV"))
    {
        return (void*)dynCheck_entry_vkGetAccelerationStructureMemoryRequirementsNV;
    }
    if (!strcmp(name, "vkBindAccelerationStructureMemoryNV"))
    {
        return (void*)dynCheck_entry_vkBindAccelerationStructureMemoryNV;
    }
    if (!strcmp(name, "vkCmdBuildAccelerationStructureNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_ray_tracing");
        return hasExt ? (void*)entry_vkCmdBuildAccelerationStructureNV : nullptr;
    }
    if (!strcmp(name, "vkCmdCopyAccelerationStructureNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_ray_tracing");
        return hasExt ? (void*)entry_vkCmdCopyAccelerationStructureNV : nullptr;
    }
    if (!strcmp(name, "vkCmdTraceRaysNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_ray_tracing");
        return hasExt ? (void*)entry_vkCmdTraceRaysNV : nullptr;
    }
    if (!strcmp(name, "vkCreateRayTracingPipelinesNV"))
    {
        return (void*)dynCheck_entry_vkCreateRayTracingPipelinesNV;
    }
    if (!strcmp(name, "vkGetRayTracingShaderGroupHandlesKHR"))
    {
        return (void*)dynCheck_entry_vkGetRayTracingShaderGroupHandlesKHR;
    }
    if (!strcmp(name, "vkGetRayTracingShaderGroupHandlesNV"))
    {
        return (void*)dynCheck_entry_vkGetRayTracingShaderGroupHandlesNV;
    }
    if (!strcmp(name, "vkGetAccelerationStructureHandleNV"))
    {
        return (void*)dynCheck_entry_vkGetAccelerationStructureHandleNV;
    }
    if (!strcmp(name, "vkCmdWriteAccelerationStructuresPropertiesNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_ray_tracing");
        return hasExt ? (void*)entry_vkCmdWriteAccelerationStructuresPropertiesNV : nullptr;
    }
    if (!strcmp(name, "vkCompileDeferredNV"))
    {
        return (void*)dynCheck_entry_vkCompileDeferredNV;
    }
#endif
#ifdef VK_EXT_external_memory_host
    if (!strcmp(name, "vkGetMemoryHostPointerPropertiesEXT"))
    {
        return (void*)dynCheck_entry_vkGetMemoryHostPointerPropertiesEXT;
    }
#endif
#ifdef VK_AMD_buffer_marker
    if (!strcmp(name, "vkCmdWriteBufferMarkerAMD"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_AMD_buffer_marker");
        return hasExt ? (void*)entry_vkCmdWriteBufferMarkerAMD : nullptr;
    }
#endif
#ifdef VK_EXT_calibrated_timestamps
    if (!strcmp(name, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_calibrated_timestamps");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT : nullptr;
    }
    if (!strcmp(name, "vkGetCalibratedTimestampsEXT"))
    {
        return (void*)dynCheck_entry_vkGetCalibratedTimestampsEXT;
    }
#endif
#ifdef VK_NV_mesh_shader
    if (!strcmp(name, "vkCmdDrawMeshTasksNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_mesh_shader");
        return hasExt ? (void*)entry_vkCmdDrawMeshTasksNV : nullptr;
    }
    if (!strcmp(name, "vkCmdDrawMeshTasksIndirectNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_mesh_shader");
        return hasExt ? (void*)entry_vkCmdDrawMeshTasksIndirectNV : nullptr;
    }
    if (!strcmp(name, "vkCmdDrawMeshTasksIndirectCountNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_mesh_shader");
        return hasExt ? (void*)entry_vkCmdDrawMeshTasksIndirectCountNV : nullptr;
    }
#endif
#ifdef VK_NV_scissor_exclusive
    if (!strcmp(name, "vkCmdSetExclusiveScissorNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_scissor_exclusive");
        return hasExt ? (void*)entry_vkCmdSetExclusiveScissorNV : nullptr;
    }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
    if (!strcmp(name, "vkCmdSetCheckpointNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_device_diagnostic_checkpoints");
        return hasExt ? (void*)entry_vkCmdSetCheckpointNV : nullptr;
    }
    if (!strcmp(name, "vkGetQueueCheckpointDataNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_device_diagnostic_checkpoints");
        return hasExt ? (void*)entry_vkGetQueueCheckpointDataNV : nullptr;
    }
#endif
#ifdef VK_INTEL_performance_query
    if (!strcmp(name, "vkInitializePerformanceApiINTEL"))
    {
        return (void*)dynCheck_entry_vkInitializePerformanceApiINTEL;
    }
    if (!strcmp(name, "vkUninitializePerformanceApiINTEL"))
    {
        return (void*)dynCheck_entry_vkUninitializePerformanceApiINTEL;
    }
    if (!strcmp(name, "vkCmdSetPerformanceMarkerINTEL"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_INTEL_performance_query");
        return hasExt ? (void*)entry_vkCmdSetPerformanceMarkerINTEL : nullptr;
    }
    if (!strcmp(name, "vkCmdSetPerformanceStreamMarkerINTEL"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_INTEL_performance_query");
        return hasExt ? (void*)entry_vkCmdSetPerformanceStreamMarkerINTEL : nullptr;
    }
    if (!strcmp(name, "vkCmdSetPerformanceOverrideINTEL"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_INTEL_performance_query");
        return hasExt ? (void*)entry_vkCmdSetPerformanceOverrideINTEL : nullptr;
    }
    if (!strcmp(name, "vkAcquirePerformanceConfigurationINTEL"))
    {
        return (void*)dynCheck_entry_vkAcquirePerformanceConfigurationINTEL;
    }
    if (!strcmp(name, "vkReleasePerformanceConfigurationINTEL"))
    {
        return (void*)dynCheck_entry_vkReleasePerformanceConfigurationINTEL;
    }
    if (!strcmp(name, "vkQueueSetPerformanceConfigurationINTEL"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_INTEL_performance_query");
        return hasExt ? (void*)entry_vkQueueSetPerformanceConfigurationINTEL : nullptr;
    }
    if (!strcmp(name, "vkGetPerformanceParameterINTEL"))
    {
        return (void*)dynCheck_entry_vkGetPerformanceParameterINTEL;
    }
#endif
#ifdef VK_AMD_display_native_hdr
    if (!strcmp(name, "vkSetLocalDimmingAMD"))
    {
        return (void*)dynCheck_entry_vkSetLocalDimmingAMD;
    }
#endif
#ifdef VK_FUCHSIA_imagepipe_surface
    if (!strcmp(name, "vkCreateImagePipeSurfaceFUCHSIA"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_FUCHSIA_imagepipe_surface");
        return hasExt ? (void*)entry_vkCreateImagePipeSurfaceFUCHSIA : nullptr;
    }
#endif
#ifdef VK_EXT_metal_surface
    if (!strcmp(name, "vkCreateMetalSurfaceEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_metal_surface");
        return hasExt ? (void*)entry_vkCreateMetalSurfaceEXT : nullptr;
    }
#endif
#ifdef VK_EXT_buffer_device_address
    if (!strcmp(name, "vkGetBufferDeviceAddressEXT"))
    {
        return (void*)dynCheck_entry_vkGetBufferDeviceAddressEXT;
    }
#endif
#ifdef VK_EXT_tooling_info
    if (!strcmp(name, "vkGetPhysicalDeviceToolPropertiesEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_tooling_info");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceToolPropertiesEXT : nullptr;
    }
#endif
#ifdef VK_NV_cooperative_matrix
    if (!strcmp(name, "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_cooperative_matrix");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV : nullptr;
    }
#endif
#ifdef VK_NV_coverage_reduction_mode
    if (!strcmp(name, "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_coverage_reduction_mode");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV : nullptr;
    }
#endif
#ifdef VK_EXT_full_screen_exclusive
    if (!strcmp(name, "vkGetPhysicalDeviceSurfacePresentModes2EXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_full_screen_exclusive");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSurfacePresentModes2EXT : nullptr;
    }
    if (!strcmp(name, "vkAcquireFullScreenExclusiveModeEXT"))
    {
        return (void*)dynCheck_entry_vkAcquireFullScreenExclusiveModeEXT;
    }
    if (!strcmp(name, "vkReleaseFullScreenExclusiveModeEXT"))
    {
        return (void*)dynCheck_entry_vkReleaseFullScreenExclusiveModeEXT;
    }
    if (!strcmp(name, "vkGetDeviceGroupSurfacePresentModes2EXT"))
    {
        return (void*)dynCheck_entry_vkGetDeviceGroupSurfacePresentModes2EXT;
    }
#endif
#ifdef VK_EXT_headless_surface
    if (!strcmp(name, "vkCreateHeadlessSurfaceEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_headless_surface");
        return hasExt ? (void*)entry_vkCreateHeadlessSurfaceEXT : nullptr;
    }
#endif
#ifdef VK_EXT_line_rasterization
    if (!strcmp(name, "vkCmdSetLineStippleEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_line_rasterization");
        return hasExt ? (void*)entry_vkCmdSetLineStippleEXT : nullptr;
    }
#endif
#ifdef VK_EXT_host_query_reset
    if (!strcmp(name, "vkResetQueryPoolEXT"))
    {
        return (void*)dynCheck_entry_vkResetQueryPoolEXT;
    }
#endif
#ifdef VK_EXT_extended_dynamic_state
    if (!strcmp(name, "vkCmdSetCullModeEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetCullModeEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetFrontFaceEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetFrontFaceEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetPrimitiveTopologyEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetPrimitiveTopologyEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetViewportWithCountEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetViewportWithCountEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetScissorWithCountEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetScissorWithCountEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdBindVertexBuffers2EXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdBindVertexBuffers2EXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthTestEnableEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetDepthTestEnableEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthWriteEnableEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetDepthWriteEnableEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthCompareOpEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetDepthCompareOpEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthBoundsTestEnableEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetDepthBoundsTestEnableEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetStencilTestEnableEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetStencilTestEnableEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetStencilOpEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetStencilOpEXT : nullptr;
    }
#endif
#ifdef VK_NV_device_generated_commands
    if (!strcmp(name, "vkGetGeneratedCommandsMemoryRequirementsNV"))
    {
        return (void*)dynCheck_entry_vkGetGeneratedCommandsMemoryRequirementsNV;
    }
    if (!strcmp(name, "vkCmdPreprocessGeneratedCommandsNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_device_generated_commands");
        return hasExt ? (void*)entry_vkCmdPreprocessGeneratedCommandsNV : nullptr;
    }
    if (!strcmp(name, "vkCmdExecuteGeneratedCommandsNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_device_generated_commands");
        return hasExt ? (void*)entry_vkCmdExecuteGeneratedCommandsNV : nullptr;
    }
    if (!strcmp(name, "vkCmdBindPipelineShaderGroupNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_device_generated_commands");
        return hasExt ? (void*)entry_vkCmdBindPipelineShaderGroupNV : nullptr;
    }
    if (!strcmp(name, "vkCreateIndirectCommandsLayoutNV"))
    {
        return (void*)dynCheck_entry_vkCreateIndirectCommandsLayoutNV;
    }
    if (!strcmp(name, "vkDestroyIndirectCommandsLayoutNV"))
    {
        return (void*)dynCheck_entry_vkDestroyIndirectCommandsLayoutNV;
    }
#endif
#ifdef VK_EXT_private_data
    if (!strcmp(name, "vkCreatePrivateDataSlotEXT"))
    {
        return (void*)dynCheck_entry_vkCreatePrivateDataSlotEXT;
    }
    if (!strcmp(name, "vkDestroyPrivateDataSlotEXT"))
    {
        return (void*)dynCheck_entry_vkDestroyPrivateDataSlotEXT;
    }
    if (!strcmp(name, "vkSetPrivateDataEXT"))
    {
        return (void*)dynCheck_entry_vkSetPrivateDataEXT;
    }
    if (!strcmp(name, "vkGetPrivateDataEXT"))
    {
        return (void*)dynCheck_entry_vkGetPrivateDataEXT;
    }
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    if (!strcmp(name, "vkCmdSetFragmentShadingRateEnumNV"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_NV_fragment_shading_rate_enums");
        return hasExt ? (void*)entry_vkCmdSetFragmentShadingRateEnumNV : nullptr;
    }
#endif
#ifdef VK_EXT_directfb_surface
    if (!strcmp(name, "vkCreateDirectFBSurfaceEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_directfb_surface");
        return hasExt ? (void*)entry_vkCreateDirectFBSurfaceEXT : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceDirectFBPresentationSupportEXT"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_EXT_directfb_surface");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceDirectFBPresentationSupportEXT : nullptr;
    }
#endif
#ifdef VK_GOOGLE_gfxstream
    if (!strcmp(name, "vkRegisterImageColorBufferGOOGLE"))
    {
        return (void*)dynCheck_entry_vkRegisterImageColorBufferGOOGLE;
    }
    if (!strcmp(name, "vkRegisterBufferColorBufferGOOGLE"))
    {
        return (void*)dynCheck_entry_vkRegisterBufferColorBufferGOOGLE;
    }
    if (!strcmp(name, "vkMapMemoryIntoAddressSpaceGOOGLE"))
    {
        return (void*)dynCheck_entry_vkMapMemoryIntoAddressSpaceGOOGLE;
    }
    if (!strcmp(name, "vkUpdateDescriptorSetWithTemplateSizedGOOGLE"))
    {
        return (void*)dynCheck_entry_vkUpdateDescriptorSetWithTemplateSizedGOOGLE;
    }
    if (!strcmp(name, "vkBeginCommandBufferAsyncGOOGLE"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkBeginCommandBufferAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkEndCommandBufferAsyncGOOGLE"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkEndCommandBufferAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkResetCommandBufferAsyncGOOGLE"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkResetCommandBufferAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkCommandBufferHostSyncGOOGLE"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkCommandBufferHostSyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkCreateImageWithRequirementsGOOGLE"))
    {
        return (void*)dynCheck_entry_vkCreateImageWithRequirementsGOOGLE;
    }
    if (!strcmp(name, "vkCreateBufferWithRequirementsGOOGLE"))
    {
        return (void*)dynCheck_entry_vkCreateBufferWithRequirementsGOOGLE;
    }
    if (!strcmp(name, "vkGetMemoryHostAddressInfoGOOGLE"))
    {
        return (void*)dynCheck_entry_vkGetMemoryHostAddressInfoGOOGLE;
    }
    if (!strcmp(name, "vkFreeMemorySyncGOOGLE"))
    {
        return (void*)dynCheck_entry_vkFreeMemorySyncGOOGLE;
    }
    if (!strcmp(name, "vkQueueHostSyncGOOGLE"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueHostSyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueSubmitAsyncGOOGLE"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueSubmitAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueWaitIdleAsyncGOOGLE"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueWaitIdleAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueBindSparseAsyncGOOGLE"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueBindSparseAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkGetLinearImageLayoutGOOGLE"))
    {
        return (void*)dynCheck_entry_vkGetLinearImageLayoutGOOGLE;
    }
    if (!strcmp(name, "vkQueueFlushCommandsGOOGLE"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueFlushCommandsGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueCommitDescriptorSetUpdatesGOOGLE"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueCommitDescriptorSetUpdatesGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkCollectDescriptorPoolIdsGOOGLE"))
    {
        return (void*)dynCheck_entry_vkCollectDescriptorPoolIdsGOOGLE;
    }
#endif
#ifdef VK_KHR_acceleration_structure
    if (!strcmp(name, "vkCreateAccelerationStructureKHR"))
    {
        return (void*)dynCheck_entry_vkCreateAccelerationStructureKHR;
    }
    if (!strcmp(name, "vkDestroyAccelerationStructureKHR"))
    {
        return (void*)dynCheck_entry_vkDestroyAccelerationStructureKHR;
    }
    if (!strcmp(name, "vkCmdBuildAccelerationStructuresKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkCmdBuildAccelerationStructuresKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdBuildAccelerationStructuresIndirectKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkCmdBuildAccelerationStructuresIndirectKHR : nullptr;
    }
    if (!strcmp(name, "vkBuildAccelerationStructuresKHR"))
    {
        return (void*)dynCheck_entry_vkBuildAccelerationStructuresKHR;
    }
    if (!strcmp(name, "vkCopyAccelerationStructureKHR"))
    {
        return (void*)dynCheck_entry_vkCopyAccelerationStructureKHR;
    }
    if (!strcmp(name, "vkCopyAccelerationStructureToMemoryKHR"))
    {
        return (void*)dynCheck_entry_vkCopyAccelerationStructureToMemoryKHR;
    }
    if (!strcmp(name, "vkCopyMemoryToAccelerationStructureKHR"))
    {
        return (void*)dynCheck_entry_vkCopyMemoryToAccelerationStructureKHR;
    }
    if (!strcmp(name, "vkWriteAccelerationStructuresPropertiesKHR"))
    {
        return (void*)dynCheck_entry_vkWriteAccelerationStructuresPropertiesKHR;
    }
    if (!strcmp(name, "vkCmdCopyAccelerationStructureKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkCmdCopyAccelerationStructureKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdCopyAccelerationStructureToMemoryKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkCmdCopyAccelerationStructureToMemoryKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdCopyMemoryToAccelerationStructureKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkCmdCopyMemoryToAccelerationStructureKHR : nullptr;
    }
    if (!strcmp(name, "vkGetAccelerationStructureDeviceAddressKHR"))
    {
        return (void*)dynCheck_entry_vkGetAccelerationStructureDeviceAddressKHR;
    }
    if (!strcmp(name, "vkCmdWriteAccelerationStructuresPropertiesKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkCmdWriteAccelerationStructuresPropertiesKHR : nullptr;
    }
    if (!strcmp(name, "vkGetDeviceAccelerationStructureCompatibilityKHR"))
    {
        return (void*)dynCheck_entry_vkGetDeviceAccelerationStructureCompatibilityKHR;
    }
    if (!strcmp(name, "vkGetAccelerationStructureBuildSizesKHR"))
    {
        return (void*)dynCheck_entry_vkGetAccelerationStructureBuildSizesKHR;
    }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    if (!strcmp(name, "vkCmdTraceRaysKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_ray_tracing_pipeline");
        return hasExt ? (void*)entry_vkCmdTraceRaysKHR : nullptr;
    }
    if (!strcmp(name, "vkCreateRayTracingPipelinesKHR"))
    {
        return (void*)dynCheck_entry_vkCreateRayTracingPipelinesKHR;
    }
    if (!strcmp(name, "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR"))
    {
        return (void*)dynCheck_entry_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR;
    }
    if (!strcmp(name, "vkCmdTraceRaysIndirectKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_ray_tracing_pipeline");
        return hasExt ? (void*)entry_vkCmdTraceRaysIndirectKHR : nullptr;
    }
    if (!strcmp(name, "vkGetRayTracingShaderGroupStackSizeKHR"))
    {
        return (void*)dynCheck_entry_vkGetRayTracingShaderGroupStackSizeKHR;
    }
    if (!strcmp(name, "vkCmdSetRayTracingPipelineStackSizeKHR"))
    {
        bool hasExt = resources->hasInstanceExtension(instance, "VK_KHR_ray_tracing_pipeline");
        return hasExt ? (void*)entry_vkCmdSetRayTracingPipelineStackSizeKHR : nullptr;
    }
#endif
    return nullptr;
}
void* goldfish_vulkan_get_device_proc_address(VkDevice device, const char* name){
    auto resources = ResourceTracker::get();
    bool has1_1OrHigher = resources->getApiVersionFromDevice(device) >= VK_API_VERSION_1_1;
#ifdef VK_VERSION_1_0
    if (!strcmp(name, "vkCreateInstance"))
    {
        return (void*)entry_vkCreateInstance;
    }
    if (!strcmp(name, "vkDestroyInstance"))
    {
        return (void*)entry_vkDestroyInstance;
    }
    if (!strcmp(name, "vkEnumeratePhysicalDevices"))
    {
        return (void*)entry_vkEnumeratePhysicalDevices;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFeatures"))
    {
        return (void*)entry_vkGetPhysicalDeviceFeatures;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFormatProperties"))
    {
        return (void*)entry_vkGetPhysicalDeviceFormatProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceImageFormatProperties"))
    {
        return (void*)entry_vkGetPhysicalDeviceImageFormatProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceProperties"))
    {
        return (void*)entry_vkGetPhysicalDeviceProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyProperties"))
    {
        return (void*)entry_vkGetPhysicalDeviceQueueFamilyProperties;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMemoryProperties"))
    {
        return (void*)entry_vkGetPhysicalDeviceMemoryProperties;
    }
    if (!strcmp(name, "vkGetInstanceProcAddr"))
    {
        return (void*)entry_vkGetInstanceProcAddr;
    }
    if (!strcmp(name, "vkGetDeviceProcAddr"))
    {
        return (void*)entry_vkGetDeviceProcAddr;
    }
    if (!strcmp(name, "vkCreateDevice"))
    {
        return (void*)entry_vkCreateDevice;
    }
    if (!strcmp(name, "vkDestroyDevice"))
    {
        return (void*)entry_vkDestroyDevice;
    }
    if (!strcmp(name, "vkEnumerateInstanceExtensionProperties"))
    {
        return (void*)entry_vkEnumerateInstanceExtensionProperties;
    }
    if (!strcmp(name, "vkEnumerateDeviceExtensionProperties"))
    {
        return (void*)entry_vkEnumerateDeviceExtensionProperties;
    }
    if (!strcmp(name, "vkEnumerateInstanceLayerProperties"))
    {
        return (void*)entry_vkEnumerateInstanceLayerProperties;
    }
    if (!strcmp(name, "vkEnumerateDeviceLayerProperties"))
    {
        return (void*)entry_vkEnumerateDeviceLayerProperties;
    }
    if (!strcmp(name, "vkGetDeviceQueue"))
    {
        return (void*)entry_vkGetDeviceQueue;
    }
    if (!strcmp(name, "vkQueueSubmit"))
    {
        return (void*)entry_vkQueueSubmit;
    }
    if (!strcmp(name, "vkQueueWaitIdle"))
    {
        return (void*)entry_vkQueueWaitIdle;
    }
    if (!strcmp(name, "vkDeviceWaitIdle"))
    {
        return (void*)entry_vkDeviceWaitIdle;
    }
    if (!strcmp(name, "vkAllocateMemory"))
    {
        return (void*)entry_vkAllocateMemory;
    }
    if (!strcmp(name, "vkFreeMemory"))
    {
        return (void*)entry_vkFreeMemory;
    }
    if (!strcmp(name, "vkMapMemory"))
    {
        return (void*)entry_vkMapMemory;
    }
    if (!strcmp(name, "vkUnmapMemory"))
    {
        return (void*)entry_vkUnmapMemory;
    }
    if (!strcmp(name, "vkFlushMappedMemoryRanges"))
    {
        return (void*)entry_vkFlushMappedMemoryRanges;
    }
    if (!strcmp(name, "vkInvalidateMappedMemoryRanges"))
    {
        return (void*)entry_vkInvalidateMappedMemoryRanges;
    }
    if (!strcmp(name, "vkGetDeviceMemoryCommitment"))
    {
        return (void*)entry_vkGetDeviceMemoryCommitment;
    }
    if (!strcmp(name, "vkBindBufferMemory"))
    {
        return (void*)entry_vkBindBufferMemory;
    }
    if (!strcmp(name, "vkBindImageMemory"))
    {
        return (void*)entry_vkBindImageMemory;
    }
    if (!strcmp(name, "vkGetBufferMemoryRequirements"))
    {
        return (void*)entry_vkGetBufferMemoryRequirements;
    }
    if (!strcmp(name, "vkGetImageMemoryRequirements"))
    {
        return (void*)entry_vkGetImageMemoryRequirements;
    }
    if (!strcmp(name, "vkGetImageSparseMemoryRequirements"))
    {
        return (void*)entry_vkGetImageSparseMemoryRequirements;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSparseImageFormatProperties"))
    {
        return (void*)entry_vkGetPhysicalDeviceSparseImageFormatProperties;
    }
    if (!strcmp(name, "vkQueueBindSparse"))
    {
        return (void*)entry_vkQueueBindSparse;
    }
    if (!strcmp(name, "vkCreateFence"))
    {
        return (void*)entry_vkCreateFence;
    }
    if (!strcmp(name, "vkDestroyFence"))
    {
        return (void*)entry_vkDestroyFence;
    }
    if (!strcmp(name, "vkResetFences"))
    {
        return (void*)entry_vkResetFences;
    }
    if (!strcmp(name, "vkGetFenceStatus"))
    {
        return (void*)entry_vkGetFenceStatus;
    }
    if (!strcmp(name, "vkWaitForFences"))
    {
        return (void*)entry_vkWaitForFences;
    }
    if (!strcmp(name, "vkCreateSemaphore"))
    {
        return (void*)entry_vkCreateSemaphore;
    }
    if (!strcmp(name, "vkDestroySemaphore"))
    {
        return (void*)entry_vkDestroySemaphore;
    }
    if (!strcmp(name, "vkCreateEvent"))
    {
        return (void*)entry_vkCreateEvent;
    }
    if (!strcmp(name, "vkDestroyEvent"))
    {
        return (void*)entry_vkDestroyEvent;
    }
    if (!strcmp(name, "vkGetEventStatus"))
    {
        return (void*)entry_vkGetEventStatus;
    }
    if (!strcmp(name, "vkSetEvent"))
    {
        return (void*)entry_vkSetEvent;
    }
    if (!strcmp(name, "vkResetEvent"))
    {
        return (void*)entry_vkResetEvent;
    }
    if (!strcmp(name, "vkCreateQueryPool"))
    {
        return (void*)entry_vkCreateQueryPool;
    }
    if (!strcmp(name, "vkDestroyQueryPool"))
    {
        return (void*)entry_vkDestroyQueryPool;
    }
    if (!strcmp(name, "vkGetQueryPoolResults"))
    {
        return (void*)entry_vkGetQueryPoolResults;
    }
    if (!strcmp(name, "vkCreateBuffer"))
    {
        return (void*)entry_vkCreateBuffer;
    }
    if (!strcmp(name, "vkDestroyBuffer"))
    {
        return (void*)entry_vkDestroyBuffer;
    }
    if (!strcmp(name, "vkCreateBufferView"))
    {
        return (void*)entry_vkCreateBufferView;
    }
    if (!strcmp(name, "vkDestroyBufferView"))
    {
        return (void*)entry_vkDestroyBufferView;
    }
    if (!strcmp(name, "vkCreateImage"))
    {
        return (void*)entry_vkCreateImage;
    }
    if (!strcmp(name, "vkDestroyImage"))
    {
        return (void*)entry_vkDestroyImage;
    }
    if (!strcmp(name, "vkGetImageSubresourceLayout"))
    {
        return (void*)entry_vkGetImageSubresourceLayout;
    }
    if (!strcmp(name, "vkCreateImageView"))
    {
        return (void*)entry_vkCreateImageView;
    }
    if (!strcmp(name, "vkDestroyImageView"))
    {
        return (void*)entry_vkDestroyImageView;
    }
    if (!strcmp(name, "vkCreateShaderModule"))
    {
        return (void*)entry_vkCreateShaderModule;
    }
    if (!strcmp(name, "vkDestroyShaderModule"))
    {
        return (void*)entry_vkDestroyShaderModule;
    }
    if (!strcmp(name, "vkCreatePipelineCache"))
    {
        return (void*)entry_vkCreatePipelineCache;
    }
    if (!strcmp(name, "vkDestroyPipelineCache"))
    {
        return (void*)entry_vkDestroyPipelineCache;
    }
    if (!strcmp(name, "vkGetPipelineCacheData"))
    {
        return (void*)entry_vkGetPipelineCacheData;
    }
    if (!strcmp(name, "vkMergePipelineCaches"))
    {
        return (void*)entry_vkMergePipelineCaches;
    }
    if (!strcmp(name, "vkCreateGraphicsPipelines"))
    {
        return (void*)entry_vkCreateGraphicsPipelines;
    }
    if (!strcmp(name, "vkCreateComputePipelines"))
    {
        return (void*)entry_vkCreateComputePipelines;
    }
    if (!strcmp(name, "vkDestroyPipeline"))
    {
        return (void*)entry_vkDestroyPipeline;
    }
    if (!strcmp(name, "vkCreatePipelineLayout"))
    {
        return (void*)entry_vkCreatePipelineLayout;
    }
    if (!strcmp(name, "vkDestroyPipelineLayout"))
    {
        return (void*)entry_vkDestroyPipelineLayout;
    }
    if (!strcmp(name, "vkCreateSampler"))
    {
        return (void*)entry_vkCreateSampler;
    }
    if (!strcmp(name, "vkDestroySampler"))
    {
        return (void*)entry_vkDestroySampler;
    }
    if (!strcmp(name, "vkCreateDescriptorSetLayout"))
    {
        return (void*)entry_vkCreateDescriptorSetLayout;
    }
    if (!strcmp(name, "vkDestroyDescriptorSetLayout"))
    {
        return (void*)entry_vkDestroyDescriptorSetLayout;
    }
    if (!strcmp(name, "vkCreateDescriptorPool"))
    {
        return (void*)entry_vkCreateDescriptorPool;
    }
    if (!strcmp(name, "vkDestroyDescriptorPool"))
    {
        return (void*)entry_vkDestroyDescriptorPool;
    }
    if (!strcmp(name, "vkResetDescriptorPool"))
    {
        return (void*)entry_vkResetDescriptorPool;
    }
    if (!strcmp(name, "vkAllocateDescriptorSets"))
    {
        return (void*)entry_vkAllocateDescriptorSets;
    }
    if (!strcmp(name, "vkFreeDescriptorSets"))
    {
        return (void*)entry_vkFreeDescriptorSets;
    }
    if (!strcmp(name, "vkUpdateDescriptorSets"))
    {
        return (void*)entry_vkUpdateDescriptorSets;
    }
    if (!strcmp(name, "vkCreateFramebuffer"))
    {
        return (void*)entry_vkCreateFramebuffer;
    }
    if (!strcmp(name, "vkDestroyFramebuffer"))
    {
        return (void*)entry_vkDestroyFramebuffer;
    }
    if (!strcmp(name, "vkCreateRenderPass"))
    {
        return (void*)entry_vkCreateRenderPass;
    }
    if (!strcmp(name, "vkDestroyRenderPass"))
    {
        return (void*)entry_vkDestroyRenderPass;
    }
    if (!strcmp(name, "vkGetRenderAreaGranularity"))
    {
        return (void*)entry_vkGetRenderAreaGranularity;
    }
    if (!strcmp(name, "vkCreateCommandPool"))
    {
        return (void*)entry_vkCreateCommandPool;
    }
    if (!strcmp(name, "vkDestroyCommandPool"))
    {
        return (void*)entry_vkDestroyCommandPool;
    }
    if (!strcmp(name, "vkResetCommandPool"))
    {
        return (void*)entry_vkResetCommandPool;
    }
    if (!strcmp(name, "vkAllocateCommandBuffers"))
    {
        return (void*)entry_vkAllocateCommandBuffers;
    }
    if (!strcmp(name, "vkFreeCommandBuffers"))
    {
        return (void*)entry_vkFreeCommandBuffers;
    }
    if (!strcmp(name, "vkBeginCommandBuffer"))
    {
        return (void*)entry_vkBeginCommandBuffer;
    }
    if (!strcmp(name, "vkEndCommandBuffer"))
    {
        return (void*)entry_vkEndCommandBuffer;
    }
    if (!strcmp(name, "vkResetCommandBuffer"))
    {
        return (void*)entry_vkResetCommandBuffer;
    }
    if (!strcmp(name, "vkCmdBindPipeline"))
    {
        return (void*)entry_vkCmdBindPipeline;
    }
    if (!strcmp(name, "vkCmdSetViewport"))
    {
        return (void*)entry_vkCmdSetViewport;
    }
    if (!strcmp(name, "vkCmdSetScissor"))
    {
        return (void*)entry_vkCmdSetScissor;
    }
    if (!strcmp(name, "vkCmdSetLineWidth"))
    {
        return (void*)entry_vkCmdSetLineWidth;
    }
    if (!strcmp(name, "vkCmdSetDepthBias"))
    {
        return (void*)entry_vkCmdSetDepthBias;
    }
    if (!strcmp(name, "vkCmdSetBlendConstants"))
    {
        return (void*)entry_vkCmdSetBlendConstants;
    }
    if (!strcmp(name, "vkCmdSetDepthBounds"))
    {
        return (void*)entry_vkCmdSetDepthBounds;
    }
    if (!strcmp(name, "vkCmdSetStencilCompareMask"))
    {
        return (void*)entry_vkCmdSetStencilCompareMask;
    }
    if (!strcmp(name, "vkCmdSetStencilWriteMask"))
    {
        return (void*)entry_vkCmdSetStencilWriteMask;
    }
    if (!strcmp(name, "vkCmdSetStencilReference"))
    {
        return (void*)entry_vkCmdSetStencilReference;
    }
    if (!strcmp(name, "vkCmdBindDescriptorSets"))
    {
        return (void*)entry_vkCmdBindDescriptorSets;
    }
    if (!strcmp(name, "vkCmdBindIndexBuffer"))
    {
        return (void*)entry_vkCmdBindIndexBuffer;
    }
    if (!strcmp(name, "vkCmdBindVertexBuffers"))
    {
        return (void*)entry_vkCmdBindVertexBuffers;
    }
    if (!strcmp(name, "vkCmdDraw"))
    {
        return (void*)entry_vkCmdDraw;
    }
    if (!strcmp(name, "vkCmdDrawIndexed"))
    {
        return (void*)entry_vkCmdDrawIndexed;
    }
    if (!strcmp(name, "vkCmdDrawIndirect"))
    {
        return (void*)entry_vkCmdDrawIndirect;
    }
    if (!strcmp(name, "vkCmdDrawIndexedIndirect"))
    {
        return (void*)entry_vkCmdDrawIndexedIndirect;
    }
    if (!strcmp(name, "vkCmdDispatch"))
    {
        return (void*)entry_vkCmdDispatch;
    }
    if (!strcmp(name, "vkCmdDispatchIndirect"))
    {
        return (void*)entry_vkCmdDispatchIndirect;
    }
    if (!strcmp(name, "vkCmdCopyBuffer"))
    {
        return (void*)entry_vkCmdCopyBuffer;
    }
    if (!strcmp(name, "vkCmdCopyImage"))
    {
        return (void*)entry_vkCmdCopyImage;
    }
    if (!strcmp(name, "vkCmdBlitImage"))
    {
        return (void*)entry_vkCmdBlitImage;
    }
    if (!strcmp(name, "vkCmdCopyBufferToImage"))
    {
        return (void*)entry_vkCmdCopyBufferToImage;
    }
    if (!strcmp(name, "vkCmdCopyImageToBuffer"))
    {
        return (void*)entry_vkCmdCopyImageToBuffer;
    }
    if (!strcmp(name, "vkCmdUpdateBuffer"))
    {
        return (void*)entry_vkCmdUpdateBuffer;
    }
    if (!strcmp(name, "vkCmdFillBuffer"))
    {
        return (void*)entry_vkCmdFillBuffer;
    }
    if (!strcmp(name, "vkCmdClearColorImage"))
    {
        return (void*)entry_vkCmdClearColorImage;
    }
    if (!strcmp(name, "vkCmdClearDepthStencilImage"))
    {
        return (void*)entry_vkCmdClearDepthStencilImage;
    }
    if (!strcmp(name, "vkCmdClearAttachments"))
    {
        return (void*)entry_vkCmdClearAttachments;
    }
    if (!strcmp(name, "vkCmdResolveImage"))
    {
        return (void*)entry_vkCmdResolveImage;
    }
    if (!strcmp(name, "vkCmdSetEvent"))
    {
        return (void*)entry_vkCmdSetEvent;
    }
    if (!strcmp(name, "vkCmdResetEvent"))
    {
        return (void*)entry_vkCmdResetEvent;
    }
    if (!strcmp(name, "vkCmdWaitEvents"))
    {
        return (void*)entry_vkCmdWaitEvents;
    }
    if (!strcmp(name, "vkCmdPipelineBarrier"))
    {
        return (void*)entry_vkCmdPipelineBarrier;
    }
    if (!strcmp(name, "vkCmdBeginQuery"))
    {
        return (void*)entry_vkCmdBeginQuery;
    }
    if (!strcmp(name, "vkCmdEndQuery"))
    {
        return (void*)entry_vkCmdEndQuery;
    }
    if (!strcmp(name, "vkCmdResetQueryPool"))
    {
        return (void*)entry_vkCmdResetQueryPool;
    }
    if (!strcmp(name, "vkCmdWriteTimestamp"))
    {
        return (void*)entry_vkCmdWriteTimestamp;
    }
    if (!strcmp(name, "vkCmdCopyQueryPoolResults"))
    {
        return (void*)entry_vkCmdCopyQueryPoolResults;
    }
    if (!strcmp(name, "vkCmdPushConstants"))
    {
        return (void*)entry_vkCmdPushConstants;
    }
    if (!strcmp(name, "vkCmdBeginRenderPass"))
    {
        return (void*)entry_vkCmdBeginRenderPass;
    }
    if (!strcmp(name, "vkCmdNextSubpass"))
    {
        return (void*)entry_vkCmdNextSubpass;
    }
    if (!strcmp(name, "vkCmdEndRenderPass"))
    {
        return (void*)entry_vkCmdEndRenderPass;
    }
    if (!strcmp(name, "vkCmdExecuteCommands"))
    {
        return (void*)entry_vkCmdExecuteCommands;
    }
#endif
#ifdef VK_VERSION_1_1
    if (!strcmp(name, "vkEnumerateInstanceVersion"))
    {
        return has1_1OrHigher ? (void*)entry_vkEnumerateInstanceVersion : nullptr;
    }
    if (!strcmp(name, "vkBindBufferMemory2"))
    {
        return has1_1OrHigher ? (void*)entry_vkBindBufferMemory2 : nullptr;
    }
    if (!strcmp(name, "vkBindImageMemory2"))
    {
        return has1_1OrHigher ? (void*)entry_vkBindImageMemory2 : nullptr;
    }
    if (!strcmp(name, "vkGetDeviceGroupPeerMemoryFeatures"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetDeviceGroupPeerMemoryFeatures : nullptr;
    }
    if (!strcmp(name, "vkCmdSetDeviceMask"))
    {
        return has1_1OrHigher ? (void*)entry_vkCmdSetDeviceMask : nullptr;
    }
    if (!strcmp(name, "vkCmdDispatchBase"))
    {
        return has1_1OrHigher ? (void*)entry_vkCmdDispatchBase : nullptr;
    }
    if (!strcmp(name, "vkEnumeratePhysicalDeviceGroups"))
    {
        return nullptr;
    }
    if (!strcmp(name, "vkGetImageMemoryRequirements2"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetImageMemoryRequirements2 : nullptr;
    }
    if (!strcmp(name, "vkGetBufferMemoryRequirements2"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetBufferMemoryRequirements2 : nullptr;
    }
    if (!strcmp(name, "vkGetImageSparseMemoryRequirements2"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetImageSparseMemoryRequirements2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFeatures2"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceFeatures2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceProperties2"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFormatProperties2"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceFormatProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceImageFormatProperties2"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceImageFormatProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyProperties2"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceQueueFamilyProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMemoryProperties2"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceMemoryProperties2 : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSparseImageFormatProperties2"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceSparseImageFormatProperties2 : nullptr;
    }
    if (!strcmp(name, "vkTrimCommandPool"))
    {
        return has1_1OrHigher ? (void*)entry_vkTrimCommandPool : nullptr;
    }
    if (!strcmp(name, "vkGetDeviceQueue2"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetDeviceQueue2 : nullptr;
    }
    if (!strcmp(name, "vkCreateSamplerYcbcrConversion"))
    {
        return has1_1OrHigher ? (void*)entry_vkCreateSamplerYcbcrConversion : nullptr;
    }
    if (!strcmp(name, "vkDestroySamplerYcbcrConversion"))
    {
        return has1_1OrHigher ? (void*)entry_vkDestroySamplerYcbcrConversion : nullptr;
    }
    if (!strcmp(name, "vkCreateDescriptorUpdateTemplate"))
    {
        return has1_1OrHigher ? (void*)entry_vkCreateDescriptorUpdateTemplate : nullptr;
    }
    if (!strcmp(name, "vkDestroyDescriptorUpdateTemplate"))
    {
        return has1_1OrHigher ? (void*)entry_vkDestroyDescriptorUpdateTemplate : nullptr;
    }
    if (!strcmp(name, "vkUpdateDescriptorSetWithTemplate"))
    {
        return has1_1OrHigher ? (void*)entry_vkUpdateDescriptorSetWithTemplate : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceExternalBufferProperties"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceExternalBufferProperties : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceExternalFenceProperties"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceExternalFenceProperties : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceExternalSemaphoreProperties"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetPhysicalDeviceExternalSemaphoreProperties : nullptr;
    }
    if (!strcmp(name, "vkGetDescriptorSetLayoutSupport"))
    {
        return has1_1OrHigher ? (void*)entry_vkGetDescriptorSetLayoutSupport : nullptr;
    }
#endif
#ifdef VK_VERSION_1_2
    if (!strcmp(name, "vkCmdDrawIndirectCount"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkCmdDrawIndirectCount : nullptr;
    }
    if (!strcmp(name, "vkCmdDrawIndexedIndirectCount"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkCmdDrawIndexedIndirectCount : nullptr;
    }
    if (!strcmp(name, "vkCreateRenderPass2"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkCreateRenderPass2 : nullptr;
    }
    if (!strcmp(name, "vkCmdBeginRenderPass2"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkCmdBeginRenderPass2 : nullptr;
    }
    if (!strcmp(name, "vkCmdNextSubpass2"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkCmdNextSubpass2 : nullptr;
    }
    if (!strcmp(name, "vkCmdEndRenderPass2"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkCmdEndRenderPass2 : nullptr;
    }
    if (!strcmp(name, "vkResetQueryPool"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkResetQueryPool : nullptr;
    }
    if (!strcmp(name, "vkGetSemaphoreCounterValue"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkGetSemaphoreCounterValue : nullptr;
    }
    if (!strcmp(name, "vkWaitSemaphores"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkWaitSemaphores : nullptr;
    }
    if (!strcmp(name, "vkSignalSemaphore"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkSignalSemaphore : nullptr;
    }
    if (!strcmp(name, "vkGetBufferDeviceAddress"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkGetBufferDeviceAddress : nullptr;
    }
    if (!strcmp(name, "vkGetBufferOpaqueCaptureAddress"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkGetBufferOpaqueCaptureAddress : nullptr;
    }
    if (!strcmp(name, "vkGetDeviceMemoryOpaqueCaptureAddress"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_VERSION_1_2");
        return hasExt ? (void*)entry_vkGetDeviceMemoryOpaqueCaptureAddress : nullptr;
    }
#endif
#ifdef VK_KHR_surface
    if (!strcmp(name, "vkDestroySurfaceKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_surface");
        return hasExt ? (void*)entry_vkDestroySurfaceKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSurfaceSupportKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_surface");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSurfaceSupportKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_surface");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSurfaceCapabilitiesKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSurfaceFormatsKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_surface");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSurfaceFormatsKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSurfacePresentModesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_surface");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSurfacePresentModesKHR : nullptr;
    }
#endif
#ifdef VK_KHR_swapchain
    if (!strcmp(name, "vkCreateSwapchainKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_swapchain");
        return hasExt ? (void*)entry_vkCreateSwapchainKHR : nullptr;
    }
    if (!strcmp(name, "vkDestroySwapchainKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_swapchain");
        return hasExt ? (void*)entry_vkDestroySwapchainKHR : nullptr;
    }
    if (!strcmp(name, "vkGetSwapchainImagesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_swapchain");
        return hasExt ? (void*)entry_vkGetSwapchainImagesKHR : nullptr;
    }
    if (!strcmp(name, "vkAcquireNextImageKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_swapchain");
        return hasExt ? (void*)entry_vkAcquireNextImageKHR : nullptr;
    }
    if (!strcmp(name, "vkQueuePresentKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_swapchain");
        return hasExt ? (void*)entry_vkQueuePresentKHR : nullptr;
    }
    if (!strcmp(name, "vkGetDeviceGroupPresentCapabilitiesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_swapchain");
        return hasExt ? (void*)entry_vkGetDeviceGroupPresentCapabilitiesKHR : nullptr;
    }
    if (!strcmp(name, "vkGetDeviceGroupSurfacePresentModesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_swapchain");
        return hasExt ? (void*)entry_vkGetDeviceGroupSurfacePresentModesKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDevicePresentRectanglesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_swapchain");
        return hasExt ? (void*)entry_vkGetPhysicalDevicePresentRectanglesKHR : nullptr;
    }
    if (!strcmp(name, "vkAcquireNextImage2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_swapchain");
        return hasExt ? (void*)entry_vkAcquireNextImage2KHR : nullptr;
    }
#endif
#ifdef VK_KHR_display
    if (!strcmp(name, "vkGetPhysicalDeviceDisplayPropertiesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_display");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceDisplayPropertiesKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_display");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceDisplayPlanePropertiesKHR : nullptr;
    }
    if (!strcmp(name, "vkGetDisplayPlaneSupportedDisplaysKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_display");
        return hasExt ? (void*)entry_vkGetDisplayPlaneSupportedDisplaysKHR : nullptr;
    }
    if (!strcmp(name, "vkGetDisplayModePropertiesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_display");
        return hasExt ? (void*)entry_vkGetDisplayModePropertiesKHR : nullptr;
    }
    if (!strcmp(name, "vkCreateDisplayModeKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_display");
        return hasExt ? (void*)entry_vkCreateDisplayModeKHR : nullptr;
    }
    if (!strcmp(name, "vkGetDisplayPlaneCapabilitiesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_display");
        return hasExt ? (void*)entry_vkGetDisplayPlaneCapabilitiesKHR : nullptr;
    }
    if (!strcmp(name, "vkCreateDisplayPlaneSurfaceKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_display");
        return hasExt ? (void*)entry_vkCreateDisplayPlaneSurfaceKHR : nullptr;
    }
#endif
#ifdef VK_KHR_display_swapchain
    if (!strcmp(name, "vkCreateSharedSwapchainsKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_display_swapchain");
        return hasExt ? (void*)entry_vkCreateSharedSwapchainsKHR : nullptr;
    }
#endif
#ifdef VK_KHR_xlib_surface
    if (!strcmp(name, "vkCreateXlibSurfaceKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_xlib_surface");
        return hasExt ? (void*)entry_vkCreateXlibSurfaceKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceXlibPresentationSupportKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_xlib_surface");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceXlibPresentationSupportKHR : nullptr;
    }
#endif
#ifdef VK_KHR_xcb_surface
    if (!strcmp(name, "vkCreateXcbSurfaceKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_xcb_surface");
        return hasExt ? (void*)entry_vkCreateXcbSurfaceKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceXcbPresentationSupportKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_xcb_surface");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceXcbPresentationSupportKHR : nullptr;
    }
#endif
#ifdef VK_KHR_wayland_surface
    if (!strcmp(name, "vkCreateWaylandSurfaceKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_wayland_surface");
        return hasExt ? (void*)entry_vkCreateWaylandSurfaceKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceWaylandPresentationSupportKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_wayland_surface");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceWaylandPresentationSupportKHR : nullptr;
    }
#endif
#ifdef VK_KHR_android_surface
    if (!strcmp(name, "vkCreateAndroidSurfaceKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_android_surface");
        return hasExt ? (void*)entry_vkCreateAndroidSurfaceKHR : nullptr;
    }
#endif
#ifdef VK_KHR_win32_surface
    if (!strcmp(name, "vkCreateWin32SurfaceKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_win32_surface");
        return hasExt ? (void*)entry_vkCreateWin32SurfaceKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceWin32PresentationSupportKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_win32_surface");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceWin32PresentationSupportKHR : nullptr;
    }
#endif
#ifdef VK_KHR_get_physical_device_properties2
    if (!strcmp(name, "vkGetPhysicalDeviceFeatures2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceFeatures2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceProperties2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceFormatProperties2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceFormatProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceImageFormatProperties2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceImageFormatProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyProperties2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceQueueFamilyProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMemoryProperties2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceMemoryProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_physical_device_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSparseImageFormatProperties2KHR : nullptr;
    }
#endif
#ifdef VK_KHR_device_group
    if (!strcmp(name, "vkGetDeviceGroupPeerMemoryFeaturesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_device_group");
        return hasExt ? (void*)entry_vkGetDeviceGroupPeerMemoryFeaturesKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdSetDeviceMaskKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_device_group");
        return hasExt ? (void*)entry_vkCmdSetDeviceMaskKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdDispatchBaseKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_device_group");
        return hasExt ? (void*)entry_vkCmdDispatchBaseKHR : nullptr;
    }
#endif
#ifdef VK_KHR_maintenance1
    if (!strcmp(name, "vkTrimCommandPoolKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_maintenance1");
        return hasExt ? (void*)entry_vkTrimCommandPoolKHR : nullptr;
    }
#endif
#ifdef VK_KHR_device_group_creation
    if (!strcmp(name, "vkEnumeratePhysicalDeviceGroupsKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_device_group_creation");
        return hasExt ? (void*)entry_vkEnumeratePhysicalDeviceGroupsKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_memory_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalBufferPropertiesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_memory_capabilities");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceExternalBufferPropertiesKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_memory_win32
    if (!strcmp(name, "vkGetMemoryWin32HandleKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_memory_win32");
        return hasExt ? (void*)entry_vkGetMemoryWin32HandleKHR : nullptr;
    }
    if (!strcmp(name, "vkGetMemoryWin32HandlePropertiesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_memory_win32");
        return hasExt ? (void*)entry_vkGetMemoryWin32HandlePropertiesKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_memory_fd
    if (!strcmp(name, "vkGetMemoryFdKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_memory_fd");
        return hasExt ? (void*)entry_vkGetMemoryFdKHR : nullptr;
    }
    if (!strcmp(name, "vkGetMemoryFdPropertiesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_memory_fd");
        return hasExt ? (void*)entry_vkGetMemoryFdPropertiesKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_semaphore_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_semaphore_capabilities");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_semaphore_win32
    if (!strcmp(name, "vkImportSemaphoreWin32HandleKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_semaphore_win32");
        return hasExt ? (void*)entry_vkImportSemaphoreWin32HandleKHR : nullptr;
    }
    if (!strcmp(name, "vkGetSemaphoreWin32HandleKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_semaphore_win32");
        return hasExt ? (void*)entry_vkGetSemaphoreWin32HandleKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_semaphore_fd
    if (!strcmp(name, "vkImportSemaphoreFdKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_semaphore_fd");
        return hasExt ? (void*)entry_vkImportSemaphoreFdKHR : nullptr;
    }
    if (!strcmp(name, "vkGetSemaphoreFdKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_semaphore_fd");
        return hasExt ? (void*)entry_vkGetSemaphoreFdKHR : nullptr;
    }
#endif
#ifdef VK_KHR_push_descriptor
    if (!strcmp(name, "vkCmdPushDescriptorSetKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_push_descriptor");
        return hasExt ? (void*)entry_vkCmdPushDescriptorSetKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdPushDescriptorSetWithTemplateKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_push_descriptor");
        return hasExt ? (void*)entry_vkCmdPushDescriptorSetWithTemplateKHR : nullptr;
    }
#endif
#ifdef VK_KHR_descriptor_update_template
    if (!strcmp(name, "vkCreateDescriptorUpdateTemplateKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_descriptor_update_template");
        return hasExt ? (void*)entry_vkCreateDescriptorUpdateTemplateKHR : nullptr;
    }
    if (!strcmp(name, "vkDestroyDescriptorUpdateTemplateKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_descriptor_update_template");
        return hasExt ? (void*)entry_vkDestroyDescriptorUpdateTemplateKHR : nullptr;
    }
    if (!strcmp(name, "vkUpdateDescriptorSetWithTemplateKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_descriptor_update_template");
        return hasExt ? (void*)entry_vkUpdateDescriptorSetWithTemplateKHR : nullptr;
    }
#endif
#ifdef VK_KHR_create_renderpass2
    if (!strcmp(name, "vkCreateRenderPass2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_create_renderpass2");
        return hasExt ? (void*)entry_vkCreateRenderPass2KHR : nullptr;
    }
    if (!strcmp(name, "vkCmdBeginRenderPass2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_create_renderpass2");
        return hasExt ? (void*)entry_vkCmdBeginRenderPass2KHR : nullptr;
    }
    if (!strcmp(name, "vkCmdNextSubpass2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_create_renderpass2");
        return hasExt ? (void*)entry_vkCmdNextSubpass2KHR : nullptr;
    }
    if (!strcmp(name, "vkCmdEndRenderPass2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_create_renderpass2");
        return hasExt ? (void*)entry_vkCmdEndRenderPass2KHR : nullptr;
    }
#endif
#ifdef VK_KHR_shared_presentable_image
    if (!strcmp(name, "vkGetSwapchainStatusKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_shared_presentable_image");
        return hasExt ? (void*)entry_vkGetSwapchainStatusKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_fence_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalFencePropertiesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_fence_capabilities");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceExternalFencePropertiesKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_fence_win32
    if (!strcmp(name, "vkImportFenceWin32HandleKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_fence_win32");
        return hasExt ? (void*)entry_vkImportFenceWin32HandleKHR : nullptr;
    }
    if (!strcmp(name, "vkGetFenceWin32HandleKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_fence_win32");
        return hasExt ? (void*)entry_vkGetFenceWin32HandleKHR : nullptr;
    }
#endif
#ifdef VK_KHR_external_fence_fd
    if (!strcmp(name, "vkImportFenceFdKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_fence_fd");
        return hasExt ? (void*)entry_vkImportFenceFdKHR : nullptr;
    }
    if (!strcmp(name, "vkGetFenceFdKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_external_fence_fd");
        return hasExt ? (void*)entry_vkGetFenceFdKHR : nullptr;
    }
#endif
#ifdef VK_KHR_performance_query
    if (!strcmp(name, "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_performance_query");
        return hasExt ? (void*)entry_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_performance_query");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR : nullptr;
    }
    if (!strcmp(name, "vkAcquireProfilingLockKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_performance_query");
        return hasExt ? (void*)entry_vkAcquireProfilingLockKHR : nullptr;
    }
    if (!strcmp(name, "vkReleaseProfilingLockKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_performance_query");
        return hasExt ? (void*)entry_vkReleaseProfilingLockKHR : nullptr;
    }
#endif
#ifdef VK_KHR_get_surface_capabilities2
    if (!strcmp(name, "vkGetPhysicalDeviceSurfaceCapabilities2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_surface_capabilities2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSurfaceCapabilities2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceSurfaceFormats2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_surface_capabilities2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSurfaceFormats2KHR : nullptr;
    }
#endif
#ifdef VK_KHR_get_display_properties2
    if (!strcmp(name, "vkGetPhysicalDeviceDisplayProperties2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_display_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceDisplayProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceDisplayPlaneProperties2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_display_properties2");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceDisplayPlaneProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetDisplayModeProperties2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_display_properties2");
        return hasExt ? (void*)entry_vkGetDisplayModeProperties2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetDisplayPlaneCapabilities2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_display_properties2");
        return hasExt ? (void*)entry_vkGetDisplayPlaneCapabilities2KHR : nullptr;
    }
#endif
#ifdef VK_KHR_get_memory_requirements2
    if (!strcmp(name, "vkGetImageMemoryRequirements2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_memory_requirements2");
        return hasExt ? (void*)entry_vkGetImageMemoryRequirements2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetBufferMemoryRequirements2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_memory_requirements2");
        return hasExt ? (void*)entry_vkGetBufferMemoryRequirements2KHR : nullptr;
    }
    if (!strcmp(name, "vkGetImageSparseMemoryRequirements2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_get_memory_requirements2");
        return hasExt ? (void*)entry_vkGetImageSparseMemoryRequirements2KHR : nullptr;
    }
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
    if (!strcmp(name, "vkCreateSamplerYcbcrConversionKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_sampler_ycbcr_conversion");
        return hasExt ? (void*)entry_vkCreateSamplerYcbcrConversionKHR : nullptr;
    }
    if (!strcmp(name, "vkDestroySamplerYcbcrConversionKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_sampler_ycbcr_conversion");
        return hasExt ? (void*)entry_vkDestroySamplerYcbcrConversionKHR : nullptr;
    }
#endif
#ifdef VK_KHR_bind_memory2
    if (!strcmp(name, "vkBindBufferMemory2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_bind_memory2");
        return hasExt ? (void*)entry_vkBindBufferMemory2KHR : nullptr;
    }
    if (!strcmp(name, "vkBindImageMemory2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_bind_memory2");
        return hasExt ? (void*)entry_vkBindImageMemory2KHR : nullptr;
    }
#endif
#ifdef VK_KHR_maintenance3
    if (!strcmp(name, "vkGetDescriptorSetLayoutSupportKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_maintenance3");
        return hasExt ? (void*)entry_vkGetDescriptorSetLayoutSupportKHR : nullptr;
    }
#endif
#ifdef VK_KHR_draw_indirect_count
    if (!strcmp(name, "vkCmdDrawIndirectCountKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_draw_indirect_count");
        return hasExt ? (void*)entry_vkCmdDrawIndirectCountKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdDrawIndexedIndirectCountKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_draw_indirect_count");
        return hasExt ? (void*)entry_vkCmdDrawIndexedIndirectCountKHR : nullptr;
    }
#endif
#ifdef VK_KHR_timeline_semaphore
    if (!strcmp(name, "vkGetSemaphoreCounterValueKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_timeline_semaphore");
        return hasExt ? (void*)entry_vkGetSemaphoreCounterValueKHR : nullptr;
    }
    if (!strcmp(name, "vkWaitSemaphoresKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_timeline_semaphore");
        return hasExt ? (void*)entry_vkWaitSemaphoresKHR : nullptr;
    }
    if (!strcmp(name, "vkSignalSemaphoreKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_timeline_semaphore");
        return hasExt ? (void*)entry_vkSignalSemaphoreKHR : nullptr;
    }
#endif
#ifdef VK_KHR_fragment_shading_rate
    if (!strcmp(name, "vkGetPhysicalDeviceFragmentShadingRatesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_fragment_shading_rate");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceFragmentShadingRatesKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdSetFragmentShadingRateKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_fragment_shading_rate");
        return hasExt ? (void*)entry_vkCmdSetFragmentShadingRateKHR : nullptr;
    }
#endif
#ifdef VK_KHR_buffer_device_address
    if (!strcmp(name, "vkGetBufferDeviceAddressKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_buffer_device_address");
        return hasExt ? (void*)entry_vkGetBufferDeviceAddressKHR : nullptr;
    }
    if (!strcmp(name, "vkGetBufferOpaqueCaptureAddressKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_buffer_device_address");
        return hasExt ? (void*)entry_vkGetBufferOpaqueCaptureAddressKHR : nullptr;
    }
    if (!strcmp(name, "vkGetDeviceMemoryOpaqueCaptureAddressKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_buffer_device_address");
        return hasExt ? (void*)entry_vkGetDeviceMemoryOpaqueCaptureAddressKHR : nullptr;
    }
#endif
#ifdef VK_KHR_deferred_host_operations
    if (!strcmp(name, "vkCreateDeferredOperationKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_deferred_host_operations");
        return hasExt ? (void*)entry_vkCreateDeferredOperationKHR : nullptr;
    }
    if (!strcmp(name, "vkDestroyDeferredOperationKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_deferred_host_operations");
        return hasExt ? (void*)entry_vkDestroyDeferredOperationKHR : nullptr;
    }
    if (!strcmp(name, "vkGetDeferredOperationMaxConcurrencyKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_deferred_host_operations");
        return hasExt ? (void*)entry_vkGetDeferredOperationMaxConcurrencyKHR : nullptr;
    }
    if (!strcmp(name, "vkGetDeferredOperationResultKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_deferred_host_operations");
        return hasExt ? (void*)entry_vkGetDeferredOperationResultKHR : nullptr;
    }
    if (!strcmp(name, "vkDeferredOperationJoinKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_deferred_host_operations");
        return hasExt ? (void*)entry_vkDeferredOperationJoinKHR : nullptr;
    }
#endif
#ifdef VK_KHR_pipeline_executable_properties
    if (!strcmp(name, "vkGetPipelineExecutablePropertiesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_pipeline_executable_properties");
        return hasExt ? (void*)entry_vkGetPipelineExecutablePropertiesKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPipelineExecutableStatisticsKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_pipeline_executable_properties");
        return hasExt ? (void*)entry_vkGetPipelineExecutableStatisticsKHR : nullptr;
    }
    if (!strcmp(name, "vkGetPipelineExecutableInternalRepresentationsKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_pipeline_executable_properties");
        return hasExt ? (void*)entry_vkGetPipelineExecutableInternalRepresentationsKHR : nullptr;
    }
#endif
#ifdef VK_KHR_copy_commands2
    if (!strcmp(name, "vkCmdCopyBuffer2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_copy_commands2");
        return hasExt ? (void*)entry_vkCmdCopyBuffer2KHR : nullptr;
    }
    if (!strcmp(name, "vkCmdCopyImage2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_copy_commands2");
        return hasExt ? (void*)entry_vkCmdCopyImage2KHR : nullptr;
    }
    if (!strcmp(name, "vkCmdCopyBufferToImage2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_copy_commands2");
        return hasExt ? (void*)entry_vkCmdCopyBufferToImage2KHR : nullptr;
    }
    if (!strcmp(name, "vkCmdCopyImageToBuffer2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_copy_commands2");
        return hasExt ? (void*)entry_vkCmdCopyImageToBuffer2KHR : nullptr;
    }
    if (!strcmp(name, "vkCmdBlitImage2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_copy_commands2");
        return hasExt ? (void*)entry_vkCmdBlitImage2KHR : nullptr;
    }
    if (!strcmp(name, "vkCmdResolveImage2KHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_copy_commands2");
        return hasExt ? (void*)entry_vkCmdResolveImage2KHR : nullptr;
    }
#endif
#ifdef VK_ANDROID_native_buffer
    if (!strcmp(name, "vkGetSwapchainGrallocUsageANDROID"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_ANDROID_native_buffer");
        return hasExt ? (void*)entry_vkGetSwapchainGrallocUsageANDROID : nullptr;
    }
    if (!strcmp(name, "vkAcquireImageANDROID"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_ANDROID_native_buffer");
        return hasExt ? (void*)entry_vkAcquireImageANDROID : nullptr;
    }
    if (!strcmp(name, "vkQueueSignalReleaseImageANDROID"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_ANDROID_native_buffer");
        return hasExt ? (void*)entry_vkQueueSignalReleaseImageANDROID : nullptr;
    }
#endif
#ifdef VK_EXT_debug_report
    if (!strcmp(name, "vkCreateDebugReportCallbackEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_report");
        return hasExt ? (void*)entry_vkCreateDebugReportCallbackEXT : nullptr;
    }
    if (!strcmp(name, "vkDestroyDebugReportCallbackEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_report");
        return hasExt ? (void*)entry_vkDestroyDebugReportCallbackEXT : nullptr;
    }
    if (!strcmp(name, "vkDebugReportMessageEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_report");
        return hasExt ? (void*)entry_vkDebugReportMessageEXT : nullptr;
    }
#endif
#ifdef VK_EXT_debug_marker
    if (!strcmp(name, "vkDebugMarkerSetObjectTagEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_marker");
        return hasExt ? (void*)entry_vkDebugMarkerSetObjectTagEXT : nullptr;
    }
    if (!strcmp(name, "vkDebugMarkerSetObjectNameEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_marker");
        return hasExt ? (void*)entry_vkDebugMarkerSetObjectNameEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdDebugMarkerBeginEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_marker");
        return hasExt ? (void*)entry_vkCmdDebugMarkerBeginEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdDebugMarkerEndEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_marker");
        return hasExt ? (void*)entry_vkCmdDebugMarkerEndEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdDebugMarkerInsertEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_marker");
        return hasExt ? (void*)entry_vkCmdDebugMarkerInsertEXT : nullptr;
    }
#endif
#ifdef VK_EXT_transform_feedback
    if (!strcmp(name, "vkCmdBindTransformFeedbackBuffersEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_transform_feedback");
        return hasExt ? (void*)entry_vkCmdBindTransformFeedbackBuffersEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdBeginTransformFeedbackEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_transform_feedback");
        return hasExt ? (void*)entry_vkCmdBeginTransformFeedbackEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdEndTransformFeedbackEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_transform_feedback");
        return hasExt ? (void*)entry_vkCmdEndTransformFeedbackEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdBeginQueryIndexedEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_transform_feedback");
        return hasExt ? (void*)entry_vkCmdBeginQueryIndexedEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdEndQueryIndexedEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_transform_feedback");
        return hasExt ? (void*)entry_vkCmdEndQueryIndexedEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdDrawIndirectByteCountEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_transform_feedback");
        return hasExt ? (void*)entry_vkCmdDrawIndirectByteCountEXT : nullptr;
    }
#endif
#ifdef VK_NVX_image_view_handle
    if (!strcmp(name, "vkGetImageViewHandleNVX"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NVX_image_view_handle");
        return hasExt ? (void*)entry_vkGetImageViewHandleNVX : nullptr;
    }
    if (!strcmp(name, "vkGetImageViewAddressNVX"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NVX_image_view_handle");
        return hasExt ? (void*)entry_vkGetImageViewAddressNVX : nullptr;
    }
#endif
#ifdef VK_AMD_draw_indirect_count
    if (!strcmp(name, "vkCmdDrawIndirectCountAMD"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_AMD_draw_indirect_count");
        return hasExt ? (void*)entry_vkCmdDrawIndirectCountAMD : nullptr;
    }
    if (!strcmp(name, "vkCmdDrawIndexedIndirectCountAMD"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_AMD_draw_indirect_count");
        return hasExt ? (void*)entry_vkCmdDrawIndexedIndirectCountAMD : nullptr;
    }
#endif
#ifdef VK_AMD_shader_info
    if (!strcmp(name, "vkGetShaderInfoAMD"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_AMD_shader_info");
        return hasExt ? (void*)entry_vkGetShaderInfoAMD : nullptr;
    }
#endif
#ifdef VK_GGP_stream_descriptor_surface
    if (!strcmp(name, "vkCreateStreamDescriptorSurfaceGGP"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GGP_stream_descriptor_surface");
        return hasExt ? (void*)entry_vkCreateStreamDescriptorSurfaceGGP : nullptr;
    }
#endif
#ifdef VK_NV_external_memory_capabilities
    if (!strcmp(name, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_external_memory_capabilities");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceExternalImageFormatPropertiesNV : nullptr;
    }
#endif
#ifdef VK_NV_external_memory_win32
    if (!strcmp(name, "vkGetMemoryWin32HandleNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_external_memory_win32");
        return hasExt ? (void*)entry_vkGetMemoryWin32HandleNV : nullptr;
    }
#endif
#ifdef VK_NN_vi_surface
    if (!strcmp(name, "vkCreateViSurfaceNN"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NN_vi_surface");
        return hasExt ? (void*)entry_vkCreateViSurfaceNN : nullptr;
    }
#endif
#ifdef VK_EXT_conditional_rendering
    if (!strcmp(name, "vkCmdBeginConditionalRenderingEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_conditional_rendering");
        return hasExt ? (void*)entry_vkCmdBeginConditionalRenderingEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdEndConditionalRenderingEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_conditional_rendering");
        return hasExt ? (void*)entry_vkCmdEndConditionalRenderingEXT : nullptr;
    }
#endif
#ifdef VK_NV_clip_space_w_scaling
    if (!strcmp(name, "vkCmdSetViewportWScalingNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_clip_space_w_scaling");
        return hasExt ? (void*)entry_vkCmdSetViewportWScalingNV : nullptr;
    }
#endif
#ifdef VK_EXT_direct_mode_display
    if (!strcmp(name, "vkReleaseDisplayEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_direct_mode_display");
        return hasExt ? (void*)entry_vkReleaseDisplayEXT : nullptr;
    }
#endif
#ifdef VK_EXT_acquire_xlib_display
    if (!strcmp(name, "vkAcquireXlibDisplayEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_acquire_xlib_display");
        return hasExt ? (void*)entry_vkAcquireXlibDisplayEXT : nullptr;
    }
    if (!strcmp(name, "vkGetRandROutputDisplayEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_acquire_xlib_display");
        return hasExt ? (void*)entry_vkGetRandROutputDisplayEXT : nullptr;
    }
#endif
#ifdef VK_EXT_display_surface_counter
    if (!strcmp(name, "vkGetPhysicalDeviceSurfaceCapabilities2EXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_display_surface_counter");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSurfaceCapabilities2EXT : nullptr;
    }
#endif
#ifdef VK_EXT_display_control
    if (!strcmp(name, "vkDisplayPowerControlEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_display_control");
        return hasExt ? (void*)entry_vkDisplayPowerControlEXT : nullptr;
    }
    if (!strcmp(name, "vkRegisterDeviceEventEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_display_control");
        return hasExt ? (void*)entry_vkRegisterDeviceEventEXT : nullptr;
    }
    if (!strcmp(name, "vkRegisterDisplayEventEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_display_control");
        return hasExt ? (void*)entry_vkRegisterDisplayEventEXT : nullptr;
    }
    if (!strcmp(name, "vkGetSwapchainCounterEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_display_control");
        return hasExt ? (void*)entry_vkGetSwapchainCounterEXT : nullptr;
    }
#endif
#ifdef VK_GOOGLE_display_timing
    if (!strcmp(name, "vkGetRefreshCycleDurationGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_display_timing");
        return hasExt ? (void*)entry_vkGetRefreshCycleDurationGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkGetPastPresentationTimingGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_display_timing");
        return hasExt ? (void*)entry_vkGetPastPresentationTimingGOOGLE : nullptr;
    }
#endif
#ifdef VK_EXT_discard_rectangles
    if (!strcmp(name, "vkCmdSetDiscardRectangleEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_discard_rectangles");
        return hasExt ? (void*)entry_vkCmdSetDiscardRectangleEXT : nullptr;
    }
#endif
#ifdef VK_EXT_hdr_metadata
    if (!strcmp(name, "vkSetHdrMetadataEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_hdr_metadata");
        return hasExt ? (void*)entry_vkSetHdrMetadataEXT : nullptr;
    }
#endif
#ifdef VK_MVK_ios_surface
    if (!strcmp(name, "vkCreateIOSSurfaceMVK"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_MVK_ios_surface");
        return hasExt ? (void*)entry_vkCreateIOSSurfaceMVK : nullptr;
    }
#endif
#ifdef VK_MVK_macos_surface
    if (!strcmp(name, "vkCreateMacOSSurfaceMVK"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_MVK_macos_surface");
        return hasExt ? (void*)entry_vkCreateMacOSSurfaceMVK : nullptr;
    }
#endif
#ifdef VK_MVK_moltenvk
    if (!strcmp(name, "vkGetMTLDeviceMVK"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_MVK_moltenvk");
        return hasExt ? (void*)entry_vkGetMTLDeviceMVK : nullptr;
    }
    if (!strcmp(name, "vkSetMTLTextureMVK"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_MVK_moltenvk");
        return hasExt ? (void*)entry_vkSetMTLTextureMVK : nullptr;
    }
    if (!strcmp(name, "vkGetMTLTextureMVK"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_MVK_moltenvk");
        return hasExt ? (void*)entry_vkGetMTLTextureMVK : nullptr;
    }
    if (!strcmp(name, "vkGetMTLBufferMVK"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_MVK_moltenvk");
        return hasExt ? (void*)entry_vkGetMTLBufferMVK : nullptr;
    }
    if (!strcmp(name, "vkUseIOSurfaceMVK"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_MVK_moltenvk");
        return hasExt ? (void*)entry_vkUseIOSurfaceMVK : nullptr;
    }
    if (!strcmp(name, "vkGetIOSurfaceMVK"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_MVK_moltenvk");
        return hasExt ? (void*)entry_vkGetIOSurfaceMVK : nullptr;
    }
#endif
#ifdef VK_EXT_debug_utils
    if (!strcmp(name, "vkSetDebugUtilsObjectNameEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkSetDebugUtilsObjectNameEXT : nullptr;
    }
    if (!strcmp(name, "vkSetDebugUtilsObjectTagEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkSetDebugUtilsObjectTagEXT : nullptr;
    }
    if (!strcmp(name, "vkQueueBeginDebugUtilsLabelEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkQueueBeginDebugUtilsLabelEXT : nullptr;
    }
    if (!strcmp(name, "vkQueueEndDebugUtilsLabelEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkQueueEndDebugUtilsLabelEXT : nullptr;
    }
    if (!strcmp(name, "vkQueueInsertDebugUtilsLabelEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkQueueInsertDebugUtilsLabelEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdBeginDebugUtilsLabelEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkCmdBeginDebugUtilsLabelEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdEndDebugUtilsLabelEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkCmdEndDebugUtilsLabelEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdInsertDebugUtilsLabelEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkCmdInsertDebugUtilsLabelEXT : nullptr;
    }
    if (!strcmp(name, "vkCreateDebugUtilsMessengerEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkCreateDebugUtilsMessengerEXT : nullptr;
    }
    if (!strcmp(name, "vkDestroyDebugUtilsMessengerEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkDestroyDebugUtilsMessengerEXT : nullptr;
    }
    if (!strcmp(name, "vkSubmitDebugUtilsMessageEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_debug_utils");
        return hasExt ? (void*)entry_vkSubmitDebugUtilsMessageEXT : nullptr;
    }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
    if (!strcmp(name, "vkGetAndroidHardwareBufferPropertiesANDROID"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_ANDROID_external_memory_android_hardware_buffer");
        return hasExt ? (void*)entry_vkGetAndroidHardwareBufferPropertiesANDROID : nullptr;
    }
    if (!strcmp(name, "vkGetMemoryAndroidHardwareBufferANDROID"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_ANDROID_external_memory_android_hardware_buffer");
        return hasExt ? (void*)entry_vkGetMemoryAndroidHardwareBufferANDROID : nullptr;
    }
#endif
#ifdef VK_EXT_sample_locations
    if (!strcmp(name, "vkCmdSetSampleLocationsEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_sample_locations");
        return hasExt ? (void*)entry_vkCmdSetSampleLocationsEXT : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceMultisamplePropertiesEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_sample_locations");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceMultisamplePropertiesEXT : nullptr;
    }
#endif
#ifdef VK_EXT_image_drm_format_modifier
    if (!strcmp(name, "vkGetImageDrmFormatModifierPropertiesEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_image_drm_format_modifier");
        return hasExt ? (void*)entry_vkGetImageDrmFormatModifierPropertiesEXT : nullptr;
    }
#endif
#ifdef VK_EXT_validation_cache
    if (!strcmp(name, "vkCreateValidationCacheEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_validation_cache");
        return hasExt ? (void*)entry_vkCreateValidationCacheEXT : nullptr;
    }
    if (!strcmp(name, "vkDestroyValidationCacheEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_validation_cache");
        return hasExt ? (void*)entry_vkDestroyValidationCacheEXT : nullptr;
    }
    if (!strcmp(name, "vkMergeValidationCachesEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_validation_cache");
        return hasExt ? (void*)entry_vkMergeValidationCachesEXT : nullptr;
    }
    if (!strcmp(name, "vkGetValidationCacheDataEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_validation_cache");
        return hasExt ? (void*)entry_vkGetValidationCacheDataEXT : nullptr;
    }
#endif
#ifdef VK_NV_shading_rate_image
    if (!strcmp(name, "vkCmdBindShadingRateImageNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_shading_rate_image");
        return hasExt ? (void*)entry_vkCmdBindShadingRateImageNV : nullptr;
    }
    if (!strcmp(name, "vkCmdSetViewportShadingRatePaletteNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_shading_rate_image");
        return hasExt ? (void*)entry_vkCmdSetViewportShadingRatePaletteNV : nullptr;
    }
    if (!strcmp(name, "vkCmdSetCoarseSampleOrderNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_shading_rate_image");
        return hasExt ? (void*)entry_vkCmdSetCoarseSampleOrderNV : nullptr;
    }
#endif
#ifdef VK_NV_ray_tracing
    if (!strcmp(name, "vkCreateAccelerationStructureNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_ray_tracing");
        return hasExt ? (void*)entry_vkCreateAccelerationStructureNV : nullptr;
    }
    if (!strcmp(name, "vkDestroyAccelerationStructureNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_ray_tracing");
        return hasExt ? (void*)entry_vkDestroyAccelerationStructureNV : nullptr;
    }
    if (!strcmp(name, "vkGetAccelerationStructureMemoryRequirementsNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_ray_tracing");
        return hasExt ? (void*)entry_vkGetAccelerationStructureMemoryRequirementsNV : nullptr;
    }
    if (!strcmp(name, "vkBindAccelerationStructureMemoryNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_ray_tracing");
        return hasExt ? (void*)entry_vkBindAccelerationStructureMemoryNV : nullptr;
    }
    if (!strcmp(name, "vkCmdBuildAccelerationStructureNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_ray_tracing");
        return hasExt ? (void*)entry_vkCmdBuildAccelerationStructureNV : nullptr;
    }
    if (!strcmp(name, "vkCmdCopyAccelerationStructureNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_ray_tracing");
        return hasExt ? (void*)entry_vkCmdCopyAccelerationStructureNV : nullptr;
    }
    if (!strcmp(name, "vkCmdTraceRaysNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_ray_tracing");
        return hasExt ? (void*)entry_vkCmdTraceRaysNV : nullptr;
    }
    if (!strcmp(name, "vkCreateRayTracingPipelinesNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_ray_tracing");
        return hasExt ? (void*)entry_vkCreateRayTracingPipelinesNV : nullptr;
    }
    if (!strcmp(name, "vkGetRayTracingShaderGroupHandlesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_ray_tracing");
        return hasExt ? (void*)entry_vkGetRayTracingShaderGroupHandlesKHR : nullptr;
    }
    if (!strcmp(name, "vkGetRayTracingShaderGroupHandlesNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_ray_tracing");
        return hasExt ? (void*)entry_vkGetRayTracingShaderGroupHandlesNV : nullptr;
    }
    if (!strcmp(name, "vkGetAccelerationStructureHandleNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_ray_tracing");
        return hasExt ? (void*)entry_vkGetAccelerationStructureHandleNV : nullptr;
    }
    if (!strcmp(name, "vkCmdWriteAccelerationStructuresPropertiesNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_ray_tracing");
        return hasExt ? (void*)entry_vkCmdWriteAccelerationStructuresPropertiesNV : nullptr;
    }
    if (!strcmp(name, "vkCompileDeferredNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_ray_tracing");
        return hasExt ? (void*)entry_vkCompileDeferredNV : nullptr;
    }
#endif
#ifdef VK_EXT_external_memory_host
    if (!strcmp(name, "vkGetMemoryHostPointerPropertiesEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_external_memory_host");
        return hasExt ? (void*)entry_vkGetMemoryHostPointerPropertiesEXT : nullptr;
    }
#endif
#ifdef VK_AMD_buffer_marker
    if (!strcmp(name, "vkCmdWriteBufferMarkerAMD"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_AMD_buffer_marker");
        return hasExt ? (void*)entry_vkCmdWriteBufferMarkerAMD : nullptr;
    }
#endif
#ifdef VK_EXT_calibrated_timestamps
    if (!strcmp(name, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_calibrated_timestamps");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT : nullptr;
    }
    if (!strcmp(name, "vkGetCalibratedTimestampsEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_calibrated_timestamps");
        return hasExt ? (void*)entry_vkGetCalibratedTimestampsEXT : nullptr;
    }
#endif
#ifdef VK_NV_mesh_shader
    if (!strcmp(name, "vkCmdDrawMeshTasksNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_mesh_shader");
        return hasExt ? (void*)entry_vkCmdDrawMeshTasksNV : nullptr;
    }
    if (!strcmp(name, "vkCmdDrawMeshTasksIndirectNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_mesh_shader");
        return hasExt ? (void*)entry_vkCmdDrawMeshTasksIndirectNV : nullptr;
    }
    if (!strcmp(name, "vkCmdDrawMeshTasksIndirectCountNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_mesh_shader");
        return hasExt ? (void*)entry_vkCmdDrawMeshTasksIndirectCountNV : nullptr;
    }
#endif
#ifdef VK_NV_scissor_exclusive
    if (!strcmp(name, "vkCmdSetExclusiveScissorNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_scissor_exclusive");
        return hasExt ? (void*)entry_vkCmdSetExclusiveScissorNV : nullptr;
    }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
    if (!strcmp(name, "vkCmdSetCheckpointNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_device_diagnostic_checkpoints");
        return hasExt ? (void*)entry_vkCmdSetCheckpointNV : nullptr;
    }
    if (!strcmp(name, "vkGetQueueCheckpointDataNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_device_diagnostic_checkpoints");
        return hasExt ? (void*)entry_vkGetQueueCheckpointDataNV : nullptr;
    }
#endif
#ifdef VK_INTEL_performance_query
    if (!strcmp(name, "vkInitializePerformanceApiINTEL"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_INTEL_performance_query");
        return hasExt ? (void*)entry_vkInitializePerformanceApiINTEL : nullptr;
    }
    if (!strcmp(name, "vkUninitializePerformanceApiINTEL"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_INTEL_performance_query");
        return hasExt ? (void*)entry_vkUninitializePerformanceApiINTEL : nullptr;
    }
    if (!strcmp(name, "vkCmdSetPerformanceMarkerINTEL"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_INTEL_performance_query");
        return hasExt ? (void*)entry_vkCmdSetPerformanceMarkerINTEL : nullptr;
    }
    if (!strcmp(name, "vkCmdSetPerformanceStreamMarkerINTEL"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_INTEL_performance_query");
        return hasExt ? (void*)entry_vkCmdSetPerformanceStreamMarkerINTEL : nullptr;
    }
    if (!strcmp(name, "vkCmdSetPerformanceOverrideINTEL"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_INTEL_performance_query");
        return hasExt ? (void*)entry_vkCmdSetPerformanceOverrideINTEL : nullptr;
    }
    if (!strcmp(name, "vkAcquirePerformanceConfigurationINTEL"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_INTEL_performance_query");
        return hasExt ? (void*)entry_vkAcquirePerformanceConfigurationINTEL : nullptr;
    }
    if (!strcmp(name, "vkReleasePerformanceConfigurationINTEL"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_INTEL_performance_query");
        return hasExt ? (void*)entry_vkReleasePerformanceConfigurationINTEL : nullptr;
    }
    if (!strcmp(name, "vkQueueSetPerformanceConfigurationINTEL"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_INTEL_performance_query");
        return hasExt ? (void*)entry_vkQueueSetPerformanceConfigurationINTEL : nullptr;
    }
    if (!strcmp(name, "vkGetPerformanceParameterINTEL"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_INTEL_performance_query");
        return hasExt ? (void*)entry_vkGetPerformanceParameterINTEL : nullptr;
    }
#endif
#ifdef VK_AMD_display_native_hdr
    if (!strcmp(name, "vkSetLocalDimmingAMD"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_AMD_display_native_hdr");
        return hasExt ? (void*)entry_vkSetLocalDimmingAMD : nullptr;
    }
#endif
#ifdef VK_FUCHSIA_imagepipe_surface
    if (!strcmp(name, "vkCreateImagePipeSurfaceFUCHSIA"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_FUCHSIA_imagepipe_surface");
        return hasExt ? (void*)entry_vkCreateImagePipeSurfaceFUCHSIA : nullptr;
    }
#endif
#ifdef VK_EXT_metal_surface
    if (!strcmp(name, "vkCreateMetalSurfaceEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_metal_surface");
        return hasExt ? (void*)entry_vkCreateMetalSurfaceEXT : nullptr;
    }
#endif
#ifdef VK_EXT_buffer_device_address
    if (!strcmp(name, "vkGetBufferDeviceAddressEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_buffer_device_address");
        return hasExt ? (void*)entry_vkGetBufferDeviceAddressEXT : nullptr;
    }
#endif
#ifdef VK_EXT_tooling_info
    if (!strcmp(name, "vkGetPhysicalDeviceToolPropertiesEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_tooling_info");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceToolPropertiesEXT : nullptr;
    }
#endif
#ifdef VK_NV_cooperative_matrix
    if (!strcmp(name, "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_cooperative_matrix");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV : nullptr;
    }
#endif
#ifdef VK_NV_coverage_reduction_mode
    if (!strcmp(name, "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_coverage_reduction_mode");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV : nullptr;
    }
#endif
#ifdef VK_EXT_full_screen_exclusive
    if (!strcmp(name, "vkGetPhysicalDeviceSurfacePresentModes2EXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_full_screen_exclusive");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceSurfacePresentModes2EXT : nullptr;
    }
    if (!strcmp(name, "vkAcquireFullScreenExclusiveModeEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_full_screen_exclusive");
        return hasExt ? (void*)entry_vkAcquireFullScreenExclusiveModeEXT : nullptr;
    }
    if (!strcmp(name, "vkReleaseFullScreenExclusiveModeEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_full_screen_exclusive");
        return hasExt ? (void*)entry_vkReleaseFullScreenExclusiveModeEXT : nullptr;
    }
    if (!strcmp(name, "vkGetDeviceGroupSurfacePresentModes2EXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_full_screen_exclusive");
        return hasExt ? (void*)entry_vkGetDeviceGroupSurfacePresentModes2EXT : nullptr;
    }
#endif
#ifdef VK_EXT_headless_surface
    if (!strcmp(name, "vkCreateHeadlessSurfaceEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_headless_surface");
        return hasExt ? (void*)entry_vkCreateHeadlessSurfaceEXT : nullptr;
    }
#endif
#ifdef VK_EXT_line_rasterization
    if (!strcmp(name, "vkCmdSetLineStippleEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_line_rasterization");
        return hasExt ? (void*)entry_vkCmdSetLineStippleEXT : nullptr;
    }
#endif
#ifdef VK_EXT_host_query_reset
    if (!strcmp(name, "vkResetQueryPoolEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_host_query_reset");
        return hasExt ? (void*)entry_vkResetQueryPoolEXT : nullptr;
    }
#endif
#ifdef VK_EXT_extended_dynamic_state
    if (!strcmp(name, "vkCmdSetCullModeEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetCullModeEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetFrontFaceEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetFrontFaceEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetPrimitiveTopologyEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetPrimitiveTopologyEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetViewportWithCountEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetViewportWithCountEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetScissorWithCountEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetScissorWithCountEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdBindVertexBuffers2EXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdBindVertexBuffers2EXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthTestEnableEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetDepthTestEnableEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthWriteEnableEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetDepthWriteEnableEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthCompareOpEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetDepthCompareOpEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetDepthBoundsTestEnableEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetDepthBoundsTestEnableEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetStencilTestEnableEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetStencilTestEnableEXT : nullptr;
    }
    if (!strcmp(name, "vkCmdSetStencilOpEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_extended_dynamic_state");
        return hasExt ? (void*)entry_vkCmdSetStencilOpEXT : nullptr;
    }
#endif
#ifdef VK_NV_device_generated_commands
    if (!strcmp(name, "vkGetGeneratedCommandsMemoryRequirementsNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_device_generated_commands");
        return hasExt ? (void*)entry_vkGetGeneratedCommandsMemoryRequirementsNV : nullptr;
    }
    if (!strcmp(name, "vkCmdPreprocessGeneratedCommandsNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_device_generated_commands");
        return hasExt ? (void*)entry_vkCmdPreprocessGeneratedCommandsNV : nullptr;
    }
    if (!strcmp(name, "vkCmdExecuteGeneratedCommandsNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_device_generated_commands");
        return hasExt ? (void*)entry_vkCmdExecuteGeneratedCommandsNV : nullptr;
    }
    if (!strcmp(name, "vkCmdBindPipelineShaderGroupNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_device_generated_commands");
        return hasExt ? (void*)entry_vkCmdBindPipelineShaderGroupNV : nullptr;
    }
    if (!strcmp(name, "vkCreateIndirectCommandsLayoutNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_device_generated_commands");
        return hasExt ? (void*)entry_vkCreateIndirectCommandsLayoutNV : nullptr;
    }
    if (!strcmp(name, "vkDestroyIndirectCommandsLayoutNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_device_generated_commands");
        return hasExt ? (void*)entry_vkDestroyIndirectCommandsLayoutNV : nullptr;
    }
#endif
#ifdef VK_EXT_private_data
    if (!strcmp(name, "vkCreatePrivateDataSlotEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_private_data");
        return hasExt ? (void*)entry_vkCreatePrivateDataSlotEXT : nullptr;
    }
    if (!strcmp(name, "vkDestroyPrivateDataSlotEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_private_data");
        return hasExt ? (void*)entry_vkDestroyPrivateDataSlotEXT : nullptr;
    }
    if (!strcmp(name, "vkSetPrivateDataEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_private_data");
        return hasExt ? (void*)entry_vkSetPrivateDataEXT : nullptr;
    }
    if (!strcmp(name, "vkGetPrivateDataEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_private_data");
        return hasExt ? (void*)entry_vkGetPrivateDataEXT : nullptr;
    }
#endif
#ifdef VK_NV_fragment_shading_rate_enums
    if (!strcmp(name, "vkCmdSetFragmentShadingRateEnumNV"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_NV_fragment_shading_rate_enums");
        return hasExt ? (void*)entry_vkCmdSetFragmentShadingRateEnumNV : nullptr;
    }
#endif
#ifdef VK_EXT_directfb_surface
    if (!strcmp(name, "vkCreateDirectFBSurfaceEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_directfb_surface");
        return hasExt ? (void*)entry_vkCreateDirectFBSurfaceEXT : nullptr;
    }
    if (!strcmp(name, "vkGetPhysicalDeviceDirectFBPresentationSupportEXT"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_EXT_directfb_surface");
        return hasExt ? (void*)entry_vkGetPhysicalDeviceDirectFBPresentationSupportEXT : nullptr;
    }
#endif
#ifdef VK_GOOGLE_gfxstream
    if (!strcmp(name, "vkRegisterImageColorBufferGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkRegisterImageColorBufferGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkRegisterBufferColorBufferGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkRegisterBufferColorBufferGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkMapMemoryIntoAddressSpaceGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkMapMemoryIntoAddressSpaceGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkUpdateDescriptorSetWithTemplateSizedGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkUpdateDescriptorSetWithTemplateSizedGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkBeginCommandBufferAsyncGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkBeginCommandBufferAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkEndCommandBufferAsyncGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkEndCommandBufferAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkResetCommandBufferAsyncGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkResetCommandBufferAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkCommandBufferHostSyncGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkCommandBufferHostSyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkCreateImageWithRequirementsGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkCreateImageWithRequirementsGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkCreateBufferWithRequirementsGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkCreateBufferWithRequirementsGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkGetMemoryHostAddressInfoGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkGetMemoryHostAddressInfoGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkFreeMemorySyncGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkFreeMemorySyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueHostSyncGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueHostSyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueSubmitAsyncGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueSubmitAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueWaitIdleAsyncGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueWaitIdleAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueBindSparseAsyncGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueBindSparseAsyncGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkGetLinearImageLayoutGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkGetLinearImageLayoutGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueFlushCommandsGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueFlushCommandsGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkQueueCommitDescriptorSetUpdatesGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkQueueCommitDescriptorSetUpdatesGOOGLE : nullptr;
    }
    if (!strcmp(name, "vkCollectDescriptorPoolIdsGOOGLE"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_GOOGLE_gfxstream");
        return hasExt ? (void*)entry_vkCollectDescriptorPoolIdsGOOGLE : nullptr;
    }
#endif
#ifdef VK_KHR_acceleration_structure
    if (!strcmp(name, "vkCreateAccelerationStructureKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkCreateAccelerationStructureKHR : nullptr;
    }
    if (!strcmp(name, "vkDestroyAccelerationStructureKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkDestroyAccelerationStructureKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdBuildAccelerationStructuresKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkCmdBuildAccelerationStructuresKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdBuildAccelerationStructuresIndirectKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkCmdBuildAccelerationStructuresIndirectKHR : nullptr;
    }
    if (!strcmp(name, "vkBuildAccelerationStructuresKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkBuildAccelerationStructuresKHR : nullptr;
    }
    if (!strcmp(name, "vkCopyAccelerationStructureKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkCopyAccelerationStructureKHR : nullptr;
    }
    if (!strcmp(name, "vkCopyAccelerationStructureToMemoryKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkCopyAccelerationStructureToMemoryKHR : nullptr;
    }
    if (!strcmp(name, "vkCopyMemoryToAccelerationStructureKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkCopyMemoryToAccelerationStructureKHR : nullptr;
    }
    if (!strcmp(name, "vkWriteAccelerationStructuresPropertiesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkWriteAccelerationStructuresPropertiesKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdCopyAccelerationStructureKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkCmdCopyAccelerationStructureKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdCopyAccelerationStructureToMemoryKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkCmdCopyAccelerationStructureToMemoryKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdCopyMemoryToAccelerationStructureKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkCmdCopyMemoryToAccelerationStructureKHR : nullptr;
    }
    if (!strcmp(name, "vkGetAccelerationStructureDeviceAddressKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkGetAccelerationStructureDeviceAddressKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdWriteAccelerationStructuresPropertiesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkCmdWriteAccelerationStructuresPropertiesKHR : nullptr;
    }
    if (!strcmp(name, "vkGetDeviceAccelerationStructureCompatibilityKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkGetDeviceAccelerationStructureCompatibilityKHR : nullptr;
    }
    if (!strcmp(name, "vkGetAccelerationStructureBuildSizesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_acceleration_structure");
        return hasExt ? (void*)entry_vkGetAccelerationStructureBuildSizesKHR : nullptr;
    }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
    if (!strcmp(name, "vkCmdTraceRaysKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_ray_tracing_pipeline");
        return hasExt ? (void*)entry_vkCmdTraceRaysKHR : nullptr;
    }
    if (!strcmp(name, "vkCreateRayTracingPipelinesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_ray_tracing_pipeline");
        return hasExt ? (void*)entry_vkCreateRayTracingPipelinesKHR : nullptr;
    }
    if (!strcmp(name, "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_ray_tracing_pipeline");
        return hasExt ? (void*)entry_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdTraceRaysIndirectKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_ray_tracing_pipeline");
        return hasExt ? (void*)entry_vkCmdTraceRaysIndirectKHR : nullptr;
    }
    if (!strcmp(name, "vkGetRayTracingShaderGroupStackSizeKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_ray_tracing_pipeline");
        return hasExt ? (void*)entry_vkGetRayTracingShaderGroupStackSizeKHR : nullptr;
    }
    if (!strcmp(name, "vkCmdSetRayTracingPipelineStackSizeKHR"))
    {
        bool hasExt = resources->hasDeviceExtension(device, "VK_KHR_ray_tracing_pipeline");
        return hasExt ? (void*)entry_vkCmdSetRayTracingPipelineStackSizeKHR : nullptr;
    }
#endif
    return nullptr;
}

} // namespace goldfish_vk
