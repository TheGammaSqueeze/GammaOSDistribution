// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module VkEncoder
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "VkEncoder.h"


#include "IOStream.h"
#include "Resources.h"
#include "ResourceTracker.h"
#include "Validation.h"
#include "VulkanStreamGuest.h"

#include "android/base/AlignedBuf.h"
#include "android/base/BumpPool.h"
#include "android/base/synchronization/AndroidLock.h"

#include <cutils/properties.h>

#include "goldfish_vk_marshaling_guest.h"
#include "goldfish_vk_reserved_marshaling_guest.h"
#include "goldfish_vk_deepcopy_guest.h"
#include "goldfish_vk_counting_guest.h"
#include "goldfish_vk_handlemap_guest.h"
#include "goldfish_vk_private_defs.h"
#include "goldfish_vk_transform_guest.h"

#include <unordered_map>



namespace goldfish_vk {



using namespace goldfish_vk;

using android::aligned_buf_alloc;
using android::aligned_buf_free;
using android::base::guest::AutoLock;
using android::base::guest::Lock;
using android::base::BumpPool;

#include "VkEncoder.cpp.inl"

#define VALIDATE_RET(retType, success, validate) \
    retType goldfish_vk_validateResult = validate; \
    if (goldfish_vk_validateResult != success) return goldfish_vk_validateResult; \

#define VALIDATE_VOID(validate) \
    VkResult goldfish_vk_validateResult = validate; \
    if (goldfish_vk_validateResult != VK_SUCCESS) return; \

#ifdef VK_VERSION_1_0
VkResult VkEncoder::vkCreateInstance(
    const VkInstanceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkInstance* pInstance,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstanceCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkInstanceCreateInfo*)pool->alloc(sizeof(const VkInstanceCreateInfo));
        deepcopy_VkInstanceCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkInstanceCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkInstanceCreateInfo(sResourceTracker, (VkInstanceCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        count_VkInstanceCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkInstanceCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_0;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateInstance = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateInstance);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateInstance = OP_vkCreateInstance;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateInstance, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateInstance, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    reservedmarshal_VkInstanceCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkInstanceCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_1;
    *&cgen_var_1 = (uint64_t)((*pInstance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_2;
    stream->read((uint64_t*)&cgen_var_2, 8);
    stream->handleMapping()->mapHandles_u64_VkInstance(&cgen_var_2, (VkInstance*)pInstance, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateInstance_VkResult_return = (VkResult)0;
    stream->read(&vkCreateInstance_VkResult_return, sizeof(VkResult));
    sResourceTracker->on_vkCreateInstance(this, vkCreateInstance_VkResult_return, pCreateInfo, pAllocator, pInstance);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateInstance_VkResult_return;
}

void VkEncoder::vkDestroyInstance(
    VkInstance instance,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyInstance = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyInstance);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyInstance = OP_vkDestroyInstance;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyInstance, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyInstance, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkInstance((VkInstance*)&instance);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkEnumeratePhysicalDevices(
    VkInstance instance,
    uint32_t* pPhysicalDeviceCount,
    VkPhysicalDevice* pPhysicalDevices,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    local_instance = instance;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPhysicalDeviceCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPhysicalDevices)
        {
            if ((*(pPhysicalDeviceCount)))
            {
                *countPtr += (*(pPhysicalDeviceCount)) * 8;
            }
        }
    }
    uint32_t packetSize_vkEnumeratePhysicalDevices = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEnumeratePhysicalDevices);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEnumeratePhysicalDevices = OP_vkEnumeratePhysicalDevices;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkEnumeratePhysicalDevices, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEnumeratePhysicalDevices, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pPhysicalDeviceCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPhysicalDeviceCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    /* is handle, possibly out */;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pPhysicalDevices;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPhysicalDevices)
    {
        if ((*(pPhysicalDeviceCount)))
        {
            uint8_t* cgen_var_2_0_ptr = (uint8_t*)(*streamPtrPtr);
            if (pPhysicalDeviceCount)
            {
                for (uint32_t k = 0; k < (*(pPhysicalDeviceCount)); ++k)
                {
                    uint64_t tmpval = (uint64_t)(pPhysicalDevices[k]);
                    memcpy(cgen_var_2_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
                }
            }
            *streamPtrPtr += 8 * (*(pPhysicalDeviceCount));
        }
    }
    /* is handle, possibly out */;
    // WARNING PTR CHECK
    uint32_t* check_pPhysicalDeviceCount;
    check_pPhysicalDeviceCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceCount)
    {
        if (!(check_pPhysicalDeviceCount))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPhysicalDeviceCount, sizeof(uint32_t));
    }
    stream->setHandleMapping(sResourceTracker->createMapping());
    // WARNING PTR CHECK
    VkPhysicalDevice* check_pPhysicalDevices;
    check_pPhysicalDevices = (VkPhysicalDevice*)(uintptr_t)stream->getBe64();
    if (pPhysicalDevices)
    {
        if (!(check_pPhysicalDevices))
        {
            fprintf(stderr, "fatal: pPhysicalDevices inconsistent between guest and host\n");
        }
        if ((*(pPhysicalDeviceCount)))
        {
            uint64_t* cgen_var_4_0;
            stream->alloc((void**)&cgen_var_4_0, (*(pPhysicalDeviceCount)) * 8);
            stream->read((uint64_t*)cgen_var_4_0, (*(pPhysicalDeviceCount)) * 8);
            stream->handleMapping()->mapHandles_u64_VkPhysicalDevice(cgen_var_4_0, (VkPhysicalDevice*)pPhysicalDevices, (*(pPhysicalDeviceCount)));
        }
    }
    stream->unsetHandleMapping();
    VkResult vkEnumeratePhysicalDevices_VkResult_return = (VkResult)0;
    stream->read(&vkEnumeratePhysicalDevices_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEnumeratePhysicalDevices_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures* pFeatures,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceFeatures(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFeatures*)(pFeatures), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceFeatures = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceFeatures);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceFeatures = OP_vkGetPhysicalDeviceFeatures;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceFeatures, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceFeatures, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceFeatures(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFeatures*)(pFeatures), streamPtrPtr);
    unmarshal_VkPhysicalDeviceFeatures(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFeatures*)(pFeatures));
    if (pFeatures)
    {
        transform_fromhost_VkPhysicalDeviceFeatures(sResourceTracker, (VkPhysicalDeviceFeatures*)(pFeatures));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties* pFormatProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    local_physicalDevice = physicalDevice;
    local_format = format;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkFormat);
        count_VkFormatProperties(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFormatProperties*)(pFormatProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceFormatProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceFormatProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceFormatProperties = OP_vkGetPhysicalDeviceFormatProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceFormatProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceFormatProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkFormat*)&local_format, sizeof(VkFormat));
    *streamPtrPtr += sizeof(VkFormat);
    reservedmarshal_VkFormatProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFormatProperties*)(pFormatProperties), streamPtrPtr);
    unmarshal_VkFormatProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFormatProperties*)(pFormatProperties));
    if (pFormatProperties)
    {
        transform_fromhost_VkFormatProperties(sResourceTracker, (VkFormatProperties*)(pFormatProperties));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkImageTiling tiling,
    VkImageUsageFlags usage,
    VkImageCreateFlags flags,
    VkImageFormatProperties* pImageFormatProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    VkImageType local_type;
    VkImageTiling local_tiling;
    VkImageUsageFlags local_usage;
    VkImageCreateFlags local_flags;
    local_physicalDevice = physicalDevice;
    local_format = format;
    local_type = type;
    local_tiling = tiling;
    local_usage = usage;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkFormat);
        *countPtr += sizeof(VkImageType);
        *countPtr += sizeof(VkImageTiling);
        *countPtr += sizeof(VkImageUsageFlags);
        *countPtr += sizeof(VkImageCreateFlags);
        count_VkImageFormatProperties(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageFormatProperties*)(pImageFormatProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceImageFormatProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceImageFormatProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceImageFormatProperties = OP_vkGetPhysicalDeviceImageFormatProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceImageFormatProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceImageFormatProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkFormat*)&local_format, sizeof(VkFormat));
    *streamPtrPtr += sizeof(VkFormat);
    memcpy(*streamPtrPtr, (VkImageType*)&local_type, sizeof(VkImageType));
    *streamPtrPtr += sizeof(VkImageType);
    memcpy(*streamPtrPtr, (VkImageTiling*)&local_tiling, sizeof(VkImageTiling));
    *streamPtrPtr += sizeof(VkImageTiling);
    memcpy(*streamPtrPtr, (VkImageUsageFlags*)&local_usage, sizeof(VkImageUsageFlags));
    *streamPtrPtr += sizeof(VkImageUsageFlags);
    memcpy(*streamPtrPtr, (VkImageCreateFlags*)&local_flags, sizeof(VkImageCreateFlags));
    *streamPtrPtr += sizeof(VkImageCreateFlags);
    reservedmarshal_VkImageFormatProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageFormatProperties*)(pImageFormatProperties), streamPtrPtr);
    unmarshal_VkImageFormatProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageFormatProperties*)(pImageFormatProperties));
    if (pImageFormatProperties)
    {
        transform_fromhost_VkImageFormatProperties(sResourceTracker, (VkImageFormatProperties*)(pImageFormatProperties));
    }
    VkResult vkGetPhysicalDeviceImageFormatProperties_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceImageFormatProperties_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceImageFormatProperties_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceProperties(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceProperties(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceProperties*)(pProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceProperties = OP_vkGetPhysicalDeviceProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceProperties*)(pProperties), streamPtrPtr);
    unmarshal_VkPhysicalDeviceProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceProperties*)(pProperties));
    if (pProperties)
    {
        transform_fromhost_VkPhysicalDeviceProperties(sResourceTracker, (VkPhysicalDeviceProperties*)(pProperties));
    }
    sResourceTracker->on_vkGetPhysicalDeviceProperties(this, physicalDevice, pProperties);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties* pQueueFamilyProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pQueueFamilyPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pQueueFamilyProperties)
        {
            if (pQueueFamilyPropertyCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                {
                    count_VkQueueFamilyProperties(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceQueueFamilyProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceQueueFamilyProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceQueueFamilyProperties = OP_vkGetPhysicalDeviceQueueFamilyProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceQueueFamilyProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceQueueFamilyProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pQueueFamilyPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            reservedmarshal_VkQueueFamilyProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pQueueFamilyPropertyCount;
    check_pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyPropertyCount)
    {
        if (!(check_pQueueFamilyPropertyCount))
        {
            fprintf(stderr, "fatal: pQueueFamilyPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkQueueFamilyProperties* check_pQueueFamilyProperties;
    check_pQueueFamilyProperties = (VkQueueFamilyProperties*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyProperties)
    {
        if (!(check_pQueueFamilyProperties))
        {
            fprintf(stderr, "fatal: pQueueFamilyProperties inconsistent between guest and host\n");
        }
        if (pQueueFamilyPropertyCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
            {
                unmarshal_VkQueueFamilyProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
            }
        }
    }
    if (pQueueFamilyPropertyCount)
    {
        if (pQueueFamilyProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
            {
                transform_fromhost_VkQueueFamilyProperties(sResourceTracker, (VkQueueFamilyProperties*)(pQueueFamilyProperties + i));
            }
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties* pMemoryProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceMemoryProperties(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceMemoryProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceMemoryProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceMemoryProperties = OP_vkGetPhysicalDeviceMemoryProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceMemoryProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceMemoryProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceMemoryProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties), streamPtrPtr);
    unmarshal_VkPhysicalDeviceMemoryProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
    if (pMemoryProperties)
    {
        transform_fromhost_VkPhysicalDeviceMemoryProperties(sResourceTracker, (VkPhysicalDeviceMemoryProperties*)(pMemoryProperties));
    }
    sResourceTracker->on_vkGetPhysicalDeviceMemoryProperties(this, physicalDevice, pMemoryProperties);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

PFN_vkVoidFunction VkEncoder::vkGetInstanceProcAddr(
    VkInstance instance,
    const char* pName,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    char* local_pName;
    local_instance = instance;
    // Avoiding deepcopy for pName
    local_pName = (char*)pName;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t) + (local_pName ? strlen(local_pName) : 0);
    }
    uint32_t packetSize_vkGetInstanceProcAddr = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetInstanceProcAddr);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetInstanceProcAddr = OP_vkGetInstanceProcAddr;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetInstanceProcAddr, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetInstanceProcAddr, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    {
        uint32_t l = local_pName ? strlen(local_pName): 0;
        memcpy(*streamPtrPtr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*streamPtrPtr);
        *streamPtrPtr += sizeof(uint32_t);
        memcpy(*streamPtrPtr, (char*)local_pName, l);
        *streamPtrPtr += l;
    }
    PFN_vkVoidFunction vkGetInstanceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
    stream->read(&vkGetInstanceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetInstanceProcAddr_PFN_vkVoidFunction_return;
}

PFN_vkVoidFunction VkEncoder::vkGetDeviceProcAddr(
    VkDevice device,
    const char* pName,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    char* local_pName;
    local_device = device;
    // Avoiding deepcopy for pName
    local_pName = (char*)pName;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t) + (local_pName ? strlen(local_pName) : 0);
    }
    uint32_t packetSize_vkGetDeviceProcAddr = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceProcAddr);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceProcAddr = OP_vkGetDeviceProcAddr;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceProcAddr, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceProcAddr, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    {
        uint32_t l = local_pName ? strlen(local_pName): 0;
        memcpy(*streamPtrPtr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*streamPtrPtr);
        *streamPtrPtr += sizeof(uint32_t);
        memcpy(*streamPtrPtr, (char*)local_pName, l);
        *streamPtrPtr += l;
    }
    PFN_vkVoidFunction vkGetDeviceProcAddr_PFN_vkVoidFunction_return = (PFN_vkVoidFunction)0;
    stream->read(&vkGetDeviceProcAddr_PFN_vkVoidFunction_return, sizeof(PFN_vkVoidFunction));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDeviceProcAddr_PFN_vkVoidFunction_return;
}

VkResult VkEncoder::vkCreateDevice(
    VkPhysicalDevice physicalDevice,
    const VkDeviceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDevice* pDevice,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkDeviceCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_physicalDevice = physicalDevice;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDeviceCreateInfo*)pool->alloc(sizeof(const VkDeviceCreateInfo));
        deepcopy_VkDeviceCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkDeviceCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDeviceCreateInfo(sResourceTracker, (VkDeviceCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDeviceCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDevice = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDevice);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDevice = OP_vkCreateDevice;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDevice, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDevice, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDeviceCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkDevice(&cgen_var_3, (VkDevice*)pDevice, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDevice_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDevice_VkResult_return, sizeof(VkResult));
    sResourceTracker->on_vkCreateDevice(this, vkCreateDevice_VkResult_return, physicalDevice, pCreateInfo, pAllocator, pDevice);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDevice_VkResult_return;
}

void VkEncoder::vkDestroyDevice(
    VkDevice device,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    sResourceTracker->on_vkDestroyDevice_pre(this, device, pAllocator);
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyDevice = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyDevice);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyDevice = OP_vkDestroyDevice;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyDevice, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyDevice, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkDevice((VkDevice*)&device);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkEnumerateInstanceExtensionProperties(
    const char* pLayerName,
    uint32_t* pPropertyCount,
    VkExtensionProperties* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    char* local_pLayerName;
    // Avoiding deepcopy for pLayerName
    local_pLayerName = (char*)pLayerName;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        if (sFeatureBits & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
        {
            // WARNING PTR CHECK
            *countPtr += 8;
            if (local_pLayerName)
            {
                *countPtr += sizeof(uint32_t) + (local_pLayerName ? strlen(local_pLayerName) : 0);
            }
        }
        else
        {
            *countPtr += sizeof(uint32_t) + (local_pLayerName ? strlen(local_pLayerName) : 0);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            if (pPropertyCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                {
                    count_VkExtensionProperties(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExtensionProperties*)(pProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkEnumerateInstanceExtensionProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEnumerateInstanceExtensionProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEnumerateInstanceExtensionProperties = OP_vkEnumerateInstanceExtensionProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkEnumerateInstanceExtensionProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEnumerateInstanceExtensionProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    if (stream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_0 = (uint64_t)(uintptr_t)local_pLayerName;
        memcpy((*streamPtrPtr), &cgen_var_0, 8);
        android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
        *streamPtrPtr += 8;
        if (local_pLayerName)
        {
            {
                uint32_t l = local_pLayerName ? strlen(local_pLayerName): 0;
                memcpy(*streamPtrPtr, (uint32_t*)&l, sizeof(uint32_t));
                android::base::Stream::toBe32((uint8_t*)*streamPtrPtr);
                *streamPtrPtr += sizeof(uint32_t);
                memcpy(*streamPtrPtr, (char*)local_pLayerName, l);
                *streamPtrPtr += l;
            }
        }
    }
    else
    {
        {
            uint32_t l = local_pLayerName ? strlen(local_pLayerName): 0;
            memcpy(*streamPtrPtr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*streamPtrPtr);
            *streamPtrPtr += sizeof(uint32_t);
            memcpy(*streamPtrPtr, (char*)local_pLayerName, l);
            *streamPtrPtr += l;
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkExtensionProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExtensionProperties*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkExtensionProperties* check_pProperties;
    check_pProperties = (VkExtensionProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        if (pPropertyCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                unmarshal_VkExtensionProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExtensionProperties*)(pProperties + i));
            }
        }
    }
    if (pPropertyCount)
    {
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                transform_fromhost_VkExtensionProperties(sResourceTracker, (VkExtensionProperties*)(pProperties + i));
            }
        }
    }
    VkResult vkEnumerateInstanceExtensionProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateInstanceExtensionProperties_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEnumerateInstanceExtensionProperties_VkResult_return;
}

VkResult VkEncoder::vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice physicalDevice,
    const char* pLayerName,
    uint32_t* pPropertyCount,
    VkExtensionProperties* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    char* local_pLayerName;
    local_physicalDevice = physicalDevice;
    // Avoiding deepcopy for pLayerName
    local_pLayerName = (char*)pLayerName;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        if (sFeatureBits & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
        {
            // WARNING PTR CHECK
            *countPtr += 8;
            if (local_pLayerName)
            {
                *countPtr += sizeof(uint32_t) + (local_pLayerName ? strlen(local_pLayerName) : 0);
            }
        }
        else
        {
            *countPtr += sizeof(uint32_t) + (local_pLayerName ? strlen(local_pLayerName) : 0);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            if (pPropertyCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                {
                    count_VkExtensionProperties(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExtensionProperties*)(pProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkEnumerateDeviceExtensionProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEnumerateDeviceExtensionProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEnumerateDeviceExtensionProperties = OP_vkEnumerateDeviceExtensionProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkEnumerateDeviceExtensionProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEnumerateDeviceExtensionProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    if (stream->getFeatureBits() & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        uint64_t cgen_var_0_0 = (uint64_t)(uintptr_t)local_pLayerName;
        memcpy((*streamPtrPtr), &cgen_var_0_0, 8);
        android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
        *streamPtrPtr += 8;
        if (local_pLayerName)
        {
            {
                uint32_t l = local_pLayerName ? strlen(local_pLayerName): 0;
                memcpy(*streamPtrPtr, (uint32_t*)&l, sizeof(uint32_t));
                android::base::Stream::toBe32((uint8_t*)*streamPtrPtr);
                *streamPtrPtr += sizeof(uint32_t);
                memcpy(*streamPtrPtr, (char*)local_pLayerName, l);
                *streamPtrPtr += l;
            }
        }
    }
    else
    {
        {
            uint32_t l = local_pLayerName ? strlen(local_pLayerName): 0;
            memcpy(*streamPtrPtr, (uint32_t*)&l, sizeof(uint32_t));
            android::base::Stream::toBe32((uint8_t*)*streamPtrPtr);
            *streamPtrPtr += sizeof(uint32_t);
            memcpy(*streamPtrPtr, (char*)local_pLayerName, l);
            *streamPtrPtr += l;
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkExtensionProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExtensionProperties*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkExtensionProperties* check_pProperties;
    check_pProperties = (VkExtensionProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        if (pPropertyCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                unmarshal_VkExtensionProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExtensionProperties*)(pProperties + i));
            }
        }
    }
    if (pPropertyCount)
    {
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                transform_fromhost_VkExtensionProperties(sResourceTracker, (VkExtensionProperties*)(pProperties + i));
            }
        }
    }
    VkResult vkEnumerateDeviceExtensionProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateDeviceExtensionProperties_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEnumerateDeviceExtensionProperties_VkResult_return;
}

VkResult VkEncoder::vkEnumerateInstanceLayerProperties(
    uint32_t* pPropertyCount,
    VkLayerProperties* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    size_t count = 0;
    size_t* countPtr = &count;
    {
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            if (pPropertyCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                {
                    count_VkLayerProperties(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkLayerProperties*)(pProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkEnumerateInstanceLayerProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEnumerateInstanceLayerProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEnumerateInstanceLayerProperties = OP_vkEnumerateInstanceLayerProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkEnumerateInstanceLayerProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEnumerateInstanceLayerProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkLayerProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkLayerProperties*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkLayerProperties* check_pProperties;
    check_pProperties = (VkLayerProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        if (pPropertyCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                unmarshal_VkLayerProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkLayerProperties*)(pProperties + i));
            }
        }
    }
    if (pPropertyCount)
    {
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                transform_fromhost_VkLayerProperties(sResourceTracker, (VkLayerProperties*)(pProperties + i));
            }
        }
    }
    VkResult vkEnumerateInstanceLayerProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateInstanceLayerProperties_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEnumerateInstanceLayerProperties_VkResult_return;
}

VkResult VkEncoder::vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkLayerProperties* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            if (pPropertyCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                {
                    count_VkLayerProperties(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkLayerProperties*)(pProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkEnumerateDeviceLayerProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEnumerateDeviceLayerProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEnumerateDeviceLayerProperties = OP_vkEnumerateDeviceLayerProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkEnumerateDeviceLayerProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEnumerateDeviceLayerProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkLayerProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkLayerProperties*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkLayerProperties* check_pProperties;
    check_pProperties = (VkLayerProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        if (pPropertyCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                unmarshal_VkLayerProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkLayerProperties*)(pProperties + i));
            }
        }
    }
    if (pPropertyCount)
    {
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                transform_fromhost_VkLayerProperties(sResourceTracker, (VkLayerProperties*)(pProperties + i));
            }
        }
    }
    VkResult vkEnumerateDeviceLayerProperties_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateDeviceLayerProperties_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEnumerateDeviceLayerProperties_VkResult_return;
}

void VkEncoder::vkGetDeviceQueue(
    VkDevice device,
    uint32_t queueFamilyIndex,
    uint32_t queueIndex,
    VkQueue* pQueue,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_queueFamilyIndex;
    uint32_t local_queueIndex;
    local_device = device;
    local_queueFamilyIndex = queueFamilyIndex;
    local_queueIndex = queueIndex;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkGetDeviceQueue = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceQueue);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceQueue = OP_vkGetDeviceQueue;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceQueue, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceQueue, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_queueIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    /* is handle, possibly out */;
    uint64_t cgen_var_1;
    *&cgen_var_1 = (uint64_t)((*pQueue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_2;
    stream->read((uint64_t*)&cgen_var_2, 8);
    stream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_2, (VkQueue*)pQueue, 1);
    stream->unsetHandleMapping();
    sResourceTracker->on_vkGetDeviceQueue(this, device, queueFamilyIndex,
                                          queueIndex, pQueue);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkQueueSubmit(
    VkQueue queue,
    uint32_t submitCount,
    const VkSubmitInfo* pSubmits,
    VkFence fence,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    uint32_t local_submitCount;
    VkSubmitInfo* local_pSubmits;
    VkFence local_fence;
    local_queue = queue;
    local_submitCount = submitCount;
    local_pSubmits = nullptr;
    if (pSubmits)
    {
        local_pSubmits = (VkSubmitInfo*)pool->alloc(((submitCount)) * sizeof(const VkSubmitInfo));
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            deepcopy_VkSubmitInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pSubmits + i, (VkSubmitInfo*)(local_pSubmits + i));
        }
    }
    local_fence = fence;
    if (local_pSubmits)
    {
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            transform_tohost_VkSubmitInfo(sResourceTracker, (VkSubmitInfo*)(local_pSubmits + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            count_VkSubmitInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubmitInfo*)(local_pSubmits + i), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkQueueSubmit = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueSubmit);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueSubmit = OP_vkQueueSubmit;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueSubmit, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueSubmit, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_submitCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
    {
        reservedmarshal_VkSubmitInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubmitInfo*)(local_pSubmits + i), streamPtrPtr);
    }
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkFence((*&local_fence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkQueueSubmit_VkResult_return = (VkResult)0;
    stream->read(&vkQueueSubmit_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkQueueSubmit_VkResult_return;
}

VkResult VkEncoder::vkQueueWaitIdle(
    VkQueue queue,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    local_queue = queue;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkQueueWaitIdle = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueWaitIdle);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueWaitIdle = OP_vkQueueWaitIdle;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueWaitIdle, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueWaitIdle, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkQueueWaitIdle_VkResult_return = (VkResult)0;
    stream->read(&vkQueueWaitIdle_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkQueueWaitIdle_VkResult_return;
}

VkResult VkEncoder::vkDeviceWaitIdle(
    VkDevice device,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    local_device = device;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkDeviceWaitIdle = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDeviceWaitIdle);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDeviceWaitIdle = OP_vkDeviceWaitIdle;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDeviceWaitIdle, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDeviceWaitIdle, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkDeviceWaitIdle_VkResult_return = (VkResult)0;
    stream->read(&vkDeviceWaitIdle_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkDeviceWaitIdle_VkResult_return;
}

VkResult VkEncoder::vkAllocateMemory(
    VkDevice device,
    const VkMemoryAllocateInfo* pAllocateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDeviceMemory* pMemory,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkMemoryAllocateInfo* local_pAllocateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pAllocateInfo = nullptr;
    if (pAllocateInfo)
    {
        local_pAllocateInfo = (VkMemoryAllocateInfo*)pool->alloc(sizeof(const VkMemoryAllocateInfo));
        deepcopy_VkMemoryAllocateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocateInfo, (VkMemoryAllocateInfo*)(local_pAllocateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocateInfo)
    {
        transform_tohost_VkMemoryAllocateInfo(sResourceTracker, (VkMemoryAllocateInfo*)(local_pAllocateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkMemoryAllocateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryAllocateInfo*)(local_pAllocateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkAllocateMemory = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkAllocateMemory);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkAllocateMemory = OP_vkAllocateMemory;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkAllocateMemory, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkAllocateMemory, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkMemoryAllocateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryAllocateInfo*)(local_pAllocateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pMemory));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_3, (VkDeviceMemory*)pMemory, 1);
    stream->unsetHandleMapping();
    VkResult vkAllocateMemory_VkResult_return = (VkResult)0;
    stream->read(&vkAllocateMemory_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkAllocateMemory_VkResult_return;
}

void VkEncoder::vkFreeMemory(
    VkDevice device,
    VkDeviceMemory memory,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeviceMemory local_memory;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_memory = memory;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    sResourceTracker->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)nullptr, 0, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkFreeMemory = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkFreeMemory);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkFreeMemory = OP_vkFreeMemory;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkFreeMemory, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkFreeMemory, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDeviceMemory((*&local_memory));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkDeviceMemory((VkDeviceMemory*)&memory);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkMapMemory(
    VkDevice device,
    VkDeviceMemory memory,
    VkDeviceSize offset,
    VkDeviceSize size,
    VkMemoryMapFlags flags,
    void** ppData,
    uint32_t doLock)
{
    (void)doLock;
    VkResult vkMapMemory_VkResult_return = (VkResult)0;
    vkMapMemory_VkResult_return = sResourceTracker->on_vkMapMemory(this, VK_SUCCESS, device, memory, offset, size, flags, ppData);
    return vkMapMemory_VkResult_return;
}

void VkEncoder::vkUnmapMemory(
    VkDevice device,
    VkDeviceMemory memory,
    uint32_t doLock)
{
    (void)doLock;
    sResourceTracker->on_vkUnmapMemory(this, device, memory);
}

VkResult VkEncoder::vkFlushMappedMemoryRanges(
    VkDevice device,
    uint32_t memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    VALIDATE_RET(VkResult, VK_SUCCESS, mImpl->validation()->on_vkFlushMappedMemoryRanges(this, VK_SUCCESS, device, memoryRangeCount, pMemoryRanges));
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_memoryRangeCount;
    VkMappedMemoryRange* local_pMemoryRanges;
    local_device = device;
    local_memoryRangeCount = memoryRangeCount;
    local_pMemoryRanges = nullptr;
    if (pMemoryRanges)
    {
        local_pMemoryRanges = (VkMappedMemoryRange*)pool->alloc(((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            deepcopy_VkMappedMemoryRange(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pMemoryRanges + i, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    if (local_pMemoryRanges)
    {
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            transform_tohost_VkMappedMemoryRange(sResourceTracker, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            count_VkMappedMemoryRange(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMappedMemoryRange*)(local_pMemoryRanges + i), countPtr);
        }
    }
    uint32_t packetSize_vkFlushMappedMemoryRanges = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkFlushMappedMemoryRanges);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkFlushMappedMemoryRanges = OP_vkFlushMappedMemoryRanges;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkFlushMappedMemoryRanges, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkFlushMappedMemoryRanges, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_memoryRangeCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
    {
        reservedmarshal_VkMappedMemoryRange(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMappedMemoryRange*)(local_pMemoryRanges + i), streamPtrPtr);
    }
    if (!sResourceTracker->usingDirectMapping())
    {
        for (uint32_t i = 0; i < memoryRangeCount; ++i)
        {
            auto range = pMemoryRanges[i];
            auto memory = pMemoryRanges[i].memory;
            auto size = pMemoryRanges[i].size;
            auto offset = pMemoryRanges[i].offset;
            uint64_t streamSize = 0;
            if (!memory) { stream->write(&streamSize, sizeof(uint64_t)); continue; };
            auto hostPtr = sResourceTracker->getMappedPointer(memory);
            auto actualSize = size == VK_WHOLE_SIZE ? sResourceTracker->getMappedSize(memory) : size;
            if (!hostPtr) { stream->write(&streamSize, sizeof(uint64_t)); continue; };
            streamSize = actualSize;
            stream->write(&streamSize, sizeof(uint64_t));
            uint8_t* targetRange = hostPtr + offset;
            stream->write(targetRange, actualSize);
        }
    }
    VkResult vkFlushMappedMemoryRanges_VkResult_return = (VkResult)0;
    stream->read(&vkFlushMappedMemoryRanges_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkFlushMappedMemoryRanges_VkResult_return;
}

VkResult VkEncoder::vkInvalidateMappedMemoryRanges(
    VkDevice device,
    uint32_t memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    VALIDATE_RET(VkResult, VK_SUCCESS, mImpl->validation()->on_vkInvalidateMappedMemoryRanges(this, VK_SUCCESS, device, memoryRangeCount, pMemoryRanges));
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_memoryRangeCount;
    VkMappedMemoryRange* local_pMemoryRanges;
    local_device = device;
    local_memoryRangeCount = memoryRangeCount;
    local_pMemoryRanges = nullptr;
    if (pMemoryRanges)
    {
        local_pMemoryRanges = (VkMappedMemoryRange*)pool->alloc(((memoryRangeCount)) * sizeof(const VkMappedMemoryRange));
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            deepcopy_VkMappedMemoryRange(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pMemoryRanges + i, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    if (local_pMemoryRanges)
    {
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            transform_tohost_VkMappedMemoryRange(sResourceTracker, (VkMappedMemoryRange*)(local_pMemoryRanges + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
        {
            count_VkMappedMemoryRange(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMappedMemoryRange*)(local_pMemoryRanges + i), countPtr);
        }
    }
    uint32_t packetSize_vkInvalidateMappedMemoryRanges = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkInvalidateMappedMemoryRanges);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkInvalidateMappedMemoryRanges = OP_vkInvalidateMappedMemoryRanges;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkInvalidateMappedMemoryRanges, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkInvalidateMappedMemoryRanges, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_memoryRangeCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((memoryRangeCount)); ++i)
    {
        reservedmarshal_VkMappedMemoryRange(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMappedMemoryRange*)(local_pMemoryRanges + i), streamPtrPtr);
    }
    VkResult vkInvalidateMappedMemoryRanges_VkResult_return = (VkResult)0;
    stream->read(&vkInvalidateMappedMemoryRanges_VkResult_return, sizeof(VkResult));
    if (!sResourceTracker->usingDirectMapping())
    {
        for (uint32_t i = 0; i < memoryRangeCount; ++i)
        {
            auto range = pMemoryRanges[i];
            auto memory = pMemoryRanges[i].memory;
            auto size = pMemoryRanges[i].size;
            auto offset = pMemoryRanges[i].offset;
            uint64_t streamSize = 0;
            if (!memory) { stream->read(&streamSize, sizeof(uint64_t)); continue; };
            auto hostPtr = sResourceTracker->getMappedPointer(memory);
            auto actualSize = size == VK_WHOLE_SIZE ? sResourceTracker->getMappedSize(memory) : size;
            if (!hostPtr) { stream->read(&streamSize, sizeof(uint64_t)); continue; };
            streamSize = actualSize;
            stream->read(&streamSize, sizeof(uint64_t));
            uint8_t* targetRange = hostPtr + offset;
            stream->read(targetRange, actualSize);
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkInvalidateMappedMemoryRanges_VkResult_return;
}

void VkEncoder::vkGetDeviceMemoryCommitment(
    VkDevice device,
    VkDeviceMemory memory,
    VkDeviceSize* pCommittedMemoryInBytes,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeviceMemory local_memory;
    local_device = device;
    local_memory = memory;
    sResourceTracker->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)nullptr, 0, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
    }
    uint32_t packetSize_vkGetDeviceMemoryCommitment = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceMemoryCommitment);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceMemoryCommitment = OP_vkGetDeviceMemoryCommitment;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceMemoryCommitment, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceMemoryCommitment, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDeviceMemory((*&local_memory));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    stream->read((VkDeviceSize*)pCommittedMemoryInBytes, sizeof(VkDeviceSize));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkBindBufferMemory(
    VkDevice device,
    VkBuffer buffer,
    VkDeviceMemory memory,
    VkDeviceSize memoryOffset,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBuffer local_buffer;
    VkDeviceMemory local_memory;
    VkDeviceSize local_memoryOffset;
    local_device = device;
    local_buffer = buffer;
    local_memory = memory;
    local_memoryOffset = memoryOffset;
    sResourceTracker->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)&local_memoryOffset, 1, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
    }
    uint32_t packetSize_vkBindBufferMemory = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkBindBufferMemory);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkBindBufferMemory = OP_vkBindBufferMemory;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkBindBufferMemory, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkBindBufferMemory, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_2;
    *&cgen_var_2 = get_host_u64_VkDeviceMemory((*&local_memory));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_memoryOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    VkResult vkBindBufferMemory_VkResult_return = (VkResult)0;
    stream->read(&vkBindBufferMemory_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkBindBufferMemory_VkResult_return;
}

VkResult VkEncoder::vkBindImageMemory(
    VkDevice device,
    VkImage image,
    VkDeviceMemory memory,
    VkDeviceSize memoryOffset,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImage local_image;
    VkDeviceMemory local_memory;
    VkDeviceSize local_memoryOffset;
    local_device = device;
    local_image = image;
    local_memory = memory;
    local_memoryOffset = memoryOffset;
    sResourceTracker->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)&local_memoryOffset, 1, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
    }
    uint32_t packetSize_vkBindImageMemory = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkBindImageMemory);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkBindImageMemory = OP_vkBindImageMemory;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkBindImageMemory, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkBindImageMemory, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_2;
    *&cgen_var_2 = get_host_u64_VkDeviceMemory((*&local_memory));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_memoryOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    VkResult vkBindImageMemory_VkResult_return = (VkResult)0;
    stream->read(&vkBindImageMemory_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkBindImageMemory_VkResult_return;
}

void VkEncoder::vkGetBufferMemoryRequirements(
    VkDevice device,
    VkBuffer buffer,
    VkMemoryRequirements* pMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBuffer local_buffer;
    local_device = device;
    local_buffer = buffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        count_VkMemoryRequirements(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements), countPtr);
    }
    uint32_t packetSize_vkGetBufferMemoryRequirements = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetBufferMemoryRequirements);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetBufferMemoryRequirements = OP_vkGetBufferMemoryRequirements;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetBufferMemoryRequirements, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetBufferMemoryRequirements, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkMemoryRequirements(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements), streamPtrPtr);
    unmarshal_VkMemoryRequirements(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements(sResourceTracker, (VkMemoryRequirements*)(pMemoryRequirements));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetImageMemoryRequirements(
    VkDevice device,
    VkImage image,
    VkMemoryRequirements* pMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImage local_image;
    local_device = device;
    local_image = image;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        count_VkMemoryRequirements(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements), countPtr);
    }
    uint32_t packetSize_vkGetImageMemoryRequirements = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetImageMemoryRequirements);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetImageMemoryRequirements = OP_vkGetImageMemoryRequirements;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetImageMemoryRequirements, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetImageMemoryRequirements, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkMemoryRequirements(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements), streamPtrPtr);
    unmarshal_VkMemoryRequirements(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements(sResourceTracker, (VkMemoryRequirements*)(pMemoryRequirements));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetImageSparseMemoryRequirements(
    VkDevice device,
    VkImage image,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImage local_image;
    local_device = device;
    local_image = image;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSparseMemoryRequirementCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSparseMemoryRequirements)
        {
            if (pSparseMemoryRequirementCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                {
                    count_VkSparseImageMemoryRequirements(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetImageSparseMemoryRequirements = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetImageSparseMemoryRequirements);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetImageSparseMemoryRequirements = OP_vkGetImageSparseMemoryRequirements;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetImageSparseMemoryRequirements, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetImageSparseMemoryRequirements, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSparseMemoryRequirementCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
    memcpy((*streamPtrPtr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            reservedmarshal_VkSparseImageMemoryRequirements(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pSparseMemoryRequirementCount;
    check_pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirementCount)
    {
        if (!(check_pSparseMemoryRequirementCount))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirementCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageMemoryRequirements* check_pSparseMemoryRequirements;
    check_pSparseMemoryRequirements = (VkSparseImageMemoryRequirements*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirements)
    {
        if (!(check_pSparseMemoryRequirements))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirements inconsistent between guest and host\n");
        }
        if (pSparseMemoryRequirementCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
            {
                unmarshal_VkSparseImageMemoryRequirements(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
            }
        }
    }
    if (pSparseMemoryRequirementCount)
    {
        if (pSparseMemoryRequirements)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
            {
                transform_fromhost_VkSparseImageMemoryRequirements(sResourceTracker, (VkSparseImageMemoryRequirements*)(pSparseMemoryRequirements + i));
            }
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkSampleCountFlagBits samples,
    VkImageUsageFlags usage,
    VkImageTiling tiling,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    VkImageType local_type;
    VkSampleCountFlagBits local_samples;
    VkImageUsageFlags local_usage;
    VkImageTiling local_tiling;
    local_physicalDevice = physicalDevice;
    local_format = format;
    local_type = type;
    local_samples = samples;
    local_usage = usage;
    local_tiling = tiling;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkFormat);
        *countPtr += sizeof(VkImageType);
        *countPtr += sizeof(VkSampleCountFlagBits);
        *countPtr += sizeof(VkImageUsageFlags);
        *countPtr += sizeof(VkImageTiling);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            if (pPropertyCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                {
                    count_VkSparseImageFormatProperties(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageFormatProperties*)(pProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSparseImageFormatProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSparseImageFormatProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSparseImageFormatProperties = OP_vkGetPhysicalDeviceSparseImageFormatProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSparseImageFormatProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSparseImageFormatProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkFormat*)&local_format, sizeof(VkFormat));
    *streamPtrPtr += sizeof(VkFormat);
    memcpy(*streamPtrPtr, (VkImageType*)&local_type, sizeof(VkImageType));
    *streamPtrPtr += sizeof(VkImageType);
    memcpy(*streamPtrPtr, (VkSampleCountFlagBits*)&local_samples, sizeof(VkSampleCountFlagBits));
    *streamPtrPtr += sizeof(VkSampleCountFlagBits);
    memcpy(*streamPtrPtr, (VkImageUsageFlags*)&local_usage, sizeof(VkImageUsageFlags));
    *streamPtrPtr += sizeof(VkImageUsageFlags);
    memcpy(*streamPtrPtr, (VkImageTiling*)&local_tiling, sizeof(VkImageTiling));
    *streamPtrPtr += sizeof(VkImageTiling);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkSparseImageFormatProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageFormatProperties*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageFormatProperties* check_pProperties;
    check_pProperties = (VkSparseImageFormatProperties*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        if (pPropertyCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                unmarshal_VkSparseImageFormatProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageFormatProperties*)(pProperties + i));
            }
        }
    }
    if (pPropertyCount)
    {
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                transform_fromhost_VkSparseImageFormatProperties(sResourceTracker, (VkSparseImageFormatProperties*)(pProperties + i));
            }
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkQueueBindSparse(
    VkQueue queue,
    uint32_t bindInfoCount,
    const VkBindSparseInfo* pBindInfo,
    VkFence fence,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    uint32_t local_bindInfoCount;
    VkBindSparseInfo* local_pBindInfo;
    VkFence local_fence;
    local_queue = queue;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfo = nullptr;
    if (pBindInfo)
    {
        local_pBindInfo = (VkBindSparseInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindSparseInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindSparseInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pBindInfo + i, (VkBindSparseInfo*)(local_pBindInfo + i));
        }
    }
    local_fence = fence;
    if (local_pBindInfo)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindSparseInfo(sResourceTracker, (VkBindSparseInfo*)(local_pBindInfo + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            count_VkBindSparseInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindSparseInfo*)(local_pBindInfo + i), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkQueueBindSparse = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueBindSparse);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueBindSparse = OP_vkQueueBindSparse;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueBindSparse, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueBindSparse, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        reservedmarshal_VkBindSparseInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindSparseInfo*)(local_pBindInfo + i), streamPtrPtr);
    }
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkFence((*&local_fence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkQueueBindSparse_VkResult_return = (VkResult)0;
    stream->read(&vkQueueBindSparse_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkQueueBindSparse_VkResult_return;
}

VkResult VkEncoder::vkCreateFence(
    VkDevice device,
    const VkFenceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkFenceCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkFenceCreateInfo*)pool->alloc(sizeof(const VkFenceCreateInfo));
        deepcopy_VkFenceCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkFenceCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkFenceCreateInfo(sResourceTracker, (VkFenceCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkFenceCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFenceCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateFence = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateFence);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateFence = OP_vkCreateFence;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateFence, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateFence, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkFenceCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFenceCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pFence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_3, (VkFence*)pFence, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateFence_VkResult_return = (VkResult)0;
    stream->read(&vkCreateFence_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateFence_VkResult_return;
}

void VkEncoder::vkDestroyFence(
    VkDevice device,
    VkFence fence,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkFence local_fence;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_fence = fence;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyFence = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyFence);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyFence = OP_vkDestroyFence;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyFence, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyFence, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkFence((*&local_fence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkFence((VkFence*)&fence);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkResetFences(
    VkDevice device,
    uint32_t fenceCount,
    const VkFence* pFences,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_fenceCount;
    VkFence* local_pFences;
    local_device = device;
    local_fenceCount = fenceCount;
    // Avoiding deepcopy for pFences
    local_pFences = (VkFence*)pFences;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        if (((fenceCount)))
        {
            *countPtr += ((fenceCount)) * 8;
        }
    }
    uint32_t packetSize_vkResetFences = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkResetFences);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkResetFences = OP_vkResetFences;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkResetFences, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkResetFences, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_fenceCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((fenceCount)))
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((fenceCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkFence(local_pFences[k]);
            memcpy(cgen_var_1_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((fenceCount));
    }
    VkResult vkResetFences_VkResult_return = (VkResult)0;
    stream->read(&vkResetFences_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkResetFences_VkResult_return;
}

VkResult VkEncoder::vkGetFenceStatus(
    VkDevice device,
    VkFence fence,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkFence local_fence;
    local_device = device;
    local_fence = fence;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkGetFenceStatus = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetFenceStatus);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetFenceStatus = OP_vkGetFenceStatus;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetFenceStatus, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetFenceStatus, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkFence((*&local_fence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkGetFenceStatus_VkResult_return = (VkResult)0;
    stream->read(&vkGetFenceStatus_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetFenceStatus_VkResult_return;
}

VkResult VkEncoder::vkWaitForFences(
    VkDevice device,
    uint32_t fenceCount,
    const VkFence* pFences,
    VkBool32 waitAll,
    uint64_t timeout,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_fenceCount;
    VkFence* local_pFences;
    VkBool32 local_waitAll;
    uint64_t local_timeout;
    local_device = device;
    local_fenceCount = fenceCount;
    // Avoiding deepcopy for pFences
    local_pFences = (VkFence*)pFences;
    local_waitAll = waitAll;
    local_timeout = timeout;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        if (((fenceCount)))
        {
            *countPtr += ((fenceCount)) * 8;
        }
        *countPtr += sizeof(VkBool32);
        *countPtr += sizeof(uint64_t);
    }
    uint32_t packetSize_vkWaitForFences = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkWaitForFences);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkWaitForFences = OP_vkWaitForFences;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkWaitForFences, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkWaitForFences, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_fenceCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((fenceCount)))
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((fenceCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkFence(local_pFences[k]);
            memcpy(cgen_var_1_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((fenceCount));
    }
    memcpy(*streamPtrPtr, (VkBool32*)&local_waitAll, sizeof(VkBool32));
    *streamPtrPtr += sizeof(VkBool32);
    memcpy(*streamPtrPtr, (uint64_t*)&local_timeout, sizeof(uint64_t));
    *streamPtrPtr += sizeof(uint64_t);
    VkResult vkWaitForFences_VkResult_return = (VkResult)0;
    stream->read(&vkWaitForFences_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkWaitForFences_VkResult_return;
}

VkResult VkEncoder::vkCreateSemaphore(
    VkDevice device,
    const VkSemaphoreCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSemaphore* pSemaphore,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSemaphoreCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSemaphoreCreateInfo*)pool->alloc(sizeof(const VkSemaphoreCreateInfo));
        deepcopy_VkSemaphoreCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkSemaphoreCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSemaphoreCreateInfo(sResourceTracker, (VkSemaphoreCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkSemaphoreCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateSemaphore = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateSemaphore);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateSemaphore = OP_vkCreateSemaphore;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateSemaphore, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateSemaphore, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSemaphoreCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pSemaphore));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_3, (VkSemaphore*)pSemaphore, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateSemaphore_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSemaphore_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateSemaphore_VkResult_return;
}

void VkEncoder::vkDestroySemaphore(
    VkDevice device,
    VkSemaphore semaphore,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSemaphore local_semaphore;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_semaphore = semaphore;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroySemaphore = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroySemaphore);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroySemaphore = OP_vkDestroySemaphore;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroySemaphore, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroySemaphore, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSemaphore((*&local_semaphore));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkSemaphore((VkSemaphore*)&semaphore);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateEvent(
    VkDevice device,
    const VkEventCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkEvent* pEvent,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkEventCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkEventCreateInfo*)pool->alloc(sizeof(const VkEventCreateInfo));
        deepcopy_VkEventCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkEventCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkEventCreateInfo(sResourceTracker, (VkEventCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkEventCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkEventCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateEvent = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateEvent);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateEvent = OP_vkCreateEvent;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkEventCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkEventCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pEvent));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkEvent(&cgen_var_3, (VkEvent*)pEvent, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateEvent_VkResult_return = (VkResult)0;
    stream->read(&vkCreateEvent_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateEvent_VkResult_return;
}

void VkEncoder::vkDestroyEvent(
    VkDevice device,
    VkEvent event,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkEvent local_event;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_event = event;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyEvent = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyEvent);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyEvent = OP_vkDestroyEvent;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkEvent((*&local_event));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkEvent((VkEvent*)&event);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkGetEventStatus(
    VkDevice device,
    VkEvent event,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkEvent local_event;
    local_device = device;
    local_event = event;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkGetEventStatus = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetEventStatus);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetEventStatus = OP_vkGetEventStatus;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetEventStatus, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetEventStatus, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkEvent((*&local_event));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkGetEventStatus_VkResult_return = (VkResult)0;
    stream->read(&vkGetEventStatus_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetEventStatus_VkResult_return;
}

VkResult VkEncoder::vkSetEvent(
    VkDevice device,
    VkEvent event,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkEvent local_event;
    local_device = device;
    local_event = event;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkSetEvent = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkSetEvent);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkSetEvent = OP_vkSetEvent;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkSetEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkSetEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkEvent((*&local_event));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkSetEvent_VkResult_return = (VkResult)0;
    stream->read(&vkSetEvent_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkSetEvent_VkResult_return;
}

VkResult VkEncoder::vkResetEvent(
    VkDevice device,
    VkEvent event,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkEvent local_event;
    local_device = device;
    local_event = event;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkResetEvent = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkResetEvent);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkResetEvent = OP_vkResetEvent;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkResetEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkResetEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkEvent((*&local_event));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkResetEvent_VkResult_return = (VkResult)0;
    stream->read(&vkResetEvent_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkResetEvent_VkResult_return;
}

VkResult VkEncoder::vkCreateQueryPool(
    VkDevice device,
    const VkQueryPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkQueryPool* pQueryPool,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkQueryPoolCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkQueryPoolCreateInfo*)pool->alloc(sizeof(const VkQueryPoolCreateInfo));
        deepcopy_VkQueryPoolCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkQueryPoolCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkQueryPoolCreateInfo(sResourceTracker, (VkQueryPoolCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkQueryPoolCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueryPoolCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateQueryPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateQueryPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateQueryPool = OP_vkCreateQueryPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateQueryPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateQueryPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkQueryPoolCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueryPoolCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pQueryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkQueryPool(&cgen_var_3, (VkQueryPool*)pQueryPool, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateQueryPool_VkResult_return = (VkResult)0;
    stream->read(&vkCreateQueryPool_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateQueryPool_VkResult_return;
}

void VkEncoder::vkDestroyQueryPool(
    VkDevice device,
    VkQueryPool queryPool,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkQueryPool local_queryPool;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_queryPool = queryPool;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyQueryPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyQueryPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyQueryPool = OP_vkDestroyQueryPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyQueryPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyQueryPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkQueryPool((VkQueryPool*)&queryPool);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkGetQueryPoolResults(
    VkDevice device,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    size_t dataSize,
    void* pData,
    VkDeviceSize stride,
    VkQueryResultFlags flags,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkQueryPool local_queryPool;
    uint32_t local_firstQuery;
    uint32_t local_queryCount;
    size_t local_dataSize;
    VkDeviceSize local_stride;
    VkQueryResultFlags local_flags;
    local_device = device;
    local_queryPool = queryPool;
    local_firstQuery = firstQuery;
    local_queryCount = queryCount;
    local_dataSize = dataSize;
    local_stride = stride;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += 8;
        *countPtr += ((dataSize)) * sizeof(uint8_t);
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(VkQueryResultFlags);
    }
    uint32_t packetSize_vkGetQueryPoolResults = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetQueryPoolResults);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetQueryPoolResults = OP_vkGetQueryPoolResults;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetQueryPoolResults, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetQueryPoolResults, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstQuery, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_queryCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    uint64_t cgen_var_2 = (uint64_t)local_dataSize;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    memcpy(*streamPtrPtr, (void*)pData, ((dataSize)) * sizeof(uint8_t));
    *streamPtrPtr += ((dataSize)) * sizeof(uint8_t);
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_stride, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (VkQueryResultFlags*)&local_flags, sizeof(VkQueryResultFlags));
    *streamPtrPtr += sizeof(VkQueryResultFlags);
    stream->read((void*)pData, ((dataSize)) * sizeof(uint8_t));
    VkResult vkGetQueryPoolResults_VkResult_return = (VkResult)0;
    stream->read(&vkGetQueryPoolResults_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetQueryPoolResults_VkResult_return;
}

VkResult VkEncoder::vkCreateBuffer(
    VkDevice device,
    const VkBufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBufferCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkBufferCreateInfo*)pool->alloc(sizeof(const VkBufferCreateInfo));
        deepcopy_VkBufferCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkBufferCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkBufferCreateInfo(sResourceTracker, (VkBufferCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkBufferCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateBuffer = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateBuffer = OP_vkCreateBuffer;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkBufferCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_3, (VkBuffer*)pBuffer, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkCreateBuffer_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateBuffer_VkResult_return;
}

void VkEncoder::vkDestroyBuffer(
    VkDevice device,
    VkBuffer buffer,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBuffer local_buffer;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_buffer = buffer;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyBuffer = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyBuffer = OP_vkDestroyBuffer;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkBuffer((VkBuffer*)&buffer);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateBufferView(
    VkDevice device,
    const VkBufferViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBufferView* pView,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBufferViewCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkBufferViewCreateInfo*)pool->alloc(sizeof(const VkBufferViewCreateInfo));
        deepcopy_VkBufferViewCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkBufferViewCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkBufferViewCreateInfo(sResourceTracker, (VkBufferViewCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkBufferViewCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferViewCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateBufferView = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateBufferView);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateBufferView = OP_vkCreateBufferView;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateBufferView, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateBufferView, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkBufferViewCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferViewCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pView));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkBufferView(&cgen_var_3, (VkBufferView*)pView, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateBufferView_VkResult_return = (VkResult)0;
    stream->read(&vkCreateBufferView_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateBufferView_VkResult_return;
}

void VkEncoder::vkDestroyBufferView(
    VkDevice device,
    VkBufferView bufferView,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBufferView local_bufferView;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_bufferView = bufferView;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyBufferView = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyBufferView);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyBufferView = OP_vkDestroyBufferView;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyBufferView, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyBufferView, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBufferView((*&local_bufferView));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkBufferView((VkBufferView*)&bufferView);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateImage(
    VkDevice device,
    const VkImageCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage* pImage,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImageCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkImageCreateInfo*)pool->alloc(sizeof(const VkImageCreateInfo));
        deepcopy_VkImageCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkImageCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    sResourceTracker->unwrap_VkNativeBufferANDROID(pCreateInfo, local_pCreateInfo);
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkImageCreateInfo(sResourceTracker, (VkImageCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkImageCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateImage = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateImage);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateImage = OP_vkCreateImage;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_3, (VkImage*)pImage, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateImage_VkResult_return = (VkResult)0;
    stream->read(&vkCreateImage_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateImage_VkResult_return;
}

void VkEncoder::vkDestroyImage(
    VkDevice device,
    VkImage image,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImage local_image;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_image = image;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyImage = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyImage);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyImage = OP_vkDestroyImage;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkImage((VkImage*)&image);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetImageSubresourceLayout(
    VkDevice device,
    VkImage image,
    const VkImageSubresource* pSubresource,
    VkSubresourceLayout* pLayout,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImage local_image;
    VkImageSubresource* local_pSubresource;
    local_device = device;
    local_image = image;
    local_pSubresource = nullptr;
    if (pSubresource)
    {
        local_pSubresource = (VkImageSubresource*)pool->alloc(sizeof(const VkImageSubresource));
        deepcopy_VkImageSubresource(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pSubresource, (VkImageSubresource*)(local_pSubresource));
    }
    if (local_pSubresource)
    {
        transform_tohost_VkImageSubresource(sResourceTracker, (VkImageSubresource*)(local_pSubresource));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        count_VkImageSubresource(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageSubresource*)(local_pSubresource), countPtr);
        count_VkSubresourceLayout(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubresourceLayout*)(pLayout), countPtr);
    }
    uint32_t packetSize_vkGetImageSubresourceLayout = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetImageSubresourceLayout);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetImageSubresourceLayout = OP_vkGetImageSubresourceLayout;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetImageSubresourceLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetImageSubresourceLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageSubresource(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageSubresource*)(local_pSubresource), streamPtrPtr);
    reservedmarshal_VkSubresourceLayout(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubresourceLayout*)(pLayout), streamPtrPtr);
    unmarshal_VkSubresourceLayout(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubresourceLayout*)(pLayout));
    if (pLayout)
    {
        transform_fromhost_VkSubresourceLayout(sResourceTracker, (VkSubresourceLayout*)(pLayout));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateImageView(
    VkDevice device,
    const VkImageViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImageView* pView,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImageViewCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkImageViewCreateInfo*)pool->alloc(sizeof(const VkImageViewCreateInfo));
        deepcopy_VkImageViewCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkImageViewCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkImageViewCreateInfo(sResourceTracker, (VkImageViewCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkImageViewCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageViewCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateImageView = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateImageView);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateImageView = OP_vkCreateImageView;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateImageView, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateImageView, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageViewCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageViewCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pView));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkImageView(&cgen_var_3, (VkImageView*)pView, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateImageView_VkResult_return = (VkResult)0;
    stream->read(&vkCreateImageView_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateImageView_VkResult_return;
}

void VkEncoder::vkDestroyImageView(
    VkDevice device,
    VkImageView imageView,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImageView local_imageView;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_imageView = imageView;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyImageView = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyImageView);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyImageView = OP_vkDestroyImageView;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyImageView, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyImageView, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImageView((*&local_imageView));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkImageView((VkImageView*)&imageView);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateShaderModule(
    VkDevice device,
    const VkShaderModuleCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkShaderModule* pShaderModule,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkShaderModuleCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkShaderModuleCreateInfo*)pool->alloc(sizeof(const VkShaderModuleCreateInfo));
        deepcopy_VkShaderModuleCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkShaderModuleCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkShaderModuleCreateInfo(sResourceTracker, (VkShaderModuleCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkShaderModuleCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkShaderModuleCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateShaderModule = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateShaderModule);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateShaderModule = OP_vkCreateShaderModule;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateShaderModule, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateShaderModule, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkShaderModuleCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkShaderModuleCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pShaderModule));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkShaderModule(&cgen_var_3, (VkShaderModule*)pShaderModule, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateShaderModule_VkResult_return = (VkResult)0;
    stream->read(&vkCreateShaderModule_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateShaderModule_VkResult_return;
}

void VkEncoder::vkDestroyShaderModule(
    VkDevice device,
    VkShaderModule shaderModule,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkShaderModule local_shaderModule;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_shaderModule = shaderModule;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyShaderModule = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyShaderModule);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyShaderModule = OP_vkDestroyShaderModule;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyShaderModule, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyShaderModule, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkShaderModule((*&local_shaderModule));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkShaderModule((VkShaderModule*)&shaderModule);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreatePipelineCache(
    VkDevice device,
    const VkPipelineCacheCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPipelineCache* pPipelineCache,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineCacheCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkPipelineCacheCreateInfo*)pool->alloc(sizeof(const VkPipelineCacheCreateInfo));
        deepcopy_VkPipelineCacheCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkPipelineCacheCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkPipelineCacheCreateInfo(sResourceTracker, (VkPipelineCacheCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPipelineCacheCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineCacheCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreatePipelineCache = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreatePipelineCache);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreatePipelineCache = OP_vkCreatePipelineCache;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreatePipelineCache, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreatePipelineCache, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPipelineCacheCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineCacheCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pPipelineCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkPipelineCache(&cgen_var_3, (VkPipelineCache*)pPipelineCache, 1);
    stream->unsetHandleMapping();
    VkResult vkCreatePipelineCache_VkResult_return = (VkResult)0;
    stream->read(&vkCreatePipelineCache_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreatePipelineCache_VkResult_return;
}

void VkEncoder::vkDestroyPipelineCache(
    VkDevice device,
    VkPipelineCache pipelineCache,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineCache local_pipelineCache;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipelineCache = pipelineCache;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyPipelineCache = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyPipelineCache);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyPipelineCache = OP_vkDestroyPipelineCache;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyPipelineCache, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyPipelineCache, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkPipelineCache((*&local_pipelineCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkPipelineCache((VkPipelineCache*)&pipelineCache);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkGetPipelineCacheData(
    VkDevice device,
    VkPipelineCache pipelineCache,
    size_t* pDataSize,
    void* pData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineCache local_pipelineCache;
    local_device = device;
    local_pipelineCache = pipelineCache;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pDataSize)
        {
            *countPtr += 8;
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pData)
        {
            if (pDataSize)
            {
                *countPtr += (*(pDataSize)) * sizeof(uint8_t);
            }
        }
    }
    uint32_t packetSize_vkGetPipelineCacheData = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPipelineCacheData);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPipelineCacheData = OP_vkGetPipelineCacheData;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPipelineCacheData, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPipelineCacheData, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkPipelineCache((*&local_pipelineCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pDataSize;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pDataSize)
    {
        uint64_t cgen_var_2_0 = (uint64_t)(*pDataSize);
        memcpy((*streamPtrPtr), &cgen_var_2_0, 8);
        android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
        *streamPtrPtr += 8;
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pData;
    memcpy((*streamPtrPtr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pData)
    {
        memcpy(*streamPtrPtr, (void*)pData, (*(pDataSize)) * sizeof(uint8_t));
        *streamPtrPtr += (*(pDataSize)) * sizeof(uint8_t);
    }
    // WARNING PTR CHECK
    size_t* check_pDataSize;
    check_pDataSize = (size_t*)(uintptr_t)stream->getBe64();
    if (pDataSize)
    {
        if (!(check_pDataSize))
        {
            fprintf(stderr, "fatal: pDataSize inconsistent between guest and host\n");
        }
        (*pDataSize) = (size_t)stream->getBe64();
    }
    // WARNING PTR CHECK
    void* check_pData;
    check_pData = (void*)(uintptr_t)stream->getBe64();
    if (pData)
    {
        if (!(check_pData))
        {
            fprintf(stderr, "fatal: pData inconsistent between guest and host\n");
        }
        stream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    }
    VkResult vkGetPipelineCacheData_VkResult_return = (VkResult)0;
    stream->read(&vkGetPipelineCacheData_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPipelineCacheData_VkResult_return;
}

VkResult VkEncoder::vkMergePipelineCaches(
    VkDevice device,
    VkPipelineCache dstCache,
    uint32_t srcCacheCount,
    const VkPipelineCache* pSrcCaches,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineCache local_dstCache;
    uint32_t local_srcCacheCount;
    VkPipelineCache* local_pSrcCaches;
    local_device = device;
    local_dstCache = dstCache;
    local_srcCacheCount = srcCacheCount;
    // Avoiding deepcopy for pSrcCaches
    local_pSrcCaches = (VkPipelineCache*)pSrcCaches;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        if (((srcCacheCount)))
        {
            *countPtr += ((srcCacheCount)) * 8;
        }
    }
    uint32_t packetSize_vkMergePipelineCaches = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkMergePipelineCaches);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkMergePipelineCaches = OP_vkMergePipelineCaches;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkMergePipelineCaches, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkMergePipelineCaches, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkPipelineCache((*&local_dstCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_srcCacheCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((srcCacheCount)))
    {
        uint8_t* cgen_var_2_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((srcCacheCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkPipelineCache(local_pSrcCaches[k]);
            memcpy(cgen_var_2_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((srcCacheCount));
    }
    VkResult vkMergePipelineCaches_VkResult_return = (VkResult)0;
    stream->read(&vkMergePipelineCaches_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkMergePipelineCaches_VkResult_return;
}

VkResult VkEncoder::vkCreateGraphicsPipelines(
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkGraphicsPipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineCache local_pipelineCache;
    uint32_t local_createInfoCount;
    VkGraphicsPipelineCreateInfo* local_pCreateInfos;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipelineCache = pipelineCache;
    local_createInfoCount = createInfoCount;
    local_pCreateInfos = nullptr;
    if (pCreateInfos)
    {
        local_pCreateInfos = (VkGraphicsPipelineCreateInfo*)pool->alloc(((createInfoCount)) * sizeof(const VkGraphicsPipelineCreateInfo));
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            deepcopy_VkGraphicsPipelineCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfos + i, (VkGraphicsPipelineCreateInfo*)(local_pCreateInfos + i));
        }
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            transform_tohost_VkGraphicsPipelineCreateInfo(sResourceTracker, (VkGraphicsPipelineCreateInfo*)(local_pCreateInfos + i));
        }
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            count_VkGraphicsPipelineCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkGraphicsPipelineCreateInfo*)(local_pCreateInfos + i), countPtr);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        if (((createInfoCount)))
        {
            *countPtr += ((createInfoCount)) * 8;
        }
    }
    uint32_t packetSize_vkCreateGraphicsPipelines = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateGraphicsPipelines);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateGraphicsPipelines = OP_vkCreateGraphicsPipelines;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateGraphicsPipelines, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateGraphicsPipelines, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkPipelineCache((*&local_pipelineCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_createInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
    {
        reservedmarshal_VkGraphicsPipelineCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkGraphicsPipelineCreateInfo*)(local_pCreateInfos + i), streamPtrPtr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    if (((createInfoCount)))
    {
        uint8_t* cgen_var_3_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((createInfoCount)); ++k)
        {
            uint64_t tmpval = (uint64_t)(pPipelines[k]);
            memcpy(cgen_var_3_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((createInfoCount));
    }
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    if (((createInfoCount)))
    {
        uint64_t* cgen_var_4;
        stream->alloc((void**)&cgen_var_4, ((createInfoCount)) * 8);
        stream->read((uint64_t*)cgen_var_4, ((createInfoCount)) * 8);
        stream->handleMapping()->mapHandles_u64_VkPipeline(cgen_var_4, (VkPipeline*)pPipelines, ((createInfoCount)));
    }
    stream->unsetHandleMapping();
    VkResult vkCreateGraphicsPipelines_VkResult_return = (VkResult)0;
    stream->read(&vkCreateGraphicsPipelines_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateGraphicsPipelines_VkResult_return;
}

VkResult VkEncoder::vkCreateComputePipelines(
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkComputePipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineCache local_pipelineCache;
    uint32_t local_createInfoCount;
    VkComputePipelineCreateInfo* local_pCreateInfos;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipelineCache = pipelineCache;
    local_createInfoCount = createInfoCount;
    local_pCreateInfos = nullptr;
    if (pCreateInfos)
    {
        local_pCreateInfos = (VkComputePipelineCreateInfo*)pool->alloc(((createInfoCount)) * sizeof(const VkComputePipelineCreateInfo));
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            deepcopy_VkComputePipelineCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfos + i, (VkComputePipelineCreateInfo*)(local_pCreateInfos + i));
        }
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            transform_tohost_VkComputePipelineCreateInfo(sResourceTracker, (VkComputePipelineCreateInfo*)(local_pCreateInfos + i));
        }
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            count_VkComputePipelineCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkComputePipelineCreateInfo*)(local_pCreateInfos + i), countPtr);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        if (((createInfoCount)))
        {
            *countPtr += ((createInfoCount)) * 8;
        }
    }
    uint32_t packetSize_vkCreateComputePipelines = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateComputePipelines);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateComputePipelines = OP_vkCreateComputePipelines;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateComputePipelines, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateComputePipelines, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkPipelineCache((*&local_pipelineCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_createInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
    {
        reservedmarshal_VkComputePipelineCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkComputePipelineCreateInfo*)(local_pCreateInfos + i), streamPtrPtr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    if (((createInfoCount)))
    {
        uint8_t* cgen_var_3_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((createInfoCount)); ++k)
        {
            uint64_t tmpval = (uint64_t)(pPipelines[k]);
            memcpy(cgen_var_3_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((createInfoCount));
    }
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    if (((createInfoCount)))
    {
        uint64_t* cgen_var_4;
        stream->alloc((void**)&cgen_var_4, ((createInfoCount)) * 8);
        stream->read((uint64_t*)cgen_var_4, ((createInfoCount)) * 8);
        stream->handleMapping()->mapHandles_u64_VkPipeline(cgen_var_4, (VkPipeline*)pPipelines, ((createInfoCount)));
    }
    stream->unsetHandleMapping();
    VkResult vkCreateComputePipelines_VkResult_return = (VkResult)0;
    stream->read(&vkCreateComputePipelines_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateComputePipelines_VkResult_return;
}

void VkEncoder::vkDestroyPipeline(
    VkDevice device,
    VkPipeline pipeline,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipeline local_pipeline;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipeline = pipeline;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyPipeline = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyPipeline);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyPipeline = OP_vkDestroyPipeline;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyPipeline, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyPipeline, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkPipeline((*&local_pipeline));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkPipeline((VkPipeline*)&pipeline);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreatePipelineLayout(
    VkDevice device,
    const VkPipelineLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPipelineLayout* pPipelineLayout,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineLayoutCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkPipelineLayoutCreateInfo*)pool->alloc(sizeof(const VkPipelineLayoutCreateInfo));
        deepcopy_VkPipelineLayoutCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkPipelineLayoutCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkPipelineLayoutCreateInfo(sResourceTracker, (VkPipelineLayoutCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPipelineLayoutCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineLayoutCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreatePipelineLayout = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreatePipelineLayout);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreatePipelineLayout = OP_vkCreatePipelineLayout;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreatePipelineLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreatePipelineLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPipelineLayoutCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineLayoutCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pPipelineLayout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_3, (VkPipelineLayout*)pPipelineLayout, 1);
    stream->unsetHandleMapping();
    VkResult vkCreatePipelineLayout_VkResult_return = (VkResult)0;
    stream->read(&vkCreatePipelineLayout_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreatePipelineLayout_VkResult_return;
}

void VkEncoder::vkDestroyPipelineLayout(
    VkDevice device,
    VkPipelineLayout pipelineLayout,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineLayout local_pipelineLayout;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipelineLayout = pipelineLayout;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyPipelineLayout = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyPipelineLayout);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyPipelineLayout = OP_vkDestroyPipelineLayout;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyPipelineLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyPipelineLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkPipelineLayout((*&local_pipelineLayout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkPipelineLayout((VkPipelineLayout*)&pipelineLayout);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateSampler(
    VkDevice device,
    const VkSamplerCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSampler* pSampler,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSamplerCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSamplerCreateInfo*)pool->alloc(sizeof(const VkSamplerCreateInfo));
        deepcopy_VkSamplerCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkSamplerCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSamplerCreateInfo(sResourceTracker, (VkSamplerCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkSamplerCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSamplerCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateSampler = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateSampler);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateSampler = OP_vkCreateSampler;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateSampler, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateSampler, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSamplerCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSamplerCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pSampler));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSampler(&cgen_var_3, (VkSampler*)pSampler, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateSampler_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSampler_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateSampler_VkResult_return;
}

void VkEncoder::vkDestroySampler(
    VkDevice device,
    VkSampler sampler,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSampler local_sampler;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_sampler = sampler;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroySampler = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroySampler);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroySampler = OP_vkDestroySampler;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroySampler, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroySampler, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSampler((*&local_sampler));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkSampler((VkSampler*)&sampler);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateDescriptorSetLayout(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorSetLayout* pSetLayout,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorSetLayoutCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorSetLayoutCreateInfo*)pool->alloc(sizeof(const VkDescriptorSetLayoutCreateInfo));
        deepcopy_VkDescriptorSetLayoutCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorSetLayoutCreateInfo(sResourceTracker, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDescriptorSetLayoutCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDescriptorSetLayout = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDescriptorSetLayout);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDescriptorSetLayout = OP_vkCreateDescriptorSetLayout;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDescriptorSetLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDescriptorSetLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDescriptorSetLayoutCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pSetLayout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkDescriptorSetLayout(&cgen_var_3, (VkDescriptorSetLayout*)pSetLayout, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDescriptorSetLayout_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorSetLayout_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDescriptorSetLayout_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorSetLayout(
    VkDevice device,
    VkDescriptorSetLayout descriptorSetLayout,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorSetLayout local_descriptorSetLayout;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_descriptorSetLayout = descriptorSetLayout;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyDescriptorSetLayout = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyDescriptorSetLayout);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyDescriptorSetLayout = OP_vkDestroyDescriptorSetLayout;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyDescriptorSetLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyDescriptorSetLayout, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDescriptorSetLayout((*&local_descriptorSetLayout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkDescriptorSetLayout((VkDescriptorSetLayout*)&descriptorSetLayout);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateDescriptorPool(
    VkDevice device,
    const VkDescriptorPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorPool* pDescriptorPool,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorPoolCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorPoolCreateInfo*)pool->alloc(sizeof(const VkDescriptorPoolCreateInfo));
        deepcopy_VkDescriptorPoolCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkDescriptorPoolCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorPoolCreateInfo(sResourceTracker, (VkDescriptorPoolCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDescriptorPoolCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorPoolCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDescriptorPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDescriptorPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDescriptorPool = OP_vkCreateDescriptorPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDescriptorPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDescriptorPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDescriptorPoolCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorPoolCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pDescriptorPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkDescriptorPool(&cgen_var_3, (VkDescriptorPool*)pDescriptorPool, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDescriptorPool_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorPool_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDescriptorPool_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorPool(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorPool local_descriptorPool;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_descriptorPool = descriptorPool;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyDescriptorPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyDescriptorPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyDescriptorPool = OP_vkDestroyDescriptorPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyDescriptorPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyDescriptorPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDescriptorPool((*&local_descriptorPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkDescriptorPool((VkDescriptorPool*)&descriptorPool);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkResetDescriptorPool(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    VkDescriptorPoolResetFlags flags,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorPool local_descriptorPool;
    VkDescriptorPoolResetFlags local_flags;
    local_device = device;
    local_descriptorPool = descriptorPool;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDescriptorPoolResetFlags);
    }
    uint32_t packetSize_vkResetDescriptorPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkResetDescriptorPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkResetDescriptorPool = OP_vkResetDescriptorPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkResetDescriptorPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkResetDescriptorPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDescriptorPool((*&local_descriptorPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDescriptorPoolResetFlags*)&local_flags, sizeof(VkDescriptorPoolResetFlags));
    *streamPtrPtr += sizeof(VkDescriptorPoolResetFlags);
    VkResult vkResetDescriptorPool_VkResult_return = (VkResult)0;
    stream->read(&vkResetDescriptorPool_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkResetDescriptorPool_VkResult_return;
}

VkResult VkEncoder::vkAllocateDescriptorSets(
    VkDevice device,
    const VkDescriptorSetAllocateInfo* pAllocateInfo,
    VkDescriptorSet* pDescriptorSets,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorSetAllocateInfo* local_pAllocateInfo;
    local_device = device;
    local_pAllocateInfo = nullptr;
    if (pAllocateInfo)
    {
        local_pAllocateInfo = (VkDescriptorSetAllocateInfo*)pool->alloc(sizeof(const VkDescriptorSetAllocateInfo));
        deepcopy_VkDescriptorSetAllocateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocateInfo, (VkDescriptorSetAllocateInfo*)(local_pAllocateInfo));
    }
    if (local_pAllocateInfo)
    {
        transform_tohost_VkDescriptorSetAllocateInfo(sResourceTracker, (VkDescriptorSetAllocateInfo*)(local_pAllocateInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDescriptorSetAllocateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetAllocateInfo*)(local_pAllocateInfo), countPtr);
        if (pAllocateInfo->descriptorSetCount)
        {
            *countPtr += pAllocateInfo->descriptorSetCount * 8;
        }
    }
    uint32_t packetSize_vkAllocateDescriptorSets = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkAllocateDescriptorSets);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkAllocateDescriptorSets = OP_vkAllocateDescriptorSets;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkAllocateDescriptorSets, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkAllocateDescriptorSets, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDescriptorSetAllocateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetAllocateInfo*)(local_pAllocateInfo), streamPtrPtr);
    /* is handle, possibly out */;
    if (pAllocateInfo->descriptorSetCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < pAllocateInfo->descriptorSetCount; ++k)
        {
            uint64_t tmpval = (uint64_t)(pDescriptorSets[k]);
            memcpy(cgen_var_1_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * pAllocateInfo->descriptorSetCount;
    }
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    if (pAllocateInfo->descriptorSetCount)
    {
        uint64_t* cgen_var_2;
        stream->alloc((void**)&cgen_var_2, pAllocateInfo->descriptorSetCount * 8);
        stream->read((uint64_t*)cgen_var_2, pAllocateInfo->descriptorSetCount * 8);
        stream->handleMapping()->mapHandles_u64_VkDescriptorSet(cgen_var_2, (VkDescriptorSet*)pDescriptorSets, pAllocateInfo->descriptorSetCount);
    }
    stream->unsetHandleMapping();
    VkResult vkAllocateDescriptorSets_VkResult_return = (VkResult)0;
    stream->read(&vkAllocateDescriptorSets_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkAllocateDescriptorSets_VkResult_return;
}

VkResult VkEncoder::vkFreeDescriptorSets(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    uint32_t descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorPool local_descriptorPool;
    uint32_t local_descriptorSetCount;
    VkDescriptorSet* local_pDescriptorSets;
    local_device = device;
    local_descriptorPool = descriptorPool;
    local_descriptorSetCount = descriptorSetCount;
    // Avoiding deepcopy for pDescriptorSets
    local_pDescriptorSets = (VkDescriptorSet*)pDescriptorSets;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pDescriptorSets)
        {
            if (((descriptorSetCount)))
            {
                *countPtr += ((descriptorSetCount)) * 8;
            }
        }
    }
    uint32_t packetSize_vkFreeDescriptorSets = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkFreeDescriptorSets);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkFreeDescriptorSets = OP_vkFreeDescriptorSets;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkFreeDescriptorSets, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkFreeDescriptorSets, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDescriptorPool((*&local_descriptorPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_descriptorSetCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pDescriptorSets;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pDescriptorSets)
    {
        if (((descriptorSetCount)))
        {
            uint8_t* cgen_var_2_0_ptr = (uint8_t*)(*streamPtrPtr);
            for (uint32_t k = 0; k < ((descriptorSetCount)); ++k)
            {
                uint64_t tmpval = get_host_u64_VkDescriptorSet(local_pDescriptorSets[k]);
                memcpy(cgen_var_2_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
            *streamPtrPtr += 8 * ((descriptorSetCount));
        }
    }
    VkResult vkFreeDescriptorSets_VkResult_return = (VkResult)0;
    stream->read(&vkFreeDescriptorSets_VkResult_return, sizeof(VkResult));
    if (pDescriptorSets)
    {
        sResourceTracker->destroyMapping()->mapHandles_VkDescriptorSet((VkDescriptorSet*)pDescriptorSets, ((descriptorSetCount)));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkFreeDescriptorSets_VkResult_return;
}

void VkEncoder::vkUpdateDescriptorSets(
    VkDevice device,
    uint32_t descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites,
    uint32_t descriptorCopyCount,
    const VkCopyDescriptorSet* pDescriptorCopies,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_descriptorWriteCount;
    VkWriteDescriptorSet* local_pDescriptorWrites;
    uint32_t local_descriptorCopyCount;
    VkCopyDescriptorSet* local_pDescriptorCopies;
    local_device = device;
    local_descriptorWriteCount = descriptorWriteCount;
    local_pDescriptorWrites = nullptr;
    if (pDescriptorWrites)
    {
        local_pDescriptorWrites = (VkWriteDescriptorSet*)pool->alloc(((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            deepcopy_VkWriteDescriptorSet(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pDescriptorWrites + i, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
    }
    local_descriptorCopyCount = descriptorCopyCount;
    local_pDescriptorCopies = nullptr;
    if (pDescriptorCopies)
    {
        local_pDescriptorCopies = (VkCopyDescriptorSet*)pool->alloc(((descriptorCopyCount)) * sizeof(const VkCopyDescriptorSet));
        for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
        {
            deepcopy_VkCopyDescriptorSet(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pDescriptorCopies + i, (VkCopyDescriptorSet*)(local_pDescriptorCopies + i));
        }
    }
    if (local_pDescriptorWrites)
    {
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            transform_tohost_VkWriteDescriptorSet(sResourceTracker, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
    }
    if (local_pDescriptorCopies)
    {
        for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
        {
            transform_tohost_VkCopyDescriptorSet(sResourceTracker, (VkCopyDescriptorSet*)(local_pDescriptorCopies + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            count_VkWriteDescriptorSet(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i), countPtr);
        }
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
        {
            count_VkCopyDescriptorSet(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyDescriptorSet*)(local_pDescriptorCopies + i), countPtr);
        }
    }
    uint32_t packetSize_vkUpdateDescriptorSets = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkUpdateDescriptorSets);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkUpdateDescriptorSets = OP_vkUpdateDescriptorSets;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkUpdateDescriptorSets, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkUpdateDescriptorSets, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_descriptorWriteCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
    {
        reservedmarshal_VkWriteDescriptorSet(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i), streamPtrPtr);
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_descriptorCopyCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((descriptorCopyCount)); ++i)
    {
        reservedmarshal_VkCopyDescriptorSet(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyDescriptorSet*)(local_pDescriptorCopies + i), streamPtrPtr);
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateFramebuffer(
    VkDevice device,
    const VkFramebufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFramebuffer* pFramebuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkFramebufferCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkFramebufferCreateInfo*)pool->alloc(sizeof(const VkFramebufferCreateInfo));
        deepcopy_VkFramebufferCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkFramebufferCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkFramebufferCreateInfo(sResourceTracker, (VkFramebufferCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkFramebufferCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFramebufferCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateFramebuffer = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateFramebuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateFramebuffer = OP_vkCreateFramebuffer;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateFramebuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateFramebuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkFramebufferCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFramebufferCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pFramebuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkFramebuffer(&cgen_var_3, (VkFramebuffer*)pFramebuffer, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateFramebuffer_VkResult_return = (VkResult)0;
    stream->read(&vkCreateFramebuffer_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateFramebuffer_VkResult_return;
}

void VkEncoder::vkDestroyFramebuffer(
    VkDevice device,
    VkFramebuffer framebuffer,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkFramebuffer local_framebuffer;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_framebuffer = framebuffer;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyFramebuffer = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyFramebuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyFramebuffer = OP_vkDestroyFramebuffer;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyFramebuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyFramebuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkFramebuffer((*&local_framebuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkFramebuffer((VkFramebuffer*)&framebuffer);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateRenderPass(
    VkDevice device,
    const VkRenderPassCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkRenderPassCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkRenderPassCreateInfo*)pool->alloc(sizeof(const VkRenderPassCreateInfo));
        deepcopy_VkRenderPassCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkRenderPassCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkRenderPassCreateInfo(sResourceTracker, (VkRenderPassCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkRenderPassCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRenderPassCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateRenderPass = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateRenderPass);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateRenderPass = OP_vkCreateRenderPass;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateRenderPass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateRenderPass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkRenderPassCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRenderPassCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pRenderPass));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_3, (VkRenderPass*)pRenderPass, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateRenderPass_VkResult_return = (VkResult)0;
    stream->read(&vkCreateRenderPass_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateRenderPass_VkResult_return;
}

void VkEncoder::vkDestroyRenderPass(
    VkDevice device,
    VkRenderPass renderPass,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkRenderPass local_renderPass;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_renderPass = renderPass;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyRenderPass = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyRenderPass);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyRenderPass = OP_vkDestroyRenderPass;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyRenderPass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyRenderPass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkRenderPass((*&local_renderPass));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkRenderPass((VkRenderPass*)&renderPass);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetRenderAreaGranularity(
    VkDevice device,
    VkRenderPass renderPass,
    VkExtent2D* pGranularity,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkRenderPass local_renderPass;
    local_device = device;
    local_renderPass = renderPass;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        count_VkExtent2D(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExtent2D*)(pGranularity), countPtr);
    }
    uint32_t packetSize_vkGetRenderAreaGranularity = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetRenderAreaGranularity);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetRenderAreaGranularity = OP_vkGetRenderAreaGranularity;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetRenderAreaGranularity, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetRenderAreaGranularity, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkRenderPass((*&local_renderPass));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkExtent2D(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExtent2D*)(pGranularity), streamPtrPtr);
    unmarshal_VkExtent2D(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExtent2D*)(pGranularity));
    if (pGranularity)
    {
        transform_fromhost_VkExtent2D(sResourceTracker, (VkExtent2D*)(pGranularity));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateCommandPool(
    VkDevice device,
    const VkCommandPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkCommandPool* pCommandPool,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkCommandPoolCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkCommandPoolCreateInfo*)pool->alloc(sizeof(const VkCommandPoolCreateInfo));
        deepcopy_VkCommandPoolCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkCommandPoolCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkCommandPoolCreateInfo(sResourceTracker, (VkCommandPoolCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkCommandPoolCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCommandPoolCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateCommandPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateCommandPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateCommandPool = OP_vkCreateCommandPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateCommandPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateCommandPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkCommandPoolCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCommandPoolCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pCommandPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_3, (VkCommandPool*)pCommandPool, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateCommandPool_VkResult_return = (VkResult)0;
    stream->read(&vkCreateCommandPool_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateCommandPool_VkResult_return;
}

void VkEncoder::vkDestroyCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkCommandPool local_commandPool;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_commandPool = commandPool;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyCommandPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyCommandPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyCommandPool = OP_vkDestroyCommandPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyCommandPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyCommandPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkCommandPool((*&local_commandPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkCommandPool((VkCommandPool*)&commandPool);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkResetCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolResetFlags flags,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkCommandPool local_commandPool;
    VkCommandPoolResetFlags local_flags;
    local_device = device;
    local_commandPool = commandPool;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkCommandPoolResetFlags);
    }
    uint32_t packetSize_vkResetCommandPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkResetCommandPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkResetCommandPool = OP_vkResetCommandPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkResetCommandPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkResetCommandPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkCommandPool((*&local_commandPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkCommandPoolResetFlags*)&local_flags, sizeof(VkCommandPoolResetFlags));
    *streamPtrPtr += sizeof(VkCommandPoolResetFlags);
    VkResult vkResetCommandPool_VkResult_return = (VkResult)0;
    stream->read(&vkResetCommandPool_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkResetCommandPool_VkResult_return;
}

VkResult VkEncoder::vkAllocateCommandBuffers(
    VkDevice device,
    const VkCommandBufferAllocateInfo* pAllocateInfo,
    VkCommandBuffer* pCommandBuffers,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkCommandBufferAllocateInfo* local_pAllocateInfo;
    local_device = device;
    local_pAllocateInfo = nullptr;
    if (pAllocateInfo)
    {
        local_pAllocateInfo = (VkCommandBufferAllocateInfo*)pool->alloc(sizeof(const VkCommandBufferAllocateInfo));
        deepcopy_VkCommandBufferAllocateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocateInfo, (VkCommandBufferAllocateInfo*)(local_pAllocateInfo));
    }
    if (local_pAllocateInfo)
    {
        transform_tohost_VkCommandBufferAllocateInfo(sResourceTracker, (VkCommandBufferAllocateInfo*)(local_pAllocateInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkCommandBufferAllocateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCommandBufferAllocateInfo*)(local_pAllocateInfo), countPtr);
        if (pAllocateInfo->commandBufferCount)
        {
            *countPtr += pAllocateInfo->commandBufferCount * 8;
        }
    }
    uint32_t packetSize_vkAllocateCommandBuffers = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkAllocateCommandBuffers);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkAllocateCommandBuffers = OP_vkAllocateCommandBuffers;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkAllocateCommandBuffers, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkAllocateCommandBuffers, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkCommandBufferAllocateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCommandBufferAllocateInfo*)(local_pAllocateInfo), streamPtrPtr);
    /* is handle, possibly out */;
    if (pAllocateInfo->commandBufferCount)
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < pAllocateInfo->commandBufferCount; ++k)
        {
            uint64_t tmpval = (uint64_t)(pCommandBuffers[k]);
            memcpy(cgen_var_1_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * pAllocateInfo->commandBufferCount;
    }
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    if (pAllocateInfo->commandBufferCount)
    {
        uint64_t* cgen_var_2;
        stream->alloc((void**)&cgen_var_2, pAllocateInfo->commandBufferCount * 8);
        stream->read((uint64_t*)cgen_var_2, pAllocateInfo->commandBufferCount * 8);
        stream->handleMapping()->mapHandles_u64_VkCommandBuffer(cgen_var_2, (VkCommandBuffer*)pCommandBuffers, pAllocateInfo->commandBufferCount);
    }
    stream->unsetHandleMapping();
    VkResult vkAllocateCommandBuffers_VkResult_return = (VkResult)0;
    stream->read(&vkAllocateCommandBuffers_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkAllocateCommandBuffers_VkResult_return;
}

void VkEncoder::vkFreeCommandBuffers(
    VkDevice device,
    VkCommandPool commandPool,
    uint32_t commandBufferCount,
    const VkCommandBuffer* pCommandBuffers,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkCommandPool local_commandPool;
    uint32_t local_commandBufferCount;
    VkCommandBuffer* local_pCommandBuffers;
    local_device = device;
    local_commandPool = commandPool;
    local_commandBufferCount = commandBufferCount;
    // Avoiding deepcopy for pCommandBuffers
    local_pCommandBuffers = (VkCommandBuffer*)pCommandBuffers;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pCommandBuffers)
        {
            if (((commandBufferCount)))
            {
                *countPtr += ((commandBufferCount)) * 8;
            }
        }
    }
    uint32_t packetSize_vkFreeCommandBuffers = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkFreeCommandBuffers);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkFreeCommandBuffers = OP_vkFreeCommandBuffers;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkFreeCommandBuffers, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkFreeCommandBuffers, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkCommandPool((*&local_commandPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_commandBufferCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pCommandBuffers;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pCommandBuffers)
    {
        if (((commandBufferCount)))
        {
            uint8_t* cgen_var_2_0_ptr = (uint8_t*)(*streamPtrPtr);
            for (uint32_t k = 0; k < ((commandBufferCount)); ++k)
            {
                uint64_t tmpval = get_host_u64_VkCommandBuffer(local_pCommandBuffers[k]);
                memcpy(cgen_var_2_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
            *streamPtrPtr += 8 * ((commandBufferCount));
        }
    }
    if (pCommandBuffers)
    {
        sResourceTracker->destroyMapping()->mapHandles_VkCommandBuffer((VkCommandBuffer*)pCommandBuffers, ((commandBufferCount)));
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkBeginCommandBuffer(
    VkCommandBuffer commandBuffer,
    const VkCommandBufferBeginInfo* pBeginInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCommandBufferBeginInfo* local_pBeginInfo;
    local_commandBuffer = commandBuffer;
    local_pBeginInfo = nullptr;
    if (pBeginInfo)
    {
        local_pBeginInfo = (VkCommandBufferBeginInfo*)pool->alloc(sizeof(const VkCommandBufferBeginInfo));
        deepcopy_VkCommandBufferBeginInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pBeginInfo, (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    }
    if (local_pBeginInfo)
    {
        transform_tohost_VkCommandBufferBeginInfo(sResourceTracker, (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkCommandBufferBeginInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCommandBufferBeginInfo*)(local_pBeginInfo), countPtr);
    }
    uint32_t packetSize_vkBeginCommandBuffer = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkBeginCommandBuffer -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkBeginCommandBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkBeginCommandBuffer = OP_vkBeginCommandBuffer;
    memcpy(streamPtr, &opcode_vkBeginCommandBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkBeginCommandBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkCommandBufferBeginInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCommandBufferBeginInfo*)(local_pBeginInfo), streamPtrPtr);
    VkResult vkBeginCommandBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkBeginCommandBuffer_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkBeginCommandBuffer_VkResult_return;
}

VkResult VkEncoder::vkEndCommandBuffer(
    VkCommandBuffer commandBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkEndCommandBuffer = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkEndCommandBuffer -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEndCommandBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEndCommandBuffer = OP_vkEndCommandBuffer;
    memcpy(streamPtr, &opcode_vkEndCommandBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEndCommandBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    VkResult vkEndCommandBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkEndCommandBuffer_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEndCommandBuffer_VkResult_return;
}

VkResult VkEncoder::vkResetCommandBuffer(
    VkCommandBuffer commandBuffer,
    VkCommandBufferResetFlags flags,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCommandBufferResetFlags local_flags;
    local_commandBuffer = commandBuffer;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkCommandBufferResetFlags);
    }
    uint32_t packetSize_vkResetCommandBuffer = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkResetCommandBuffer -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkResetCommandBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkResetCommandBuffer = OP_vkResetCommandBuffer;
    memcpy(streamPtr, &opcode_vkResetCommandBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkResetCommandBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkCommandBufferResetFlags*)&local_flags, sizeof(VkCommandBufferResetFlags));
    *streamPtrPtr += sizeof(VkCommandBufferResetFlags);
    VkResult vkResetCommandBuffer_VkResult_return = (VkResult)0;
    stream->read(&vkResetCommandBuffer_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkResetCommandBuffer_VkResult_return;
}

void VkEncoder::vkCmdBindPipeline(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipeline pipeline,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPipelineBindPoint local_pipelineBindPoint;
    VkPipeline local_pipeline;
    local_commandBuffer = commandBuffer;
    local_pipelineBindPoint = pipelineBindPoint;
    local_pipeline = pipeline;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPipelineBindPoint);
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkCmdBindPipeline = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBindPipeline -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBindPipeline);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBindPipeline = OP_vkCmdBindPipeline;
    memcpy(streamPtr, &opcode_vkCmdBindPipeline, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBindPipeline, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
    *streamPtrPtr += sizeof(VkPipelineBindPoint);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPipeline((*&local_pipeline));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetViewport(
    VkCommandBuffer commandBuffer,
    uint32_t firstViewport,
    uint32_t viewportCount,
    const VkViewport* pViewports,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstViewport;
    uint32_t local_viewportCount;
    VkViewport* local_pViewports;
    local_commandBuffer = commandBuffer;
    local_firstViewport = firstViewport;
    local_viewportCount = viewportCount;
    local_pViewports = nullptr;
    if (pViewports)
    {
        local_pViewports = (VkViewport*)pool->alloc(((viewportCount)) * sizeof(const VkViewport));
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            deepcopy_VkViewport(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pViewports + i, (VkViewport*)(local_pViewports + i));
        }
    }
    if (local_pViewports)
    {
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            transform_tohost_VkViewport(sResourceTracker, (VkViewport*)(local_pViewports + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            count_VkViewport(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkViewport*)(local_pViewports + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdSetViewport = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetViewport -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetViewport);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetViewport = OP_vkCmdSetViewport;
    memcpy(streamPtr, &opcode_vkCmdSetViewport, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetViewport, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstViewport, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_viewportCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
    {
        reservedmarshal_VkViewport(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkViewport*)(local_pViewports + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetScissor(
    VkCommandBuffer commandBuffer,
    uint32_t firstScissor,
    uint32_t scissorCount,
    const VkRect2D* pScissors,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstScissor;
    uint32_t local_scissorCount;
    VkRect2D* local_pScissors;
    local_commandBuffer = commandBuffer;
    local_firstScissor = firstScissor;
    local_scissorCount = scissorCount;
    local_pScissors = nullptr;
    if (pScissors)
    {
        local_pScissors = (VkRect2D*)pool->alloc(((scissorCount)) * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
        {
            deepcopy_VkRect2D(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pScissors + i, (VkRect2D*)(local_pScissors + i));
        }
    }
    if (local_pScissors)
    {
        for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
        {
            transform_tohost_VkRect2D(sResourceTracker, (VkRect2D*)(local_pScissors + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
        {
            count_VkRect2D(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRect2D*)(local_pScissors + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdSetScissor = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetScissor -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetScissor);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetScissor = OP_vkCmdSetScissor;
    memcpy(streamPtr, &opcode_vkCmdSetScissor, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetScissor, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstScissor, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_scissorCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
    {
        reservedmarshal_VkRect2D(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRect2D*)(local_pScissors + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetLineWidth(
    VkCommandBuffer commandBuffer,
    float lineWidth,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    float local_lineWidth;
    local_commandBuffer = commandBuffer;
    local_lineWidth = lineWidth;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(float);
    }
    uint32_t packetSize_vkCmdSetLineWidth = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetLineWidth -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetLineWidth);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetLineWidth = OP_vkCmdSetLineWidth;
    memcpy(streamPtr, &opcode_vkCmdSetLineWidth, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetLineWidth, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (float*)&local_lineWidth, sizeof(float));
    *streamPtrPtr += sizeof(float);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetDepthBias(
    VkCommandBuffer commandBuffer,
    float depthBiasConstantFactor,
    float depthBiasClamp,
    float depthBiasSlopeFactor,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    float local_depthBiasConstantFactor;
    float local_depthBiasClamp;
    float local_depthBiasSlopeFactor;
    local_commandBuffer = commandBuffer;
    local_depthBiasConstantFactor = depthBiasConstantFactor;
    local_depthBiasClamp = depthBiasClamp;
    local_depthBiasSlopeFactor = depthBiasSlopeFactor;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(float);
        *countPtr += sizeof(float);
        *countPtr += sizeof(float);
    }
    uint32_t packetSize_vkCmdSetDepthBias = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetDepthBias -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetDepthBias);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetDepthBias = OP_vkCmdSetDepthBias;
    memcpy(streamPtr, &opcode_vkCmdSetDepthBias, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetDepthBias, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (float*)&local_depthBiasConstantFactor, sizeof(float));
    *streamPtrPtr += sizeof(float);
    memcpy(*streamPtrPtr, (float*)&local_depthBiasClamp, sizeof(float));
    *streamPtrPtr += sizeof(float);
    memcpy(*streamPtrPtr, (float*)&local_depthBiasSlopeFactor, sizeof(float));
    *streamPtrPtr += sizeof(float);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetBlendConstants(
    VkCommandBuffer commandBuffer,
    const float blendConstants[4],
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    float local_blendConstants[4];
    local_commandBuffer = commandBuffer;
    memcpy(local_blendConstants, blendConstants, 4 * sizeof(const float));
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += 4 * sizeof(float);
    }
    uint32_t packetSize_vkCmdSetBlendConstants = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetBlendConstants -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetBlendConstants);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetBlendConstants = OP_vkCmdSetBlendConstants;
    memcpy(streamPtr, &opcode_vkCmdSetBlendConstants, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetBlendConstants, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (float*)local_blendConstants, 4 * sizeof(float));
    *streamPtrPtr += 4 * sizeof(float);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetDepthBounds(
    VkCommandBuffer commandBuffer,
    float minDepthBounds,
    float maxDepthBounds,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    float local_minDepthBounds;
    float local_maxDepthBounds;
    local_commandBuffer = commandBuffer;
    local_minDepthBounds = minDepthBounds;
    local_maxDepthBounds = maxDepthBounds;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(float);
        *countPtr += sizeof(float);
    }
    uint32_t packetSize_vkCmdSetDepthBounds = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetDepthBounds -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetDepthBounds);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetDepthBounds = OP_vkCmdSetDepthBounds;
    memcpy(streamPtr, &opcode_vkCmdSetDepthBounds, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetDepthBounds, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (float*)&local_minDepthBounds, sizeof(float));
    *streamPtrPtr += sizeof(float);
    memcpy(*streamPtrPtr, (float*)&local_maxDepthBounds, sizeof(float));
    *streamPtrPtr += sizeof(float);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetStencilCompareMask(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t compareMask,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkStencilFaceFlags local_faceMask;
    uint32_t local_compareMask;
    local_commandBuffer = commandBuffer;
    local_faceMask = faceMask;
    local_compareMask = compareMask;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkStencilFaceFlags);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdSetStencilCompareMask = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetStencilCompareMask -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetStencilCompareMask);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetStencilCompareMask = OP_vkCmdSetStencilCompareMask;
    memcpy(streamPtr, &opcode_vkCmdSetStencilCompareMask, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetStencilCompareMask, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
    *streamPtrPtr += sizeof(VkStencilFaceFlags);
    memcpy(*streamPtrPtr, (uint32_t*)&local_compareMask, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetStencilWriteMask(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t writeMask,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkStencilFaceFlags local_faceMask;
    uint32_t local_writeMask;
    local_commandBuffer = commandBuffer;
    local_faceMask = faceMask;
    local_writeMask = writeMask;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkStencilFaceFlags);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdSetStencilWriteMask = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetStencilWriteMask -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetStencilWriteMask);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetStencilWriteMask = OP_vkCmdSetStencilWriteMask;
    memcpy(streamPtr, &opcode_vkCmdSetStencilWriteMask, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetStencilWriteMask, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
    *streamPtrPtr += sizeof(VkStencilFaceFlags);
    memcpy(*streamPtrPtr, (uint32_t*)&local_writeMask, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetStencilReference(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    uint32_t reference,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkStencilFaceFlags local_faceMask;
    uint32_t local_reference;
    local_commandBuffer = commandBuffer;
    local_faceMask = faceMask;
    local_reference = reference;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkStencilFaceFlags);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdSetStencilReference = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetStencilReference -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetStencilReference);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetStencilReference = OP_vkCmdSetStencilReference;
    memcpy(streamPtr, &opcode_vkCmdSetStencilReference, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetStencilReference, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
    *streamPtrPtr += sizeof(VkStencilFaceFlags);
    memcpy(*streamPtrPtr, (uint32_t*)&local_reference, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBindDescriptorSets(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipelineLayout layout,
    uint32_t firstSet,
    uint32_t descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets,
    uint32_t dynamicOffsetCount,
    const uint32_t* pDynamicOffsets,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPipelineBindPoint local_pipelineBindPoint;
    VkPipelineLayout local_layout;
    uint32_t local_firstSet;
    uint32_t local_descriptorSetCount;
    VkDescriptorSet* local_pDescriptorSets;
    uint32_t local_dynamicOffsetCount;
    uint32_t* local_pDynamicOffsets;
    local_commandBuffer = commandBuffer;
    local_pipelineBindPoint = pipelineBindPoint;
    local_layout = layout;
    local_firstSet = firstSet;
    local_descriptorSetCount = descriptorSetCount;
    // Avoiding deepcopy for pDescriptorSets
    local_pDescriptorSets = (VkDescriptorSet*)pDescriptorSets;
    local_dynamicOffsetCount = dynamicOffsetCount;
    // Avoiding deepcopy for pDynamicOffsets
    local_pDynamicOffsets = (uint32_t*)pDynamicOffsets;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPipelineBindPoint);
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        if (((descriptorSetCount)))
        {
            *countPtr += ((descriptorSetCount)) * 8;
        }
        *countPtr += sizeof(uint32_t);
        *countPtr += ((dynamicOffsetCount)) * sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdBindDescriptorSets = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBindDescriptorSets -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBindDescriptorSets);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBindDescriptorSets = OP_vkCmdBindDescriptorSets;
    memcpy(streamPtr, &opcode_vkCmdBindDescriptorSets, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBindDescriptorSets, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
    *streamPtrPtr += sizeof(VkPipelineBindPoint);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPipelineLayout((*&local_layout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstSet, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_descriptorSetCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((descriptorSetCount)))
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((descriptorSetCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkDescriptorSet(local_pDescriptorSets[k]);
            memcpy(cgen_var_1_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((descriptorSetCount));
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_dynamicOffsetCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)local_pDynamicOffsets, ((dynamicOffsetCount)) * sizeof(uint32_t));
    *streamPtrPtr += ((dynamicOffsetCount)) * sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBindIndexBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkIndexType indexType,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkIndexType local_indexType;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_indexType = indexType;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(VkIndexType);
    }
    uint32_t packetSize_vkCmdBindIndexBuffer = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBindIndexBuffer -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBindIndexBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBindIndexBuffer = OP_vkCmdBindIndexBuffer;
    memcpy(streamPtr, &opcode_vkCmdBindIndexBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBindIndexBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (VkIndexType*)&local_indexType, sizeof(VkIndexType));
    *streamPtrPtr += sizeof(VkIndexType);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBindVertexBuffers(
    VkCommandBuffer commandBuffer,
    uint32_t firstBinding,
    uint32_t bindingCount,
    const VkBuffer* pBuffers,
    const VkDeviceSize* pOffsets,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstBinding;
    uint32_t local_bindingCount;
    VkBuffer* local_pBuffers;
    VkDeviceSize* local_pOffsets;
    local_commandBuffer = commandBuffer;
    local_firstBinding = firstBinding;
    local_bindingCount = bindingCount;
    // Avoiding deepcopy for pBuffers
    local_pBuffers = (VkBuffer*)pBuffers;
    // Avoiding deepcopy for pOffsets
    local_pOffsets = (VkDeviceSize*)pOffsets;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        if (((bindingCount)))
        {
            *countPtr += ((bindingCount)) * 8;
        }
        *countPtr += ((bindingCount)) * sizeof(VkDeviceSize);
    }
    uint32_t packetSize_vkCmdBindVertexBuffers = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBindVertexBuffers -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBindVertexBuffers);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBindVertexBuffers = OP_vkCmdBindVertexBuffers;
    memcpy(streamPtr, &opcode_vkCmdBindVertexBuffers, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBindVertexBuffers, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstBinding, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_bindingCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((bindingCount)))
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((bindingCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkBuffer(local_pBuffers[k]);
            memcpy(cgen_var_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((bindingCount));
    }
    memcpy(*streamPtrPtr, (VkDeviceSize*)local_pOffsets, ((bindingCount)) * sizeof(VkDeviceSize));
    *streamPtrPtr += ((bindingCount)) * sizeof(VkDeviceSize);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDraw(
    VkCommandBuffer commandBuffer,
    uint32_t vertexCount,
    uint32_t instanceCount,
    uint32_t firstVertex,
    uint32_t firstInstance,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_vertexCount;
    uint32_t local_instanceCount;
    uint32_t local_firstVertex;
    uint32_t local_firstInstance;
    local_commandBuffer = commandBuffer;
    local_vertexCount = vertexCount;
    local_instanceCount = instanceCount;
    local_firstVertex = firstVertex;
    local_firstInstance = firstInstance;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDraw = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDraw -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDraw);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDraw = OP_vkCmdDraw;
    memcpy(streamPtr, &opcode_vkCmdDraw, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDraw, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_vertexCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_instanceCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstVertex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstInstance, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDrawIndexed(
    VkCommandBuffer commandBuffer,
    uint32_t indexCount,
    uint32_t instanceCount,
    uint32_t firstIndex,
    int32_t vertexOffset,
    uint32_t firstInstance,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_indexCount;
    uint32_t local_instanceCount;
    uint32_t local_firstIndex;
    int32_t local_vertexOffset;
    uint32_t local_firstInstance;
    local_commandBuffer = commandBuffer;
    local_indexCount = indexCount;
    local_instanceCount = instanceCount;
    local_firstIndex = firstIndex;
    local_vertexOffset = vertexOffset;
    local_firstInstance = firstInstance;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(int32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawIndexed = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawIndexed -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawIndexed);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawIndexed = OP_vkCmdDrawIndexed;
    memcpy(streamPtr, &opcode_vkCmdDrawIndexed, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawIndexed, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_indexCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_instanceCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (int32_t*)&local_vertexOffset, sizeof(int32_t));
    *streamPtrPtr += sizeof(int32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstInstance, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDrawIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t drawCount,
    uint32_t stride,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    uint32_t local_drawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_drawCount = drawCount;
    local_stride = stride;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawIndirect = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawIndirect -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawIndirect);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawIndirect = OP_vkCmdDrawIndirect;
    memcpy(streamPtr, &opcode_vkCmdDrawIndirect, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawIndirect, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_drawCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_stride, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDrawIndexedIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t drawCount,
    uint32_t stride,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    uint32_t local_drawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_drawCount = drawCount;
    local_stride = stride;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawIndexedIndirect = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawIndexedIndirect -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawIndexedIndirect);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawIndexedIndirect = OP_vkCmdDrawIndexedIndirect;
    memcpy(streamPtr, &opcode_vkCmdDrawIndexedIndirect, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawIndexedIndirect, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_drawCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_stride, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDispatch(
    VkCommandBuffer commandBuffer,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_groupCountX;
    uint32_t local_groupCountY;
    uint32_t local_groupCountZ;
    local_commandBuffer = commandBuffer;
    local_groupCountX = groupCountX;
    local_groupCountY = groupCountY;
    local_groupCountZ = groupCountZ;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDispatch = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDispatch -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDispatch);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDispatch = OP_vkCmdDispatch;
    memcpy(streamPtr, &opcode_vkCmdDispatch, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDispatch, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCountX, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCountY, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCountZ, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDispatchIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
    }
    uint32_t packetSize_vkCmdDispatchIndirect = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDispatchIndirect -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDispatchIndirect);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDispatchIndirect = OP_vkCmdDispatchIndirect;
    memcpy(streamPtr, &opcode_vkCmdDispatchIndirect, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDispatchIndirect, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdCopyBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer srcBuffer,
    VkBuffer dstBuffer,
    uint32_t regionCount,
    const VkBufferCopy* pRegions,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_srcBuffer;
    VkBuffer local_dstBuffer;
    uint32_t local_regionCount;
    VkBufferCopy* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcBuffer = srcBuffer;
    local_dstBuffer = dstBuffer;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkBufferCopy*)pool->alloc(((regionCount)) * sizeof(const VkBufferCopy));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkBufferCopy(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pRegions + i, (VkBufferCopy*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkBufferCopy(sResourceTracker, (VkBufferCopy*)(local_pRegions + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            count_VkBufferCopy(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferCopy*)(local_pRegions + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdCopyBuffer = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdCopyBuffer -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdCopyBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdCopyBuffer = OP_vkCmdCopyBuffer;
    memcpy(streamPtr, &opcode_vkCmdCopyBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdCopyBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_srcBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&local_dstBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_regionCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        reservedmarshal_VkBufferCopy(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferCopy*)(local_pRegions + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdCopyImage(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageCopy* pRegions,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkImage local_srcImage;
    VkImageLayout local_srcImageLayout;
    VkImage local_dstImage;
    VkImageLayout local_dstImageLayout;
    uint32_t local_regionCount;
    VkImageCopy* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcImage = srcImage;
    local_srcImageLayout = srcImageLayout;
    local_dstImage = dstImage;
    local_dstImageLayout = dstImageLayout;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkImageCopy*)pool->alloc(((regionCount)) * sizeof(const VkImageCopy));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkImageCopy(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pRegions + i, (VkImageCopy*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkImageCopy(sResourceTracker, (VkImageCopy*)(local_pRegions + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            count_VkImageCopy(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageCopy*)(local_pRegions + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdCopyImage = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdCopyImage -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdCopyImage);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdCopyImage = OP_vkCmdCopyImage;
    memcpy(streamPtr, &opcode_vkCmdCopyImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdCopyImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&local_srcImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImage((*&local_dstImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    memcpy(*streamPtrPtr, (uint32_t*)&local_regionCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        reservedmarshal_VkImageCopy(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageCopy*)(local_pRegions + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBlitImage(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageBlit* pRegions,
    VkFilter filter,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkImage local_srcImage;
    VkImageLayout local_srcImageLayout;
    VkImage local_dstImage;
    VkImageLayout local_dstImageLayout;
    uint32_t local_regionCount;
    VkImageBlit* local_pRegions;
    VkFilter local_filter;
    local_commandBuffer = commandBuffer;
    local_srcImage = srcImage;
    local_srcImageLayout = srcImageLayout;
    local_dstImage = dstImage;
    local_dstImageLayout = dstImageLayout;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkImageBlit*)pool->alloc(((regionCount)) * sizeof(const VkImageBlit));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkImageBlit(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pRegions + i, (VkImageBlit*)(local_pRegions + i));
        }
    }
    local_filter = filter;
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkImageBlit(sResourceTracker, (VkImageBlit*)(local_pRegions + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            count_VkImageBlit(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageBlit*)(local_pRegions + i), countPtr);
        }
        *countPtr += sizeof(VkFilter);
    }
    uint32_t packetSize_vkCmdBlitImage = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBlitImage -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBlitImage);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBlitImage = OP_vkCmdBlitImage;
    memcpy(streamPtr, &opcode_vkCmdBlitImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBlitImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&local_srcImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImage((*&local_dstImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    memcpy(*streamPtrPtr, (uint32_t*)&local_regionCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        reservedmarshal_VkImageBlit(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageBlit*)(local_pRegions + i), streamPtrPtr);
    }
    memcpy(*streamPtrPtr, (VkFilter*)&local_filter, sizeof(VkFilter));
    *streamPtrPtr += sizeof(VkFilter);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdCopyBufferToImage(
    VkCommandBuffer commandBuffer,
    VkBuffer srcBuffer,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkBufferImageCopy* pRegions,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_srcBuffer;
    VkImage local_dstImage;
    VkImageLayout local_dstImageLayout;
    uint32_t local_regionCount;
    VkBufferImageCopy* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcBuffer = srcBuffer;
    local_dstImage = dstImage;
    local_dstImageLayout = dstImageLayout;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkBufferImageCopy*)pool->alloc(((regionCount)) * sizeof(const VkBufferImageCopy));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkBufferImageCopy(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pRegions + i, (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkBufferImageCopy(sResourceTracker, (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            count_VkBufferImageCopy(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferImageCopy*)(local_pRegions + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdCopyBufferToImage = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdCopyBufferToImage -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdCopyBufferToImage);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdCopyBufferToImage = OP_vkCmdCopyBufferToImage;
    memcpy(streamPtr, &opcode_vkCmdCopyBufferToImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdCopyBufferToImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_srcBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImage((*&local_dstImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    memcpy(*streamPtrPtr, (uint32_t*)&local_regionCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        reservedmarshal_VkBufferImageCopy(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferImageCopy*)(local_pRegions + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdCopyImageToBuffer(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkBuffer dstBuffer,
    uint32_t regionCount,
    const VkBufferImageCopy* pRegions,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkImage local_srcImage;
    VkImageLayout local_srcImageLayout;
    VkBuffer local_dstBuffer;
    uint32_t local_regionCount;
    VkBufferImageCopy* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcImage = srcImage;
    local_srcImageLayout = srcImageLayout;
    local_dstBuffer = dstBuffer;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkBufferImageCopy*)pool->alloc(((regionCount)) * sizeof(const VkBufferImageCopy));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkBufferImageCopy(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pRegions + i, (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkBufferImageCopy(sResourceTracker, (VkBufferImageCopy*)(local_pRegions + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            count_VkBufferImageCopy(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferImageCopy*)(local_pRegions + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdCopyImageToBuffer = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdCopyImageToBuffer -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdCopyImageToBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdCopyImageToBuffer = OP_vkCmdCopyImageToBuffer;
    memcpy(streamPtr, &opcode_vkCmdCopyImageToBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdCopyImageToBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&local_srcImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&local_dstBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_regionCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        reservedmarshal_VkBufferImageCopy(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferImageCopy*)(local_pRegions + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdUpdateBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize dataSize,
    const void* pData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_dstBuffer;
    VkDeviceSize local_dstOffset;
    VkDeviceSize local_dataSize;
    void* local_pData;
    local_commandBuffer = commandBuffer;
    local_dstBuffer = dstBuffer;
    local_dstOffset = dstOffset;
    local_dataSize = dataSize;
    // Avoiding deepcopy for pData
    local_pData = (void*)pData;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += ((dataSize)) * sizeof(uint8_t);
    }
    uint32_t packetSize_vkCmdUpdateBuffer = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdUpdateBuffer -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdUpdateBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdUpdateBuffer = OP_vkCmdUpdateBuffer;
    memcpy(streamPtr, &opcode_vkCmdUpdateBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdUpdateBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_dstBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_dataSize, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (void*)local_pData, ((dataSize)) * sizeof(uint8_t));
    *streamPtrPtr += ((dataSize)) * sizeof(uint8_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdFillBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize size,
    uint32_t data,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_dstBuffer;
    VkDeviceSize local_dstOffset;
    VkDeviceSize local_size;
    uint32_t local_data;
    local_commandBuffer = commandBuffer;
    local_dstBuffer = dstBuffer;
    local_dstOffset = dstOffset;
    local_size = size;
    local_data = data;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdFillBuffer = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdFillBuffer -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdFillBuffer);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdFillBuffer = OP_vkCmdFillBuffer;
    memcpy(streamPtr, &opcode_vkCmdFillBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdFillBuffer, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_dstBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_size, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_data, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdClearColorImage(
    VkCommandBuffer commandBuffer,
    VkImage image,
    VkImageLayout imageLayout,
    const VkClearColorValue* pColor,
    uint32_t rangeCount,
    const VkImageSubresourceRange* pRanges,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkImage local_image;
    VkImageLayout local_imageLayout;
    VkClearColorValue* local_pColor;
    uint32_t local_rangeCount;
    VkImageSubresourceRange* local_pRanges;
    local_commandBuffer = commandBuffer;
    local_image = image;
    local_imageLayout = imageLayout;
    local_pColor = nullptr;
    if (pColor)
    {
        local_pColor = (VkClearColorValue*)pool->alloc(sizeof(const VkClearColorValue));
        deepcopy_VkClearColorValue(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pColor, (VkClearColorValue*)(local_pColor));
    }
    local_rangeCount = rangeCount;
    local_pRanges = nullptr;
    if (pRanges)
    {
        local_pRanges = (VkImageSubresourceRange*)pool->alloc(((rangeCount)) * sizeof(const VkImageSubresourceRange));
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            deepcopy_VkImageSubresourceRange(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pRanges + i, (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    if (local_pColor)
    {
        transform_tohost_VkClearColorValue(sResourceTracker, (VkClearColorValue*)(local_pColor));
    }
    if (local_pRanges)
    {
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            transform_tohost_VkImageSubresourceRange(sResourceTracker, (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        count_VkClearColorValue(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkClearColorValue*)(local_pColor), countPtr);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            count_VkImageSubresourceRange(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageSubresourceRange*)(local_pRanges + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdClearColorImage = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdClearColorImage -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdClearColorImage);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdClearColorImage = OP_vkCmdClearColorImage;
    memcpy(streamPtr, &opcode_vkCmdClearColorImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdClearColorImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_imageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    reservedmarshal_VkClearColorValue(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkClearColorValue*)(local_pColor), streamPtrPtr);
    memcpy(*streamPtrPtr, (uint32_t*)&local_rangeCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
    {
        reservedmarshal_VkImageSubresourceRange(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageSubresourceRange*)(local_pRanges + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdClearDepthStencilImage(
    VkCommandBuffer commandBuffer,
    VkImage image,
    VkImageLayout imageLayout,
    const VkClearDepthStencilValue* pDepthStencil,
    uint32_t rangeCount,
    const VkImageSubresourceRange* pRanges,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkImage local_image;
    VkImageLayout local_imageLayout;
    VkClearDepthStencilValue* local_pDepthStencil;
    uint32_t local_rangeCount;
    VkImageSubresourceRange* local_pRanges;
    local_commandBuffer = commandBuffer;
    local_image = image;
    local_imageLayout = imageLayout;
    local_pDepthStencil = nullptr;
    if (pDepthStencil)
    {
        local_pDepthStencil = (VkClearDepthStencilValue*)pool->alloc(sizeof(const VkClearDepthStencilValue));
        deepcopy_VkClearDepthStencilValue(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pDepthStencil, (VkClearDepthStencilValue*)(local_pDepthStencil));
    }
    local_rangeCount = rangeCount;
    local_pRanges = nullptr;
    if (pRanges)
    {
        local_pRanges = (VkImageSubresourceRange*)pool->alloc(((rangeCount)) * sizeof(const VkImageSubresourceRange));
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            deepcopy_VkImageSubresourceRange(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pRanges + i, (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    if (local_pDepthStencil)
    {
        transform_tohost_VkClearDepthStencilValue(sResourceTracker, (VkClearDepthStencilValue*)(local_pDepthStencil));
    }
    if (local_pRanges)
    {
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            transform_tohost_VkImageSubresourceRange(sResourceTracker, (VkImageSubresourceRange*)(local_pRanges + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        count_VkClearDepthStencilValue(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkClearDepthStencilValue*)(local_pDepthStencil), countPtr);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
        {
            count_VkImageSubresourceRange(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageSubresourceRange*)(local_pRanges + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdClearDepthStencilImage = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdClearDepthStencilImage -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdClearDepthStencilImage);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdClearDepthStencilImage = OP_vkCmdClearDepthStencilImage;
    memcpy(streamPtr, &opcode_vkCmdClearDepthStencilImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdClearDepthStencilImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_imageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    reservedmarshal_VkClearDepthStencilValue(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkClearDepthStencilValue*)(local_pDepthStencil), streamPtrPtr);
    memcpy(*streamPtrPtr, (uint32_t*)&local_rangeCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((rangeCount)); ++i)
    {
        reservedmarshal_VkImageSubresourceRange(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageSubresourceRange*)(local_pRanges + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdClearAttachments(
    VkCommandBuffer commandBuffer,
    uint32_t attachmentCount,
    const VkClearAttachment* pAttachments,
    uint32_t rectCount,
    const VkClearRect* pRects,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_attachmentCount;
    VkClearAttachment* local_pAttachments;
    uint32_t local_rectCount;
    VkClearRect* local_pRects;
    local_commandBuffer = commandBuffer;
    local_attachmentCount = attachmentCount;
    local_pAttachments = nullptr;
    if (pAttachments)
    {
        local_pAttachments = (VkClearAttachment*)pool->alloc(((attachmentCount)) * sizeof(const VkClearAttachment));
        for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
        {
            deepcopy_VkClearAttachment(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAttachments + i, (VkClearAttachment*)(local_pAttachments + i));
        }
    }
    local_rectCount = rectCount;
    local_pRects = nullptr;
    if (pRects)
    {
        local_pRects = (VkClearRect*)pool->alloc(((rectCount)) * sizeof(const VkClearRect));
        for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
        {
            deepcopy_VkClearRect(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pRects + i, (VkClearRect*)(local_pRects + i));
        }
    }
    if (local_pAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
        {
            transform_tohost_VkClearAttachment(sResourceTracker, (VkClearAttachment*)(local_pAttachments + i));
        }
    }
    if (local_pRects)
    {
        for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
        {
            transform_tohost_VkClearRect(sResourceTracker, (VkClearRect*)(local_pRects + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
        {
            count_VkClearAttachment(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkClearAttachment*)(local_pAttachments + i), countPtr);
        }
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
        {
            count_VkClearRect(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkClearRect*)(local_pRects + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdClearAttachments = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdClearAttachments -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdClearAttachments);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdClearAttachments = OP_vkCmdClearAttachments;
    memcpy(streamPtr, &opcode_vkCmdClearAttachments, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdClearAttachments, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_attachmentCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((attachmentCount)); ++i)
    {
        reservedmarshal_VkClearAttachment(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkClearAttachment*)(local_pAttachments + i), streamPtrPtr);
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_rectCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((rectCount)); ++i)
    {
        reservedmarshal_VkClearRect(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkClearRect*)(local_pRects + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdResolveImage(
    VkCommandBuffer commandBuffer,
    VkImage srcImage,
    VkImageLayout srcImageLayout,
    VkImage dstImage,
    VkImageLayout dstImageLayout,
    uint32_t regionCount,
    const VkImageResolve* pRegions,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkImage local_srcImage;
    VkImageLayout local_srcImageLayout;
    VkImage local_dstImage;
    VkImageLayout local_dstImageLayout;
    uint32_t local_regionCount;
    VkImageResolve* local_pRegions;
    local_commandBuffer = commandBuffer;
    local_srcImage = srcImage;
    local_srcImageLayout = srcImageLayout;
    local_dstImage = dstImage;
    local_dstImageLayout = dstImageLayout;
    local_regionCount = regionCount;
    local_pRegions = nullptr;
    if (pRegions)
    {
        local_pRegions = (VkImageResolve*)pool->alloc(((regionCount)) * sizeof(const VkImageResolve));
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            deepcopy_VkImageResolve(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pRegions + i, (VkImageResolve*)(local_pRegions + i));
        }
    }
    if (local_pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            transform_tohost_VkImageResolve(sResourceTracker, (VkImageResolve*)(local_pRegions + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
        {
            count_VkImageResolve(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageResolve*)(local_pRegions + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdResolveImage = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdResolveImage -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdResolveImage);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdResolveImage = OP_vkCmdResolveImage;
    memcpy(streamPtr, &opcode_vkCmdResolveImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdResolveImage, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&local_srcImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_srcImageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImage((*&local_dstImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_dstImageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    memcpy(*streamPtrPtr, (uint32_t*)&local_regionCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((regionCount)); ++i)
    {
        reservedmarshal_VkImageResolve(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageResolve*)(local_pRegions + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetEvent(
    VkCommandBuffer commandBuffer,
    VkEvent event,
    VkPipelineStageFlags stageMask,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkEvent local_event;
    VkPipelineStageFlags local_stageMask;
    local_commandBuffer = commandBuffer;
    local_event = event;
    local_stageMask = stageMask;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPipelineStageFlags);
    }
    uint32_t packetSize_vkCmdSetEvent = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetEvent -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetEvent);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetEvent = OP_vkCmdSetEvent;
    memcpy(streamPtr, &opcode_vkCmdSetEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkEvent((*&local_event));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkPipelineStageFlags*)&local_stageMask, sizeof(VkPipelineStageFlags));
    *streamPtrPtr += sizeof(VkPipelineStageFlags);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdResetEvent(
    VkCommandBuffer commandBuffer,
    VkEvent event,
    VkPipelineStageFlags stageMask,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkEvent local_event;
    VkPipelineStageFlags local_stageMask;
    local_commandBuffer = commandBuffer;
    local_event = event;
    local_stageMask = stageMask;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPipelineStageFlags);
    }
    uint32_t packetSize_vkCmdResetEvent = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdResetEvent -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdResetEvent);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdResetEvent = OP_vkCmdResetEvent;
    memcpy(streamPtr, &opcode_vkCmdResetEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdResetEvent, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkEvent((*&local_event));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkPipelineStageFlags*)&local_stageMask, sizeof(VkPipelineStageFlags));
    *streamPtrPtr += sizeof(VkPipelineStageFlags);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdWaitEvents(
    VkCommandBuffer commandBuffer,
    uint32_t eventCount,
    const VkEvent* pEvents,
    VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask,
    uint32_t memoryBarrierCount,
    const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount,
    const VkImageMemoryBarrier* pImageMemoryBarriers,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_eventCount;
    VkEvent* local_pEvents;
    VkPipelineStageFlags local_srcStageMask;
    VkPipelineStageFlags local_dstStageMask;
    uint32_t local_memoryBarrierCount;
    VkMemoryBarrier* local_pMemoryBarriers;
    uint32_t local_bufferMemoryBarrierCount;
    VkBufferMemoryBarrier* local_pBufferMemoryBarriers;
    uint32_t local_imageMemoryBarrierCount;
    VkImageMemoryBarrier* local_pImageMemoryBarriers;
    local_commandBuffer = commandBuffer;
    local_eventCount = eventCount;
    // Avoiding deepcopy for pEvents
    local_pEvents = (VkEvent*)pEvents;
    local_srcStageMask = srcStageMask;
    local_dstStageMask = dstStageMask;
    local_memoryBarrierCount = memoryBarrierCount;
    local_pMemoryBarriers = nullptr;
    if (pMemoryBarriers)
    {
        local_pMemoryBarriers = (VkMemoryBarrier*)pool->alloc(((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            deepcopy_VkMemoryBarrier(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pMemoryBarriers + i, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
    }
    local_bufferMemoryBarrierCount = bufferMemoryBarrierCount;
    local_pBufferMemoryBarriers = nullptr;
    if (pBufferMemoryBarriers)
    {
        local_pBufferMemoryBarriers = (VkBufferMemoryBarrier*)pool->alloc(((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            deepcopy_VkBufferMemoryBarrier(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pBufferMemoryBarriers + i, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
    }
    local_imageMemoryBarrierCount = imageMemoryBarrierCount;
    local_pImageMemoryBarriers = nullptr;
    if (pImageMemoryBarriers)
    {
        local_pImageMemoryBarriers = (VkImageMemoryBarrier*)pool->alloc(((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            deepcopy_VkImageMemoryBarrier(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pImageMemoryBarriers + i, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    if (local_pMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            transform_tohost_VkMemoryBarrier(sResourceTracker, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
    }
    if (local_pBufferMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            transform_tohost_VkBufferMemoryBarrier(sResourceTracker, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
    }
    if (local_pImageMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            transform_tohost_VkImageMemoryBarrier(sResourceTracker, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        if (((eventCount)))
        {
            *countPtr += ((eventCount)) * 8;
        }
        *countPtr += sizeof(VkPipelineStageFlags);
        *countPtr += sizeof(VkPipelineStageFlags);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            count_VkMemoryBarrier(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryBarrier*)(local_pMemoryBarriers + i), countPtr);
        }
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            count_VkBufferMemoryBarrier(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i), countPtr);
        }
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            count_VkImageMemoryBarrier(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdWaitEvents = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdWaitEvents -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdWaitEvents);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdWaitEvents = OP_vkCmdWaitEvents;
    memcpy(streamPtr, &opcode_vkCmdWaitEvents, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdWaitEvents, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_eventCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((eventCount)))
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((eventCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkEvent(local_pEvents[k]);
            memcpy(cgen_var_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((eventCount));
    }
    memcpy(*streamPtrPtr, (VkPipelineStageFlags*)&local_srcStageMask, sizeof(VkPipelineStageFlags));
    *streamPtrPtr += sizeof(VkPipelineStageFlags);
    memcpy(*streamPtrPtr, (VkPipelineStageFlags*)&local_dstStageMask, sizeof(VkPipelineStageFlags));
    *streamPtrPtr += sizeof(VkPipelineStageFlags);
    memcpy(*streamPtrPtr, (uint32_t*)&local_memoryBarrierCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
    {
        reservedmarshal_VkMemoryBarrier(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryBarrier*)(local_pMemoryBarriers + i), streamPtrPtr);
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_bufferMemoryBarrierCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
    {
        reservedmarshal_VkBufferMemoryBarrier(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i), streamPtrPtr);
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_imageMemoryBarrierCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
    {
        reservedmarshal_VkImageMemoryBarrier(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdPipelineBarrier(
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask,
    VkDependencyFlags dependencyFlags,
    uint32_t memoryBarrierCount,
    const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount,
    const VkImageMemoryBarrier* pImageMemoryBarriers,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPipelineStageFlags local_srcStageMask;
    VkPipelineStageFlags local_dstStageMask;
    VkDependencyFlags local_dependencyFlags;
    uint32_t local_memoryBarrierCount;
    VkMemoryBarrier* local_pMemoryBarriers;
    uint32_t local_bufferMemoryBarrierCount;
    VkBufferMemoryBarrier* local_pBufferMemoryBarriers;
    uint32_t local_imageMemoryBarrierCount;
    VkImageMemoryBarrier* local_pImageMemoryBarriers;
    local_commandBuffer = commandBuffer;
    local_srcStageMask = srcStageMask;
    local_dstStageMask = dstStageMask;
    local_dependencyFlags = dependencyFlags;
    local_memoryBarrierCount = memoryBarrierCount;
    local_pMemoryBarriers = nullptr;
    if (pMemoryBarriers)
    {
        local_pMemoryBarriers = (VkMemoryBarrier*)pool->alloc(((memoryBarrierCount)) * sizeof(const VkMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            deepcopy_VkMemoryBarrier(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pMemoryBarriers + i, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
    }
    local_bufferMemoryBarrierCount = bufferMemoryBarrierCount;
    local_pBufferMemoryBarriers = nullptr;
    if (pBufferMemoryBarriers)
    {
        local_pBufferMemoryBarriers = (VkBufferMemoryBarrier*)pool->alloc(((bufferMemoryBarrierCount)) * sizeof(const VkBufferMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            deepcopy_VkBufferMemoryBarrier(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pBufferMemoryBarriers + i, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
    }
    local_imageMemoryBarrierCount = imageMemoryBarrierCount;
    local_pImageMemoryBarriers = nullptr;
    if (pImageMemoryBarriers)
    {
        local_pImageMemoryBarriers = (VkImageMemoryBarrier*)pool->alloc(((imageMemoryBarrierCount)) * sizeof(const VkImageMemoryBarrier));
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            deepcopy_VkImageMemoryBarrier(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pImageMemoryBarriers + i, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    if (local_pMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            transform_tohost_VkMemoryBarrier(sResourceTracker, (VkMemoryBarrier*)(local_pMemoryBarriers + i));
        }
    }
    if (local_pBufferMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            transform_tohost_VkBufferMemoryBarrier(sResourceTracker, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i));
        }
    }
    if (local_pImageMemoryBarriers)
    {
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            transform_tohost_VkImageMemoryBarrier(sResourceTracker, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPipelineStageFlags);
        *countPtr += sizeof(VkPipelineStageFlags);
        *countPtr += sizeof(VkDependencyFlags);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
        {
            count_VkMemoryBarrier(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryBarrier*)(local_pMemoryBarriers + i), countPtr);
        }
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
        {
            count_VkBufferMemoryBarrier(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i), countPtr);
        }
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
        {
            count_VkImageMemoryBarrier(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdPipelineBarrier = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdPipelineBarrier -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdPipelineBarrier);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdPipelineBarrier = OP_vkCmdPipelineBarrier;
    memcpy(streamPtr, &opcode_vkCmdPipelineBarrier, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdPipelineBarrier, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkPipelineStageFlags*)&local_srcStageMask, sizeof(VkPipelineStageFlags));
    *streamPtrPtr += sizeof(VkPipelineStageFlags);
    memcpy(*streamPtrPtr, (VkPipelineStageFlags*)&local_dstStageMask, sizeof(VkPipelineStageFlags));
    *streamPtrPtr += sizeof(VkPipelineStageFlags);
    memcpy(*streamPtrPtr, (VkDependencyFlags*)&local_dependencyFlags, sizeof(VkDependencyFlags));
    *streamPtrPtr += sizeof(VkDependencyFlags);
    memcpy(*streamPtrPtr, (uint32_t*)&local_memoryBarrierCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((memoryBarrierCount)); ++i)
    {
        reservedmarshal_VkMemoryBarrier(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryBarrier*)(local_pMemoryBarriers + i), streamPtrPtr);
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_bufferMemoryBarrierCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((bufferMemoryBarrierCount)); ++i)
    {
        reservedmarshal_VkBufferMemoryBarrier(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferMemoryBarrier*)(local_pBufferMemoryBarriers + i), streamPtrPtr);
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_imageMemoryBarrierCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((imageMemoryBarrierCount)); ++i)
    {
        reservedmarshal_VkImageMemoryBarrier(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageMemoryBarrier*)(local_pImageMemoryBarriers + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBeginQuery(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query,
    VkQueryControlFlags flags,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkQueryPool local_queryPool;
    uint32_t local_query;
    VkQueryControlFlags local_flags;
    local_commandBuffer = commandBuffer;
    local_queryPool = queryPool;
    local_query = query;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(VkQueryControlFlags);
    }
    uint32_t packetSize_vkCmdBeginQuery = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBeginQuery -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBeginQuery);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBeginQuery = OP_vkCmdBeginQuery;
    memcpy(streamPtr, &opcode_vkCmdBeginQuery, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBeginQuery, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_query, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (VkQueryControlFlags*)&local_flags, sizeof(VkQueryControlFlags));
    *streamPtrPtr += sizeof(VkQueryControlFlags);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdEndQuery(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkQueryPool local_queryPool;
    uint32_t local_query;
    local_commandBuffer = commandBuffer;
    local_queryPool = queryPool;
    local_query = query;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdEndQuery = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdEndQuery -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdEndQuery);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdEndQuery = OP_vkCmdEndQuery;
    memcpy(streamPtr, &opcode_vkCmdEndQuery, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdEndQuery, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_query, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdResetQueryPool(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkQueryPool local_queryPool;
    uint32_t local_firstQuery;
    uint32_t local_queryCount;
    local_commandBuffer = commandBuffer;
    local_queryPool = queryPool;
    local_firstQuery = firstQuery;
    local_queryCount = queryCount;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdResetQueryPool = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdResetQueryPool -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdResetQueryPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdResetQueryPool = OP_vkCmdResetQueryPool;
    memcpy(streamPtr, &opcode_vkCmdResetQueryPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdResetQueryPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstQuery, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_queryCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdWriteTimestamp(
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkQueryPool queryPool,
    uint32_t query,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPipelineStageFlagBits local_pipelineStage;
    VkQueryPool local_queryPool;
    uint32_t local_query;
    local_commandBuffer = commandBuffer;
    local_pipelineStage = pipelineStage;
    local_queryPool = queryPool;
    local_query = query;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPipelineStageFlagBits);
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdWriteTimestamp = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdWriteTimestamp -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdWriteTimestamp);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdWriteTimestamp = OP_vkCmdWriteTimestamp;
    memcpy(streamPtr, &opcode_vkCmdWriteTimestamp, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdWriteTimestamp, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkPipelineStageFlagBits*)&local_pipelineStage, sizeof(VkPipelineStageFlagBits));
    *streamPtrPtr += sizeof(VkPipelineStageFlagBits);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_query, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdCopyQueryPoolResults(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    VkDeviceSize stride,
    VkQueryResultFlags flags,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkQueryPool local_queryPool;
    uint32_t local_firstQuery;
    uint32_t local_queryCount;
    VkBuffer local_dstBuffer;
    VkDeviceSize local_dstOffset;
    VkDeviceSize local_stride;
    VkQueryResultFlags local_flags;
    local_commandBuffer = commandBuffer;
    local_queryPool = queryPool;
    local_firstQuery = firstQuery;
    local_queryCount = queryCount;
    local_dstBuffer = dstBuffer;
    local_dstOffset = dstOffset;
    local_stride = stride;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(VkQueryResultFlags);
    }
    uint32_t packetSize_vkCmdCopyQueryPoolResults = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdCopyQueryPoolResults -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdCopyQueryPoolResults);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdCopyQueryPoolResults = OP_vkCmdCopyQueryPoolResults;
    memcpy(streamPtr, &opcode_vkCmdCopyQueryPoolResults, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdCopyQueryPoolResults, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstQuery, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_queryCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&local_dstBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_stride, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (VkQueryResultFlags*)&local_flags, sizeof(VkQueryResultFlags));
    *streamPtrPtr += sizeof(VkQueryResultFlags);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdPushConstants(
    VkCommandBuffer commandBuffer,
    VkPipelineLayout layout,
    VkShaderStageFlags stageFlags,
    uint32_t offset,
    uint32_t size,
    const void* pValues,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPipelineLayout local_layout;
    VkShaderStageFlags local_stageFlags;
    uint32_t local_offset;
    uint32_t local_size;
    void* local_pValues;
    local_commandBuffer = commandBuffer;
    local_layout = layout;
    local_stageFlags = stageFlags;
    local_offset = offset;
    local_size = size;
    // Avoiding deepcopy for pValues
    local_pValues = (void*)pValues;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkShaderStageFlags);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += ((size)) * sizeof(uint8_t);
    }
    uint32_t packetSize_vkCmdPushConstants = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdPushConstants -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdPushConstants);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdPushConstants = OP_vkCmdPushConstants;
    memcpy(streamPtr, &opcode_vkCmdPushConstants, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdPushConstants, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPipelineLayout((*&local_layout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkShaderStageFlags*)&local_stageFlags, sizeof(VkShaderStageFlags));
    *streamPtrPtr += sizeof(VkShaderStageFlags);
    memcpy(*streamPtrPtr, (uint32_t*)&local_offset, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_size, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (void*)local_pValues, ((size)) * sizeof(uint8_t));
    *streamPtrPtr += ((size)) * sizeof(uint8_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBeginRenderPass(
    VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    VkSubpassContents contents,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkRenderPassBeginInfo* local_pRenderPassBegin;
    VkSubpassContents local_contents;
    local_commandBuffer = commandBuffer;
    local_pRenderPassBegin = nullptr;
    if (pRenderPassBegin)
    {
        local_pRenderPassBegin = (VkRenderPassBeginInfo*)pool->alloc(sizeof(const VkRenderPassBeginInfo));
        deepcopy_VkRenderPassBeginInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pRenderPassBegin, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    }
    local_contents = contents;
    if (local_pRenderPassBegin)
    {
        transform_tohost_VkRenderPassBeginInfo(sResourceTracker, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkRenderPassBeginInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRenderPassBeginInfo*)(local_pRenderPassBegin), countPtr);
        *countPtr += sizeof(VkSubpassContents);
    }
    uint32_t packetSize_vkCmdBeginRenderPass = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBeginRenderPass -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBeginRenderPass);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBeginRenderPass = OP_vkCmdBeginRenderPass;
    memcpy(streamPtr, &opcode_vkCmdBeginRenderPass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBeginRenderPass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkRenderPassBeginInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRenderPassBeginInfo*)(local_pRenderPassBegin), streamPtrPtr);
    memcpy(*streamPtrPtr, (VkSubpassContents*)&local_contents, sizeof(VkSubpassContents));
    *streamPtrPtr += sizeof(VkSubpassContents);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdNextSubpass(
    VkCommandBuffer commandBuffer,
    VkSubpassContents contents,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkSubpassContents local_contents;
    local_commandBuffer = commandBuffer;
    local_contents = contents;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkSubpassContents);
    }
    uint32_t packetSize_vkCmdNextSubpass = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdNextSubpass -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdNextSubpass);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdNextSubpass = OP_vkCmdNextSubpass;
    memcpy(streamPtr, &opcode_vkCmdNextSubpass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdNextSubpass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkSubpassContents*)&local_contents, sizeof(VkSubpassContents));
    *streamPtrPtr += sizeof(VkSubpassContents);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdEndRenderPass(
    VkCommandBuffer commandBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkCmdEndRenderPass = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdEndRenderPass -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdEndRenderPass);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdEndRenderPass = OP_vkCmdEndRenderPass;
    memcpy(streamPtr, &opcode_vkCmdEndRenderPass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdEndRenderPass, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdExecuteCommands(
    VkCommandBuffer commandBuffer,
    uint32_t commandBufferCount,
    const VkCommandBuffer* pCommandBuffers,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_commandBufferCount;
    VkCommandBuffer* local_pCommandBuffers;
    local_commandBuffer = commandBuffer;
    local_commandBufferCount = commandBufferCount;
    // Avoiding deepcopy for pCommandBuffers
    local_pCommandBuffers = (VkCommandBuffer*)pCommandBuffers;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        if (((commandBufferCount)))
        {
            *countPtr += ((commandBufferCount)) * 8;
        }
    }
    uint32_t packetSize_vkCmdExecuteCommands = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdExecuteCommands -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdExecuteCommands);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdExecuteCommands = OP_vkCmdExecuteCommands;
    memcpy(streamPtr, &opcode_vkCmdExecuteCommands, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdExecuteCommands, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_commandBufferCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((commandBufferCount)))
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((commandBufferCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkCommandBuffer(local_pCommandBuffers[k]);
            memcpy(cgen_var_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((commandBufferCount));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_VERSION_1_1
VkResult VkEncoder::vkEnumerateInstanceVersion(
    uint32_t* pApiVersion,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    size_t count = 0;
    size_t* countPtr = &count;
    {
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkEnumerateInstanceVersion = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEnumerateInstanceVersion);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEnumerateInstanceVersion = OP_vkEnumerateInstanceVersion;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkEnumerateInstanceVersion, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEnumerateInstanceVersion, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    memcpy(*streamPtrPtr, (uint32_t*)pApiVersion, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    stream->read((uint32_t*)pApiVersion, sizeof(uint32_t));
    VkResult vkEnumerateInstanceVersion_VkResult_return = (VkResult)0;
    stream->read(&vkEnumerateInstanceVersion_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEnumerateInstanceVersion_VkResult_return;
}

VkResult VkEncoder::vkBindBufferMemory2(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_bindInfoCount;
    VkBindBufferMemoryInfo* local_pBindInfos;
    local_device = device;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfos = nullptr;
    if (pBindInfos)
    {
        local_pBindInfos = (VkBindBufferMemoryInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindBufferMemoryInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pBindInfos + i, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    if (local_pBindInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindBufferMemoryInfo(sResourceTracker, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            count_VkBindBufferMemoryInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindBufferMemoryInfo*)(local_pBindInfos + i), countPtr);
        }
    }
    uint32_t packetSize_vkBindBufferMemory2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkBindBufferMemory2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkBindBufferMemory2 = OP_vkBindBufferMemory2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkBindBufferMemory2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkBindBufferMemory2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        reservedmarshal_VkBindBufferMemoryInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindBufferMemoryInfo*)(local_pBindInfos + i), streamPtrPtr);
    }
    VkResult vkBindBufferMemory2_VkResult_return = (VkResult)0;
    stream->read(&vkBindBufferMemory2_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkBindBufferMemory2_VkResult_return;
}

VkResult VkEncoder::vkBindImageMemory2(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_bindInfoCount;
    VkBindImageMemoryInfo* local_pBindInfos;
    local_device = device;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfos = nullptr;
    if (pBindInfos)
    {
        local_pBindInfos = (VkBindImageMemoryInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindImageMemoryInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pBindInfos + i, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    if (local_pBindInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindImageMemoryInfo(sResourceTracker, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            count_VkBindImageMemoryInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindImageMemoryInfo*)(local_pBindInfos + i), countPtr);
        }
    }
    uint32_t packetSize_vkBindImageMemory2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkBindImageMemory2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkBindImageMemory2 = OP_vkBindImageMemory2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkBindImageMemory2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkBindImageMemory2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        reservedmarshal_VkBindImageMemoryInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindImageMemoryInfo*)(local_pBindInfos + i), streamPtrPtr);
    }
    VkResult vkBindImageMemory2_VkResult_return = (VkResult)0;
    stream->read(&vkBindImageMemory2_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkBindImageMemory2_VkResult_return;
}

void VkEncoder::vkGetDeviceGroupPeerMemoryFeatures(
    VkDevice device,
    uint32_t heapIndex,
    uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_heapIndex;
    uint32_t local_localDeviceIndex;
    uint32_t local_remoteDeviceIndex;
    local_device = device;
    local_heapIndex = heapIndex;
    local_localDeviceIndex = localDeviceIndex;
    local_remoteDeviceIndex = remoteDeviceIndex;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(VkPeerMemoryFeatureFlags);
    }
    uint32_t packetSize_vkGetDeviceGroupPeerMemoryFeatures = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceGroupPeerMemoryFeatures);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceGroupPeerMemoryFeatures = OP_vkGetDeviceGroupPeerMemoryFeatures;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceGroupPeerMemoryFeatures, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceGroupPeerMemoryFeatures, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_heapIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_localDeviceIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_remoteDeviceIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    *streamPtrPtr += sizeof(VkPeerMemoryFeatureFlags);
    stream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetDeviceMask(
    VkCommandBuffer commandBuffer,
    uint32_t deviceMask,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_deviceMask;
    local_commandBuffer = commandBuffer;
    local_deviceMask = deviceMask;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdSetDeviceMask = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetDeviceMask -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetDeviceMask);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetDeviceMask = OP_vkCmdSetDeviceMask;
    memcpy(streamPtr, &opcode_vkCmdSetDeviceMask, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetDeviceMask, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_deviceMask, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDispatchBase(
    VkCommandBuffer commandBuffer,
    uint32_t baseGroupX,
    uint32_t baseGroupY,
    uint32_t baseGroupZ,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_baseGroupX;
    uint32_t local_baseGroupY;
    uint32_t local_baseGroupZ;
    uint32_t local_groupCountX;
    uint32_t local_groupCountY;
    uint32_t local_groupCountZ;
    local_commandBuffer = commandBuffer;
    local_baseGroupX = baseGroupX;
    local_baseGroupY = baseGroupY;
    local_baseGroupZ = baseGroupZ;
    local_groupCountX = groupCountX;
    local_groupCountY = groupCountY;
    local_groupCountZ = groupCountZ;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDispatchBase = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDispatchBase -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDispatchBase);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDispatchBase = OP_vkCmdDispatchBase;
    memcpy(streamPtr, &opcode_vkCmdDispatchBase, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDispatchBase, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_baseGroupX, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_baseGroupY, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_baseGroupZ, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCountX, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCountY, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCountZ, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkEnumeratePhysicalDeviceGroups(
    VkInstance instance,
    uint32_t* pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    local_instance = instance;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPhysicalDeviceGroupCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPhysicalDeviceGroupProperties)
        {
            if (pPhysicalDeviceGroupCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                {
                    count_VkPhysicalDeviceGroupProperties(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkEnumeratePhysicalDeviceGroups = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEnumeratePhysicalDeviceGroups);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEnumeratePhysicalDeviceGroups = OP_vkEnumeratePhysicalDeviceGroups;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkEnumeratePhysicalDeviceGroups, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEnumeratePhysicalDeviceGroups, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPhysicalDeviceGroupCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPhysicalDeviceGroupProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            reservedmarshal_VkPhysicalDeviceGroupProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPhysicalDeviceGroupCount;
    check_pPhysicalDeviceGroupCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceGroupCount)
    {
        if (!(check_pPhysicalDeviceGroupCount))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPhysicalDeviceGroupProperties* check_pPhysicalDeviceGroupProperties;
    check_pPhysicalDeviceGroupProperties = (VkPhysicalDeviceGroupProperties*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceGroupProperties)
    {
        if (!(check_pPhysicalDeviceGroupProperties))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupProperties inconsistent between guest and host\n");
        }
        if (pPhysicalDeviceGroupCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
            {
                unmarshal_VkPhysicalDeviceGroupProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
            }
        }
    }
    if (pPhysicalDeviceGroupCount)
    {
        if (pPhysicalDeviceGroupProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
            {
                transform_fromhost_VkPhysicalDeviceGroupProperties(sResourceTracker, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
            }
        }
    }
    VkResult vkEnumeratePhysicalDeviceGroups_VkResult_return = (VkResult)0;
    stream->read(&vkEnumeratePhysicalDeviceGroups_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEnumeratePhysicalDeviceGroups_VkResult_return;
}

void VkEncoder::vkGetImageMemoryRequirements2(
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImageMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkImageMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkImageMemoryRequirementsInfo2));
        deepcopy_VkImageMemoryRequirementsInfo2(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkImageMemoryRequirementsInfo2(sResourceTracker, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkImageMemoryRequirementsInfo2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageMemoryRequirementsInfo2*)(local_pInfo), countPtr);
        count_VkMemoryRequirements2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements), countPtr);
    }
    uint32_t packetSize_vkGetImageMemoryRequirements2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetImageMemoryRequirements2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetImageMemoryRequirements2 = OP_vkGetImageMemoryRequirements2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetImageMemoryRequirements2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetImageMemoryRequirements2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageMemoryRequirementsInfo2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageMemoryRequirementsInfo2*)(local_pInfo), streamPtrPtr);
    reservedmarshal_VkMemoryRequirements2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements), streamPtrPtr);
    unmarshal_VkMemoryRequirements2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements2(sResourceTracker, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetBufferMemoryRequirements2(
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBufferMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkBufferMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkBufferMemoryRequirementsInfo2));
        deepcopy_VkBufferMemoryRequirementsInfo2(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkBufferMemoryRequirementsInfo2(sResourceTracker, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkBufferMemoryRequirementsInfo2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferMemoryRequirementsInfo2*)(local_pInfo), countPtr);
        count_VkMemoryRequirements2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements), countPtr);
    }
    uint32_t packetSize_vkGetBufferMemoryRequirements2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetBufferMemoryRequirements2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetBufferMemoryRequirements2 = OP_vkGetBufferMemoryRequirements2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetBufferMemoryRequirements2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetBufferMemoryRequirements2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkBufferMemoryRequirementsInfo2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferMemoryRequirementsInfo2*)(local_pInfo), streamPtrPtr);
    reservedmarshal_VkMemoryRequirements2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements), streamPtrPtr);
    unmarshal_VkMemoryRequirements2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements2(sResourceTracker, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetImageSparseMemoryRequirements2(
    VkDevice device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImageSparseMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkImageSparseMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkImageSparseMemoryRequirementsInfo2));
        deepcopy_VkImageSparseMemoryRequirementsInfo2(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkImageSparseMemoryRequirementsInfo2(sResourceTracker, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkImageSparseMemoryRequirementsInfo2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSparseMemoryRequirementCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSparseMemoryRequirements)
        {
            if (pSparseMemoryRequirementCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                {
                    count_VkSparseImageMemoryRequirements2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetImageSparseMemoryRequirements2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetImageSparseMemoryRequirements2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetImageSparseMemoryRequirements2 = OP_vkGetImageSparseMemoryRequirements2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetImageSparseMemoryRequirements2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetImageSparseMemoryRequirements2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageSparseMemoryRequirementsInfo2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSparseMemoryRequirementCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            reservedmarshal_VkSparseImageMemoryRequirements2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pSparseMemoryRequirementCount;
    check_pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirementCount)
    {
        if (!(check_pSparseMemoryRequirementCount))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirementCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageMemoryRequirements2* check_pSparseMemoryRequirements;
    check_pSparseMemoryRequirements = (VkSparseImageMemoryRequirements2*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirements)
    {
        if (!(check_pSparseMemoryRequirements))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirements inconsistent between guest and host\n");
        }
        if (pSparseMemoryRequirementCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
            {
                unmarshal_VkSparseImageMemoryRequirements2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
            }
        }
    }
    if (pSparseMemoryRequirementCount)
    {
        if (pSparseMemoryRequirements)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
            {
                transform_fromhost_VkSparseImageMemoryRequirements2(sResourceTracker, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
            }
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceFeatures2(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures2* pFeatures,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceFeatures2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFeatures2*)(pFeatures), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceFeatures2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceFeatures2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceFeatures2 = OP_vkGetPhysicalDeviceFeatures2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceFeatures2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceFeatures2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceFeatures2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFeatures2*)(pFeatures), streamPtrPtr);
    unmarshal_VkPhysicalDeviceFeatures2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFeatures2*)(pFeatures));
    if (pFeatures)
    {
        transform_fromhost_VkPhysicalDeviceFeatures2(sResourceTracker, (VkPhysicalDeviceFeatures2*)(pFeatures));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceProperties2(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties2* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceProperties2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceProperties2*)(pProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceProperties2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceProperties2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceProperties2 = OP_vkGetPhysicalDeviceProperties2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceProperties2*)(pProperties), streamPtrPtr);
    unmarshal_VkPhysicalDeviceProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceProperties2*)(pProperties));
    if (pProperties)
    {
        transform_fromhost_VkPhysicalDeviceProperties2(sResourceTracker, (VkPhysicalDeviceProperties2*)(pProperties));
    }
    sResourceTracker->on_vkGetPhysicalDeviceProperties2(this, physicalDevice, pProperties);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceFormatProperties2(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties2* pFormatProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    local_physicalDevice = physicalDevice;
    local_format = format;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkFormat);
        count_VkFormatProperties2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFormatProperties2*)(pFormatProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceFormatProperties2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceFormatProperties2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceFormatProperties2 = OP_vkGetPhysicalDeviceFormatProperties2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceFormatProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceFormatProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkFormat*)&local_format, sizeof(VkFormat));
    *streamPtrPtr += sizeof(VkFormat);
    reservedmarshal_VkFormatProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFormatProperties2*)(pFormatProperties), streamPtrPtr);
    unmarshal_VkFormatProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFormatProperties2*)(pFormatProperties));
    if (pFormatProperties)
    {
        transform_fromhost_VkFormatProperties2(sResourceTracker, (VkFormatProperties2*)(pFormatProperties));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkGetPhysicalDeviceImageFormatProperties2(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceImageFormatInfo2* local_pImageFormatInfo;
    local_physicalDevice = physicalDevice;
    local_pImageFormatInfo = nullptr;
    if (pImageFormatInfo)
    {
        local_pImageFormatInfo = (VkPhysicalDeviceImageFormatInfo2*)pool->alloc(sizeof(const VkPhysicalDeviceImageFormatInfo2));
        deepcopy_VkPhysicalDeviceImageFormatInfo2(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pImageFormatInfo, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    }
    if (local_pImageFormatInfo)
    {
        transform_tohost_VkPhysicalDeviceImageFormatInfo2(sResourceTracker, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceImageFormatInfo2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo), countPtr);
        count_VkImageFormatProperties2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageFormatProperties2*)(pImageFormatProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceImageFormatProperties2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceImageFormatProperties2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceImageFormatProperties2 = OP_vkGetPhysicalDeviceImageFormatProperties2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceImageFormatProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceImageFormatProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceImageFormatInfo2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo), streamPtrPtr);
    reservedmarshal_VkImageFormatProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageFormatProperties2*)(pImageFormatProperties), streamPtrPtr);
    unmarshal_VkImageFormatProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageFormatProperties2*)(pImageFormatProperties));
    if (pImageFormatProperties)
    {
        transform_fromhost_VkImageFormatProperties2(sResourceTracker, (VkImageFormatProperties2*)(pImageFormatProperties));
    }
    VkResult vkGetPhysicalDeviceImageFormatProperties2_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceImageFormatProperties2_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceImageFormatProperties2_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceQueueFamilyProperties2(
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pQueueFamilyPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pQueueFamilyProperties)
        {
            if (pQueueFamilyPropertyCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                {
                    count_VkQueueFamilyProperties2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceQueueFamilyProperties2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceQueueFamilyProperties2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceQueueFamilyProperties2 = OP_vkGetPhysicalDeviceQueueFamilyProperties2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceQueueFamilyProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceQueueFamilyProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pQueueFamilyPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            reservedmarshal_VkQueueFamilyProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pQueueFamilyPropertyCount;
    check_pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyPropertyCount)
    {
        if (!(check_pQueueFamilyPropertyCount))
        {
            fprintf(stderr, "fatal: pQueueFamilyPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkQueueFamilyProperties2* check_pQueueFamilyProperties;
    check_pQueueFamilyProperties = (VkQueueFamilyProperties2*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyProperties)
    {
        if (!(check_pQueueFamilyProperties))
        {
            fprintf(stderr, "fatal: pQueueFamilyProperties inconsistent between guest and host\n");
        }
        if (pQueueFamilyPropertyCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
            {
                unmarshal_VkQueueFamilyProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
            }
        }
    }
    if (pQueueFamilyPropertyCount)
    {
        if (pQueueFamilyProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
            {
                transform_fromhost_VkQueueFamilyProperties2(sResourceTracker, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
            }
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceMemoryProperties2(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceMemoryProperties2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceMemoryProperties2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceMemoryProperties2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceMemoryProperties2 = OP_vkGetPhysicalDeviceMemoryProperties2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceMemoryProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceMemoryProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceMemoryProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties), streamPtrPtr);
    unmarshal_VkPhysicalDeviceMemoryProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    if (pMemoryProperties)
    {
        transform_fromhost_VkPhysicalDeviceMemoryProperties2(sResourceTracker, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    }
    sResourceTracker->on_vkGetPhysicalDeviceMemoryProperties2(this, physicalDevice, pMemoryProperties);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceSparseImageFormatProperties2(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceSparseImageFormatInfo2* local_pFormatInfo;
    local_physicalDevice = physicalDevice;
    local_pFormatInfo = nullptr;
    if (pFormatInfo)
    {
        local_pFormatInfo = (VkPhysicalDeviceSparseImageFormatInfo2*)pool->alloc(sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
        deepcopy_VkPhysicalDeviceSparseImageFormatInfo2(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pFormatInfo, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    }
    if (local_pFormatInfo)
    {
        transform_tohost_VkPhysicalDeviceSparseImageFormatInfo2(sResourceTracker, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceSparseImageFormatInfo2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            if (pPropertyCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                {
                    count_VkSparseImageFormatProperties2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageFormatProperties2*)(pProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSparseImageFormatProperties2 = OP_vkGetPhysicalDeviceSparseImageFormatProperties2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSparseImageFormatProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceSparseImageFormatInfo2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkSparseImageFormatProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageFormatProperties2*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageFormatProperties2* check_pProperties;
    check_pProperties = (VkSparseImageFormatProperties2*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        if (pPropertyCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                unmarshal_VkSparseImageFormatProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageFormatProperties2*)(pProperties + i));
            }
        }
    }
    if (pPropertyCount)
    {
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                transform_fromhost_VkSparseImageFormatProperties2(sResourceTracker, (VkSparseImageFormatProperties2*)(pProperties + i));
            }
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkTrimCommandPool(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolTrimFlags flags,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkCommandPool local_commandPool;
    VkCommandPoolTrimFlags local_flags;
    local_device = device;
    local_commandPool = commandPool;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkCommandPoolTrimFlags);
    }
    uint32_t packetSize_vkTrimCommandPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkTrimCommandPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkTrimCommandPool = OP_vkTrimCommandPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkTrimCommandPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkTrimCommandPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkCommandPool((*&local_commandPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkCommandPoolTrimFlags*)&local_flags, sizeof(VkCommandPoolTrimFlags));
    *streamPtrPtr += sizeof(VkCommandPoolTrimFlags);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetDeviceQueue2(
    VkDevice device,
    const VkDeviceQueueInfo2* pQueueInfo,
    VkQueue* pQueue,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeviceQueueInfo2* local_pQueueInfo;
    local_device = device;
    local_pQueueInfo = nullptr;
    if (pQueueInfo)
    {
        local_pQueueInfo = (VkDeviceQueueInfo2*)pool->alloc(sizeof(const VkDeviceQueueInfo2));
        deepcopy_VkDeviceQueueInfo2(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pQueueInfo, (VkDeviceQueueInfo2*)(local_pQueueInfo));
    }
    if (local_pQueueInfo)
    {
        transform_tohost_VkDeviceQueueInfo2(sResourceTracker, (VkDeviceQueueInfo2*)(local_pQueueInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDeviceQueueInfo2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceQueueInfo2*)(local_pQueueInfo), countPtr);
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkGetDeviceQueue2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceQueue2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceQueue2 = OP_vkGetDeviceQueue2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceQueue2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceQueue2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDeviceQueueInfo2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceQueueInfo2*)(local_pQueueInfo), streamPtrPtr);
    /* is handle, possibly out */;
    uint64_t cgen_var_1;
    *&cgen_var_1 = (uint64_t)((*pQueue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    stream->read((uint64_t*)&cgen_var_2, 8);
    stream->handleMapping()->mapHandles_u64_VkQueue(&cgen_var_2, (VkQueue*)pQueue, 1);
    sResourceTracker->on_vkGetDeviceQueue2(this, device, pQueueInfo, pQueue);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateSamplerYcbcrConversion(
    VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSamplerYcbcrConversionCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSamplerYcbcrConversionCreateInfo*)pool->alloc(sizeof(const VkSamplerYcbcrConversionCreateInfo));
        deepcopy_VkSamplerYcbcrConversionCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSamplerYcbcrConversionCreateInfo(sResourceTracker, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkSamplerYcbcrConversionCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateSamplerYcbcrConversion = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateSamplerYcbcrConversion);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateSamplerYcbcrConversion = OP_vkCreateSamplerYcbcrConversion;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateSamplerYcbcrConversion, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateSamplerYcbcrConversion, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSamplerYcbcrConversionCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pYcbcrConversion));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_3, (VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateSamplerYcbcrConversion_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSamplerYcbcrConversion_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateSamplerYcbcrConversion_VkResult_return;
}

void VkEncoder::vkDestroySamplerYcbcrConversion(
    VkDevice device,
    VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSamplerYcbcrConversion local_ycbcrConversion;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_ycbcrConversion = ycbcrConversion;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroySamplerYcbcrConversion = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroySamplerYcbcrConversion);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroySamplerYcbcrConversion = OP_vkDestroySamplerYcbcrConversion;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroySamplerYcbcrConversion, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroySamplerYcbcrConversion, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSamplerYcbcrConversion((*&local_ycbcrConversion));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkSamplerYcbcrConversion((VkSamplerYcbcrConversion*)&ycbcrConversion);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateDescriptorUpdateTemplate(
    VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorUpdateTemplateCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorUpdateTemplateCreateInfo*)pool->alloc(sizeof(const VkDescriptorUpdateTemplateCreateInfo));
        deepcopy_VkDescriptorUpdateTemplateCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorUpdateTemplateCreateInfo(sResourceTracker, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDescriptorUpdateTemplateCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDescriptorUpdateTemplate = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDescriptorUpdateTemplate);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDescriptorUpdateTemplate = OP_vkCreateDescriptorUpdateTemplate;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDescriptorUpdateTemplate, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDescriptorUpdateTemplate, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDescriptorUpdateTemplateCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pDescriptorUpdateTemplate));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_3, (VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDescriptorUpdateTemplate_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorUpdateTemplate_VkResult_return, sizeof(VkResult));
    sResourceTracker->on_vkCreateDescriptorUpdateTemplate(this, vkCreateDescriptorUpdateTemplate_VkResult_return, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDescriptorUpdateTemplate_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorUpdateTemplate(
    VkDevice device,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyDescriptorUpdateTemplate = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyDescriptorUpdateTemplate);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyDescriptorUpdateTemplate = OP_vkDestroyDescriptorUpdateTemplate;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyDescriptorUpdateTemplate, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyDescriptorUpdateTemplate, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDescriptorUpdateTemplate((*&local_descriptorUpdateTemplate));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkUpdateDescriptorSetWithTemplate(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const void* pData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorSet local_descriptorSet;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    void* local_pData;
    local_device = device;
    local_descriptorSet = descriptorSet;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    // Avoiding deepcopy for pData
    local_pData = (void*)pData;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pData)
        {
            *countPtr += sizeof(uint8_t);
        }
    }
    uint32_t packetSize_vkUpdateDescriptorSetWithTemplate = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkUpdateDescriptorSetWithTemplate);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkUpdateDescriptorSetWithTemplate = OP_vkUpdateDescriptorSetWithTemplate;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkUpdateDescriptorSetWithTemplate, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkUpdateDescriptorSetWithTemplate, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDescriptorSet((*&local_descriptorSet));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_2;
    *&cgen_var_2 = get_host_u64_VkDescriptorUpdateTemplate((*&local_descriptorUpdateTemplate));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)local_pData;
    memcpy((*streamPtrPtr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pData)
    {
        memcpy(*streamPtrPtr, (void*)local_pData, sizeof(uint8_t));
        *streamPtrPtr += sizeof(uint8_t);
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceExternalBufferProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalBufferInfo* local_pExternalBufferInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalBufferInfo = nullptr;
    if (pExternalBufferInfo)
    {
        local_pExternalBufferInfo = (VkPhysicalDeviceExternalBufferInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalBufferInfo));
        deepcopy_VkPhysicalDeviceExternalBufferInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pExternalBufferInfo, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    }
    if (local_pExternalBufferInfo)
    {
        sResourceTracker->transformImpl_VkPhysicalDeviceExternalBufferInfo_tohost(local_pExternalBufferInfo, 1);
        transform_tohost_VkPhysicalDeviceExternalBufferInfo(sResourceTracker, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceExternalBufferInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo), countPtr);
        count_VkExternalBufferProperties(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalBufferProperties*)(pExternalBufferProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalBufferProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceExternalBufferProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceExternalBufferProperties = OP_vkGetPhysicalDeviceExternalBufferProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceExternalBufferProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceExternalBufferProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceExternalBufferInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo), streamPtrPtr);
    reservedmarshal_VkExternalBufferProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalBufferProperties*)(pExternalBufferProperties), streamPtrPtr);
    unmarshal_VkExternalBufferProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalBufferProperties*)(pExternalBufferProperties));
    if (pExternalBufferProperties)
    {
        sResourceTracker->transformImpl_VkExternalBufferProperties_fromhost(pExternalBufferProperties, 1);
        transform_fromhost_VkExternalBufferProperties(sResourceTracker, (VkExternalBufferProperties*)(pExternalBufferProperties));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceExternalFenceProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalFenceInfo* local_pExternalFenceInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalFenceInfo = nullptr;
    if (pExternalFenceInfo)
    {
        local_pExternalFenceInfo = (VkPhysicalDeviceExternalFenceInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalFenceInfo));
        deepcopy_VkPhysicalDeviceExternalFenceInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pExternalFenceInfo, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    }
    if (local_pExternalFenceInfo)
    {
        transform_tohost_VkPhysicalDeviceExternalFenceInfo(sResourceTracker, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceExternalFenceInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo), countPtr);
        count_VkExternalFenceProperties(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalFenceProperties*)(pExternalFenceProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalFenceProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceExternalFenceProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceExternalFenceProperties = OP_vkGetPhysicalDeviceExternalFenceProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceExternalFenceProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceExternalFenceProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceExternalFenceInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo), streamPtrPtr);
    reservedmarshal_VkExternalFenceProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalFenceProperties*)(pExternalFenceProperties), streamPtrPtr);
    unmarshal_VkExternalFenceProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalFenceProperties*)(pExternalFenceProperties));
    if (pExternalFenceProperties)
    {
        transform_fromhost_VkExternalFenceProperties(sResourceTracker, (VkExternalFenceProperties*)(pExternalFenceProperties));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceExternalSemaphoreProperties(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalSemaphoreInfo* local_pExternalSemaphoreInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalSemaphoreInfo = nullptr;
    if (pExternalSemaphoreInfo)
    {
        local_pExternalSemaphoreInfo = (VkPhysicalDeviceExternalSemaphoreInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
        deepcopy_VkPhysicalDeviceExternalSemaphoreInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pExternalSemaphoreInfo, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    }
    if (local_pExternalSemaphoreInfo)
    {
        transform_tohost_VkPhysicalDeviceExternalSemaphoreInfo(sResourceTracker, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceExternalSemaphoreInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo), countPtr);
        count_VkExternalSemaphoreProperties(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalSemaphoreProperties = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceExternalSemaphoreProperties);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceExternalSemaphoreProperties = OP_vkGetPhysicalDeviceExternalSemaphoreProperties;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceExternalSemaphoreProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceExternalSemaphoreProperties, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceExternalSemaphoreInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo), streamPtrPtr);
    reservedmarshal_VkExternalSemaphoreProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties), streamPtrPtr);
    unmarshal_VkExternalSemaphoreProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    if (pExternalSemaphoreProperties)
    {
        transform_fromhost_VkExternalSemaphoreProperties(sResourceTracker, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    }
    sResourceTracker->on_vkGetPhysicalDeviceExternalSemaphoreProperties(this, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetDescriptorSetLayoutSupport(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorSetLayoutCreateInfo* local_pCreateInfo;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorSetLayoutCreateInfo*)pool->alloc(sizeof(const VkDescriptorSetLayoutCreateInfo));
        deepcopy_VkDescriptorSetLayoutCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorSetLayoutCreateInfo(sResourceTracker, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDescriptorSetLayoutCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo), countPtr);
        count_VkDescriptorSetLayoutSupport(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutSupport*)(pSupport), countPtr);
    }
    uint32_t packetSize_vkGetDescriptorSetLayoutSupport = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDescriptorSetLayoutSupport);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDescriptorSetLayoutSupport = OP_vkGetDescriptorSetLayoutSupport;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDescriptorSetLayoutSupport, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDescriptorSetLayoutSupport, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDescriptorSetLayoutCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    reservedmarshal_VkDescriptorSetLayoutSupport(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutSupport*)(pSupport), streamPtrPtr);
    unmarshal_VkDescriptorSetLayoutSupport(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutSupport*)(pSupport));
    if (pSupport)
    {
        transform_fromhost_VkDescriptorSetLayoutSupport(sResourceTracker, (VkDescriptorSetLayoutSupport*)(pSupport));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_VERSION_1_2
void VkEncoder::vkCmdDrawIndirectCount(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawIndirectCount = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawIndirectCount -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawIndirectCount);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawIndirectCount = OP_vkCmdDrawIndirectCount;
    memcpy(streamPtr, &opcode_vkCmdDrawIndirectCount, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawIndirectCount, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&local_countBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_stride, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDrawIndexedIndirectCount(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawIndexedIndirectCount = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawIndexedIndirectCount -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawIndexedIndirectCount);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawIndexedIndirectCount = OP_vkCmdDrawIndexedIndirectCount;
    memcpy(streamPtr, &opcode_vkCmdDrawIndexedIndirectCount, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawIndexedIndirectCount, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&local_countBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_stride, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateRenderPass2(
    VkDevice device,
    const VkRenderPassCreateInfo2* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkRenderPassCreateInfo2* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkRenderPassCreateInfo2*)pool->alloc(sizeof(const VkRenderPassCreateInfo2));
        deepcopy_VkRenderPassCreateInfo2(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkRenderPassCreateInfo2*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkRenderPassCreateInfo2(sResourceTracker, (VkRenderPassCreateInfo2*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkRenderPassCreateInfo2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRenderPassCreateInfo2*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateRenderPass2 = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateRenderPass2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateRenderPass2 = OP_vkCreateRenderPass2;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateRenderPass2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateRenderPass2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkRenderPassCreateInfo2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRenderPassCreateInfo2*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pRenderPass));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_3, (VkRenderPass*)pRenderPass, 1);
    VkResult vkCreateRenderPass2_VkResult_return = (VkResult)0;
    stream->read(&vkCreateRenderPass2_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateRenderPass2_VkResult_return;
}

void VkEncoder::vkCmdBeginRenderPass2(
    VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    const VkSubpassBeginInfo* pSubpassBeginInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkRenderPassBeginInfo* local_pRenderPassBegin;
    VkSubpassBeginInfo* local_pSubpassBeginInfo;
    local_commandBuffer = commandBuffer;
    local_pRenderPassBegin = nullptr;
    if (pRenderPassBegin)
    {
        local_pRenderPassBegin = (VkRenderPassBeginInfo*)pool->alloc(sizeof(const VkRenderPassBeginInfo));
        deepcopy_VkRenderPassBeginInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pRenderPassBegin, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    }
    local_pSubpassBeginInfo = nullptr;
    if (pSubpassBeginInfo)
    {
        local_pSubpassBeginInfo = (VkSubpassBeginInfo*)pool->alloc(sizeof(const VkSubpassBeginInfo));
        deepcopy_VkSubpassBeginInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pSubpassBeginInfo, (VkSubpassBeginInfo*)(local_pSubpassBeginInfo));
    }
    if (local_pRenderPassBegin)
    {
        transform_tohost_VkRenderPassBeginInfo(sResourceTracker, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    }
    if (local_pSubpassBeginInfo)
    {
        transform_tohost_VkSubpassBeginInfo(sResourceTracker, (VkSubpassBeginInfo*)(local_pSubpassBeginInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkRenderPassBeginInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRenderPassBeginInfo*)(local_pRenderPassBegin), countPtr);
        count_VkSubpassBeginInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassBeginInfo*)(local_pSubpassBeginInfo), countPtr);
    }
    uint32_t packetSize_vkCmdBeginRenderPass2 = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBeginRenderPass2 -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBeginRenderPass2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBeginRenderPass2 = OP_vkCmdBeginRenderPass2;
    memcpy(streamPtr, &opcode_vkCmdBeginRenderPass2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBeginRenderPass2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkRenderPassBeginInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRenderPassBeginInfo*)(local_pRenderPassBegin), streamPtrPtr);
    reservedmarshal_VkSubpassBeginInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassBeginInfo*)(local_pSubpassBeginInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdNextSubpass2(
    VkCommandBuffer commandBuffer,
    const VkSubpassBeginInfo* pSubpassBeginInfo,
    const VkSubpassEndInfo* pSubpassEndInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkSubpassBeginInfo* local_pSubpassBeginInfo;
    VkSubpassEndInfo* local_pSubpassEndInfo;
    local_commandBuffer = commandBuffer;
    local_pSubpassBeginInfo = nullptr;
    if (pSubpassBeginInfo)
    {
        local_pSubpassBeginInfo = (VkSubpassBeginInfo*)pool->alloc(sizeof(const VkSubpassBeginInfo));
        deepcopy_VkSubpassBeginInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pSubpassBeginInfo, (VkSubpassBeginInfo*)(local_pSubpassBeginInfo));
    }
    local_pSubpassEndInfo = nullptr;
    if (pSubpassEndInfo)
    {
        local_pSubpassEndInfo = (VkSubpassEndInfo*)pool->alloc(sizeof(const VkSubpassEndInfo));
        deepcopy_VkSubpassEndInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pSubpassEndInfo, (VkSubpassEndInfo*)(local_pSubpassEndInfo));
    }
    if (local_pSubpassBeginInfo)
    {
        transform_tohost_VkSubpassBeginInfo(sResourceTracker, (VkSubpassBeginInfo*)(local_pSubpassBeginInfo));
    }
    if (local_pSubpassEndInfo)
    {
        transform_tohost_VkSubpassEndInfo(sResourceTracker, (VkSubpassEndInfo*)(local_pSubpassEndInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkSubpassBeginInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassBeginInfo*)(local_pSubpassBeginInfo), countPtr);
        count_VkSubpassEndInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassEndInfo*)(local_pSubpassEndInfo), countPtr);
    }
    uint32_t packetSize_vkCmdNextSubpass2 = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdNextSubpass2 -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdNextSubpass2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdNextSubpass2 = OP_vkCmdNextSubpass2;
    memcpy(streamPtr, &opcode_vkCmdNextSubpass2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdNextSubpass2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkSubpassBeginInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassBeginInfo*)(local_pSubpassBeginInfo), streamPtrPtr);
    reservedmarshal_VkSubpassEndInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassEndInfo*)(local_pSubpassEndInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdEndRenderPass2(
    VkCommandBuffer commandBuffer,
    const VkSubpassEndInfo* pSubpassEndInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkSubpassEndInfo* local_pSubpassEndInfo;
    local_commandBuffer = commandBuffer;
    local_pSubpassEndInfo = nullptr;
    if (pSubpassEndInfo)
    {
        local_pSubpassEndInfo = (VkSubpassEndInfo*)pool->alloc(sizeof(const VkSubpassEndInfo));
        deepcopy_VkSubpassEndInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pSubpassEndInfo, (VkSubpassEndInfo*)(local_pSubpassEndInfo));
    }
    if (local_pSubpassEndInfo)
    {
        transform_tohost_VkSubpassEndInfo(sResourceTracker, (VkSubpassEndInfo*)(local_pSubpassEndInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkSubpassEndInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassEndInfo*)(local_pSubpassEndInfo), countPtr);
    }
    uint32_t packetSize_vkCmdEndRenderPass2 = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdEndRenderPass2 -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdEndRenderPass2);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdEndRenderPass2 = OP_vkCmdEndRenderPass2;
    memcpy(streamPtr, &opcode_vkCmdEndRenderPass2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdEndRenderPass2, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkSubpassEndInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassEndInfo*)(local_pSubpassEndInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkResetQueryPool(
    VkDevice device,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkQueryPool local_queryPool;
    uint32_t local_firstQuery;
    uint32_t local_queryCount;
    local_device = device;
    local_queryPool = queryPool;
    local_firstQuery = firstQuery;
    local_queryCount = queryCount;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkResetQueryPool = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkResetQueryPool);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkResetQueryPool = OP_vkResetQueryPool;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkResetQueryPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkResetQueryPool, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstQuery, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_queryCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkGetSemaphoreCounterValue(
    VkDevice device,
    VkSemaphore semaphore,
    uint64_t* pValue,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSemaphore local_semaphore;
    local_device = device;
    local_semaphore = semaphore;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint64_t);
    }
    uint32_t packetSize_vkGetSemaphoreCounterValue = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetSemaphoreCounterValue);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetSemaphoreCounterValue = OP_vkGetSemaphoreCounterValue;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetSemaphoreCounterValue, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetSemaphoreCounterValue, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSemaphore((*&local_semaphore));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint64_t*)pValue, sizeof(uint64_t));
    *streamPtrPtr += sizeof(uint64_t);
    stream->read((uint64_t*)pValue, sizeof(uint64_t));
    VkResult vkGetSemaphoreCounterValue_VkResult_return = (VkResult)0;
    stream->read(&vkGetSemaphoreCounterValue_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetSemaphoreCounterValue_VkResult_return;
}

VkResult VkEncoder::vkWaitSemaphores(
    VkDevice device,
    const VkSemaphoreWaitInfo* pWaitInfo,
    uint64_t timeout,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSemaphoreWaitInfo* local_pWaitInfo;
    uint64_t local_timeout;
    local_device = device;
    local_pWaitInfo = nullptr;
    if (pWaitInfo)
    {
        local_pWaitInfo = (VkSemaphoreWaitInfo*)pool->alloc(sizeof(const VkSemaphoreWaitInfo));
        deepcopy_VkSemaphoreWaitInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pWaitInfo, (VkSemaphoreWaitInfo*)(local_pWaitInfo));
    }
    local_timeout = timeout;
    if (local_pWaitInfo)
    {
        transform_tohost_VkSemaphoreWaitInfo(sResourceTracker, (VkSemaphoreWaitInfo*)(local_pWaitInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkSemaphoreWaitInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreWaitInfo*)(local_pWaitInfo), countPtr);
        *countPtr += sizeof(uint64_t);
    }
    uint32_t packetSize_vkWaitSemaphores = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkWaitSemaphores);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkWaitSemaphores = OP_vkWaitSemaphores;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkWaitSemaphores, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkWaitSemaphores, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSemaphoreWaitInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreWaitInfo*)(local_pWaitInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (uint64_t*)&local_timeout, sizeof(uint64_t));
    *streamPtrPtr += sizeof(uint64_t);
    VkResult vkWaitSemaphores_VkResult_return = (VkResult)0;
    stream->read(&vkWaitSemaphores_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkWaitSemaphores_VkResult_return;
}

VkResult VkEncoder::vkSignalSemaphore(
    VkDevice device,
    const VkSemaphoreSignalInfo* pSignalInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSemaphoreSignalInfo* local_pSignalInfo;
    local_device = device;
    local_pSignalInfo = nullptr;
    if (pSignalInfo)
    {
        local_pSignalInfo = (VkSemaphoreSignalInfo*)pool->alloc(sizeof(const VkSemaphoreSignalInfo));
        deepcopy_VkSemaphoreSignalInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pSignalInfo, (VkSemaphoreSignalInfo*)(local_pSignalInfo));
    }
    if (local_pSignalInfo)
    {
        transform_tohost_VkSemaphoreSignalInfo(sResourceTracker, (VkSemaphoreSignalInfo*)(local_pSignalInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkSemaphoreSignalInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreSignalInfo*)(local_pSignalInfo), countPtr);
    }
    uint32_t packetSize_vkSignalSemaphore = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkSignalSemaphore);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkSignalSemaphore = OP_vkSignalSemaphore;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkSignalSemaphore, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkSignalSemaphore, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSemaphoreSignalInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreSignalInfo*)(local_pSignalInfo), streamPtrPtr);
    VkResult vkSignalSemaphore_VkResult_return = (VkResult)0;
    stream->read(&vkSignalSemaphore_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkSignalSemaphore_VkResult_return;
}

VkDeviceAddress VkEncoder::vkGetBufferDeviceAddress(
    VkDevice device,
    const VkBufferDeviceAddressInfo* pInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBufferDeviceAddressInfo* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkBufferDeviceAddressInfo*)pool->alloc(sizeof(const VkBufferDeviceAddressInfo));
        deepcopy_VkBufferDeviceAddressInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkBufferDeviceAddressInfo*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkBufferDeviceAddressInfo(sResourceTracker, (VkBufferDeviceAddressInfo*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkBufferDeviceAddressInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferDeviceAddressInfo*)(local_pInfo), countPtr);
    }
    uint32_t packetSize_vkGetBufferDeviceAddress = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetBufferDeviceAddress);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetBufferDeviceAddress = OP_vkGetBufferDeviceAddress;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetBufferDeviceAddress, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetBufferDeviceAddress, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkBufferDeviceAddressInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferDeviceAddressInfo*)(local_pInfo), streamPtrPtr);
    VkDeviceAddress vkGetBufferDeviceAddress_VkDeviceAddress_return = (VkDeviceAddress)0;
    stream->read(&vkGetBufferDeviceAddress_VkDeviceAddress_return, sizeof(VkDeviceAddress));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetBufferDeviceAddress_VkDeviceAddress_return;
}

uint64_t VkEncoder::vkGetBufferOpaqueCaptureAddress(
    VkDevice device,
    const VkBufferDeviceAddressInfo* pInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBufferDeviceAddressInfo* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkBufferDeviceAddressInfo*)pool->alloc(sizeof(const VkBufferDeviceAddressInfo));
        deepcopy_VkBufferDeviceAddressInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkBufferDeviceAddressInfo*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkBufferDeviceAddressInfo(sResourceTracker, (VkBufferDeviceAddressInfo*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkBufferDeviceAddressInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferDeviceAddressInfo*)(local_pInfo), countPtr);
    }
    uint32_t packetSize_vkGetBufferOpaqueCaptureAddress = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetBufferOpaqueCaptureAddress);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetBufferOpaqueCaptureAddress = OP_vkGetBufferOpaqueCaptureAddress;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetBufferOpaqueCaptureAddress, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetBufferOpaqueCaptureAddress, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkBufferDeviceAddressInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferDeviceAddressInfo*)(local_pInfo), streamPtrPtr);
    uint64_t vkGetBufferOpaqueCaptureAddress_uint64_t_return = (uint64_t)0;
    stream->read(&vkGetBufferOpaqueCaptureAddress_uint64_t_return, sizeof(uint64_t));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetBufferOpaqueCaptureAddress_uint64_t_return;
}

uint64_t VkEncoder::vkGetDeviceMemoryOpaqueCaptureAddress(
    VkDevice device,
    const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeviceMemoryOpaqueCaptureAddressInfo* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkDeviceMemoryOpaqueCaptureAddressInfo*)pool->alloc(sizeof(const VkDeviceMemoryOpaqueCaptureAddressInfo));
        deepcopy_VkDeviceMemoryOpaqueCaptureAddressInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkDeviceMemoryOpaqueCaptureAddressInfo*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkDeviceMemoryOpaqueCaptureAddressInfo(sResourceTracker, (VkDeviceMemoryOpaqueCaptureAddressInfo*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDeviceMemoryOpaqueCaptureAddressInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceMemoryOpaqueCaptureAddressInfo*)(local_pInfo), countPtr);
    }
    uint32_t packetSize_vkGetDeviceMemoryOpaqueCaptureAddress = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceMemoryOpaqueCaptureAddress);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceMemoryOpaqueCaptureAddress = OP_vkGetDeviceMemoryOpaqueCaptureAddress;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceMemoryOpaqueCaptureAddress, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceMemoryOpaqueCaptureAddress, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDeviceMemoryOpaqueCaptureAddressInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceMemoryOpaqueCaptureAddressInfo*)(local_pInfo), streamPtrPtr);
    uint64_t vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return = (uint64_t)0;
    stream->read(&vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return, sizeof(uint64_t));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDeviceMemoryOpaqueCaptureAddress_uint64_t_return;
}

#endif
#ifdef VK_KHR_surface
void VkEncoder::vkDestroySurfaceKHR(
    VkInstance instance,
    VkSurfaceKHR surface,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkSurfaceKHR local_surface;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_surface = surface;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroySurfaceKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroySurfaceKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroySurfaceKHR = OP_vkDestroySurfaceKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroySurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroySurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSurfaceKHR((*&local_surface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkSurfaceKHR((VkSurfaceKHR*)&surface);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    VkSurfaceKHR surface,
    VkBool32* pSupported,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    local_surface = surface;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkBool32);
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceSupportKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSurfaceSupportKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSurfaceSupportKHR = OP_vkGetPhysicalDeviceSurfaceSupportKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSurfaceSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSurfaceSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSurfaceKHR((*&local_surface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkBool32*)pSupported, sizeof(VkBool32));
    *streamPtrPtr += sizeof(VkBool32);
    stream->read((VkBool32*)pSupported, sizeof(VkBool32));
    VkResult vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceSurfaceSupportKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    VkSurfaceCapabilitiesKHR* pSurfaceCapabilities,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        count_VkSurfaceCapabilitiesKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSurfaceCapabilitiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = OP_vkGetPhysicalDeviceSurfaceCapabilitiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSurfaceCapabilitiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSurfaceCapabilitiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSurfaceKHR((*&local_surface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSurfaceCapabilitiesKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities), streamPtrPtr);
    unmarshal_VkSurfaceCapabilitiesKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
    if (pSurfaceCapabilities)
    {
        transform_fromhost_VkSurfaceCapabilitiesKHR(sResourceTracker, (VkSurfaceCapabilitiesKHR*)(pSurfaceCapabilities));
    }
    VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceSurfaceCapabilitiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pSurfaceFormatCount,
    VkSurfaceFormatKHR* pSurfaceFormats,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSurfaceFormatCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSurfaceFormats)
        {
            if (pSurfaceFormatCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                {
                    count_VkSurfaceFormatKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceFormatKHR*)(pSurfaceFormats + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceFormatsKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSurfaceFormatsKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSurfaceFormatsKHR = OP_vkGetPhysicalDeviceSurfaceFormatsKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSurfaceFormatsKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSurfaceFormatsKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSurfaceKHR((*&local_surface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSurfaceFormatCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pSurfaceFormats;
    memcpy((*streamPtrPtr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSurfaceFormats)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            reservedmarshal_VkSurfaceFormatKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceFormatKHR*)(pSurfaceFormats + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pSurfaceFormatCount;
    check_pSurfaceFormatCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSurfaceFormatCount)
    {
        if (!(check_pSurfaceFormatCount))
        {
            fprintf(stderr, "fatal: pSurfaceFormatCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSurfaceFormatKHR* check_pSurfaceFormats;
    check_pSurfaceFormats = (VkSurfaceFormatKHR*)(uintptr_t)stream->getBe64();
    if (pSurfaceFormats)
    {
        if (!(check_pSurfaceFormats))
        {
            fprintf(stderr, "fatal: pSurfaceFormats inconsistent between guest and host\n");
        }
        if (pSurfaceFormatCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
            {
                unmarshal_VkSurfaceFormatKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
            }
        }
    }
    if (pSurfaceFormatCount)
    {
        if (pSurfaceFormats)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
            {
                transform_fromhost_VkSurfaceFormatKHR(sResourceTracker, (VkSurfaceFormatKHR*)(pSurfaceFormats + i));
            }
        }
    }
    VkResult vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceSurfaceFormatsKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pPresentModeCount,
    VkPresentModeKHR* pPresentModes,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPresentModeCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPresentModes)
        {
            if (pPresentModeCount)
            {
                *countPtr += (*(pPresentModeCount)) * sizeof(VkPresentModeKHR);
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfacePresentModesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSurfacePresentModesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSurfacePresentModesKHR = OP_vkGetPhysicalDeviceSurfacePresentModesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSurfacePresentModesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSurfacePresentModesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSurfaceKHR((*&local_surface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pPresentModeCount;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPresentModeCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPresentModeCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPresentModes;
    memcpy((*streamPtrPtr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPresentModes)
    {
        memcpy(*streamPtrPtr, (VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
        *streamPtrPtr += (*(pPresentModeCount)) * sizeof(VkPresentModeKHR);
    }
    // WARNING PTR CHECK
    uint32_t* check_pPresentModeCount;
    check_pPresentModeCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPresentModeCount)
    {
        if (!(check_pPresentModeCount))
        {
            fprintf(stderr, "fatal: pPresentModeCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPresentModeCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPresentModeKHR* check_pPresentModes;
    check_pPresentModes = (VkPresentModeKHR*)(uintptr_t)stream->getBe64();
    if (pPresentModes)
    {
        if (!(check_pPresentModes))
        {
            fprintf(stderr, "fatal: pPresentModes inconsistent between guest and host\n");
        }
        stream->read((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
    }
    VkResult vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceSurfacePresentModesKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_swapchain
VkResult VkEncoder::vkCreateSwapchainKHR(
    VkDevice device,
    const VkSwapchainCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSwapchainKHR* pSwapchain,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSwapchainCreateInfoKHR*)pool->alloc(sizeof(const VkSwapchainCreateInfoKHR));
        deepcopy_VkSwapchainCreateInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkSwapchainCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSwapchainCreateInfoKHR(sResourceTracker, (VkSwapchainCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkSwapchainCreateInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSwapchainCreateInfoKHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateSwapchainKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateSwapchainKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateSwapchainKHR = OP_vkCreateSwapchainKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateSwapchainKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateSwapchainKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSwapchainCreateInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSwapchainCreateInfoKHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pSwapchain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_3, (VkSwapchainKHR*)pSwapchain, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateSwapchainKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSwapchainKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateSwapchainKHR_VkResult_return;
}

void VkEncoder::vkDestroySwapchainKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_swapchain = swapchain;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroySwapchainKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroySwapchainKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroySwapchainKHR = OP_vkDestroySwapchainKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroySwapchainKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroySwapchainKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSwapchainKHR((*&local_swapchain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkSwapchainKHR((VkSwapchainKHR*)&swapchain);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkGetSwapchainImagesKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t* pSwapchainImageCount,
    VkImage* pSwapchainImages,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    local_device = device;
    local_swapchain = swapchain;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSwapchainImageCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSwapchainImages)
        {
            if ((*(pSwapchainImageCount)))
            {
                *countPtr += (*(pSwapchainImageCount)) * 8;
            }
        }
    }
    uint32_t packetSize_vkGetSwapchainImagesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetSwapchainImagesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetSwapchainImagesKHR = OP_vkGetSwapchainImagesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetSwapchainImagesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetSwapchainImagesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSwapchainKHR((*&local_swapchain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pSwapchainImageCount;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSwapchainImageCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    /* is handle, possibly out */;
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pSwapchainImages;
    memcpy((*streamPtrPtr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSwapchainImages)
    {
        if ((*(pSwapchainImageCount)))
        {
            uint8_t* cgen_var_3_0_ptr = (uint8_t*)(*streamPtrPtr);
            if (pSwapchainImageCount)
            {
                for (uint32_t k = 0; k < (*(pSwapchainImageCount)); ++k)
                {
                    uint64_t tmpval = (uint64_t)(pSwapchainImages[k]);
                    memcpy(cgen_var_3_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
                }
            }
            *streamPtrPtr += 8 * (*(pSwapchainImageCount));
        }
    }
    /* is handle, possibly out */;
    // WARNING PTR CHECK
    uint32_t* check_pSwapchainImageCount;
    check_pSwapchainImageCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSwapchainImageCount)
    {
        if (!(check_pSwapchainImageCount))
        {
            fprintf(stderr, "fatal: pSwapchainImageCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSwapchainImageCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkImage* check_pSwapchainImages;
    check_pSwapchainImages = (VkImage*)(uintptr_t)stream->getBe64();
    if (pSwapchainImages)
    {
        if (!(check_pSwapchainImages))
        {
            fprintf(stderr, "fatal: pSwapchainImages inconsistent between guest and host\n");
        }
        if ((*(pSwapchainImageCount)))
        {
            uint64_t* cgen_var_5_0;
            stream->alloc((void**)&cgen_var_5_0, (*(pSwapchainImageCount)) * 8);
            stream->read((uint64_t*)cgen_var_5_0, (*(pSwapchainImageCount)) * 8);
            stream->handleMapping()->mapHandles_u64_VkImage(cgen_var_5_0, (VkImage*)pSwapchainImages, (*(pSwapchainImageCount)));
        }
    }
    VkResult vkGetSwapchainImagesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainImagesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetSwapchainImagesKHR_VkResult_return;
}

VkResult VkEncoder::vkAcquireNextImageKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint64_t timeout,
    VkSemaphore semaphore,
    VkFence fence,
    uint32_t* pImageIndex,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    uint64_t local_timeout;
    VkSemaphore local_semaphore;
    VkFence local_fence;
    local_device = device;
    local_swapchain = swapchain;
    local_timeout = timeout;
    local_semaphore = semaphore;
    local_fence = fence;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint64_t);
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        uint64_t cgen_var_3;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkAcquireNextImageKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkAcquireNextImageKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkAcquireNextImageKHR = OP_vkAcquireNextImageKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkAcquireNextImageKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkAcquireNextImageKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSwapchainKHR((*&local_swapchain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint64_t*)&local_timeout, sizeof(uint64_t));
    *streamPtrPtr += sizeof(uint64_t);
    uint64_t cgen_var_2;
    *&cgen_var_2 = get_host_u64_VkSemaphore((*&local_semaphore));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_3;
    *&cgen_var_3 = get_host_u64_VkFence((*&local_fence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_3, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)pImageIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    stream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
    VkResult vkAcquireNextImageKHR_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireNextImageKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkAcquireNextImageKHR_VkResult_return;
}

VkResult VkEncoder::vkQueuePresentKHR(
    VkQueue queue,
    const VkPresentInfoKHR* pPresentInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    VkPresentInfoKHR* local_pPresentInfo;
    local_queue = queue;
    local_pPresentInfo = nullptr;
    if (pPresentInfo)
    {
        local_pPresentInfo = (VkPresentInfoKHR*)pool->alloc(sizeof(const VkPresentInfoKHR));
        deepcopy_VkPresentInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pPresentInfo, (VkPresentInfoKHR*)(local_pPresentInfo));
    }
    if (local_pPresentInfo)
    {
        transform_tohost_VkPresentInfoKHR(sResourceTracker, (VkPresentInfoKHR*)(local_pPresentInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPresentInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPresentInfoKHR*)(local_pPresentInfo), countPtr);
    }
    uint32_t packetSize_vkQueuePresentKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueuePresentKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueuePresentKHR = OP_vkQueuePresentKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueuePresentKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueuePresentKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPresentInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPresentInfoKHR*)(local_pPresentInfo), streamPtrPtr);
    VkResult vkQueuePresentKHR_VkResult_return = (VkResult)0;
    stream->read(&vkQueuePresentKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkQueuePresentKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDeviceGroupPresentCapabilitiesKHR(
    VkDevice device,
    VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    local_device = device;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDeviceGroupPresentCapabilitiesKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities), countPtr);
    }
    uint32_t packetSize_vkGetDeviceGroupPresentCapabilitiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceGroupPresentCapabilitiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceGroupPresentCapabilitiesKHR = OP_vkGetDeviceGroupPresentCapabilitiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceGroupPresentCapabilitiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceGroupPresentCapabilitiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDeviceGroupPresentCapabilitiesKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities), streamPtrPtr);
    unmarshal_VkDeviceGroupPresentCapabilitiesKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
    if (pDeviceGroupPresentCapabilities)
    {
        transform_fromhost_VkDeviceGroupPresentCapabilitiesKHR(sResourceTracker, (VkDeviceGroupPresentCapabilitiesKHR*)(pDeviceGroupPresentCapabilities));
    }
    VkResult vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDeviceGroupPresentCapabilitiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDeviceGroupSurfacePresentModesKHR(
    VkDevice device,
    VkSurfaceKHR surface,
    VkDeviceGroupPresentModeFlagsKHR* pModes,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSurfaceKHR local_surface;
    local_device = device;
    local_surface = surface;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pModes)
        {
            *countPtr += sizeof(VkDeviceGroupPresentModeFlagsKHR);
        }
    }
    uint32_t packetSize_vkGetDeviceGroupSurfacePresentModesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceGroupSurfacePresentModesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceGroupSurfacePresentModesKHR = OP_vkGetDeviceGroupSurfacePresentModesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceGroupSurfacePresentModesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceGroupSurfacePresentModesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSurfaceKHR((*&local_surface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pModes;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pModes)
    {
        memcpy(*streamPtrPtr, (VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
        *streamPtrPtr += sizeof(VkDeviceGroupPresentModeFlagsKHR);
    }
    // WARNING PTR CHECK
    VkDeviceGroupPresentModeFlagsKHR* check_pModes;
    check_pModes = (VkDeviceGroupPresentModeFlagsKHR*)(uintptr_t)stream->getBe64();
    if (pModes)
    {
        if (!(check_pModes))
        {
            fprintf(stderr, "fatal: pModes inconsistent between guest and host\n");
        }
        stream->read((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    }
    VkResult vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDeviceGroupSurfacePresentModesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDevicePresentRectanglesKHR(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    uint32_t* pRectCount,
    VkRect2D* pRects,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pRectCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pRects)
        {
            if (pRectCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
                {
                    count_VkRect2D(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRect2D*)(pRects + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDevicePresentRectanglesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDevicePresentRectanglesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDevicePresentRectanglesKHR = OP_vkGetPhysicalDevicePresentRectanglesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDevicePresentRectanglesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDevicePresentRectanglesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSurfaceKHR((*&local_surface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pRectCount;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pRectCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pRectCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pRects;
    memcpy((*streamPtrPtr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pRects)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
        {
            reservedmarshal_VkRect2D(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRect2D*)(pRects + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pRectCount;
    check_pRectCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pRectCount)
    {
        if (!(check_pRectCount))
        {
            fprintf(stderr, "fatal: pRectCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pRectCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkRect2D* check_pRects;
    check_pRects = (VkRect2D*)(uintptr_t)stream->getBe64();
    if (pRects)
    {
        if (!(check_pRects))
        {
            fprintf(stderr, "fatal: pRects inconsistent between guest and host\n");
        }
        if (pRectCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
            {
                unmarshal_VkRect2D(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRect2D*)(pRects + i));
            }
        }
    }
    if (pRectCount)
    {
        if (pRects)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pRectCount)); ++i)
            {
                transform_fromhost_VkRect2D(sResourceTracker, (VkRect2D*)(pRects + i));
            }
        }
    }
    VkResult vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDevicePresentRectanglesKHR_VkResult_return;
}

VkResult VkEncoder::vkAcquireNextImage2KHR(
    VkDevice device,
    const VkAcquireNextImageInfoKHR* pAcquireInfo,
    uint32_t* pImageIndex,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkAcquireNextImageInfoKHR* local_pAcquireInfo;
    local_device = device;
    local_pAcquireInfo = nullptr;
    if (pAcquireInfo)
    {
        local_pAcquireInfo = (VkAcquireNextImageInfoKHR*)pool->alloc(sizeof(const VkAcquireNextImageInfoKHR));
        deepcopy_VkAcquireNextImageInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAcquireInfo, (VkAcquireNextImageInfoKHR*)(local_pAcquireInfo));
    }
    if (local_pAcquireInfo)
    {
        transform_tohost_VkAcquireNextImageInfoKHR(sResourceTracker, (VkAcquireNextImageInfoKHR*)(local_pAcquireInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkAcquireNextImageInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAcquireNextImageInfoKHR*)(local_pAcquireInfo), countPtr);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkAcquireNextImage2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkAcquireNextImage2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkAcquireNextImage2KHR = OP_vkAcquireNextImage2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkAcquireNextImage2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkAcquireNextImage2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkAcquireNextImageInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAcquireNextImageInfoKHR*)(local_pAcquireInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (uint32_t*)pImageIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    stream->read((uint32_t*)pImageIndex, sizeof(uint32_t));
    VkResult vkAcquireNextImage2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireNextImage2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkAcquireNextImage2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_display
VkResult VkEncoder::vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPropertiesKHR* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            if (pPropertyCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                {
                    count_VkDisplayPropertiesKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPropertiesKHR*)(pProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayPropertiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceDisplayPropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceDisplayPropertiesKHR = OP_vkGetPhysicalDeviceDisplayPropertiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceDisplayPropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceDisplayPropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkDisplayPropertiesKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPropertiesKHR*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayPropertiesKHR* check_pProperties;
    check_pProperties = (VkDisplayPropertiesKHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        if (pPropertyCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                unmarshal_VkDisplayPropertiesKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPropertiesKHR*)(pProperties + i));
            }
        }
    }
    if (pPropertyCount)
    {
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                transform_fromhost_VkDisplayPropertiesKHR(sResourceTracker, (VkDisplayPropertiesKHR*)(pProperties + i));
            }
        }
    }
    VkResult vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceDisplayPropertiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPlanePropertiesKHR* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            if (pPropertyCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                {
                    count_VkDisplayPlanePropertiesKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlanePropertiesKHR*)(pProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceDisplayPlanePropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = OP_vkGetPhysicalDeviceDisplayPlanePropertiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceDisplayPlanePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceDisplayPlanePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkDisplayPlanePropertiesKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlanePropertiesKHR*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayPlanePropertiesKHR* check_pProperties;
    check_pProperties = (VkDisplayPlanePropertiesKHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        if (pPropertyCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                unmarshal_VkDisplayPlanePropertiesKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
            }
        }
    }
    if (pPropertyCount)
    {
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                transform_fromhost_VkDisplayPlanePropertiesKHR(sResourceTracker, (VkDisplayPlanePropertiesKHR*)(pProperties + i));
            }
        }
    }
    VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceDisplayPlanePropertiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayPlaneSupportedDisplaysKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t planeIndex,
    uint32_t* pDisplayCount,
    VkDisplayKHR* pDisplays,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_planeIndex;
    local_physicalDevice = physicalDevice;
    local_planeIndex = planeIndex;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pDisplayCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pDisplays)
        {
            if ((*(pDisplayCount)))
            {
                *countPtr += (*(pDisplayCount)) * 8;
            }
        }
    }
    uint32_t packetSize_vkGetDisplayPlaneSupportedDisplaysKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDisplayPlaneSupportedDisplaysKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDisplayPlaneSupportedDisplaysKHR = OP_vkGetDisplayPlaneSupportedDisplaysKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDisplayPlaneSupportedDisplaysKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDisplayPlaneSupportedDisplaysKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_planeIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pDisplayCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pDisplayCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pDisplayCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    /* is handle, possibly out */;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pDisplays;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pDisplays)
    {
        if ((*(pDisplayCount)))
        {
            uint8_t* cgen_var_2_0_ptr = (uint8_t*)(*streamPtrPtr);
            if (pDisplayCount)
            {
                for (uint32_t k = 0; k < (*(pDisplayCount)); ++k)
                {
                    uint64_t tmpval = (uint64_t)(pDisplays[k]);
                    memcpy(cgen_var_2_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
                }
            }
            *streamPtrPtr += 8 * (*(pDisplayCount));
        }
    }
    /* is handle, possibly out */;
    // WARNING PTR CHECK
    uint32_t* check_pDisplayCount;
    check_pDisplayCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pDisplayCount)
    {
        if (!(check_pDisplayCount))
        {
            fprintf(stderr, "fatal: pDisplayCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pDisplayCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayKHR* check_pDisplays;
    check_pDisplays = (VkDisplayKHR*)(uintptr_t)stream->getBe64();
    if (pDisplays)
    {
        if (!(check_pDisplays))
        {
            fprintf(stderr, "fatal: pDisplays inconsistent between guest and host\n");
        }
        if ((*(pDisplayCount)))
        {
            uint64_t* cgen_var_4_0;
            stream->alloc((void**)&cgen_var_4_0, (*(pDisplayCount)) * 8);
            stream->read((uint64_t*)cgen_var_4_0, (*(pDisplayCount)) * 8);
            stream->handleMapping()->mapHandles_u64_VkDisplayKHR(cgen_var_4_0, (VkDisplayKHR*)pDisplays, (*(pDisplayCount)));
        }
    }
    VkResult vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDisplayPlaneSupportedDisplaysKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayModePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    uint32_t* pPropertyCount,
    VkDisplayModePropertiesKHR* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    local_physicalDevice = physicalDevice;
    local_display = display;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            if (pPropertyCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                {
                    count_VkDisplayModePropertiesKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayModePropertiesKHR*)(pProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetDisplayModePropertiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDisplayModePropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDisplayModePropertiesKHR = OP_vkGetDisplayModePropertiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDisplayModePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDisplayModePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDisplayKHR((*&local_display));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkDisplayModePropertiesKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayModePropertiesKHR*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayModePropertiesKHR* check_pProperties;
    check_pProperties = (VkDisplayModePropertiesKHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        if (pPropertyCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                unmarshal_VkDisplayModePropertiesKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayModePropertiesKHR*)(pProperties + i));
            }
        }
    }
    if (pPropertyCount)
    {
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                transform_fromhost_VkDisplayModePropertiesKHR(sResourceTracker, (VkDisplayModePropertiesKHR*)(pProperties + i));
            }
        }
    }
    VkResult vkGetDisplayModePropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayModePropertiesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDisplayModePropertiesKHR_VkResult_return;
}

VkResult VkEncoder::vkCreateDisplayModeKHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    const VkDisplayModeCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDisplayModeKHR* pMode,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    VkDisplayModeCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_physicalDevice = physicalDevice;
    local_display = display;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDisplayModeCreateInfoKHR*)pool->alloc(sizeof(const VkDisplayModeCreateInfoKHR));
        deepcopy_VkDisplayModeCreateInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkDisplayModeCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDisplayModeCreateInfoKHR(sResourceTracker, (VkDisplayModeCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        count_VkDisplayModeCreateInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayModeCreateInfoKHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_2;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDisplayModeKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDisplayModeKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDisplayModeKHR = OP_vkCreateDisplayModeKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDisplayModeKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDisplayModeKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDisplayKHR((*&local_display));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDisplayModeCreateInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayModeCreateInfoKHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    *&cgen_var_3 = (uint64_t)((*pMode));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_3, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_4;
    stream->read((uint64_t*)&cgen_var_4, 8);
    stream->handleMapping()->mapHandles_u64_VkDisplayModeKHR(&cgen_var_4, (VkDisplayModeKHR*)pMode, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDisplayModeKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDisplayModeKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDisplayModeKHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayPlaneCapabilitiesKHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayModeKHR mode,
    uint32_t planeIndex,
    VkDisplayPlaneCapabilitiesKHR* pCapabilities,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkDisplayModeKHR local_mode;
    uint32_t local_planeIndex;
    local_physicalDevice = physicalDevice;
    local_mode = mode;
    local_planeIndex = planeIndex;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        count_VkDisplayPlaneCapabilitiesKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities), countPtr);
    }
    uint32_t packetSize_vkGetDisplayPlaneCapabilitiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDisplayPlaneCapabilitiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDisplayPlaneCapabilitiesKHR = OP_vkGetDisplayPlaneCapabilitiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDisplayPlaneCapabilitiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDisplayPlaneCapabilitiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDisplayModeKHR((*&local_mode));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_planeIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    reservedmarshal_VkDisplayPlaneCapabilitiesKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities), streamPtrPtr);
    unmarshal_VkDisplayPlaneCapabilitiesKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
    if (pCapabilities)
    {
        transform_fromhost_VkDisplayPlaneCapabilitiesKHR(sResourceTracker, (VkDisplayPlaneCapabilitiesKHR*)(pCapabilities));
    }
    VkResult vkGetDisplayPlaneCapabilitiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayPlaneCapabilitiesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDisplayPlaneCapabilitiesKHR_VkResult_return;
}

VkResult VkEncoder::vkCreateDisplayPlaneSurfaceKHR(
    VkInstance instance,
    const VkDisplaySurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkDisplaySurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDisplaySurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkDisplaySurfaceCreateInfoKHR));
        deepcopy_VkDisplaySurfaceCreateInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkDisplaySurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDisplaySurfaceCreateInfoKHR(sResourceTracker, (VkDisplaySurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDisplaySurfaceCreateInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplaySurfaceCreateInfoKHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDisplayPlaneSurfaceKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDisplayPlaneSurfaceKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDisplayPlaneSurfaceKHR = OP_vkCreateDisplayPlaneSurfaceKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDisplayPlaneSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDisplayPlaneSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDisplaySurfaceCreateInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplaySurfaceCreateInfoKHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_3, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateDisplayPlaneSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDisplayPlaneSurfaceKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDisplayPlaneSurfaceKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_display_swapchain
VkResult VkEncoder::vkCreateSharedSwapchainsKHR(
    VkDevice device,
    uint32_t swapchainCount,
    const VkSwapchainCreateInfoKHR* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkSwapchainKHR* pSwapchains,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_swapchainCount;
    VkSwapchainCreateInfoKHR* local_pCreateInfos;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_swapchainCount = swapchainCount;
    local_pCreateInfos = nullptr;
    if (pCreateInfos)
    {
        local_pCreateInfos = (VkSwapchainCreateInfoKHR*)pool->alloc(((swapchainCount)) * sizeof(const VkSwapchainCreateInfoKHR));
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            deepcopy_VkSwapchainCreateInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfos + i, (VkSwapchainCreateInfoKHR*)(local_pCreateInfos + i));
        }
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            transform_tohost_VkSwapchainCreateInfoKHR(sResourceTracker, (VkSwapchainCreateInfoKHR*)(local_pCreateInfos + i));
        }
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            count_VkSwapchainCreateInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSwapchainCreateInfoKHR*)(local_pCreateInfos + i), countPtr);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        if (((swapchainCount)))
        {
            *countPtr += ((swapchainCount)) * 8;
        }
    }
    uint32_t packetSize_vkCreateSharedSwapchainsKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateSharedSwapchainsKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateSharedSwapchainsKHR = OP_vkCreateSharedSwapchainsKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateSharedSwapchainsKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateSharedSwapchainsKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_swapchainCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
    {
        reservedmarshal_VkSwapchainCreateInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSwapchainCreateInfoKHR*)(local_pCreateInfos + i), streamPtrPtr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    if (((swapchainCount)))
    {
        uint8_t* cgen_var_2_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((swapchainCount)); ++k)
        {
            uint64_t tmpval = (uint64_t)(pSwapchains[k]);
            memcpy(cgen_var_2_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((swapchainCount));
    }
    /* is handle, possibly out */;
    if (((swapchainCount)))
    {
        uint64_t* cgen_var_3;
        stream->alloc((void**)&cgen_var_3, ((swapchainCount)) * 8);
        stream->read((uint64_t*)cgen_var_3, ((swapchainCount)) * 8);
        stream->handleMapping()->mapHandles_u64_VkSwapchainKHR(cgen_var_3, (VkSwapchainKHR*)pSwapchains, ((swapchainCount)));
    }
    VkResult vkCreateSharedSwapchainsKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSharedSwapchainsKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateSharedSwapchainsKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_xlib_surface
VkResult VkEncoder::vkCreateXlibSurfaceKHR(
    VkInstance instance,
    const VkXlibSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkXlibSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkXlibSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkXlibSurfaceCreateInfoKHR));
        deepcopy_VkXlibSurfaceCreateInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkXlibSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkXlibSurfaceCreateInfoKHR(sResourceTracker, (VkXlibSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkXlibSurfaceCreateInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkXlibSurfaceCreateInfoKHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateXlibSurfaceKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateXlibSurfaceKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateXlibSurfaceKHR = OP_vkCreateXlibSurfaceKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateXlibSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateXlibSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkXlibSurfaceCreateInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkXlibSurfaceCreateInfoKHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_3, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateXlibSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateXlibSurfaceKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateXlibSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceXlibPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    Display* dpy,
    VisualID visualID,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    VisualID local_visualID;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    local_visualID = visualID;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(Display);
        *countPtr += sizeof(VisualID);
    }
    uint32_t packetSize_vkGetPhysicalDeviceXlibPresentationSupportKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceXlibPresentationSupportKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceXlibPresentationSupportKHR = OP_vkGetPhysicalDeviceXlibPresentationSupportKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceXlibPresentationSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceXlibPresentationSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (Display*)dpy, sizeof(Display));
    *streamPtrPtr += sizeof(Display);
    memcpy(*streamPtrPtr, (VisualID*)&local_visualID, sizeof(VisualID));
    *streamPtrPtr += sizeof(VisualID);
    stream->read((Display*)dpy, sizeof(Display));
    VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceXlibPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_xcb_surface
VkResult VkEncoder::vkCreateXcbSurfaceKHR(
    VkInstance instance,
    const VkXcbSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkXcbSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkXcbSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkXcbSurfaceCreateInfoKHR));
        deepcopy_VkXcbSurfaceCreateInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkXcbSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkXcbSurfaceCreateInfoKHR(sResourceTracker, (VkXcbSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkXcbSurfaceCreateInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkXcbSurfaceCreateInfoKHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateXcbSurfaceKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateXcbSurfaceKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateXcbSurfaceKHR = OP_vkCreateXcbSurfaceKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateXcbSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateXcbSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkXcbSurfaceCreateInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkXcbSurfaceCreateInfoKHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_3, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateXcbSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateXcbSurfaceKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateXcbSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceXcbPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    xcb_connection_t* connection,
    xcb_visualid_t visual_id,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    xcb_visualid_t local_visual_id;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    local_visual_id = visual_id;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(xcb_connection_t);
        *countPtr += sizeof(xcb_visualid_t);
    }
    uint32_t packetSize_vkGetPhysicalDeviceXcbPresentationSupportKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceXcbPresentationSupportKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceXcbPresentationSupportKHR = OP_vkGetPhysicalDeviceXcbPresentationSupportKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceXcbPresentationSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceXcbPresentationSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (xcb_connection_t*)connection, sizeof(xcb_connection_t));
    *streamPtrPtr += sizeof(xcb_connection_t);
    memcpy(*streamPtrPtr, (xcb_visualid_t*)&local_visual_id, sizeof(xcb_visualid_t));
    *streamPtrPtr += sizeof(xcb_visualid_t);
    stream->read((xcb_connection_t*)connection, sizeof(xcb_connection_t));
    VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceXcbPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_wayland_surface
VkResult VkEncoder::vkCreateWaylandSurfaceKHR(
    VkInstance instance,
    const VkWaylandSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkWaylandSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkWaylandSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkWaylandSurfaceCreateInfoKHR));
        deepcopy_VkWaylandSurfaceCreateInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkWaylandSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkWaylandSurfaceCreateInfoKHR(sResourceTracker, (VkWaylandSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkWaylandSurfaceCreateInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkWaylandSurfaceCreateInfoKHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateWaylandSurfaceKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateWaylandSurfaceKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateWaylandSurfaceKHR = OP_vkCreateWaylandSurfaceKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateWaylandSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateWaylandSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkWaylandSurfaceCreateInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkWaylandSurfaceCreateInfoKHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_3, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateWaylandSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateWaylandSurfaceKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateWaylandSurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    wl_display* display,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(wl_display);
    }
    uint32_t packetSize_vkGetPhysicalDeviceWaylandPresentationSupportKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceWaylandPresentationSupportKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceWaylandPresentationSupportKHR = OP_vkGetPhysicalDeviceWaylandPresentationSupportKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceWaylandPresentationSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceWaylandPresentationSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (wl_display*)display, sizeof(wl_display));
    *streamPtrPtr += sizeof(wl_display);
    stream->read((wl_display*)display, sizeof(wl_display));
    VkBool32 vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceWaylandPresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_android_surface
VkResult VkEncoder::vkCreateAndroidSurfaceKHR(
    VkInstance instance,
    const VkAndroidSurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkAndroidSurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkAndroidSurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkAndroidSurfaceCreateInfoKHR));
        deepcopy_VkAndroidSurfaceCreateInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkAndroidSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkAndroidSurfaceCreateInfoKHR(sResourceTracker, (VkAndroidSurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkAndroidSurfaceCreateInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAndroidSurfaceCreateInfoKHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateAndroidSurfaceKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateAndroidSurfaceKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateAndroidSurfaceKHR = OP_vkCreateAndroidSurfaceKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateAndroidSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateAndroidSurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkAndroidSurfaceCreateInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAndroidSurfaceCreateInfoKHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_3, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateAndroidSurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateAndroidSurfaceKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateAndroidSurfaceKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_win32_surface
VkResult VkEncoder::vkCreateWin32SurfaceKHR(
    VkInstance instance,
    const VkWin32SurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkWin32SurfaceCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkWin32SurfaceCreateInfoKHR*)pool->alloc(sizeof(const VkWin32SurfaceCreateInfoKHR));
        deepcopy_VkWin32SurfaceCreateInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkWin32SurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkWin32SurfaceCreateInfoKHR(sResourceTracker, (VkWin32SurfaceCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkWin32SurfaceCreateInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkWin32SurfaceCreateInfoKHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateWin32SurfaceKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateWin32SurfaceKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateWin32SurfaceKHR = OP_vkCreateWin32SurfaceKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateWin32SurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateWin32SurfaceKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkWin32SurfaceCreateInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkWin32SurfaceCreateInfoKHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_3, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateWin32SurfaceKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateWin32SurfaceKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateWin32SurfaceKHR_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceWin32PresentationSupportKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkGetPhysicalDeviceWin32PresentationSupportKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceWin32PresentationSupportKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceWin32PresentationSupportKHR = OP_vkGetPhysicalDeviceWin32PresentationSupportKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceWin32PresentationSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceWin32PresentationSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    VkBool32 vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return, sizeof(VkBool32));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceWin32PresentationSupportKHR_VkBool32_return;
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
void VkEncoder::vkGetPhysicalDeviceFeatures2KHR(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceFeatures2* pFeatures,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceFeatures2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFeatures2*)(pFeatures), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceFeatures2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceFeatures2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceFeatures2KHR = OP_vkGetPhysicalDeviceFeatures2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceFeatures2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceFeatures2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceFeatures2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFeatures2*)(pFeatures), streamPtrPtr);
    unmarshal_VkPhysicalDeviceFeatures2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFeatures2*)(pFeatures));
    if (pFeatures)
    {
        transform_fromhost_VkPhysicalDeviceFeatures2(sResourceTracker, (VkPhysicalDeviceFeatures2*)(pFeatures));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties2* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceProperties2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceProperties2*)(pProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceProperties2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceProperties2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceProperties2KHR = OP_vkGetPhysicalDeviceProperties2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceProperties2*)(pProperties), streamPtrPtr);
    unmarshal_VkPhysicalDeviceProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceProperties2*)(pProperties));
    if (pProperties)
    {
        transform_fromhost_VkPhysicalDeviceProperties2(sResourceTracker, (VkPhysicalDeviceProperties2*)(pProperties));
    }
    sResourceTracker->on_vkGetPhysicalDeviceProperties2KHR(this, physicalDevice, pProperties);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkFormatProperties2* pFormatProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    local_physicalDevice = physicalDevice;
    local_format = format;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkFormat);
        count_VkFormatProperties2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFormatProperties2*)(pFormatProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceFormatProperties2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceFormatProperties2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceFormatProperties2KHR = OP_vkGetPhysicalDeviceFormatProperties2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceFormatProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceFormatProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkFormat*)&local_format, sizeof(VkFormat));
    *streamPtrPtr += sizeof(VkFormat);
    reservedmarshal_VkFormatProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFormatProperties2*)(pFormatProperties), streamPtrPtr);
    unmarshal_VkFormatProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFormatProperties2*)(pFormatProperties));
    if (pFormatProperties)
    {
        transform_fromhost_VkFormatProperties2(sResourceTracker, (VkFormatProperties2*)(pFormatProperties));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkGetPhysicalDeviceImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceImageFormatInfo2* local_pImageFormatInfo;
    local_physicalDevice = physicalDevice;
    local_pImageFormatInfo = nullptr;
    if (pImageFormatInfo)
    {
        local_pImageFormatInfo = (VkPhysicalDeviceImageFormatInfo2*)pool->alloc(sizeof(const VkPhysicalDeviceImageFormatInfo2));
        deepcopy_VkPhysicalDeviceImageFormatInfo2(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pImageFormatInfo, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    }
    if (local_pImageFormatInfo)
    {
        transform_tohost_VkPhysicalDeviceImageFormatInfo2(sResourceTracker, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceImageFormatInfo2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo), countPtr);
        count_VkImageFormatProperties2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageFormatProperties2*)(pImageFormatProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceImageFormatProperties2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceImageFormatProperties2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceImageFormatProperties2KHR = OP_vkGetPhysicalDeviceImageFormatProperties2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceImageFormatProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceImageFormatProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceImageFormatInfo2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceImageFormatInfo2*)(local_pImageFormatInfo), streamPtrPtr);
    reservedmarshal_VkImageFormatProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageFormatProperties2*)(pImageFormatProperties), streamPtrPtr);
    unmarshal_VkImageFormatProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageFormatProperties2*)(pImageFormatProperties));
    if (pImageFormatProperties)
    {
        transform_fromhost_VkImageFormatProperties2(sResourceTracker, (VkImageFormatProperties2*)(pImageFormatProperties));
    }
    VkResult vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceImageFormatProperties2KHR_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pQueueFamilyPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pQueueFamilyProperties)
        {
            if (pQueueFamilyPropertyCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
                {
                    count_VkQueueFamilyProperties2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceQueueFamilyProperties2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceQueueFamilyProperties2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceQueueFamilyProperties2KHR = OP_vkGetPhysicalDeviceQueueFamilyProperties2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceQueueFamilyProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceQueueFamilyProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pQueueFamilyPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pQueueFamilyPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pQueueFamilyProperties;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pQueueFamilyProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
        {
            reservedmarshal_VkQueueFamilyProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pQueueFamilyPropertyCount;
    check_pQueueFamilyPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyPropertyCount)
    {
        if (!(check_pQueueFamilyPropertyCount))
        {
            fprintf(stderr, "fatal: pQueueFamilyPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pQueueFamilyPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkQueueFamilyProperties2* check_pQueueFamilyProperties;
    check_pQueueFamilyProperties = (VkQueueFamilyProperties2*)(uintptr_t)stream->getBe64();
    if (pQueueFamilyProperties)
    {
        if (!(check_pQueueFamilyProperties))
        {
            fprintf(stderr, "fatal: pQueueFamilyProperties inconsistent between guest and host\n");
        }
        if (pQueueFamilyPropertyCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
            {
                unmarshal_VkQueueFamilyProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
            }
        }
    }
    if (pQueueFamilyPropertyCount)
    {
        if (pQueueFamilyProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pQueueFamilyPropertyCount)); ++i)
            {
                transform_fromhost_VkQueueFamilyProperties2(sResourceTracker, (VkQueueFamilyProperties2*)(pQueueFamilyProperties + i));
            }
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceMemoryProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceMemoryProperties2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceMemoryProperties2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceMemoryProperties2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceMemoryProperties2KHR = OP_vkGetPhysicalDeviceMemoryProperties2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceMemoryProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceMemoryProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceMemoryProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties), streamPtrPtr);
    unmarshal_VkPhysicalDeviceMemoryProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    if (pMemoryProperties)
    {
        transform_fromhost_VkPhysicalDeviceMemoryProperties2(sResourceTracker, (VkPhysicalDeviceMemoryProperties2*)(pMemoryProperties));
    }
    sResourceTracker->on_vkGetPhysicalDeviceMemoryProperties2KHR(this, physicalDevice, pMemoryProperties);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceSparseImageFormatInfo2* local_pFormatInfo;
    local_physicalDevice = physicalDevice;
    local_pFormatInfo = nullptr;
    if (pFormatInfo)
    {
        local_pFormatInfo = (VkPhysicalDeviceSparseImageFormatInfo2*)pool->alloc(sizeof(const VkPhysicalDeviceSparseImageFormatInfo2));
        deepcopy_VkPhysicalDeviceSparseImageFormatInfo2(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pFormatInfo, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    }
    if (local_pFormatInfo)
    {
        transform_tohost_VkPhysicalDeviceSparseImageFormatInfo2(sResourceTracker, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceSparseImageFormatInfo2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            if (pPropertyCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                {
                    count_VkSparseImageFormatProperties2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageFormatProperties2*)(pProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = OP_vkGetPhysicalDeviceSparseImageFormatProperties2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSparseImageFormatProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSparseImageFormatProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceSparseImageFormatInfo2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceSparseImageFormatInfo2*)(local_pFormatInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkSparseImageFormatProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageFormatProperties2*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageFormatProperties2* check_pProperties;
    check_pProperties = (VkSparseImageFormatProperties2*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        if (pPropertyCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                unmarshal_VkSparseImageFormatProperties2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageFormatProperties2*)(pProperties + i));
            }
        }
    }
    if (pPropertyCount)
    {
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                transform_fromhost_VkSparseImageFormatProperties2(sResourceTracker, (VkSparseImageFormatProperties2*)(pProperties + i));
            }
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_device_group
void VkEncoder::vkGetDeviceGroupPeerMemoryFeaturesKHR(
    VkDevice device,
    uint32_t heapIndex,
    uint32_t localDeviceIndex,
    uint32_t remoteDeviceIndex,
    VkPeerMemoryFeatureFlags* pPeerMemoryFeatures,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_heapIndex;
    uint32_t local_localDeviceIndex;
    uint32_t local_remoteDeviceIndex;
    local_device = device;
    local_heapIndex = heapIndex;
    local_localDeviceIndex = localDeviceIndex;
    local_remoteDeviceIndex = remoteDeviceIndex;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(VkPeerMemoryFeatureFlags);
    }
    uint32_t packetSize_vkGetDeviceGroupPeerMemoryFeaturesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceGroupPeerMemoryFeaturesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceGroupPeerMemoryFeaturesKHR = OP_vkGetDeviceGroupPeerMemoryFeaturesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceGroupPeerMemoryFeaturesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceGroupPeerMemoryFeaturesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_heapIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_localDeviceIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_remoteDeviceIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    *streamPtrPtr += sizeof(VkPeerMemoryFeatureFlags);
    stream->read((VkPeerMemoryFeatureFlags*)pPeerMemoryFeatures, sizeof(VkPeerMemoryFeatureFlags));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetDeviceMaskKHR(
    VkCommandBuffer commandBuffer,
    uint32_t deviceMask,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_deviceMask;
    local_commandBuffer = commandBuffer;
    local_deviceMask = deviceMask;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdSetDeviceMaskKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetDeviceMaskKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetDeviceMaskKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetDeviceMaskKHR = OP_vkCmdSetDeviceMaskKHR;
    memcpy(streamPtr, &opcode_vkCmdSetDeviceMaskKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetDeviceMaskKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_deviceMask, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDispatchBaseKHR(
    VkCommandBuffer commandBuffer,
    uint32_t baseGroupX,
    uint32_t baseGroupY,
    uint32_t baseGroupZ,
    uint32_t groupCountX,
    uint32_t groupCountY,
    uint32_t groupCountZ,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_baseGroupX;
    uint32_t local_baseGroupY;
    uint32_t local_baseGroupZ;
    uint32_t local_groupCountX;
    uint32_t local_groupCountY;
    uint32_t local_groupCountZ;
    local_commandBuffer = commandBuffer;
    local_baseGroupX = baseGroupX;
    local_baseGroupY = baseGroupY;
    local_baseGroupZ = baseGroupZ;
    local_groupCountX = groupCountX;
    local_groupCountY = groupCountY;
    local_groupCountZ = groupCountZ;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDispatchBaseKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDispatchBaseKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDispatchBaseKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDispatchBaseKHR = OP_vkCmdDispatchBaseKHR;
    memcpy(streamPtr, &opcode_vkCmdDispatchBaseKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDispatchBaseKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_baseGroupX, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_baseGroupY, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_baseGroupZ, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCountX, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCountY, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCountZ, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
void VkEncoder::vkTrimCommandPoolKHR(
    VkDevice device,
    VkCommandPool commandPool,
    VkCommandPoolTrimFlags flags,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkCommandPool local_commandPool;
    VkCommandPoolTrimFlags local_flags;
    local_device = device;
    local_commandPool = commandPool;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkCommandPoolTrimFlags);
    }
    uint32_t packetSize_vkTrimCommandPoolKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkTrimCommandPoolKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkTrimCommandPoolKHR = OP_vkTrimCommandPoolKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkTrimCommandPoolKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkTrimCommandPoolKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkCommandPool((*&local_commandPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkCommandPoolTrimFlags*)&local_flags, sizeof(VkCommandPoolTrimFlags));
    *streamPtrPtr += sizeof(VkCommandPoolTrimFlags);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_device_group_creation
VkResult VkEncoder::vkEnumeratePhysicalDeviceGroupsKHR(
    VkInstance instance,
    uint32_t* pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    local_instance = instance;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPhysicalDeviceGroupCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPhysicalDeviceGroupProperties)
        {
            if (pPhysicalDeviceGroupCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
                {
                    count_VkPhysicalDeviceGroupProperties(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkEnumeratePhysicalDeviceGroupsKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEnumeratePhysicalDeviceGroupsKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEnumeratePhysicalDeviceGroupsKHR = OP_vkEnumeratePhysicalDeviceGroupsKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkEnumeratePhysicalDeviceGroupsKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEnumeratePhysicalDeviceGroupsKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPhysicalDeviceGroupCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pPhysicalDeviceGroupProperties;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPhysicalDeviceGroupProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
        {
            reservedmarshal_VkPhysicalDeviceGroupProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPhysicalDeviceGroupCount;
    check_pPhysicalDeviceGroupCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceGroupCount)
    {
        if (!(check_pPhysicalDeviceGroupCount))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPhysicalDeviceGroupCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPhysicalDeviceGroupProperties* check_pPhysicalDeviceGroupProperties;
    check_pPhysicalDeviceGroupProperties = (VkPhysicalDeviceGroupProperties*)(uintptr_t)stream->getBe64();
    if (pPhysicalDeviceGroupProperties)
    {
        if (!(check_pPhysicalDeviceGroupProperties))
        {
            fprintf(stderr, "fatal: pPhysicalDeviceGroupProperties inconsistent between guest and host\n");
        }
        if (pPhysicalDeviceGroupCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
            {
                unmarshal_VkPhysicalDeviceGroupProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
            }
        }
    }
    if (pPhysicalDeviceGroupCount)
    {
        if (pPhysicalDeviceGroupProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPhysicalDeviceGroupCount)); ++i)
            {
                transform_fromhost_VkPhysicalDeviceGroupProperties(sResourceTracker, (VkPhysicalDeviceGroupProperties*)(pPhysicalDeviceGroupProperties + i));
            }
        }
    }
    VkResult vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return = (VkResult)0;
    stream->read(&vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEnumeratePhysicalDeviceGroupsKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_memory_capabilities
void VkEncoder::vkGetPhysicalDeviceExternalBufferPropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalBufferInfo* local_pExternalBufferInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalBufferInfo = nullptr;
    if (pExternalBufferInfo)
    {
        local_pExternalBufferInfo = (VkPhysicalDeviceExternalBufferInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalBufferInfo));
        deepcopy_VkPhysicalDeviceExternalBufferInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pExternalBufferInfo, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    }
    if (local_pExternalBufferInfo)
    {
        sResourceTracker->transformImpl_VkPhysicalDeviceExternalBufferInfo_tohost(local_pExternalBufferInfo, 1);
        transform_tohost_VkPhysicalDeviceExternalBufferInfo(sResourceTracker, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceExternalBufferInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo), countPtr);
        count_VkExternalBufferProperties(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalBufferProperties*)(pExternalBufferProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalBufferPropertiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceExternalBufferPropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceExternalBufferPropertiesKHR = OP_vkGetPhysicalDeviceExternalBufferPropertiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceExternalBufferPropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceExternalBufferPropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceExternalBufferInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceExternalBufferInfo*)(local_pExternalBufferInfo), streamPtrPtr);
    reservedmarshal_VkExternalBufferProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalBufferProperties*)(pExternalBufferProperties), streamPtrPtr);
    unmarshal_VkExternalBufferProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalBufferProperties*)(pExternalBufferProperties));
    if (pExternalBufferProperties)
    {
        sResourceTracker->transformImpl_VkExternalBufferProperties_fromhost(pExternalBufferProperties, 1);
        transform_fromhost_VkExternalBufferProperties(sResourceTracker, (VkExternalBufferProperties*)(pExternalBufferProperties));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
VkResult VkEncoder::vkGetMemoryWin32HandleKHR(
    VkDevice device,
    const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkMemoryGetWin32HandleInfoKHR* local_pGetWin32HandleInfo;
    local_device = device;
    local_pGetWin32HandleInfo = nullptr;
    if (pGetWin32HandleInfo)
    {
        local_pGetWin32HandleInfo = (VkMemoryGetWin32HandleInfoKHR*)pool->alloc(sizeof(const VkMemoryGetWin32HandleInfoKHR));
        deepcopy_VkMemoryGetWin32HandleInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pGetWin32HandleInfo, (VkMemoryGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    if (local_pGetWin32HandleInfo)
    {
        transform_tohost_VkMemoryGetWin32HandleInfoKHR(sResourceTracker, (VkMemoryGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkMemoryGetWin32HandleInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo), countPtr);
        *countPtr += sizeof(HANDLE);
    }
    uint32_t packetSize_vkGetMemoryWin32HandleKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMemoryWin32HandleKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMemoryWin32HandleKHR = OP_vkGetMemoryWin32HandleKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMemoryWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMemoryWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkMemoryGetWin32HandleInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (HANDLE*)pHandle, sizeof(HANDLE));
    *streamPtrPtr += sizeof(HANDLE);
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult vkGetMemoryWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryWin32HandleKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetMemoryWin32HandleKHR_VkResult_return;
}

VkResult VkEncoder::vkGetMemoryWin32HandlePropertiesKHR(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    HANDLE handle,
    VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkExternalMemoryHandleTypeFlagBits local_handleType;
    HANDLE local_handle;
    local_device = device;
    local_handleType = handleType;
    local_handle = handle;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkExternalMemoryHandleTypeFlagBits);
        *countPtr += sizeof(HANDLE);
        count_VkMemoryWin32HandlePropertiesKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties), countPtr);
    }
    uint32_t packetSize_vkGetMemoryWin32HandlePropertiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMemoryWin32HandlePropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMemoryWin32HandlePropertiesKHR = OP_vkGetMemoryWin32HandlePropertiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMemoryWin32HandlePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMemoryWin32HandlePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkExternalMemoryHandleTypeFlagBits*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *streamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagBits);
    memcpy(*streamPtrPtr, (HANDLE*)&local_handle, sizeof(HANDLE));
    *streamPtrPtr += sizeof(HANDLE);
    reservedmarshal_VkMemoryWin32HandlePropertiesKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties), streamPtrPtr);
    unmarshal_VkMemoryWin32HandlePropertiesKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
    if (pMemoryWin32HandleProperties)
    {
        transform_fromhost_VkMemoryWin32HandlePropertiesKHR(sResourceTracker, (VkMemoryWin32HandlePropertiesKHR*)(pMemoryWin32HandleProperties));
    }
    VkResult vkGetMemoryWin32HandlePropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryWin32HandlePropertiesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetMemoryWin32HandlePropertiesKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_memory_fd
VkResult VkEncoder::vkGetMemoryFdKHR(
    VkDevice device,
    const VkMemoryGetFdInfoKHR* pGetFdInfo,
    int* pFd,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkMemoryGetFdInfoKHR* local_pGetFdInfo;
    local_device = device;
    local_pGetFdInfo = nullptr;
    if (pGetFdInfo)
    {
        local_pGetFdInfo = (VkMemoryGetFdInfoKHR*)pool->alloc(sizeof(const VkMemoryGetFdInfoKHR));
        deepcopy_VkMemoryGetFdInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pGetFdInfo, (VkMemoryGetFdInfoKHR*)(local_pGetFdInfo));
    }
    if (local_pGetFdInfo)
    {
        transform_tohost_VkMemoryGetFdInfoKHR(sResourceTracker, (VkMemoryGetFdInfoKHR*)(local_pGetFdInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkMemoryGetFdInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryGetFdInfoKHR*)(local_pGetFdInfo), countPtr);
        *countPtr += sizeof(int);
    }
    uint32_t packetSize_vkGetMemoryFdKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMemoryFdKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMemoryFdKHR = OP_vkGetMemoryFdKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMemoryFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMemoryFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkMemoryGetFdInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryGetFdInfoKHR*)(local_pGetFdInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (int*)pFd, sizeof(int));
    *streamPtrPtr += sizeof(int);
    stream->read((int*)pFd, sizeof(int));
    VkResult vkGetMemoryFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryFdKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetMemoryFdKHR_VkResult_return;
}

VkResult VkEncoder::vkGetMemoryFdPropertiesKHR(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    int fd,
    VkMemoryFdPropertiesKHR* pMemoryFdProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkExternalMemoryHandleTypeFlagBits local_handleType;
    int local_fd;
    local_device = device;
    local_handleType = handleType;
    local_fd = fd;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkExternalMemoryHandleTypeFlagBits);
        *countPtr += sizeof(int);
        count_VkMemoryFdPropertiesKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties), countPtr);
    }
    uint32_t packetSize_vkGetMemoryFdPropertiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMemoryFdPropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMemoryFdPropertiesKHR = OP_vkGetMemoryFdPropertiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMemoryFdPropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMemoryFdPropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkExternalMemoryHandleTypeFlagBits*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *streamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagBits);
    memcpy(*streamPtrPtr, (int*)&local_fd, sizeof(int));
    *streamPtrPtr += sizeof(int);
    reservedmarshal_VkMemoryFdPropertiesKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties), streamPtrPtr);
    unmarshal_VkMemoryFdPropertiesKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
    if (pMemoryFdProperties)
    {
        transform_fromhost_VkMemoryFdPropertiesKHR(sResourceTracker, (VkMemoryFdPropertiesKHR*)(pMemoryFdProperties));
    }
    VkResult vkGetMemoryFdPropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryFdPropertiesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetMemoryFdPropertiesKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
#endif
#ifdef VK_KHR_external_semaphore_capabilities
void VkEncoder::vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalSemaphoreInfo* local_pExternalSemaphoreInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalSemaphoreInfo = nullptr;
    if (pExternalSemaphoreInfo)
    {
        local_pExternalSemaphoreInfo = (VkPhysicalDeviceExternalSemaphoreInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalSemaphoreInfo));
        deepcopy_VkPhysicalDeviceExternalSemaphoreInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pExternalSemaphoreInfo, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    }
    if (local_pExternalSemaphoreInfo)
    {
        transform_tohost_VkPhysicalDeviceExternalSemaphoreInfo(sResourceTracker, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceExternalSemaphoreInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo), countPtr);
        count_VkExternalSemaphoreProperties(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = OP_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceExternalSemaphoreInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceExternalSemaphoreInfo*)(local_pExternalSemaphoreInfo), streamPtrPtr);
    reservedmarshal_VkExternalSemaphoreProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties), streamPtrPtr);
    unmarshal_VkExternalSemaphoreProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    if (pExternalSemaphoreProperties)
    {
        transform_fromhost_VkExternalSemaphoreProperties(sResourceTracker, (VkExternalSemaphoreProperties*)(pExternalSemaphoreProperties));
    }
    sResourceTracker->on_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(this, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
VkResult VkEncoder::vkImportSemaphoreWin32HandleKHR(
    VkDevice device,
    const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImportSemaphoreWin32HandleInfoKHR* local_pImportSemaphoreWin32HandleInfo;
    local_device = device;
    local_pImportSemaphoreWin32HandleInfo = nullptr;
    if (pImportSemaphoreWin32HandleInfo)
    {
        local_pImportSemaphoreWin32HandleInfo = (VkImportSemaphoreWin32HandleInfoKHR*)pool->alloc(sizeof(const VkImportSemaphoreWin32HandleInfoKHR));
        deepcopy_VkImportSemaphoreWin32HandleInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pImportSemaphoreWin32HandleInfo, (VkImportSemaphoreWin32HandleInfoKHR*)(local_pImportSemaphoreWin32HandleInfo));
    }
    if (local_pImportSemaphoreWin32HandleInfo)
    {
        transform_tohost_VkImportSemaphoreWin32HandleInfoKHR(sResourceTracker, (VkImportSemaphoreWin32HandleInfoKHR*)(local_pImportSemaphoreWin32HandleInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkImportSemaphoreWin32HandleInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImportSemaphoreWin32HandleInfoKHR*)(local_pImportSemaphoreWin32HandleInfo), countPtr);
    }
    uint32_t packetSize_vkImportSemaphoreWin32HandleKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkImportSemaphoreWin32HandleKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkImportSemaphoreWin32HandleKHR = OP_vkImportSemaphoreWin32HandleKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkImportSemaphoreWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkImportSemaphoreWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImportSemaphoreWin32HandleInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImportSemaphoreWin32HandleInfoKHR*)(local_pImportSemaphoreWin32HandleInfo), streamPtrPtr);
    VkResult vkImportSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkImportSemaphoreWin32HandleKHR_VkResult_return;
}

VkResult VkEncoder::vkGetSemaphoreWin32HandleKHR(
    VkDevice device,
    const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSemaphoreGetWin32HandleInfoKHR* local_pGetWin32HandleInfo;
    local_device = device;
    local_pGetWin32HandleInfo = nullptr;
    if (pGetWin32HandleInfo)
    {
        local_pGetWin32HandleInfo = (VkSemaphoreGetWin32HandleInfoKHR*)pool->alloc(sizeof(const VkSemaphoreGetWin32HandleInfoKHR));
        deepcopy_VkSemaphoreGetWin32HandleInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pGetWin32HandleInfo, (VkSemaphoreGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    if (local_pGetWin32HandleInfo)
    {
        transform_tohost_VkSemaphoreGetWin32HandleInfoKHR(sResourceTracker, (VkSemaphoreGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkSemaphoreGetWin32HandleInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo), countPtr);
        *countPtr += sizeof(HANDLE);
    }
    uint32_t packetSize_vkGetSemaphoreWin32HandleKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetSemaphoreWin32HandleKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetSemaphoreWin32HandleKHR = OP_vkGetSemaphoreWin32HandleKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetSemaphoreWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetSemaphoreWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSemaphoreGetWin32HandleInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (HANDLE*)pHandle, sizeof(HANDLE));
    *streamPtrPtr += sizeof(HANDLE);
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult vkGetSemaphoreWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSemaphoreWin32HandleKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetSemaphoreWin32HandleKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_semaphore_fd
VkResult VkEncoder::vkImportSemaphoreFdKHR(
    VkDevice device,
    const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImportSemaphoreFdInfoKHR* local_pImportSemaphoreFdInfo;
    local_device = device;
    local_pImportSemaphoreFdInfo = nullptr;
    if (pImportSemaphoreFdInfo)
    {
        local_pImportSemaphoreFdInfo = (VkImportSemaphoreFdInfoKHR*)pool->alloc(sizeof(const VkImportSemaphoreFdInfoKHR));
        deepcopy_VkImportSemaphoreFdInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pImportSemaphoreFdInfo, (VkImportSemaphoreFdInfoKHR*)(local_pImportSemaphoreFdInfo));
    }
    if (local_pImportSemaphoreFdInfo)
    {
        transform_tohost_VkImportSemaphoreFdInfoKHR(sResourceTracker, (VkImportSemaphoreFdInfoKHR*)(local_pImportSemaphoreFdInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkImportSemaphoreFdInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImportSemaphoreFdInfoKHR*)(local_pImportSemaphoreFdInfo), countPtr);
    }
    uint32_t packetSize_vkImportSemaphoreFdKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkImportSemaphoreFdKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkImportSemaphoreFdKHR = OP_vkImportSemaphoreFdKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkImportSemaphoreFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkImportSemaphoreFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImportSemaphoreFdInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImportSemaphoreFdInfoKHR*)(local_pImportSemaphoreFdInfo), streamPtrPtr);
    VkResult vkImportSemaphoreFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkImportSemaphoreFdKHR_VkResult_return;
}

VkResult VkEncoder::vkGetSemaphoreFdKHR(
    VkDevice device,
    const VkSemaphoreGetFdInfoKHR* pGetFdInfo,
    int* pFd,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSemaphoreGetFdInfoKHR* local_pGetFdInfo;
    local_device = device;
    local_pGetFdInfo = nullptr;
    if (pGetFdInfo)
    {
        local_pGetFdInfo = (VkSemaphoreGetFdInfoKHR*)pool->alloc(sizeof(const VkSemaphoreGetFdInfoKHR));
        deepcopy_VkSemaphoreGetFdInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pGetFdInfo, (VkSemaphoreGetFdInfoKHR*)(local_pGetFdInfo));
    }
    if (local_pGetFdInfo)
    {
        transform_tohost_VkSemaphoreGetFdInfoKHR(sResourceTracker, (VkSemaphoreGetFdInfoKHR*)(local_pGetFdInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkSemaphoreGetFdInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreGetFdInfoKHR*)(local_pGetFdInfo), countPtr);
        *countPtr += sizeof(int);
    }
    uint32_t packetSize_vkGetSemaphoreFdKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetSemaphoreFdKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetSemaphoreFdKHR = OP_vkGetSemaphoreFdKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetSemaphoreFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetSemaphoreFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSemaphoreGetFdInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreGetFdInfoKHR*)(local_pGetFdInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (int*)pFd, sizeof(int));
    *streamPtrPtr += sizeof(int);
    stream->read((int*)pFd, sizeof(int));
    VkResult vkGetSemaphoreFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSemaphoreFdKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetSemaphoreFdKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_push_descriptor
void VkEncoder::vkCmdPushDescriptorSetKHR(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipelineLayout layout,
    uint32_t set,
    uint32_t descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPipelineBindPoint local_pipelineBindPoint;
    VkPipelineLayout local_layout;
    uint32_t local_set;
    uint32_t local_descriptorWriteCount;
    VkWriteDescriptorSet* local_pDescriptorWrites;
    local_commandBuffer = commandBuffer;
    local_pipelineBindPoint = pipelineBindPoint;
    local_layout = layout;
    local_set = set;
    local_descriptorWriteCount = descriptorWriteCount;
    local_pDescriptorWrites = nullptr;
    if (pDescriptorWrites)
    {
        local_pDescriptorWrites = (VkWriteDescriptorSet*)pool->alloc(((descriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            deepcopy_VkWriteDescriptorSet(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pDescriptorWrites + i, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
    }
    if (local_pDescriptorWrites)
    {
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            transform_tohost_VkWriteDescriptorSet(sResourceTracker, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPipelineBindPoint);
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
        {
            count_VkWriteDescriptorSet(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdPushDescriptorSetKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdPushDescriptorSetKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdPushDescriptorSetKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdPushDescriptorSetKHR = OP_vkCmdPushDescriptorSetKHR;
    memcpy(streamPtr, &opcode_vkCmdPushDescriptorSetKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdPushDescriptorSetKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
    *streamPtrPtr += sizeof(VkPipelineBindPoint);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPipelineLayout((*&local_layout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_set, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_descriptorWriteCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((descriptorWriteCount)); ++i)
    {
        reservedmarshal_VkWriteDescriptorSet(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkWriteDescriptorSet*)(local_pDescriptorWrites + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdPushDescriptorSetWithTemplateKHR(
    VkCommandBuffer commandBuffer,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    VkPipelineLayout layout,
    uint32_t set,
    const void* pData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    VkPipelineLayout local_layout;
    uint32_t local_set;
    void* local_pData;
    local_commandBuffer = commandBuffer;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_layout = layout;
    local_set = set;
    // Avoiding deepcopy for pData
    local_pData = (void*)pData;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pData)
        {
            *countPtr += sizeof(uint8_t);
        }
    }
    uint32_t packetSize_vkCmdPushDescriptorSetWithTemplateKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdPushDescriptorSetWithTemplateKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdPushDescriptorSetWithTemplateKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdPushDescriptorSetWithTemplateKHR = OP_vkCmdPushDescriptorSetWithTemplateKHR;
    memcpy(streamPtr, &opcode_vkCmdPushDescriptorSetWithTemplateKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdPushDescriptorSetWithTemplateKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDescriptorUpdateTemplate((*&local_descriptorUpdateTemplate));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkPipelineLayout((*&local_layout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_set, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pData;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pData)
    {
        memcpy(*streamPtrPtr, (void*)local_pData, sizeof(uint8_t));
        *streamPtrPtr += sizeof(uint8_t);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_shader_float16_int8
#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
#endif
#ifdef VK_KHR_descriptor_update_template
VkResult VkEncoder::vkCreateDescriptorUpdateTemplateKHR(
    VkDevice device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorUpdateTemplateCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorUpdateTemplateCreateInfo*)pool->alloc(sizeof(const VkDescriptorUpdateTemplateCreateInfo));
        deepcopy_VkDescriptorUpdateTemplateCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorUpdateTemplateCreateInfo(sResourceTracker, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDescriptorUpdateTemplateCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDescriptorUpdateTemplateKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDescriptorUpdateTemplateKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDescriptorUpdateTemplateKHR = OP_vkCreateDescriptorUpdateTemplateKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDescriptorUpdateTemplateKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDescriptorUpdateTemplateKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDescriptorUpdateTemplateCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorUpdateTemplateCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pDescriptorUpdateTemplate));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkDescriptorUpdateTemplate(&cgen_var_3, (VkDescriptorUpdateTemplate*)pDescriptorUpdateTemplate, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDescriptorUpdateTemplateKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDescriptorUpdateTemplateKHR_VkResult_return, sizeof(VkResult));
    sResourceTracker->on_vkCreateDescriptorUpdateTemplateKHR(this, vkCreateDescriptorUpdateTemplateKHR_VkResult_return, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDescriptorUpdateTemplateKHR_VkResult_return;
}

void VkEncoder::vkDestroyDescriptorUpdateTemplateKHR(
    VkDevice device,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyDescriptorUpdateTemplateKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyDescriptorUpdateTemplateKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyDescriptorUpdateTemplateKHR = OP_vkDestroyDescriptorUpdateTemplateKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyDescriptorUpdateTemplateKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyDescriptorUpdateTemplateKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDescriptorUpdateTemplate((*&local_descriptorUpdateTemplate));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkDescriptorUpdateTemplate((VkDescriptorUpdateTemplate*)&descriptorUpdateTemplate);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkUpdateDescriptorSetWithTemplateKHR(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    const void* pData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorSet local_descriptorSet;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    void* local_pData;
    local_device = device;
    local_descriptorSet = descriptorSet;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    // Avoiding deepcopy for pData
    local_pData = (void*)pData;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pData)
        {
            *countPtr += sizeof(uint8_t);
        }
    }
    uint32_t packetSize_vkUpdateDescriptorSetWithTemplateKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkUpdateDescriptorSetWithTemplateKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkUpdateDescriptorSetWithTemplateKHR = OP_vkUpdateDescriptorSetWithTemplateKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkUpdateDescriptorSetWithTemplateKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkUpdateDescriptorSetWithTemplateKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDescriptorSet((*&local_descriptorSet));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_2;
    *&cgen_var_2 = get_host_u64_VkDescriptorUpdateTemplate((*&local_descriptorUpdateTemplate));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)local_pData;
    memcpy((*streamPtrPtr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pData)
    {
        memcpy(*streamPtrPtr, (void*)local_pData, sizeof(uint8_t));
        *streamPtrPtr += sizeof(uint8_t);
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_imageless_framebuffer
#endif
#ifdef VK_KHR_create_renderpass2
VkResult VkEncoder::vkCreateRenderPass2KHR(
    VkDevice device,
    const VkRenderPassCreateInfo2* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkRenderPass* pRenderPass,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkRenderPassCreateInfo2* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkRenderPassCreateInfo2*)pool->alloc(sizeof(const VkRenderPassCreateInfo2));
        deepcopy_VkRenderPassCreateInfo2(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkRenderPassCreateInfo2*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkRenderPassCreateInfo2(sResourceTracker, (VkRenderPassCreateInfo2*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkRenderPassCreateInfo2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRenderPassCreateInfo2*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateRenderPass2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateRenderPass2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateRenderPass2KHR = OP_vkCreateRenderPass2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateRenderPass2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateRenderPass2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkRenderPassCreateInfo2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRenderPassCreateInfo2*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pRenderPass));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_3, (VkRenderPass*)pRenderPass, 1);
    VkResult vkCreateRenderPass2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateRenderPass2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateRenderPass2KHR_VkResult_return;
}

void VkEncoder::vkCmdBeginRenderPass2KHR(
    VkCommandBuffer commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    const VkSubpassBeginInfo* pSubpassBeginInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkRenderPassBeginInfo* local_pRenderPassBegin;
    VkSubpassBeginInfo* local_pSubpassBeginInfo;
    local_commandBuffer = commandBuffer;
    local_pRenderPassBegin = nullptr;
    if (pRenderPassBegin)
    {
        local_pRenderPassBegin = (VkRenderPassBeginInfo*)pool->alloc(sizeof(const VkRenderPassBeginInfo));
        deepcopy_VkRenderPassBeginInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pRenderPassBegin, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    }
    local_pSubpassBeginInfo = nullptr;
    if (pSubpassBeginInfo)
    {
        local_pSubpassBeginInfo = (VkSubpassBeginInfo*)pool->alloc(sizeof(const VkSubpassBeginInfo));
        deepcopy_VkSubpassBeginInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pSubpassBeginInfo, (VkSubpassBeginInfo*)(local_pSubpassBeginInfo));
    }
    if (local_pRenderPassBegin)
    {
        transform_tohost_VkRenderPassBeginInfo(sResourceTracker, (VkRenderPassBeginInfo*)(local_pRenderPassBegin));
    }
    if (local_pSubpassBeginInfo)
    {
        transform_tohost_VkSubpassBeginInfo(sResourceTracker, (VkSubpassBeginInfo*)(local_pSubpassBeginInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkRenderPassBeginInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRenderPassBeginInfo*)(local_pRenderPassBegin), countPtr);
        count_VkSubpassBeginInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassBeginInfo*)(local_pSubpassBeginInfo), countPtr);
    }
    uint32_t packetSize_vkCmdBeginRenderPass2KHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBeginRenderPass2KHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBeginRenderPass2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBeginRenderPass2KHR = OP_vkCmdBeginRenderPass2KHR;
    memcpy(streamPtr, &opcode_vkCmdBeginRenderPass2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBeginRenderPass2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkRenderPassBeginInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRenderPassBeginInfo*)(local_pRenderPassBegin), streamPtrPtr);
    reservedmarshal_VkSubpassBeginInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassBeginInfo*)(local_pSubpassBeginInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdNextSubpass2KHR(
    VkCommandBuffer commandBuffer,
    const VkSubpassBeginInfo* pSubpassBeginInfo,
    const VkSubpassEndInfo* pSubpassEndInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkSubpassBeginInfo* local_pSubpassBeginInfo;
    VkSubpassEndInfo* local_pSubpassEndInfo;
    local_commandBuffer = commandBuffer;
    local_pSubpassBeginInfo = nullptr;
    if (pSubpassBeginInfo)
    {
        local_pSubpassBeginInfo = (VkSubpassBeginInfo*)pool->alloc(sizeof(const VkSubpassBeginInfo));
        deepcopy_VkSubpassBeginInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pSubpassBeginInfo, (VkSubpassBeginInfo*)(local_pSubpassBeginInfo));
    }
    local_pSubpassEndInfo = nullptr;
    if (pSubpassEndInfo)
    {
        local_pSubpassEndInfo = (VkSubpassEndInfo*)pool->alloc(sizeof(const VkSubpassEndInfo));
        deepcopy_VkSubpassEndInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pSubpassEndInfo, (VkSubpassEndInfo*)(local_pSubpassEndInfo));
    }
    if (local_pSubpassBeginInfo)
    {
        transform_tohost_VkSubpassBeginInfo(sResourceTracker, (VkSubpassBeginInfo*)(local_pSubpassBeginInfo));
    }
    if (local_pSubpassEndInfo)
    {
        transform_tohost_VkSubpassEndInfo(sResourceTracker, (VkSubpassEndInfo*)(local_pSubpassEndInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkSubpassBeginInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassBeginInfo*)(local_pSubpassBeginInfo), countPtr);
        count_VkSubpassEndInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassEndInfo*)(local_pSubpassEndInfo), countPtr);
    }
    uint32_t packetSize_vkCmdNextSubpass2KHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdNextSubpass2KHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdNextSubpass2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdNextSubpass2KHR = OP_vkCmdNextSubpass2KHR;
    memcpy(streamPtr, &opcode_vkCmdNextSubpass2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdNextSubpass2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkSubpassBeginInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassBeginInfo*)(local_pSubpassBeginInfo), streamPtrPtr);
    reservedmarshal_VkSubpassEndInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassEndInfo*)(local_pSubpassEndInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdEndRenderPass2KHR(
    VkCommandBuffer commandBuffer,
    const VkSubpassEndInfo* pSubpassEndInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkSubpassEndInfo* local_pSubpassEndInfo;
    local_commandBuffer = commandBuffer;
    local_pSubpassEndInfo = nullptr;
    if (pSubpassEndInfo)
    {
        local_pSubpassEndInfo = (VkSubpassEndInfo*)pool->alloc(sizeof(const VkSubpassEndInfo));
        deepcopy_VkSubpassEndInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pSubpassEndInfo, (VkSubpassEndInfo*)(local_pSubpassEndInfo));
    }
    if (local_pSubpassEndInfo)
    {
        transform_tohost_VkSubpassEndInfo(sResourceTracker, (VkSubpassEndInfo*)(local_pSubpassEndInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkSubpassEndInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassEndInfo*)(local_pSubpassEndInfo), countPtr);
    }
    uint32_t packetSize_vkCmdEndRenderPass2KHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdEndRenderPass2KHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdEndRenderPass2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdEndRenderPass2KHR = OP_vkCmdEndRenderPass2KHR;
    memcpy(streamPtr, &opcode_vkCmdEndRenderPass2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdEndRenderPass2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkSubpassEndInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubpassEndInfo*)(local_pSubpassEndInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_shared_presentable_image
VkResult VkEncoder::vkGetSwapchainStatusKHR(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    local_device = device;
    local_swapchain = swapchain;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkGetSwapchainStatusKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetSwapchainStatusKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetSwapchainStatusKHR = OP_vkGetSwapchainStatusKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetSwapchainStatusKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetSwapchainStatusKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSwapchainKHR((*&local_swapchain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkGetSwapchainStatusKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainStatusKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetSwapchainStatusKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_fence_capabilities
void VkEncoder::vkGetPhysicalDeviceExternalFencePropertiesKHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceExternalFenceInfo* local_pExternalFenceInfo;
    local_physicalDevice = physicalDevice;
    local_pExternalFenceInfo = nullptr;
    if (pExternalFenceInfo)
    {
        local_pExternalFenceInfo = (VkPhysicalDeviceExternalFenceInfo*)pool->alloc(sizeof(const VkPhysicalDeviceExternalFenceInfo));
        deepcopy_VkPhysicalDeviceExternalFenceInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pExternalFenceInfo, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    }
    if (local_pExternalFenceInfo)
    {
        transform_tohost_VkPhysicalDeviceExternalFenceInfo(sResourceTracker, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceExternalFenceInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo), countPtr);
        count_VkExternalFenceProperties(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalFenceProperties*)(pExternalFenceProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalFencePropertiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceExternalFencePropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceExternalFencePropertiesKHR = OP_vkGetPhysicalDeviceExternalFencePropertiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceExternalFencePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceExternalFencePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceExternalFenceInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceExternalFenceInfo*)(local_pExternalFenceInfo), streamPtrPtr);
    reservedmarshal_VkExternalFenceProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalFenceProperties*)(pExternalFenceProperties), streamPtrPtr);
    unmarshal_VkExternalFenceProperties(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalFenceProperties*)(pExternalFenceProperties));
    if (pExternalFenceProperties)
    {
        transform_fromhost_VkExternalFenceProperties(sResourceTracker, (VkExternalFenceProperties*)(pExternalFenceProperties));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
VkResult VkEncoder::vkImportFenceWin32HandleKHR(
    VkDevice device,
    const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImportFenceWin32HandleInfoKHR* local_pImportFenceWin32HandleInfo;
    local_device = device;
    local_pImportFenceWin32HandleInfo = nullptr;
    if (pImportFenceWin32HandleInfo)
    {
        local_pImportFenceWin32HandleInfo = (VkImportFenceWin32HandleInfoKHR*)pool->alloc(sizeof(const VkImportFenceWin32HandleInfoKHR));
        deepcopy_VkImportFenceWin32HandleInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pImportFenceWin32HandleInfo, (VkImportFenceWin32HandleInfoKHR*)(local_pImportFenceWin32HandleInfo));
    }
    if (local_pImportFenceWin32HandleInfo)
    {
        transform_tohost_VkImportFenceWin32HandleInfoKHR(sResourceTracker, (VkImportFenceWin32HandleInfoKHR*)(local_pImportFenceWin32HandleInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkImportFenceWin32HandleInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImportFenceWin32HandleInfoKHR*)(local_pImportFenceWin32HandleInfo), countPtr);
    }
    uint32_t packetSize_vkImportFenceWin32HandleKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkImportFenceWin32HandleKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkImportFenceWin32HandleKHR = OP_vkImportFenceWin32HandleKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkImportFenceWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkImportFenceWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImportFenceWin32HandleInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImportFenceWin32HandleInfoKHR*)(local_pImportFenceWin32HandleInfo), streamPtrPtr);
    VkResult vkImportFenceWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkImportFenceWin32HandleKHR_VkResult_return;
}

VkResult VkEncoder::vkGetFenceWin32HandleKHR(
    VkDevice device,
    const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo,
    HANDLE* pHandle,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkFenceGetWin32HandleInfoKHR* local_pGetWin32HandleInfo;
    local_device = device;
    local_pGetWin32HandleInfo = nullptr;
    if (pGetWin32HandleInfo)
    {
        local_pGetWin32HandleInfo = (VkFenceGetWin32HandleInfoKHR*)pool->alloc(sizeof(const VkFenceGetWin32HandleInfoKHR));
        deepcopy_VkFenceGetWin32HandleInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pGetWin32HandleInfo, (VkFenceGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    if (local_pGetWin32HandleInfo)
    {
        transform_tohost_VkFenceGetWin32HandleInfoKHR(sResourceTracker, (VkFenceGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkFenceGetWin32HandleInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFenceGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo), countPtr);
        *countPtr += sizeof(HANDLE);
    }
    uint32_t packetSize_vkGetFenceWin32HandleKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetFenceWin32HandleKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetFenceWin32HandleKHR = OP_vkGetFenceWin32HandleKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetFenceWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetFenceWin32HandleKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkFenceGetWin32HandleInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFenceGetWin32HandleInfoKHR*)(local_pGetWin32HandleInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (HANDLE*)pHandle, sizeof(HANDLE));
    *streamPtrPtr += sizeof(HANDLE);
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult vkGetFenceWin32HandleKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetFenceWin32HandleKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetFenceWin32HandleKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_external_fence_fd
VkResult VkEncoder::vkImportFenceFdKHR(
    VkDevice device,
    const VkImportFenceFdInfoKHR* pImportFenceFdInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImportFenceFdInfoKHR* local_pImportFenceFdInfo;
    local_device = device;
    local_pImportFenceFdInfo = nullptr;
    if (pImportFenceFdInfo)
    {
        local_pImportFenceFdInfo = (VkImportFenceFdInfoKHR*)pool->alloc(sizeof(const VkImportFenceFdInfoKHR));
        deepcopy_VkImportFenceFdInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pImportFenceFdInfo, (VkImportFenceFdInfoKHR*)(local_pImportFenceFdInfo));
    }
    if (local_pImportFenceFdInfo)
    {
        transform_tohost_VkImportFenceFdInfoKHR(sResourceTracker, (VkImportFenceFdInfoKHR*)(local_pImportFenceFdInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkImportFenceFdInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImportFenceFdInfoKHR*)(local_pImportFenceFdInfo), countPtr);
    }
    uint32_t packetSize_vkImportFenceFdKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkImportFenceFdKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkImportFenceFdKHR = OP_vkImportFenceFdKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkImportFenceFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkImportFenceFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImportFenceFdInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImportFenceFdInfoKHR*)(local_pImportFenceFdInfo), streamPtrPtr);
    VkResult vkImportFenceFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkImportFenceFdKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkImportFenceFdKHR_VkResult_return;
}

VkResult VkEncoder::vkGetFenceFdKHR(
    VkDevice device,
    const VkFenceGetFdInfoKHR* pGetFdInfo,
    int* pFd,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkFenceGetFdInfoKHR* local_pGetFdInfo;
    local_device = device;
    local_pGetFdInfo = nullptr;
    if (pGetFdInfo)
    {
        local_pGetFdInfo = (VkFenceGetFdInfoKHR*)pool->alloc(sizeof(const VkFenceGetFdInfoKHR));
        deepcopy_VkFenceGetFdInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pGetFdInfo, (VkFenceGetFdInfoKHR*)(local_pGetFdInfo));
    }
    if (local_pGetFdInfo)
    {
        transform_tohost_VkFenceGetFdInfoKHR(sResourceTracker, (VkFenceGetFdInfoKHR*)(local_pGetFdInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkFenceGetFdInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFenceGetFdInfoKHR*)(local_pGetFdInfo), countPtr);
        *countPtr += sizeof(int);
    }
    uint32_t packetSize_vkGetFenceFdKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetFenceFdKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetFenceFdKHR = OP_vkGetFenceFdKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetFenceFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetFenceFdKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkFenceGetFdInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFenceGetFdInfoKHR*)(local_pGetFdInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (int*)pFd, sizeof(int));
    *streamPtrPtr += sizeof(int);
    stream->read((int*)pFd, sizeof(int));
    VkResult vkGetFenceFdKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetFenceFdKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetFenceFdKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_performance_query
VkResult VkEncoder::vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    uint32_t* pCounterCount,
    VkPerformanceCounterKHR* pCounters,
    VkPerformanceCounterDescriptionKHR* pCounterDescriptions,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pCounterCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pCounters)
        {
            if (pCounterCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pCounterCount)); ++i)
                {
                    count_VkPerformanceCounterKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceCounterKHR*)(pCounters + i), countPtr);
                }
            }
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pCounterDescriptions)
        {
            if (pCounterCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pCounterCount)); ++i)
                {
                    count_VkPerformanceCounterDescriptionKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceCounterDescriptionKHR*)(pCounterDescriptions + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = OP_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pCounterCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pCounterCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pCounterCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pCounters;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pCounters)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pCounterCount)); ++i)
        {
            reservedmarshal_VkPerformanceCounterKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceCounterKHR*)(pCounters + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pCounterDescriptions;
    memcpy((*streamPtrPtr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pCounterDescriptions)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pCounterCount)); ++i)
        {
            reservedmarshal_VkPerformanceCounterDescriptionKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceCounterDescriptionKHR*)(pCounterDescriptions + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pCounterCount;
    check_pCounterCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pCounterCount)
    {
        if (!(check_pCounterCount))
        {
            fprintf(stderr, "fatal: pCounterCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pCounterCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPerformanceCounterKHR* check_pCounters;
    check_pCounters = (VkPerformanceCounterKHR*)(uintptr_t)stream->getBe64();
    if (pCounters)
    {
        if (!(check_pCounters))
        {
            fprintf(stderr, "fatal: pCounters inconsistent between guest and host\n");
        }
        if (pCounterCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pCounterCount)); ++i)
            {
                unmarshal_VkPerformanceCounterKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceCounterKHR*)(pCounters + i));
            }
        }
    }
    if (pCounterCount)
    {
        if (pCounters)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pCounterCount)); ++i)
            {
                transform_fromhost_VkPerformanceCounterKHR(sResourceTracker, (VkPerformanceCounterKHR*)(pCounters + i));
            }
        }
    }
    // WARNING PTR CHECK
    VkPerformanceCounterDescriptionKHR* check_pCounterDescriptions;
    check_pCounterDescriptions = (VkPerformanceCounterDescriptionKHR*)(uintptr_t)stream->getBe64();
    if (pCounterDescriptions)
    {
        if (!(check_pCounterDescriptions))
        {
            fprintf(stderr, "fatal: pCounterDescriptions inconsistent between guest and host\n");
        }
        if (pCounterCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pCounterCount)); ++i)
            {
                unmarshal_VkPerformanceCounterDescriptionKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceCounterDescriptionKHR*)(pCounterDescriptions + i));
            }
        }
    }
    if (pCounterCount)
    {
        if (pCounterDescriptions)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pCounterCount)); ++i)
            {
                transform_fromhost_VkPerformanceCounterDescriptionKHR(sResourceTracker, (VkPerformanceCounterDescriptionKHR*)(pCounterDescriptions + i));
            }
        }
    }
    VkResult vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR_VkResult_return = (VkResult)0;
    stream->read(&vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR_VkResult_return;
}

void VkEncoder::vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(
    VkPhysicalDevice physicalDevice,
    const VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo,
    uint32_t* pNumPasses,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkQueryPoolPerformanceCreateInfoKHR* local_pPerformanceQueryCreateInfo;
    local_physicalDevice = physicalDevice;
    local_pPerformanceQueryCreateInfo = nullptr;
    if (pPerformanceQueryCreateInfo)
    {
        local_pPerformanceQueryCreateInfo = (VkQueryPoolPerformanceCreateInfoKHR*)pool->alloc(sizeof(const VkQueryPoolPerformanceCreateInfoKHR));
        deepcopy_VkQueryPoolPerformanceCreateInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pPerformanceQueryCreateInfo, (VkQueryPoolPerformanceCreateInfoKHR*)(local_pPerformanceQueryCreateInfo));
    }
    if (local_pPerformanceQueryCreateInfo)
    {
        transform_tohost_VkQueryPoolPerformanceCreateInfoKHR(sResourceTracker, (VkQueryPoolPerformanceCreateInfoKHR*)(local_pPerformanceQueryCreateInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkQueryPoolPerformanceCreateInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueryPoolPerformanceCreateInfoKHR*)(local_pPerformanceQueryCreateInfo), countPtr);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = OP_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkQueryPoolPerformanceCreateInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkQueryPoolPerformanceCreateInfoKHR*)(local_pPerformanceQueryCreateInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (uint32_t*)pNumPasses, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    stream->read((uint32_t*)pNumPasses, sizeof(uint32_t));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkAcquireProfilingLockKHR(
    VkDevice device,
    const VkAcquireProfilingLockInfoKHR* pInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkAcquireProfilingLockInfoKHR* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkAcquireProfilingLockInfoKHR*)pool->alloc(sizeof(const VkAcquireProfilingLockInfoKHR));
        deepcopy_VkAcquireProfilingLockInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkAcquireProfilingLockInfoKHR*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkAcquireProfilingLockInfoKHR(sResourceTracker, (VkAcquireProfilingLockInfoKHR*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkAcquireProfilingLockInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAcquireProfilingLockInfoKHR*)(local_pInfo), countPtr);
    }
    uint32_t packetSize_vkAcquireProfilingLockKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkAcquireProfilingLockKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkAcquireProfilingLockKHR = OP_vkAcquireProfilingLockKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkAcquireProfilingLockKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkAcquireProfilingLockKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkAcquireProfilingLockInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAcquireProfilingLockInfoKHR*)(local_pInfo), streamPtrPtr);
    VkResult vkAcquireProfilingLockKHR_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireProfilingLockKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkAcquireProfilingLockKHR_VkResult_return;
}

void VkEncoder::vkReleaseProfilingLockKHR(
    VkDevice device,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    local_device = device;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkReleaseProfilingLockKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkReleaseProfilingLockKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkReleaseProfilingLockKHR = OP_vkReleaseProfilingLockKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkReleaseProfilingLockKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkReleaseProfilingLockKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
VkResult VkEncoder::vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    VkSurfaceCapabilities2KHR* pSurfaceCapabilities,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceSurfaceInfo2KHR* local_pSurfaceInfo;
    local_physicalDevice = physicalDevice;
    local_pSurfaceInfo = nullptr;
    if (pSurfaceInfo)
    {
        local_pSurfaceInfo = (VkPhysicalDeviceSurfaceInfo2KHR*)pool->alloc(sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
        deepcopy_VkPhysicalDeviceSurfaceInfo2KHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pSurfaceInfo, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    if (local_pSurfaceInfo)
    {
        transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(sResourceTracker, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceSurfaceInfo2KHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo), countPtr);
        count_VkSurfaceCapabilities2KHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceCapabilities2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSurfaceCapabilities2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSurfaceCapabilities2KHR = OP_vkGetPhysicalDeviceSurfaceCapabilities2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSurfaceCapabilities2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSurfaceCapabilities2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceSurfaceInfo2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo), streamPtrPtr);
    reservedmarshal_VkSurfaceCapabilities2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities), streamPtrPtr);
    unmarshal_VkSurfaceCapabilities2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
    if (pSurfaceCapabilities)
    {
        transform_fromhost_VkSurfaceCapabilities2KHR(sResourceTracker, (VkSurfaceCapabilities2KHR*)(pSurfaceCapabilities));
    }
    VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceSurfaceCapabilities2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceSurfaceFormats2KHR(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    uint32_t* pSurfaceFormatCount,
    VkSurfaceFormat2KHR* pSurfaceFormats,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceSurfaceInfo2KHR* local_pSurfaceInfo;
    local_physicalDevice = physicalDevice;
    local_pSurfaceInfo = nullptr;
    if (pSurfaceInfo)
    {
        local_pSurfaceInfo = (VkPhysicalDeviceSurfaceInfo2KHR*)pool->alloc(sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
        deepcopy_VkPhysicalDeviceSurfaceInfo2KHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pSurfaceInfo, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    if (local_pSurfaceInfo)
    {
        transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(sResourceTracker, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceSurfaceInfo2KHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSurfaceFormatCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSurfaceFormats)
        {
            if (pSurfaceFormatCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
                {
                    count_VkSurfaceFormat2KHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceFormats2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSurfaceFormats2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSurfaceFormats2KHR = OP_vkGetPhysicalDeviceSurfaceFormats2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSurfaceFormats2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSurfaceFormats2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceSurfaceInfo2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pSurfaceFormatCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSurfaceFormatCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pSurfaceFormats;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSurfaceFormats)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
        {
            reservedmarshal_VkSurfaceFormat2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pSurfaceFormatCount;
    check_pSurfaceFormatCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSurfaceFormatCount)
    {
        if (!(check_pSurfaceFormatCount))
        {
            fprintf(stderr, "fatal: pSurfaceFormatCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSurfaceFormatCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSurfaceFormat2KHR* check_pSurfaceFormats;
    check_pSurfaceFormats = (VkSurfaceFormat2KHR*)(uintptr_t)stream->getBe64();
    if (pSurfaceFormats)
    {
        if (!(check_pSurfaceFormats))
        {
            fprintf(stderr, "fatal: pSurfaceFormats inconsistent between guest and host\n");
        }
        if (pSurfaceFormatCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
            {
                unmarshal_VkSurfaceFormat2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
            }
        }
    }
    if (pSurfaceFormatCount)
    {
        if (pSurfaceFormats)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSurfaceFormatCount)); ++i)
            {
                transform_fromhost_VkSurfaceFormat2KHR(sResourceTracker, (VkSurfaceFormat2KHR*)(pSurfaceFormats + i));
            }
        }
    }
    VkResult vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceSurfaceFormats2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
VkResult VkEncoder::vkGetPhysicalDeviceDisplayProperties2KHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayProperties2KHR* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            if (pPropertyCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                {
                    count_VkDisplayProperties2KHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayProperties2KHR*)(pProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayProperties2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceDisplayProperties2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceDisplayProperties2KHR = OP_vkGetPhysicalDeviceDisplayProperties2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceDisplayProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceDisplayProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkDisplayProperties2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayProperties2KHR*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayProperties2KHR* check_pProperties;
    check_pProperties = (VkDisplayProperties2KHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        if (pPropertyCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                unmarshal_VkDisplayProperties2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayProperties2KHR*)(pProperties + i));
            }
        }
    }
    if (pPropertyCount)
    {
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                transform_fromhost_VkDisplayProperties2KHR(sResourceTracker, (VkDisplayProperties2KHR*)(pProperties + i));
            }
        }
    }
    VkResult vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceDisplayProperties2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkDisplayPlaneProperties2KHR* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            if (pPropertyCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                {
                    count_VkDisplayPlaneProperties2KHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlaneProperties2KHR*)(pProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceDisplayPlaneProperties2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = OP_vkGetPhysicalDeviceDisplayPlaneProperties2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceDisplayPlaneProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceDisplayPlaneProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkDisplayPlaneProperties2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlaneProperties2KHR*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayPlaneProperties2KHR* check_pProperties;
    check_pProperties = (VkDisplayPlaneProperties2KHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        if (pPropertyCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                unmarshal_VkDisplayPlaneProperties2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
            }
        }
    }
    if (pPropertyCount)
    {
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                transform_fromhost_VkDisplayPlaneProperties2KHR(sResourceTracker, (VkDisplayPlaneProperties2KHR*)(pProperties + i));
            }
        }
    }
    VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceDisplayPlaneProperties2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayModeProperties2KHR(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    uint32_t* pPropertyCount,
    VkDisplayModeProperties2KHR* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    local_physicalDevice = physicalDevice;
    local_display = display;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            if (pPropertyCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                {
                    count_VkDisplayModeProperties2KHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayModeProperties2KHR*)(pProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetDisplayModeProperties2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDisplayModeProperties2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDisplayModeProperties2KHR = OP_vkGetDisplayModeProperties2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDisplayModeProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDisplayModeProperties2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDisplayKHR((*&local_display));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkDisplayModeProperties2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayModeProperties2KHR*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkDisplayModeProperties2KHR* check_pProperties;
    check_pProperties = (VkDisplayModeProperties2KHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        if (pPropertyCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                unmarshal_VkDisplayModeProperties2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayModeProperties2KHR*)(pProperties + i));
            }
        }
    }
    if (pPropertyCount)
    {
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                transform_fromhost_VkDisplayModeProperties2KHR(sResourceTracker, (VkDisplayModeProperties2KHR*)(pProperties + i));
            }
        }
    }
    VkResult vkGetDisplayModeProperties2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayModeProperties2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDisplayModeProperties2KHR_VkResult_return;
}

VkResult VkEncoder::vkGetDisplayPlaneCapabilities2KHR(
    VkPhysicalDevice physicalDevice,
    const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo,
    VkDisplayPlaneCapabilities2KHR* pCapabilities,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkDisplayPlaneInfo2KHR* local_pDisplayPlaneInfo;
    local_physicalDevice = physicalDevice;
    local_pDisplayPlaneInfo = nullptr;
    if (pDisplayPlaneInfo)
    {
        local_pDisplayPlaneInfo = (VkDisplayPlaneInfo2KHR*)pool->alloc(sizeof(const VkDisplayPlaneInfo2KHR));
        deepcopy_VkDisplayPlaneInfo2KHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pDisplayPlaneInfo, (VkDisplayPlaneInfo2KHR*)(local_pDisplayPlaneInfo));
    }
    if (local_pDisplayPlaneInfo)
    {
        transform_tohost_VkDisplayPlaneInfo2KHR(sResourceTracker, (VkDisplayPlaneInfo2KHR*)(local_pDisplayPlaneInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDisplayPlaneInfo2KHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlaneInfo2KHR*)(local_pDisplayPlaneInfo), countPtr);
        count_VkDisplayPlaneCapabilities2KHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities), countPtr);
    }
    uint32_t packetSize_vkGetDisplayPlaneCapabilities2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDisplayPlaneCapabilities2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDisplayPlaneCapabilities2KHR = OP_vkGetDisplayPlaneCapabilities2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDisplayPlaneCapabilities2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDisplayPlaneCapabilities2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDisplayPlaneInfo2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlaneInfo2KHR*)(local_pDisplayPlaneInfo), streamPtrPtr);
    reservedmarshal_VkDisplayPlaneCapabilities2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities), streamPtrPtr);
    unmarshal_VkDisplayPlaneCapabilities2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
    if (pCapabilities)
    {
        transform_fromhost_VkDisplayPlaneCapabilities2KHR(sResourceTracker, (VkDisplayPlaneCapabilities2KHR*)(pCapabilities));
    }
    VkResult vkGetDisplayPlaneCapabilities2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDisplayPlaneCapabilities2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDisplayPlaneCapabilities2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
void VkEncoder::vkGetImageMemoryRequirements2KHR(
    VkDevice device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImageMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkImageMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkImageMemoryRequirementsInfo2));
        deepcopy_VkImageMemoryRequirementsInfo2(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkImageMemoryRequirementsInfo2(sResourceTracker, (VkImageMemoryRequirementsInfo2*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkImageMemoryRequirementsInfo2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageMemoryRequirementsInfo2*)(local_pInfo), countPtr);
        count_VkMemoryRequirements2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements), countPtr);
    }
    uint32_t packetSize_vkGetImageMemoryRequirements2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetImageMemoryRequirements2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetImageMemoryRequirements2KHR = OP_vkGetImageMemoryRequirements2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetImageMemoryRequirements2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetImageMemoryRequirements2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageMemoryRequirementsInfo2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageMemoryRequirementsInfo2*)(local_pInfo), streamPtrPtr);
    reservedmarshal_VkMemoryRequirements2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements), streamPtrPtr);
    unmarshal_VkMemoryRequirements2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements2(sResourceTracker, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetBufferMemoryRequirements2KHR(
    VkDevice device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2* pMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBufferMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkBufferMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkBufferMemoryRequirementsInfo2));
        deepcopy_VkBufferMemoryRequirementsInfo2(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkBufferMemoryRequirementsInfo2(sResourceTracker, (VkBufferMemoryRequirementsInfo2*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkBufferMemoryRequirementsInfo2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferMemoryRequirementsInfo2*)(local_pInfo), countPtr);
        count_VkMemoryRequirements2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements), countPtr);
    }
    uint32_t packetSize_vkGetBufferMemoryRequirements2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetBufferMemoryRequirements2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetBufferMemoryRequirements2KHR = OP_vkGetBufferMemoryRequirements2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetBufferMemoryRequirements2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetBufferMemoryRequirements2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkBufferMemoryRequirementsInfo2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferMemoryRequirementsInfo2*)(local_pInfo), streamPtrPtr);
    reservedmarshal_VkMemoryRequirements2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements), streamPtrPtr);
    unmarshal_VkMemoryRequirements2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements2(sResourceTracker, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetImageSparseMemoryRequirements2KHR(
    VkDevice device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImageSparseMemoryRequirementsInfo2* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkImageSparseMemoryRequirementsInfo2*)pool->alloc(sizeof(const VkImageSparseMemoryRequirementsInfo2));
        deepcopy_VkImageSparseMemoryRequirementsInfo2(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkImageSparseMemoryRequirementsInfo2(sResourceTracker, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkImageSparseMemoryRequirementsInfo2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSparseMemoryRequirementCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSparseMemoryRequirements)
        {
            if (pSparseMemoryRequirementCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
                {
                    count_VkSparseImageMemoryRequirements2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetImageSparseMemoryRequirements2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetImageSparseMemoryRequirements2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetImageSparseMemoryRequirements2KHR = OP_vkGetImageSparseMemoryRequirements2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetImageSparseMemoryRequirements2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetImageSparseMemoryRequirements2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageSparseMemoryRequirementsInfo2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageSparseMemoryRequirementsInfo2*)(local_pInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pSparseMemoryRequirementCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSparseMemoryRequirementCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pSparseMemoryRequirements;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSparseMemoryRequirements)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
        {
            reservedmarshal_VkSparseImageMemoryRequirements2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pSparseMemoryRequirementCount;
    check_pSparseMemoryRequirementCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirementCount)
    {
        if (!(check_pSparseMemoryRequirementCount))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirementCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pSparseMemoryRequirementCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkSparseImageMemoryRequirements2* check_pSparseMemoryRequirements;
    check_pSparseMemoryRequirements = (VkSparseImageMemoryRequirements2*)(uintptr_t)stream->getBe64();
    if (pSparseMemoryRequirements)
    {
        if (!(check_pSparseMemoryRequirements))
        {
            fprintf(stderr, "fatal: pSparseMemoryRequirements inconsistent between guest and host\n");
        }
        if (pSparseMemoryRequirementCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
            {
                unmarshal_VkSparseImageMemoryRequirements2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
            }
        }
    }
    if (pSparseMemoryRequirementCount)
    {
        if (pSparseMemoryRequirements)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pSparseMemoryRequirementCount)); ++i)
            {
                transform_fromhost_VkSparseImageMemoryRequirements2(sResourceTracker, (VkSparseImageMemoryRequirements2*)(pSparseMemoryRequirements + i));
            }
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
VkResult VkEncoder::vkCreateSamplerYcbcrConversionKHR(
    VkDevice device,
    const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSamplerYcbcrConversion* pYcbcrConversion,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSamplerYcbcrConversionCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkSamplerYcbcrConversionCreateInfo*)pool->alloc(sizeof(const VkSamplerYcbcrConversionCreateInfo));
        deepcopy_VkSamplerYcbcrConversionCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkSamplerYcbcrConversionCreateInfo(sResourceTracker, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkSamplerYcbcrConversionCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateSamplerYcbcrConversionKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateSamplerYcbcrConversionKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateSamplerYcbcrConversionKHR = OP_vkCreateSamplerYcbcrConversionKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateSamplerYcbcrConversionKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateSamplerYcbcrConversionKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSamplerYcbcrConversionCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSamplerYcbcrConversionCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pYcbcrConversion));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_3, (VkSamplerYcbcrConversion*)pYcbcrConversion, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateSamplerYcbcrConversionKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateSamplerYcbcrConversionKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateSamplerYcbcrConversionKHR_VkResult_return;
}

void VkEncoder::vkDestroySamplerYcbcrConversionKHR(
    VkDevice device,
    VkSamplerYcbcrConversion ycbcrConversion,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSamplerYcbcrConversion local_ycbcrConversion;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_ycbcrConversion = ycbcrConversion;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroySamplerYcbcrConversionKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroySamplerYcbcrConversionKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroySamplerYcbcrConversionKHR = OP_vkDestroySamplerYcbcrConversionKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroySamplerYcbcrConversionKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroySamplerYcbcrConversionKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSamplerYcbcrConversion((*&local_ycbcrConversion));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkSamplerYcbcrConversion((VkSamplerYcbcrConversion*)&ycbcrConversion);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_bind_memory2
VkResult VkEncoder::vkBindBufferMemory2KHR(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindBufferMemoryInfo* pBindInfos,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_bindInfoCount;
    VkBindBufferMemoryInfo* local_pBindInfos;
    local_device = device;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfos = nullptr;
    if (pBindInfos)
    {
        local_pBindInfos = (VkBindBufferMemoryInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindBufferMemoryInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindBufferMemoryInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pBindInfos + i, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    if (local_pBindInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindBufferMemoryInfo(sResourceTracker, (VkBindBufferMemoryInfo*)(local_pBindInfos + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            count_VkBindBufferMemoryInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindBufferMemoryInfo*)(local_pBindInfos + i), countPtr);
        }
    }
    uint32_t packetSize_vkBindBufferMemory2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkBindBufferMemory2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkBindBufferMemory2KHR = OP_vkBindBufferMemory2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkBindBufferMemory2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkBindBufferMemory2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        reservedmarshal_VkBindBufferMemoryInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindBufferMemoryInfo*)(local_pBindInfos + i), streamPtrPtr);
    }
    VkResult vkBindBufferMemory2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkBindBufferMemory2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkBindBufferMemory2KHR_VkResult_return;
}

VkResult VkEncoder::vkBindImageMemory2KHR(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_bindInfoCount;
    VkBindImageMemoryInfo* local_pBindInfos;
    local_device = device;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfos = nullptr;
    if (pBindInfos)
    {
        local_pBindInfos = (VkBindImageMemoryInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindImageMemoryInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindImageMemoryInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pBindInfos + i, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    if (local_pBindInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindImageMemoryInfo(sResourceTracker, (VkBindImageMemoryInfo*)(local_pBindInfos + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            count_VkBindImageMemoryInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindImageMemoryInfo*)(local_pBindInfos + i), countPtr);
        }
    }
    uint32_t packetSize_vkBindImageMemory2KHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkBindImageMemory2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkBindImageMemory2KHR = OP_vkBindImageMemory2KHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkBindImageMemory2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkBindImageMemory2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        reservedmarshal_VkBindImageMemoryInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindImageMemoryInfo*)(local_pBindInfos + i), streamPtrPtr);
    }
    VkResult vkBindImageMemory2KHR_VkResult_return = (VkResult)0;
    stream->read(&vkBindImageMemory2KHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkBindImageMemory2KHR_VkResult_return;
}

#endif
#ifdef VK_KHR_portability_subset
#endif
#ifdef VK_KHR_maintenance3
void VkEncoder::vkGetDescriptorSetLayoutSupportKHR(
    VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayoutSupport* pSupport,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorSetLayoutCreateInfo* local_pCreateInfo;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDescriptorSetLayoutCreateInfo*)pool->alloc(sizeof(const VkDescriptorSetLayoutCreateInfo));
        deepcopy_VkDescriptorSetLayoutCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    if (local_pCreateInfo)
    {
        transform_tohost_VkDescriptorSetLayoutCreateInfo(sResourceTracker, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDescriptorSetLayoutCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo), countPtr);
        count_VkDescriptorSetLayoutSupport(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutSupport*)(pSupport), countPtr);
    }
    uint32_t packetSize_vkGetDescriptorSetLayoutSupportKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDescriptorSetLayoutSupportKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDescriptorSetLayoutSupportKHR = OP_vkGetDescriptorSetLayoutSupportKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDescriptorSetLayoutSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDescriptorSetLayoutSupportKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDescriptorSetLayoutCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    reservedmarshal_VkDescriptorSetLayoutSupport(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutSupport*)(pSupport), streamPtrPtr);
    unmarshal_VkDescriptorSetLayoutSupport(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorSetLayoutSupport*)(pSupport));
    if (pSupport)
    {
        transform_fromhost_VkDescriptorSetLayoutSupport(sResourceTracker, (VkDescriptorSetLayoutSupport*)(pSupport));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_draw_indirect_count
void VkEncoder::vkCmdDrawIndirectCountKHR(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawIndirectCountKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawIndirectCountKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawIndirectCountKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawIndirectCountKHR = OP_vkCmdDrawIndirectCountKHR;
    memcpy(streamPtr, &opcode_vkCmdDrawIndirectCountKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawIndirectCountKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&local_countBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_stride, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDrawIndexedIndirectCountKHR(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawIndexedIndirectCountKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawIndexedIndirectCountKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawIndexedIndirectCountKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawIndexedIndirectCountKHR = OP_vkCmdDrawIndexedIndirectCountKHR;
    memcpy(streamPtr, &opcode_vkCmdDrawIndexedIndirectCountKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawIndexedIndirectCountKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&local_countBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_stride, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_shader_subgroup_extended_types
#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_KHR_shader_atomic_int64
#endif
#ifdef VK_KHR_shader_clock
#endif
#ifdef VK_KHR_driver_properties
#endif
#ifdef VK_KHR_shader_float_controls
#endif
#ifdef VK_KHR_depth_stencil_resolve
#endif
#ifdef VK_KHR_swapchain_mutable_format
#endif
#ifdef VK_KHR_timeline_semaphore
VkResult VkEncoder::vkGetSemaphoreCounterValueKHR(
    VkDevice device,
    VkSemaphore semaphore,
    uint64_t* pValue,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSemaphore local_semaphore;
    local_device = device;
    local_semaphore = semaphore;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint64_t);
    }
    uint32_t packetSize_vkGetSemaphoreCounterValueKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetSemaphoreCounterValueKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetSemaphoreCounterValueKHR = OP_vkGetSemaphoreCounterValueKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetSemaphoreCounterValueKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetSemaphoreCounterValueKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSemaphore((*&local_semaphore));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint64_t*)pValue, sizeof(uint64_t));
    *streamPtrPtr += sizeof(uint64_t);
    stream->read((uint64_t*)pValue, sizeof(uint64_t));
    VkResult vkGetSemaphoreCounterValueKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetSemaphoreCounterValueKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetSemaphoreCounterValueKHR_VkResult_return;
}

VkResult VkEncoder::vkWaitSemaphoresKHR(
    VkDevice device,
    const VkSemaphoreWaitInfo* pWaitInfo,
    uint64_t timeout,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSemaphoreWaitInfo* local_pWaitInfo;
    uint64_t local_timeout;
    local_device = device;
    local_pWaitInfo = nullptr;
    if (pWaitInfo)
    {
        local_pWaitInfo = (VkSemaphoreWaitInfo*)pool->alloc(sizeof(const VkSemaphoreWaitInfo));
        deepcopy_VkSemaphoreWaitInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pWaitInfo, (VkSemaphoreWaitInfo*)(local_pWaitInfo));
    }
    local_timeout = timeout;
    if (local_pWaitInfo)
    {
        transform_tohost_VkSemaphoreWaitInfo(sResourceTracker, (VkSemaphoreWaitInfo*)(local_pWaitInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkSemaphoreWaitInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreWaitInfo*)(local_pWaitInfo), countPtr);
        *countPtr += sizeof(uint64_t);
    }
    uint32_t packetSize_vkWaitSemaphoresKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkWaitSemaphoresKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkWaitSemaphoresKHR = OP_vkWaitSemaphoresKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkWaitSemaphoresKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkWaitSemaphoresKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSemaphoreWaitInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreWaitInfo*)(local_pWaitInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (uint64_t*)&local_timeout, sizeof(uint64_t));
    *streamPtrPtr += sizeof(uint64_t);
    VkResult vkWaitSemaphoresKHR_VkResult_return = (VkResult)0;
    stream->read(&vkWaitSemaphoresKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkWaitSemaphoresKHR_VkResult_return;
}

VkResult VkEncoder::vkSignalSemaphoreKHR(
    VkDevice device,
    const VkSemaphoreSignalInfo* pSignalInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSemaphoreSignalInfo* local_pSignalInfo;
    local_device = device;
    local_pSignalInfo = nullptr;
    if (pSignalInfo)
    {
        local_pSignalInfo = (VkSemaphoreSignalInfo*)pool->alloc(sizeof(const VkSemaphoreSignalInfo));
        deepcopy_VkSemaphoreSignalInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pSignalInfo, (VkSemaphoreSignalInfo*)(local_pSignalInfo));
    }
    if (local_pSignalInfo)
    {
        transform_tohost_VkSemaphoreSignalInfo(sResourceTracker, (VkSemaphoreSignalInfo*)(local_pSignalInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkSemaphoreSignalInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreSignalInfo*)(local_pSignalInfo), countPtr);
    }
    uint32_t packetSize_vkSignalSemaphoreKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkSignalSemaphoreKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkSignalSemaphoreKHR = OP_vkSignalSemaphoreKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkSignalSemaphoreKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkSignalSemaphoreKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSemaphoreSignalInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSemaphoreSignalInfo*)(local_pSignalInfo), streamPtrPtr);
    VkResult vkSignalSemaphoreKHR_VkResult_return = (VkResult)0;
    stream->read(&vkSignalSemaphoreKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkSignalSemaphoreKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_vulkan_memory_model
#endif
#ifdef VK_KHR_shader_terminate_invocation
#endif
#ifdef VK_KHR_fragment_shading_rate
VkResult VkEncoder::vkGetPhysicalDeviceFragmentShadingRatesKHR(
    VkPhysicalDevice physicalDevice,
    uint32_t* pFragmentShadingRateCount,
    VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pFragmentShadingRateCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pFragmentShadingRates)
        {
            if (pFragmentShadingRateCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pFragmentShadingRateCount)); ++i)
                {
                    count_VkPhysicalDeviceFragmentShadingRateKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFragmentShadingRateKHR*)(pFragmentShadingRates + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceFragmentShadingRatesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceFragmentShadingRatesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceFragmentShadingRatesKHR = OP_vkGetPhysicalDeviceFragmentShadingRatesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceFragmentShadingRatesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceFragmentShadingRatesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pFragmentShadingRateCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pFragmentShadingRateCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pFragmentShadingRateCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pFragmentShadingRates;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pFragmentShadingRates)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pFragmentShadingRateCount)); ++i)
        {
            reservedmarshal_VkPhysicalDeviceFragmentShadingRateKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFragmentShadingRateKHR*)(pFragmentShadingRates + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pFragmentShadingRateCount;
    check_pFragmentShadingRateCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pFragmentShadingRateCount)
    {
        if (!(check_pFragmentShadingRateCount))
        {
            fprintf(stderr, "fatal: pFragmentShadingRateCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pFragmentShadingRateCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPhysicalDeviceFragmentShadingRateKHR* check_pFragmentShadingRates;
    check_pFragmentShadingRates = (VkPhysicalDeviceFragmentShadingRateKHR*)(uintptr_t)stream->getBe64();
    if (pFragmentShadingRates)
    {
        if (!(check_pFragmentShadingRates))
        {
            fprintf(stderr, "fatal: pFragmentShadingRates inconsistent between guest and host\n");
        }
        if (pFragmentShadingRateCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pFragmentShadingRateCount)); ++i)
            {
                unmarshal_VkPhysicalDeviceFragmentShadingRateKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceFragmentShadingRateKHR*)(pFragmentShadingRates + i));
            }
        }
    }
    if (pFragmentShadingRateCount)
    {
        if (pFragmentShadingRates)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pFragmentShadingRateCount)); ++i)
            {
                transform_fromhost_VkPhysicalDeviceFragmentShadingRateKHR(sResourceTracker, (VkPhysicalDeviceFragmentShadingRateKHR*)(pFragmentShadingRates + i));
            }
        }
    }
    VkResult vkGetPhysicalDeviceFragmentShadingRatesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceFragmentShadingRatesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceFragmentShadingRatesKHR_VkResult_return;
}

void VkEncoder::vkCmdSetFragmentShadingRateKHR(
    VkCommandBuffer commandBuffer,
    const VkExtent2D* pFragmentSize,
    const VkFragmentShadingRateCombinerOpKHR combinerOps[2],
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkExtent2D* local_pFragmentSize;
    VkFragmentShadingRateCombinerOpKHR local_combinerOps[2];
    local_commandBuffer = commandBuffer;
    local_pFragmentSize = nullptr;
    if (pFragmentSize)
    {
        local_pFragmentSize = (VkExtent2D*)pool->alloc(sizeof(const VkExtent2D));
        deepcopy_VkExtent2D(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pFragmentSize, (VkExtent2D*)(local_pFragmentSize));
    }
    memcpy(local_combinerOps, combinerOps, 2 * sizeof(const VkFragmentShadingRateCombinerOpKHR));
    if (local_pFragmentSize)
    {
        transform_tohost_VkExtent2D(sResourceTracker, (VkExtent2D*)(local_pFragmentSize));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkExtent2D(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExtent2D*)(local_pFragmentSize), countPtr);
        *countPtr += 2 * sizeof(VkFragmentShadingRateCombinerOpKHR);
    }
    uint32_t packetSize_vkCmdSetFragmentShadingRateKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetFragmentShadingRateKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetFragmentShadingRateKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetFragmentShadingRateKHR = OP_vkCmdSetFragmentShadingRateKHR;
    memcpy(streamPtr, &opcode_vkCmdSetFragmentShadingRateKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetFragmentShadingRateKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkExtent2D(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExtent2D*)(local_pFragmentSize), streamPtrPtr);
    memcpy(*streamPtrPtr, (VkFragmentShadingRateCombinerOpKHR*)local_combinerOps, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
    *streamPtrPtr += 2 * sizeof(VkFragmentShadingRateCombinerOpKHR);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_spirv_1_4
#endif
#ifdef VK_KHR_surface_protected_capabilities
#endif
#ifdef VK_KHR_separate_depth_stencil_layouts
#endif
#ifdef VK_KHR_uniform_buffer_standard_layout
#endif
#ifdef VK_KHR_buffer_device_address
VkDeviceAddress VkEncoder::vkGetBufferDeviceAddressKHR(
    VkDevice device,
    const VkBufferDeviceAddressInfo* pInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBufferDeviceAddressInfo* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkBufferDeviceAddressInfo*)pool->alloc(sizeof(const VkBufferDeviceAddressInfo));
        deepcopy_VkBufferDeviceAddressInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkBufferDeviceAddressInfo*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkBufferDeviceAddressInfo(sResourceTracker, (VkBufferDeviceAddressInfo*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkBufferDeviceAddressInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferDeviceAddressInfo*)(local_pInfo), countPtr);
    }
    uint32_t packetSize_vkGetBufferDeviceAddressKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetBufferDeviceAddressKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetBufferDeviceAddressKHR = OP_vkGetBufferDeviceAddressKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetBufferDeviceAddressKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetBufferDeviceAddressKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkBufferDeviceAddressInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferDeviceAddressInfo*)(local_pInfo), streamPtrPtr);
    VkDeviceAddress vkGetBufferDeviceAddressKHR_VkDeviceAddress_return = (VkDeviceAddress)0;
    stream->read(&vkGetBufferDeviceAddressKHR_VkDeviceAddress_return, sizeof(VkDeviceAddress));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetBufferDeviceAddressKHR_VkDeviceAddress_return;
}

uint64_t VkEncoder::vkGetBufferOpaqueCaptureAddressKHR(
    VkDevice device,
    const VkBufferDeviceAddressInfo* pInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBufferDeviceAddressInfo* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkBufferDeviceAddressInfo*)pool->alloc(sizeof(const VkBufferDeviceAddressInfo));
        deepcopy_VkBufferDeviceAddressInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkBufferDeviceAddressInfo*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkBufferDeviceAddressInfo(sResourceTracker, (VkBufferDeviceAddressInfo*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkBufferDeviceAddressInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferDeviceAddressInfo*)(local_pInfo), countPtr);
    }
    uint32_t packetSize_vkGetBufferOpaqueCaptureAddressKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetBufferOpaqueCaptureAddressKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetBufferOpaqueCaptureAddressKHR = OP_vkGetBufferOpaqueCaptureAddressKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetBufferOpaqueCaptureAddressKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetBufferOpaqueCaptureAddressKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkBufferDeviceAddressInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferDeviceAddressInfo*)(local_pInfo), streamPtrPtr);
    uint64_t vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return = (uint64_t)0;
    stream->read(&vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return, sizeof(uint64_t));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetBufferOpaqueCaptureAddressKHR_uint64_t_return;
}

uint64_t VkEncoder::vkGetDeviceMemoryOpaqueCaptureAddressKHR(
    VkDevice device,
    const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeviceMemoryOpaqueCaptureAddressInfo* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkDeviceMemoryOpaqueCaptureAddressInfo*)pool->alloc(sizeof(const VkDeviceMemoryOpaqueCaptureAddressInfo));
        deepcopy_VkDeviceMemoryOpaqueCaptureAddressInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkDeviceMemoryOpaqueCaptureAddressInfo*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkDeviceMemoryOpaqueCaptureAddressInfo(sResourceTracker, (VkDeviceMemoryOpaqueCaptureAddressInfo*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDeviceMemoryOpaqueCaptureAddressInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceMemoryOpaqueCaptureAddressInfo*)(local_pInfo), countPtr);
    }
    uint32_t packetSize_vkGetDeviceMemoryOpaqueCaptureAddressKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceMemoryOpaqueCaptureAddressKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceMemoryOpaqueCaptureAddressKHR = OP_vkGetDeviceMemoryOpaqueCaptureAddressKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceMemoryOpaqueCaptureAddressKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceMemoryOpaqueCaptureAddressKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDeviceMemoryOpaqueCaptureAddressInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceMemoryOpaqueCaptureAddressInfo*)(local_pInfo), streamPtrPtr);
    uint64_t vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return = (uint64_t)0;
    stream->read(&vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return, sizeof(uint64_t));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDeviceMemoryOpaqueCaptureAddressKHR_uint64_t_return;
}

#endif
#ifdef VK_KHR_deferred_host_operations
VkResult VkEncoder::vkCreateDeferredOperationKHR(
    VkDevice device,
    const VkAllocationCallbacks* pAllocator,
    VkDeferredOperationKHR* pDeferredOperation,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDeferredOperationKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDeferredOperationKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDeferredOperationKHR = OP_vkCreateDeferredOperationKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDeferredOperationKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDeferredOperationKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    uint64_t cgen_var_2 = (uint64_t)(*pDeferredOperation);
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    (*pDeferredOperation) = (VkDeferredOperationKHR)stream->getBe64();
    VkResult vkCreateDeferredOperationKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDeferredOperationKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDeferredOperationKHR_VkResult_return;
}

void VkEncoder::vkDestroyDeferredOperationKHR(
    VkDevice device,
    VkDeferredOperationKHR operation,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeferredOperationKHR local_operation;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_operation = operation;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyDeferredOperationKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyDeferredOperationKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyDeferredOperationKHR = OP_vkDestroyDeferredOperationKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyDeferredOperationKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyDeferredOperationKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1 = (uint64_t)local_operation;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

uint32_t VkEncoder::vkGetDeferredOperationMaxConcurrencyKHR(
    VkDevice device,
    VkDeferredOperationKHR operation,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeferredOperationKHR local_operation;
    local_device = device;
    local_operation = operation;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += 8;
    }
    uint32_t packetSize_vkGetDeferredOperationMaxConcurrencyKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeferredOperationMaxConcurrencyKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeferredOperationMaxConcurrencyKHR = OP_vkGetDeferredOperationMaxConcurrencyKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeferredOperationMaxConcurrencyKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeferredOperationMaxConcurrencyKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1 = (uint64_t)local_operation;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    uint32_t vkGetDeferredOperationMaxConcurrencyKHR_uint32_t_return = (uint32_t)0;
    stream->read(&vkGetDeferredOperationMaxConcurrencyKHR_uint32_t_return, sizeof(uint32_t));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDeferredOperationMaxConcurrencyKHR_uint32_t_return;
}

VkResult VkEncoder::vkGetDeferredOperationResultKHR(
    VkDevice device,
    VkDeferredOperationKHR operation,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeferredOperationKHR local_operation;
    local_device = device;
    local_operation = operation;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += 8;
    }
    uint32_t packetSize_vkGetDeferredOperationResultKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeferredOperationResultKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeferredOperationResultKHR = OP_vkGetDeferredOperationResultKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeferredOperationResultKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeferredOperationResultKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1 = (uint64_t)local_operation;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    VkResult vkGetDeferredOperationResultKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetDeferredOperationResultKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDeferredOperationResultKHR_VkResult_return;
}

VkResult VkEncoder::vkDeferredOperationJoinKHR(
    VkDevice device,
    VkDeferredOperationKHR operation,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeferredOperationKHR local_operation;
    local_device = device;
    local_operation = operation;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += 8;
    }
    uint32_t packetSize_vkDeferredOperationJoinKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDeferredOperationJoinKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDeferredOperationJoinKHR = OP_vkDeferredOperationJoinKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDeferredOperationJoinKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDeferredOperationJoinKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1 = (uint64_t)local_operation;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    VkResult vkDeferredOperationJoinKHR_VkResult_return = (VkResult)0;
    stream->read(&vkDeferredOperationJoinKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkDeferredOperationJoinKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_pipeline_executable_properties
VkResult VkEncoder::vkGetPipelineExecutablePropertiesKHR(
    VkDevice device,
    const VkPipelineInfoKHR* pPipelineInfo,
    uint32_t* pExecutableCount,
    VkPipelineExecutablePropertiesKHR* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineInfoKHR* local_pPipelineInfo;
    local_device = device;
    local_pPipelineInfo = nullptr;
    if (pPipelineInfo)
    {
        local_pPipelineInfo = (VkPipelineInfoKHR*)pool->alloc(sizeof(const VkPipelineInfoKHR));
        deepcopy_VkPipelineInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pPipelineInfo, (VkPipelineInfoKHR*)(local_pPipelineInfo));
    }
    if (local_pPipelineInfo)
    {
        transform_tohost_VkPipelineInfoKHR(sResourceTracker, (VkPipelineInfoKHR*)(local_pPipelineInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPipelineInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineInfoKHR*)(local_pPipelineInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pExecutableCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            if (pExecutableCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pExecutableCount)); ++i)
                {
                    count_VkPipelineExecutablePropertiesKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutablePropertiesKHR*)(pProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPipelineExecutablePropertiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPipelineExecutablePropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPipelineExecutablePropertiesKHR = OP_vkGetPipelineExecutablePropertiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPipelineExecutablePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPipelineExecutablePropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPipelineInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineInfoKHR*)(local_pPipelineInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pExecutableCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pExecutableCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pExecutableCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pExecutableCount)); ++i)
        {
            reservedmarshal_VkPipelineExecutablePropertiesKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutablePropertiesKHR*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pExecutableCount;
    check_pExecutableCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pExecutableCount)
    {
        if (!(check_pExecutableCount))
        {
            fprintf(stderr, "fatal: pExecutableCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pExecutableCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPipelineExecutablePropertiesKHR* check_pProperties;
    check_pProperties = (VkPipelineExecutablePropertiesKHR*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        if (pExecutableCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pExecutableCount)); ++i)
            {
                unmarshal_VkPipelineExecutablePropertiesKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutablePropertiesKHR*)(pProperties + i));
            }
        }
    }
    if (pExecutableCount)
    {
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pExecutableCount)); ++i)
            {
                transform_fromhost_VkPipelineExecutablePropertiesKHR(sResourceTracker, (VkPipelineExecutablePropertiesKHR*)(pProperties + i));
            }
        }
    }
    VkResult vkGetPipelineExecutablePropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPipelineExecutablePropertiesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPipelineExecutablePropertiesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPipelineExecutableStatisticsKHR(
    VkDevice device,
    const VkPipelineExecutableInfoKHR* pExecutableInfo,
    uint32_t* pStatisticCount,
    VkPipelineExecutableStatisticKHR* pStatistics,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineExecutableInfoKHR* local_pExecutableInfo;
    local_device = device;
    local_pExecutableInfo = nullptr;
    if (pExecutableInfo)
    {
        local_pExecutableInfo = (VkPipelineExecutableInfoKHR*)pool->alloc(sizeof(const VkPipelineExecutableInfoKHR));
        deepcopy_VkPipelineExecutableInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pExecutableInfo, (VkPipelineExecutableInfoKHR*)(local_pExecutableInfo));
    }
    if (local_pExecutableInfo)
    {
        transform_tohost_VkPipelineExecutableInfoKHR(sResourceTracker, (VkPipelineExecutableInfoKHR*)(local_pExecutableInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPipelineExecutableInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutableInfoKHR*)(local_pExecutableInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pStatisticCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pStatistics)
        {
            if (pStatisticCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pStatisticCount)); ++i)
                {
                    count_VkPipelineExecutableStatisticKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutableStatisticKHR*)(pStatistics + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPipelineExecutableStatisticsKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPipelineExecutableStatisticsKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPipelineExecutableStatisticsKHR = OP_vkGetPipelineExecutableStatisticsKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPipelineExecutableStatisticsKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPipelineExecutableStatisticsKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPipelineExecutableInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutableInfoKHR*)(local_pExecutableInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pStatisticCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pStatisticCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pStatisticCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pStatistics;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pStatistics)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pStatisticCount)); ++i)
        {
            reservedmarshal_VkPipelineExecutableStatisticKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutableStatisticKHR*)(pStatistics + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pStatisticCount;
    check_pStatisticCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pStatisticCount)
    {
        if (!(check_pStatisticCount))
        {
            fprintf(stderr, "fatal: pStatisticCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pStatisticCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPipelineExecutableStatisticKHR* check_pStatistics;
    check_pStatistics = (VkPipelineExecutableStatisticKHR*)(uintptr_t)stream->getBe64();
    if (pStatistics)
    {
        if (!(check_pStatistics))
        {
            fprintf(stderr, "fatal: pStatistics inconsistent between guest and host\n");
        }
        if (pStatisticCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pStatisticCount)); ++i)
            {
                unmarshal_VkPipelineExecutableStatisticKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutableStatisticKHR*)(pStatistics + i));
            }
        }
    }
    if (pStatisticCount)
    {
        if (pStatistics)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pStatisticCount)); ++i)
            {
                transform_fromhost_VkPipelineExecutableStatisticKHR(sResourceTracker, (VkPipelineExecutableStatisticKHR*)(pStatistics + i));
            }
        }
    }
    VkResult vkGetPipelineExecutableStatisticsKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPipelineExecutableStatisticsKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPipelineExecutableStatisticsKHR_VkResult_return;
}

VkResult VkEncoder::vkGetPipelineExecutableInternalRepresentationsKHR(
    VkDevice device,
    const VkPipelineExecutableInfoKHR* pExecutableInfo,
    uint32_t* pInternalRepresentationCount,
    VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineExecutableInfoKHR* local_pExecutableInfo;
    local_device = device;
    local_pExecutableInfo = nullptr;
    if (pExecutableInfo)
    {
        local_pExecutableInfo = (VkPipelineExecutableInfoKHR*)pool->alloc(sizeof(const VkPipelineExecutableInfoKHR));
        deepcopy_VkPipelineExecutableInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pExecutableInfo, (VkPipelineExecutableInfoKHR*)(local_pExecutableInfo));
    }
    if (local_pExecutableInfo)
    {
        transform_tohost_VkPipelineExecutableInfoKHR(sResourceTracker, (VkPipelineExecutableInfoKHR*)(local_pExecutableInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPipelineExecutableInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutableInfoKHR*)(local_pExecutableInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pInternalRepresentationCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pInternalRepresentations)
        {
            if (pInternalRepresentationCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pInternalRepresentationCount)); ++i)
                {
                    count_VkPipelineExecutableInternalRepresentationKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutableInternalRepresentationKHR*)(pInternalRepresentations + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPipelineExecutableInternalRepresentationsKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPipelineExecutableInternalRepresentationsKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPipelineExecutableInternalRepresentationsKHR = OP_vkGetPipelineExecutableInternalRepresentationsKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPipelineExecutableInternalRepresentationsKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPipelineExecutableInternalRepresentationsKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPipelineExecutableInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutableInfoKHR*)(local_pExecutableInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pInternalRepresentationCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pInternalRepresentationCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pInternalRepresentationCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pInternalRepresentations;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pInternalRepresentations)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pInternalRepresentationCount)); ++i)
        {
            reservedmarshal_VkPipelineExecutableInternalRepresentationKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutableInternalRepresentationKHR*)(pInternalRepresentations + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pInternalRepresentationCount;
    check_pInternalRepresentationCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pInternalRepresentationCount)
    {
        if (!(check_pInternalRepresentationCount))
        {
            fprintf(stderr, "fatal: pInternalRepresentationCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pInternalRepresentationCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPipelineExecutableInternalRepresentationKHR* check_pInternalRepresentations;
    check_pInternalRepresentations = (VkPipelineExecutableInternalRepresentationKHR*)(uintptr_t)stream->getBe64();
    if (pInternalRepresentations)
    {
        if (!(check_pInternalRepresentations))
        {
            fprintf(stderr, "fatal: pInternalRepresentations inconsistent between guest and host\n");
        }
        if (pInternalRepresentationCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pInternalRepresentationCount)); ++i)
            {
                unmarshal_VkPipelineExecutableInternalRepresentationKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPipelineExecutableInternalRepresentationKHR*)(pInternalRepresentations + i));
            }
        }
    }
    if (pInternalRepresentationCount)
    {
        if (pInternalRepresentations)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pInternalRepresentationCount)); ++i)
            {
                transform_fromhost_VkPipelineExecutableInternalRepresentationKHR(sResourceTracker, (VkPipelineExecutableInternalRepresentationKHR*)(pInternalRepresentations + i));
            }
        }
    }
    VkResult vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPipelineExecutableInternalRepresentationsKHR_VkResult_return;
}

#endif
#ifdef VK_KHR_pipeline_library
#endif
#ifdef VK_KHR_shader_non_semantic_info
#endif
#ifdef VK_KHR_copy_commands2
void VkEncoder::vkCmdCopyBuffer2KHR(
    VkCommandBuffer commandBuffer,
    const VkCopyBufferInfo2KHR* pCopyBufferInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCopyBufferInfo2KHR* local_pCopyBufferInfo;
    local_commandBuffer = commandBuffer;
    local_pCopyBufferInfo = nullptr;
    if (pCopyBufferInfo)
    {
        local_pCopyBufferInfo = (VkCopyBufferInfo2KHR*)pool->alloc(sizeof(const VkCopyBufferInfo2KHR));
        deepcopy_VkCopyBufferInfo2KHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCopyBufferInfo, (VkCopyBufferInfo2KHR*)(local_pCopyBufferInfo));
    }
    if (local_pCopyBufferInfo)
    {
        transform_tohost_VkCopyBufferInfo2KHR(sResourceTracker, (VkCopyBufferInfo2KHR*)(local_pCopyBufferInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkCopyBufferInfo2KHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyBufferInfo2KHR*)(local_pCopyBufferInfo), countPtr);
    }
    uint32_t packetSize_vkCmdCopyBuffer2KHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdCopyBuffer2KHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdCopyBuffer2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdCopyBuffer2KHR = OP_vkCmdCopyBuffer2KHR;
    memcpy(streamPtr, &opcode_vkCmdCopyBuffer2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdCopyBuffer2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkCopyBufferInfo2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyBufferInfo2KHR*)(local_pCopyBufferInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdCopyImage2KHR(
    VkCommandBuffer commandBuffer,
    const VkCopyImageInfo2KHR* pCopyImageInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCopyImageInfo2KHR* local_pCopyImageInfo;
    local_commandBuffer = commandBuffer;
    local_pCopyImageInfo = nullptr;
    if (pCopyImageInfo)
    {
        local_pCopyImageInfo = (VkCopyImageInfo2KHR*)pool->alloc(sizeof(const VkCopyImageInfo2KHR));
        deepcopy_VkCopyImageInfo2KHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCopyImageInfo, (VkCopyImageInfo2KHR*)(local_pCopyImageInfo));
    }
    if (local_pCopyImageInfo)
    {
        transform_tohost_VkCopyImageInfo2KHR(sResourceTracker, (VkCopyImageInfo2KHR*)(local_pCopyImageInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkCopyImageInfo2KHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyImageInfo2KHR*)(local_pCopyImageInfo), countPtr);
    }
    uint32_t packetSize_vkCmdCopyImage2KHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdCopyImage2KHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdCopyImage2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdCopyImage2KHR = OP_vkCmdCopyImage2KHR;
    memcpy(streamPtr, &opcode_vkCmdCopyImage2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdCopyImage2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkCopyImageInfo2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyImageInfo2KHR*)(local_pCopyImageInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdCopyBufferToImage2KHR(
    VkCommandBuffer commandBuffer,
    const VkCopyBufferToImageInfo2KHR* pCopyBufferToImageInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCopyBufferToImageInfo2KHR* local_pCopyBufferToImageInfo;
    local_commandBuffer = commandBuffer;
    local_pCopyBufferToImageInfo = nullptr;
    if (pCopyBufferToImageInfo)
    {
        local_pCopyBufferToImageInfo = (VkCopyBufferToImageInfo2KHR*)pool->alloc(sizeof(const VkCopyBufferToImageInfo2KHR));
        deepcopy_VkCopyBufferToImageInfo2KHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCopyBufferToImageInfo, (VkCopyBufferToImageInfo2KHR*)(local_pCopyBufferToImageInfo));
    }
    if (local_pCopyBufferToImageInfo)
    {
        transform_tohost_VkCopyBufferToImageInfo2KHR(sResourceTracker, (VkCopyBufferToImageInfo2KHR*)(local_pCopyBufferToImageInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkCopyBufferToImageInfo2KHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyBufferToImageInfo2KHR*)(local_pCopyBufferToImageInfo), countPtr);
    }
    uint32_t packetSize_vkCmdCopyBufferToImage2KHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdCopyBufferToImage2KHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdCopyBufferToImage2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdCopyBufferToImage2KHR = OP_vkCmdCopyBufferToImage2KHR;
    memcpy(streamPtr, &opcode_vkCmdCopyBufferToImage2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdCopyBufferToImage2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkCopyBufferToImageInfo2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyBufferToImageInfo2KHR*)(local_pCopyBufferToImageInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdCopyImageToBuffer2KHR(
    VkCommandBuffer commandBuffer,
    const VkCopyImageToBufferInfo2KHR* pCopyImageToBufferInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCopyImageToBufferInfo2KHR* local_pCopyImageToBufferInfo;
    local_commandBuffer = commandBuffer;
    local_pCopyImageToBufferInfo = nullptr;
    if (pCopyImageToBufferInfo)
    {
        local_pCopyImageToBufferInfo = (VkCopyImageToBufferInfo2KHR*)pool->alloc(sizeof(const VkCopyImageToBufferInfo2KHR));
        deepcopy_VkCopyImageToBufferInfo2KHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCopyImageToBufferInfo, (VkCopyImageToBufferInfo2KHR*)(local_pCopyImageToBufferInfo));
    }
    if (local_pCopyImageToBufferInfo)
    {
        transform_tohost_VkCopyImageToBufferInfo2KHR(sResourceTracker, (VkCopyImageToBufferInfo2KHR*)(local_pCopyImageToBufferInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkCopyImageToBufferInfo2KHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyImageToBufferInfo2KHR*)(local_pCopyImageToBufferInfo), countPtr);
    }
    uint32_t packetSize_vkCmdCopyImageToBuffer2KHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdCopyImageToBuffer2KHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdCopyImageToBuffer2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdCopyImageToBuffer2KHR = OP_vkCmdCopyImageToBuffer2KHR;
    memcpy(streamPtr, &opcode_vkCmdCopyImageToBuffer2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdCopyImageToBuffer2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkCopyImageToBufferInfo2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyImageToBufferInfo2KHR*)(local_pCopyImageToBufferInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBlitImage2KHR(
    VkCommandBuffer commandBuffer,
    const VkBlitImageInfo2KHR* pBlitImageInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBlitImageInfo2KHR* local_pBlitImageInfo;
    local_commandBuffer = commandBuffer;
    local_pBlitImageInfo = nullptr;
    if (pBlitImageInfo)
    {
        local_pBlitImageInfo = (VkBlitImageInfo2KHR*)pool->alloc(sizeof(const VkBlitImageInfo2KHR));
        deepcopy_VkBlitImageInfo2KHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pBlitImageInfo, (VkBlitImageInfo2KHR*)(local_pBlitImageInfo));
    }
    if (local_pBlitImageInfo)
    {
        transform_tohost_VkBlitImageInfo2KHR(sResourceTracker, (VkBlitImageInfo2KHR*)(local_pBlitImageInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkBlitImageInfo2KHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBlitImageInfo2KHR*)(local_pBlitImageInfo), countPtr);
    }
    uint32_t packetSize_vkCmdBlitImage2KHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBlitImage2KHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBlitImage2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBlitImage2KHR = OP_vkCmdBlitImage2KHR;
    memcpy(streamPtr, &opcode_vkCmdBlitImage2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBlitImage2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkBlitImageInfo2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBlitImageInfo2KHR*)(local_pBlitImageInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdResolveImage2KHR(
    VkCommandBuffer commandBuffer,
    const VkResolveImageInfo2KHR* pResolveImageInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkResolveImageInfo2KHR* local_pResolveImageInfo;
    local_commandBuffer = commandBuffer;
    local_pResolveImageInfo = nullptr;
    if (pResolveImageInfo)
    {
        local_pResolveImageInfo = (VkResolveImageInfo2KHR*)pool->alloc(sizeof(const VkResolveImageInfo2KHR));
        deepcopy_VkResolveImageInfo2KHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pResolveImageInfo, (VkResolveImageInfo2KHR*)(local_pResolveImageInfo));
    }
    if (local_pResolveImageInfo)
    {
        transform_tohost_VkResolveImageInfo2KHR(sResourceTracker, (VkResolveImageInfo2KHR*)(local_pResolveImageInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkResolveImageInfo2KHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkResolveImageInfo2KHR*)(local_pResolveImageInfo), countPtr);
    }
    uint32_t packetSize_vkCmdResolveImage2KHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdResolveImage2KHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdResolveImage2KHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdResolveImage2KHR = OP_vkCmdResolveImage2KHR;
    memcpy(streamPtr, &opcode_vkCmdResolveImage2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdResolveImage2KHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkResolveImageInfo2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkResolveImageInfo2KHR*)(local_pResolveImageInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_ANDROID_native_buffer
VkResult VkEncoder::vkGetSwapchainGrallocUsageANDROID(
    VkDevice device,
    VkFormat format,
    VkImageUsageFlags imageUsage,
    int* grallocUsage,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkFormat local_format;
    VkImageUsageFlags local_imageUsage;
    local_device = device;
    local_format = format;
    local_imageUsage = imageUsage;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkFormat);
        *countPtr += sizeof(VkImageUsageFlags);
        *countPtr += sizeof(int);
    }
    uint32_t packetSize_vkGetSwapchainGrallocUsageANDROID = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetSwapchainGrallocUsageANDROID);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetSwapchainGrallocUsageANDROID = OP_vkGetSwapchainGrallocUsageANDROID;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetSwapchainGrallocUsageANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetSwapchainGrallocUsageANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkFormat*)&local_format, sizeof(VkFormat));
    *streamPtrPtr += sizeof(VkFormat);
    memcpy(*streamPtrPtr, (VkImageUsageFlags*)&local_imageUsage, sizeof(VkImageUsageFlags));
    *streamPtrPtr += sizeof(VkImageUsageFlags);
    memcpy(*streamPtrPtr, (int*)grallocUsage, sizeof(int));
    *streamPtrPtr += sizeof(int);
    stream->read((int*)grallocUsage, sizeof(int));
    VkResult vkGetSwapchainGrallocUsageANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainGrallocUsageANDROID_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetSwapchainGrallocUsageANDROID_VkResult_return;
}

VkResult VkEncoder::vkAcquireImageANDROID(
    VkDevice device,
    VkImage image,
    int nativeFenceFd,
    VkSemaphore semaphore,
    VkFence fence,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImage local_image;
    int local_nativeFenceFd;
    VkSemaphore local_semaphore;
    VkFence local_fence;
    local_device = device;
    local_image = image;
    local_nativeFenceFd = nativeFenceFd;
    local_semaphore = semaphore;
    local_fence = fence;
    sResourceTracker->unwrap_vkAcquireImageANDROID_nativeFenceFd(nativeFenceFd, &local_nativeFenceFd);
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(int);
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        uint64_t cgen_var_3;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkAcquireImageANDROID = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkAcquireImageANDROID);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkAcquireImageANDROID = OP_vkAcquireImageANDROID;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkAcquireImageANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkAcquireImageANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (int*)&local_nativeFenceFd, sizeof(int));
    *streamPtrPtr += sizeof(int);
    uint64_t cgen_var_2;
    *&cgen_var_2 = get_host_u64_VkSemaphore((*&local_semaphore));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_3;
    *&cgen_var_3 = get_host_u64_VkFence((*&local_fence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_3, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkAcquireImageANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireImageANDROID_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkAcquireImageANDROID_VkResult_return;
}

VkResult VkEncoder::vkQueueSignalReleaseImageANDROID(
    VkQueue queue,
    uint32_t waitSemaphoreCount,
    const VkSemaphore* pWaitSemaphores,
    VkImage image,
    int* pNativeFenceFd,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    uint32_t local_waitSemaphoreCount;
    VkSemaphore* local_pWaitSemaphores;
    VkImage local_image;
    local_queue = queue;
    local_waitSemaphoreCount = waitSemaphoreCount;
    // Avoiding deepcopy for pWaitSemaphores
    local_pWaitSemaphores = (VkSemaphore*)pWaitSemaphores;
    local_image = image;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pWaitSemaphores)
        {
            if (((waitSemaphoreCount)))
            {
                *countPtr += ((waitSemaphoreCount)) * 8;
            }
        }
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(int);
    }
    uint32_t packetSize_vkQueueSignalReleaseImageANDROID = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueSignalReleaseImageANDROID);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueSignalReleaseImageANDROID = OP_vkQueueSignalReleaseImageANDROID;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueSignalReleaseImageANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueSignalReleaseImageANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_waitSemaphoreCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pWaitSemaphores;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pWaitSemaphores)
    {
        if (((waitSemaphoreCount)))
        {
            uint8_t* cgen_var_1_0_ptr = (uint8_t*)(*streamPtrPtr);
            for (uint32_t k = 0; k < ((waitSemaphoreCount)); ++k)
            {
                uint64_t tmpval = get_host_u64_VkSemaphore(local_pWaitSemaphores[k]);
                memcpy(cgen_var_1_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
            *streamPtrPtr += 8 * ((waitSemaphoreCount));
        }
    }
    uint64_t cgen_var_2;
    *&cgen_var_2 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (int*)pNativeFenceFd, sizeof(int));
    *streamPtrPtr += sizeof(int);
    stream->read((int*)pNativeFenceFd, sizeof(int));
    VkResult vkQueueSignalReleaseImageANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkQueueSignalReleaseImageANDROID_VkResult_return, sizeof(VkResult));
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkQueueSignalReleaseImageANDROID_VkResult_return;
}

#endif
#ifdef VK_EXT_debug_report
VkResult VkEncoder::vkCreateDebugReportCallbackEXT(
    VkInstance instance,
    const VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDebugReportCallbackEXT* pCallback,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkDebugReportCallbackCreateInfoEXT* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDebugReportCallbackCreateInfoEXT*)pool->alloc(sizeof(const VkDebugReportCallbackCreateInfoEXT));
        deepcopy_VkDebugReportCallbackCreateInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkDebugReportCallbackCreateInfoEXT*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDebugReportCallbackCreateInfoEXT(sResourceTracker, (VkDebugReportCallbackCreateInfoEXT*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDebugReportCallbackCreateInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugReportCallbackCreateInfoEXT*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDebugReportCallbackEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDebugReportCallbackEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDebugReportCallbackEXT = OP_vkCreateDebugReportCallbackEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDebugReportCallbackEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDebugReportCallbackEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDebugReportCallbackCreateInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugReportCallbackCreateInfoEXT*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pCallback));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkDebugReportCallbackEXT(&cgen_var_3, (VkDebugReportCallbackEXT*)pCallback, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDebugReportCallbackEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDebugReportCallbackEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDebugReportCallbackEXT_VkResult_return;
}

void VkEncoder::vkDestroyDebugReportCallbackEXT(
    VkInstance instance,
    VkDebugReportCallbackEXT callback,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkDebugReportCallbackEXT local_callback;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_callback = callback;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyDebugReportCallbackEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyDebugReportCallbackEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyDebugReportCallbackEXT = OP_vkDestroyDebugReportCallbackEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyDebugReportCallbackEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyDebugReportCallbackEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDebugReportCallbackEXT((*&local_callback));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkDebugReportCallbackEXT((VkDebugReportCallbackEXT*)&callback);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkDebugReportMessageEXT(
    VkInstance instance,
    VkDebugReportFlagsEXT flags,
    VkDebugReportObjectTypeEXT objectType,
    uint64_t object,
    size_t location,
    int32_t messageCode,
    const char* pLayerPrefix,
    const char* pMessage,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkDebugReportFlagsEXT local_flags;
    VkDebugReportObjectTypeEXT local_objectType;
    uint64_t local_object;
    size_t local_location;
    int32_t local_messageCode;
    char* local_pLayerPrefix;
    char* local_pMessage;
    local_instance = instance;
    local_flags = flags;
    local_objectType = objectType;
    local_object = object;
    local_location = location;
    local_messageCode = messageCode;
    // Avoiding deepcopy for pLayerPrefix
    local_pLayerPrefix = (char*)pLayerPrefix;
    // Avoiding deepcopy for pMessage
    local_pMessage = (char*)pMessage;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDebugReportFlagsEXT);
        *countPtr += sizeof(VkDebugReportObjectTypeEXT);
        *countPtr += sizeof(uint64_t);
        *countPtr += 8;
        *countPtr += sizeof(int32_t);
        *countPtr += sizeof(uint32_t) + (local_pLayerPrefix ? strlen(local_pLayerPrefix) : 0);
        *countPtr += sizeof(uint32_t) + (local_pMessage ? strlen(local_pMessage) : 0);
    }
    uint32_t packetSize_vkDebugReportMessageEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDebugReportMessageEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDebugReportMessageEXT = OP_vkDebugReportMessageEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDebugReportMessageEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDebugReportMessageEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDebugReportFlagsEXT*)&local_flags, sizeof(VkDebugReportFlagsEXT));
    *streamPtrPtr += sizeof(VkDebugReportFlagsEXT);
    memcpy(*streamPtrPtr, (VkDebugReportObjectTypeEXT*)&local_objectType, sizeof(VkDebugReportObjectTypeEXT));
    *streamPtrPtr += sizeof(VkDebugReportObjectTypeEXT);
    memcpy(*streamPtrPtr, (uint64_t*)&local_object, sizeof(uint64_t));
    *streamPtrPtr += sizeof(uint64_t);
    uint64_t cgen_var_1 = (uint64_t)local_location;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    memcpy(*streamPtrPtr, (int32_t*)&local_messageCode, sizeof(int32_t));
    *streamPtrPtr += sizeof(int32_t);
    {
        uint32_t l = local_pLayerPrefix ? strlen(local_pLayerPrefix): 0;
        memcpy(*streamPtrPtr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*streamPtrPtr);
        *streamPtrPtr += sizeof(uint32_t);
        memcpy(*streamPtrPtr, (char*)local_pLayerPrefix, l);
        *streamPtrPtr += l;
    }
    {
        uint32_t l = local_pMessage ? strlen(local_pMessage): 0;
        memcpy(*streamPtrPtr, (uint32_t*)&l, sizeof(uint32_t));
        android::base::Stream::toBe32((uint8_t*)*streamPtrPtr);
        *streamPtrPtr += sizeof(uint32_t);
        memcpy(*streamPtrPtr, (char*)local_pMessage, l);
        *streamPtrPtr += l;
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
VkResult VkEncoder::vkDebugMarkerSetObjectTagEXT(
    VkDevice device,
    const VkDebugMarkerObjectTagInfoEXT* pTagInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDebugMarkerObjectTagInfoEXT* local_pTagInfo;
    local_device = device;
    local_pTagInfo = nullptr;
    if (pTagInfo)
    {
        local_pTagInfo = (VkDebugMarkerObjectTagInfoEXT*)pool->alloc(sizeof(const VkDebugMarkerObjectTagInfoEXT));
        deepcopy_VkDebugMarkerObjectTagInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pTagInfo, (VkDebugMarkerObjectTagInfoEXT*)(local_pTagInfo));
    }
    if (local_pTagInfo)
    {
        transform_tohost_VkDebugMarkerObjectTagInfoEXT(sResourceTracker, (VkDebugMarkerObjectTagInfoEXT*)(local_pTagInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDebugMarkerObjectTagInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugMarkerObjectTagInfoEXT*)(local_pTagInfo), countPtr);
    }
    uint32_t packetSize_vkDebugMarkerSetObjectTagEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDebugMarkerSetObjectTagEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDebugMarkerSetObjectTagEXT = OP_vkDebugMarkerSetObjectTagEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDebugMarkerSetObjectTagEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDebugMarkerSetObjectTagEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDebugMarkerObjectTagInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugMarkerObjectTagInfoEXT*)(local_pTagInfo), streamPtrPtr);
    VkResult vkDebugMarkerSetObjectTagEXT_VkResult_return = (VkResult)0;
    stream->read(&vkDebugMarkerSetObjectTagEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkDebugMarkerSetObjectTagEXT_VkResult_return;
}

VkResult VkEncoder::vkDebugMarkerSetObjectNameEXT(
    VkDevice device,
    const VkDebugMarkerObjectNameInfoEXT* pNameInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDebugMarkerObjectNameInfoEXT* local_pNameInfo;
    local_device = device;
    local_pNameInfo = nullptr;
    if (pNameInfo)
    {
        local_pNameInfo = (VkDebugMarkerObjectNameInfoEXT*)pool->alloc(sizeof(const VkDebugMarkerObjectNameInfoEXT));
        deepcopy_VkDebugMarkerObjectNameInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pNameInfo, (VkDebugMarkerObjectNameInfoEXT*)(local_pNameInfo));
    }
    if (local_pNameInfo)
    {
        transform_tohost_VkDebugMarkerObjectNameInfoEXT(sResourceTracker, (VkDebugMarkerObjectNameInfoEXT*)(local_pNameInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDebugMarkerObjectNameInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugMarkerObjectNameInfoEXT*)(local_pNameInfo), countPtr);
    }
    uint32_t packetSize_vkDebugMarkerSetObjectNameEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDebugMarkerSetObjectNameEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDebugMarkerSetObjectNameEXT = OP_vkDebugMarkerSetObjectNameEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDebugMarkerSetObjectNameEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDebugMarkerSetObjectNameEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDebugMarkerObjectNameInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugMarkerObjectNameInfoEXT*)(local_pNameInfo), streamPtrPtr);
    VkResult vkDebugMarkerSetObjectNameEXT_VkResult_return = (VkResult)0;
    stream->read(&vkDebugMarkerSetObjectNameEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkDebugMarkerSetObjectNameEXT_VkResult_return;
}

void VkEncoder::vkCmdDebugMarkerBeginEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugMarkerMarkerInfoEXT* pMarkerInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkDebugMarkerMarkerInfoEXT* local_pMarkerInfo;
    local_commandBuffer = commandBuffer;
    local_pMarkerInfo = nullptr;
    if (pMarkerInfo)
    {
        local_pMarkerInfo = (VkDebugMarkerMarkerInfoEXT*)pool->alloc(sizeof(const VkDebugMarkerMarkerInfoEXT));
        deepcopy_VkDebugMarkerMarkerInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pMarkerInfo, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    if (local_pMarkerInfo)
    {
        transform_tohost_VkDebugMarkerMarkerInfoEXT(sResourceTracker, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDebugMarkerMarkerInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo), countPtr);
    }
    uint32_t packetSize_vkCmdDebugMarkerBeginEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDebugMarkerBeginEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDebugMarkerBeginEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDebugMarkerBeginEXT = OP_vkCmdDebugMarkerBeginEXT;
    memcpy(streamPtr, &opcode_vkCmdDebugMarkerBeginEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDebugMarkerBeginEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkDebugMarkerMarkerInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDebugMarkerEndEXT(
    VkCommandBuffer commandBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkCmdDebugMarkerEndEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDebugMarkerEndEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDebugMarkerEndEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDebugMarkerEndEXT = OP_vkCmdDebugMarkerEndEXT;
    memcpy(streamPtr, &opcode_vkCmdDebugMarkerEndEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDebugMarkerEndEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDebugMarkerInsertEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugMarkerMarkerInfoEXT* pMarkerInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkDebugMarkerMarkerInfoEXT* local_pMarkerInfo;
    local_commandBuffer = commandBuffer;
    local_pMarkerInfo = nullptr;
    if (pMarkerInfo)
    {
        local_pMarkerInfo = (VkDebugMarkerMarkerInfoEXT*)pool->alloc(sizeof(const VkDebugMarkerMarkerInfoEXT));
        deepcopy_VkDebugMarkerMarkerInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pMarkerInfo, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    if (local_pMarkerInfo)
    {
        transform_tohost_VkDebugMarkerMarkerInfoEXT(sResourceTracker, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDebugMarkerMarkerInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo), countPtr);
    }
    uint32_t packetSize_vkCmdDebugMarkerInsertEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDebugMarkerInsertEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDebugMarkerInsertEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDebugMarkerInsertEXT = OP_vkCmdDebugMarkerInsertEXT;
    memcpy(streamPtr, &opcode_vkCmdDebugMarkerInsertEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDebugMarkerInsertEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkDebugMarkerMarkerInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugMarkerMarkerInfoEXT*)(local_pMarkerInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
#endif
#ifdef VK_EXT_transform_feedback
void VkEncoder::vkCmdBindTransformFeedbackBuffersEXT(
    VkCommandBuffer commandBuffer,
    uint32_t firstBinding,
    uint32_t bindingCount,
    const VkBuffer* pBuffers,
    const VkDeviceSize* pOffsets,
    const VkDeviceSize* pSizes,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstBinding;
    uint32_t local_bindingCount;
    VkBuffer* local_pBuffers;
    VkDeviceSize* local_pOffsets;
    VkDeviceSize* local_pSizes;
    local_commandBuffer = commandBuffer;
    local_firstBinding = firstBinding;
    local_bindingCount = bindingCount;
    // Avoiding deepcopy for pBuffers
    local_pBuffers = (VkBuffer*)pBuffers;
    // Avoiding deepcopy for pOffsets
    local_pOffsets = (VkDeviceSize*)pOffsets;
    // Avoiding deepcopy for pSizes
    local_pSizes = (VkDeviceSize*)pSizes;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        if (((bindingCount)))
        {
            *countPtr += ((bindingCount)) * 8;
        }
        *countPtr += ((bindingCount)) * sizeof(VkDeviceSize);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pSizes)
        {
            *countPtr += ((bindingCount)) * sizeof(VkDeviceSize);
        }
    }
    uint32_t packetSize_vkCmdBindTransformFeedbackBuffersEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBindTransformFeedbackBuffersEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBindTransformFeedbackBuffersEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBindTransformFeedbackBuffersEXT = OP_vkCmdBindTransformFeedbackBuffersEXT;
    memcpy(streamPtr, &opcode_vkCmdBindTransformFeedbackBuffersEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBindTransformFeedbackBuffersEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstBinding, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_bindingCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((bindingCount)))
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((bindingCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkBuffer(local_pBuffers[k]);
            memcpy(cgen_var_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((bindingCount));
    }
    memcpy(*streamPtrPtr, (VkDeviceSize*)local_pOffsets, ((bindingCount)) * sizeof(VkDeviceSize));
    *streamPtrPtr += ((bindingCount)) * sizeof(VkDeviceSize);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pSizes;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pSizes)
    {
        memcpy(*streamPtrPtr, (VkDeviceSize*)local_pSizes, ((bindingCount)) * sizeof(VkDeviceSize));
        *streamPtrPtr += ((bindingCount)) * sizeof(VkDeviceSize);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBeginTransformFeedbackEXT(
    VkCommandBuffer commandBuffer,
    uint32_t firstCounterBuffer,
    uint32_t counterBufferCount,
    const VkBuffer* pCounterBuffers,
    const VkDeviceSize* pCounterBufferOffsets,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstCounterBuffer;
    uint32_t local_counterBufferCount;
    VkBuffer* local_pCounterBuffers;
    VkDeviceSize* local_pCounterBufferOffsets;
    local_commandBuffer = commandBuffer;
    local_firstCounterBuffer = firstCounterBuffer;
    local_counterBufferCount = counterBufferCount;
    // Avoiding deepcopy for pCounterBuffers
    local_pCounterBuffers = (VkBuffer*)pCounterBuffers;
    // Avoiding deepcopy for pCounterBufferOffsets
    local_pCounterBufferOffsets = (VkDeviceSize*)pCounterBufferOffsets;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pCounterBuffers)
        {
            if (((counterBufferCount)))
            {
                *countPtr += ((counterBufferCount)) * 8;
            }
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pCounterBufferOffsets)
        {
            *countPtr += ((counterBufferCount)) * sizeof(VkDeviceSize);
        }
    }
    uint32_t packetSize_vkCmdBeginTransformFeedbackEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBeginTransformFeedbackEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBeginTransformFeedbackEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBeginTransformFeedbackEXT = OP_vkCmdBeginTransformFeedbackEXT;
    memcpy(streamPtr, &opcode_vkCmdBeginTransformFeedbackEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBeginTransformFeedbackEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstCounterBuffer, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_counterBufferCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)local_pCounterBuffers;
    memcpy((*streamPtrPtr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pCounterBuffers)
    {
        if (((counterBufferCount)))
        {
            uint8_t* cgen_var_0_0_ptr = (uint8_t*)(*streamPtrPtr);
            for (uint32_t k = 0; k < ((counterBufferCount)); ++k)
            {
                uint64_t tmpval = get_host_u64_VkBuffer(local_pCounterBuffers[k]);
                memcpy(cgen_var_0_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
            *streamPtrPtr += 8 * ((counterBufferCount));
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pCounterBufferOffsets;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pCounterBufferOffsets)
    {
        memcpy(*streamPtrPtr, (VkDeviceSize*)local_pCounterBufferOffsets, ((counterBufferCount)) * sizeof(VkDeviceSize));
        *streamPtrPtr += ((counterBufferCount)) * sizeof(VkDeviceSize);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdEndTransformFeedbackEXT(
    VkCommandBuffer commandBuffer,
    uint32_t firstCounterBuffer,
    uint32_t counterBufferCount,
    const VkBuffer* pCounterBuffers,
    const VkDeviceSize* pCounterBufferOffsets,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstCounterBuffer;
    uint32_t local_counterBufferCount;
    VkBuffer* local_pCounterBuffers;
    VkDeviceSize* local_pCounterBufferOffsets;
    local_commandBuffer = commandBuffer;
    local_firstCounterBuffer = firstCounterBuffer;
    local_counterBufferCount = counterBufferCount;
    // Avoiding deepcopy for pCounterBuffers
    local_pCounterBuffers = (VkBuffer*)pCounterBuffers;
    // Avoiding deepcopy for pCounterBufferOffsets
    local_pCounterBufferOffsets = (VkDeviceSize*)pCounterBufferOffsets;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pCounterBuffers)
        {
            if (((counterBufferCount)))
            {
                *countPtr += ((counterBufferCount)) * 8;
            }
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pCounterBufferOffsets)
        {
            *countPtr += ((counterBufferCount)) * sizeof(VkDeviceSize);
        }
    }
    uint32_t packetSize_vkCmdEndTransformFeedbackEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdEndTransformFeedbackEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdEndTransformFeedbackEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdEndTransformFeedbackEXT = OP_vkCmdEndTransformFeedbackEXT;
    memcpy(streamPtr, &opcode_vkCmdEndTransformFeedbackEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdEndTransformFeedbackEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstCounterBuffer, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_counterBufferCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)local_pCounterBuffers;
    memcpy((*streamPtrPtr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pCounterBuffers)
    {
        if (((counterBufferCount)))
        {
            uint8_t* cgen_var_0_0_ptr = (uint8_t*)(*streamPtrPtr);
            for (uint32_t k = 0; k < ((counterBufferCount)); ++k)
            {
                uint64_t tmpval = get_host_u64_VkBuffer(local_pCounterBuffers[k]);
                memcpy(cgen_var_0_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
            *streamPtrPtr += 8 * ((counterBufferCount));
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pCounterBufferOffsets;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pCounterBufferOffsets)
    {
        memcpy(*streamPtrPtr, (VkDeviceSize*)local_pCounterBufferOffsets, ((counterBufferCount)) * sizeof(VkDeviceSize));
        *streamPtrPtr += ((counterBufferCount)) * sizeof(VkDeviceSize);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBeginQueryIndexedEXT(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query,
    VkQueryControlFlags flags,
    uint32_t index,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkQueryPool local_queryPool;
    uint32_t local_query;
    VkQueryControlFlags local_flags;
    uint32_t local_index;
    local_commandBuffer = commandBuffer;
    local_queryPool = queryPool;
    local_query = query;
    local_flags = flags;
    local_index = index;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(VkQueryControlFlags);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdBeginQueryIndexedEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBeginQueryIndexedEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBeginQueryIndexedEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBeginQueryIndexedEXT = OP_vkCmdBeginQueryIndexedEXT;
    memcpy(streamPtr, &opcode_vkCmdBeginQueryIndexedEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBeginQueryIndexedEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_query, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (VkQueryControlFlags*)&local_flags, sizeof(VkQueryControlFlags));
    *streamPtrPtr += sizeof(VkQueryControlFlags);
    memcpy(*streamPtrPtr, (uint32_t*)&local_index, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdEndQueryIndexedEXT(
    VkCommandBuffer commandBuffer,
    VkQueryPool queryPool,
    uint32_t query,
    uint32_t index,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkQueryPool local_queryPool;
    uint32_t local_query;
    uint32_t local_index;
    local_commandBuffer = commandBuffer;
    local_queryPool = queryPool;
    local_query = query;
    local_index = index;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdEndQueryIndexedEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdEndQueryIndexedEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdEndQueryIndexedEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdEndQueryIndexedEXT = OP_vkCmdEndQueryIndexedEXT;
    memcpy(streamPtr, &opcode_vkCmdEndQueryIndexedEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdEndQueryIndexedEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_query, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_index, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDrawIndirectByteCountEXT(
    VkCommandBuffer commandBuffer,
    uint32_t instanceCount,
    uint32_t firstInstance,
    VkBuffer counterBuffer,
    VkDeviceSize counterBufferOffset,
    uint32_t counterOffset,
    uint32_t vertexStride,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_instanceCount;
    uint32_t local_firstInstance;
    VkBuffer local_counterBuffer;
    VkDeviceSize local_counterBufferOffset;
    uint32_t local_counterOffset;
    uint32_t local_vertexStride;
    local_commandBuffer = commandBuffer;
    local_instanceCount = instanceCount;
    local_firstInstance = firstInstance;
    local_counterBuffer = counterBuffer;
    local_counterBufferOffset = counterBufferOffset;
    local_counterOffset = counterOffset;
    local_vertexStride = vertexStride;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawIndirectByteCountEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawIndirectByteCountEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawIndirectByteCountEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawIndirectByteCountEXT = OP_vkCmdDrawIndirectByteCountEXT;
    memcpy(streamPtr, &opcode_vkCmdDrawIndirectByteCountEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawIndirectByteCountEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_instanceCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstInstance, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_counterBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_counterBufferOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_counterOffset, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_vertexStride, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_NVX_image_view_handle
uint32_t VkEncoder::vkGetImageViewHandleNVX(
    VkDevice device,
    const VkImageViewHandleInfoNVX* pInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImageViewHandleInfoNVX* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkImageViewHandleInfoNVX*)pool->alloc(sizeof(const VkImageViewHandleInfoNVX));
        deepcopy_VkImageViewHandleInfoNVX(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkImageViewHandleInfoNVX*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkImageViewHandleInfoNVX(sResourceTracker, (VkImageViewHandleInfoNVX*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkImageViewHandleInfoNVX(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageViewHandleInfoNVX*)(local_pInfo), countPtr);
    }
    uint32_t packetSize_vkGetImageViewHandleNVX = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetImageViewHandleNVX);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetImageViewHandleNVX = OP_vkGetImageViewHandleNVX;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetImageViewHandleNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetImageViewHandleNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageViewHandleInfoNVX(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageViewHandleInfoNVX*)(local_pInfo), streamPtrPtr);
    uint32_t vkGetImageViewHandleNVX_uint32_t_return = (uint32_t)0;
    stream->read(&vkGetImageViewHandleNVX_uint32_t_return, sizeof(uint32_t));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetImageViewHandleNVX_uint32_t_return;
}

VkResult VkEncoder::vkGetImageViewAddressNVX(
    VkDevice device,
    VkImageView imageView,
    VkImageViewAddressPropertiesNVX* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImageView local_imageView;
    local_device = device;
    local_imageView = imageView;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        count_VkImageViewAddressPropertiesNVX(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageViewAddressPropertiesNVX*)(pProperties), countPtr);
    }
    uint32_t packetSize_vkGetImageViewAddressNVX = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetImageViewAddressNVX);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetImageViewAddressNVX = OP_vkGetImageViewAddressNVX;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetImageViewAddressNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetImageViewAddressNVX, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImageView((*&local_imageView));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageViewAddressPropertiesNVX(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageViewAddressPropertiesNVX*)(pProperties), streamPtrPtr);
    unmarshal_VkImageViewAddressPropertiesNVX(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageViewAddressPropertiesNVX*)(pProperties));
    if (pProperties)
    {
        transform_fromhost_VkImageViewAddressPropertiesNVX(sResourceTracker, (VkImageViewAddressPropertiesNVX*)(pProperties));
    }
    VkResult vkGetImageViewAddressNVX_VkResult_return = (VkResult)0;
    stream->read(&vkGetImageViewAddressNVX_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetImageViewAddressNVX_VkResult_return;
}

#endif
#ifdef VK_AMD_draw_indirect_count
void VkEncoder::vkCmdDrawIndirectCountAMD(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawIndirectCountAMD = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawIndirectCountAMD -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawIndirectCountAMD);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawIndirectCountAMD = OP_vkCmdDrawIndirectCountAMD;
    memcpy(streamPtr, &opcode_vkCmdDrawIndirectCountAMD, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawIndirectCountAMD, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&local_countBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_stride, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDrawIndexedIndirectCountAMD(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawIndexedIndirectCountAMD = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawIndexedIndirectCountAMD -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawIndexedIndirectCountAMD);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawIndexedIndirectCountAMD = OP_vkCmdDrawIndexedIndirectCountAMD;
    memcpy(streamPtr, &opcode_vkCmdDrawIndexedIndirectCountAMD, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawIndexedIndirectCountAMD, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&local_countBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_stride, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
#endif
#ifdef VK_AMD_shader_info
VkResult VkEncoder::vkGetShaderInfoAMD(
    VkDevice device,
    VkPipeline pipeline,
    VkShaderStageFlagBits shaderStage,
    VkShaderInfoTypeAMD infoType,
    size_t* pInfoSize,
    void* pInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipeline local_pipeline;
    VkShaderStageFlagBits local_shaderStage;
    VkShaderInfoTypeAMD local_infoType;
    local_device = device;
    local_pipeline = pipeline;
    local_shaderStage = shaderStage;
    local_infoType = infoType;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkShaderStageFlagBits);
        *countPtr += sizeof(VkShaderInfoTypeAMD);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pInfoSize)
        {
            *countPtr += 8;
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pInfo)
        {
            if (pInfoSize)
            {
                *countPtr += (*(pInfoSize)) * sizeof(uint8_t);
            }
        }
    }
    uint32_t packetSize_vkGetShaderInfoAMD = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetShaderInfoAMD);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetShaderInfoAMD = OP_vkGetShaderInfoAMD;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetShaderInfoAMD, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetShaderInfoAMD, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkPipeline((*&local_pipeline));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkShaderStageFlagBits*)&local_shaderStage, sizeof(VkShaderStageFlagBits));
    *streamPtrPtr += sizeof(VkShaderStageFlagBits);
    memcpy(*streamPtrPtr, (VkShaderInfoTypeAMD*)&local_infoType, sizeof(VkShaderInfoTypeAMD));
    *streamPtrPtr += sizeof(VkShaderInfoTypeAMD);
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pInfoSize;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pInfoSize)
    {
        uint64_t cgen_var_2_0 = (uint64_t)(*pInfoSize);
        memcpy((*streamPtrPtr), &cgen_var_2_0, 8);
        android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
        *streamPtrPtr += 8;
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pInfo;
    memcpy((*streamPtrPtr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pInfo)
    {
        memcpy(*streamPtrPtr, (void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
        *streamPtrPtr += (*(pInfoSize)) * sizeof(uint8_t);
    }
    // WARNING PTR CHECK
    size_t* check_pInfoSize;
    check_pInfoSize = (size_t*)(uintptr_t)stream->getBe64();
    if (pInfoSize)
    {
        if (!(check_pInfoSize))
        {
            fprintf(stderr, "fatal: pInfoSize inconsistent between guest and host\n");
        }
        (*pInfoSize) = (size_t)stream->getBe64();
    }
    // WARNING PTR CHECK
    void* check_pInfo;
    check_pInfo = (void*)(uintptr_t)stream->getBe64();
    if (pInfo)
    {
        if (!(check_pInfo))
        {
            fprintf(stderr, "fatal: pInfo inconsistent between guest and host\n");
        }
        stream->read((void*)pInfo, (*(pInfoSize)) * sizeof(uint8_t));
    }
    VkResult vkGetShaderInfoAMD_VkResult_return = (VkResult)0;
    stream->read(&vkGetShaderInfoAMD_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetShaderInfoAMD_VkResult_return;
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_GGP_stream_descriptor_surface
VkResult VkEncoder::vkCreateStreamDescriptorSurfaceGGP(
    VkInstance instance,
    const VkStreamDescriptorSurfaceCreateInfoGGP* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkStreamDescriptorSurfaceCreateInfoGGP* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkStreamDescriptorSurfaceCreateInfoGGP*)pool->alloc(sizeof(const VkStreamDescriptorSurfaceCreateInfoGGP));
        deepcopy_VkStreamDescriptorSurfaceCreateInfoGGP(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkStreamDescriptorSurfaceCreateInfoGGP*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkStreamDescriptorSurfaceCreateInfoGGP(sResourceTracker, (VkStreamDescriptorSurfaceCreateInfoGGP*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkStreamDescriptorSurfaceCreateInfoGGP(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStreamDescriptorSurfaceCreateInfoGGP*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateStreamDescriptorSurfaceGGP = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateStreamDescriptorSurfaceGGP);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateStreamDescriptorSurfaceGGP = OP_vkCreateStreamDescriptorSurfaceGGP;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateStreamDescriptorSurfaceGGP, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateStreamDescriptorSurfaceGGP, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkStreamDescriptorSurfaceCreateInfoGGP(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStreamDescriptorSurfaceCreateInfoGGP*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_3, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateStreamDescriptorSurfaceGGP_VkResult_return = (VkResult)0;
    stream->read(&vkCreateStreamDescriptorSurfaceGGP_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateStreamDescriptorSurfaceGGP_VkResult_return;
}

#endif
#ifdef VK_NV_corner_sampled_image
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
VkResult VkEncoder::vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkPhysicalDevice physicalDevice,
    VkFormat format,
    VkImageType type,
    VkImageTiling tiling,
    VkImageUsageFlags usage,
    VkImageCreateFlags flags,
    VkExternalMemoryHandleTypeFlagsNV externalHandleType,
    VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkFormat local_format;
    VkImageType local_type;
    VkImageTiling local_tiling;
    VkImageUsageFlags local_usage;
    VkImageCreateFlags local_flags;
    VkExternalMemoryHandleTypeFlagsNV local_externalHandleType;
    local_physicalDevice = physicalDevice;
    local_format = format;
    local_type = type;
    local_tiling = tiling;
    local_usage = usage;
    local_flags = flags;
    local_externalHandleType = externalHandleType;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkFormat);
        *countPtr += sizeof(VkImageType);
        *countPtr += sizeof(VkImageTiling);
        *countPtr += sizeof(VkImageUsageFlags);
        *countPtr += sizeof(VkImageCreateFlags);
        *countPtr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
        count_VkExternalImageFormatPropertiesNV(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceExternalImageFormatPropertiesNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = OP_vkGetPhysicalDeviceExternalImageFormatPropertiesNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceExternalImageFormatPropertiesNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceExternalImageFormatPropertiesNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkFormat*)&local_format, sizeof(VkFormat));
    *streamPtrPtr += sizeof(VkFormat);
    memcpy(*streamPtrPtr, (VkImageType*)&local_type, sizeof(VkImageType));
    *streamPtrPtr += sizeof(VkImageType);
    memcpy(*streamPtrPtr, (VkImageTiling*)&local_tiling, sizeof(VkImageTiling));
    *streamPtrPtr += sizeof(VkImageTiling);
    memcpy(*streamPtrPtr, (VkImageUsageFlags*)&local_usage, sizeof(VkImageUsageFlags));
    *streamPtrPtr += sizeof(VkImageUsageFlags);
    memcpy(*streamPtrPtr, (VkImageCreateFlags*)&local_flags, sizeof(VkImageCreateFlags));
    *streamPtrPtr += sizeof(VkImageCreateFlags);
    memcpy(*streamPtrPtr, (VkExternalMemoryHandleTypeFlagsNV*)&local_externalHandleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *streamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
    reservedmarshal_VkExternalImageFormatPropertiesNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties), streamPtrPtr);
    unmarshal_VkExternalImageFormatPropertiesNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
    if (pExternalImageFormatProperties)
    {
        transform_fromhost_VkExternalImageFormatPropertiesNV(sResourceTracker, (VkExternalImageFormatPropertiesNV*)(pExternalImageFormatProperties));
    }
    VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceExternalImageFormatPropertiesNV_VkResult_return;
}

#endif
#ifdef VK_NV_external_memory
#endif
#ifdef VK_NV_external_memory_win32
VkResult VkEncoder::vkGetMemoryWin32HandleNV(
    VkDevice device,
    VkDeviceMemory memory,
    VkExternalMemoryHandleTypeFlagsNV handleType,
    HANDLE* pHandle,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeviceMemory local_memory;
    VkExternalMemoryHandleTypeFlagsNV local_handleType;
    local_device = device;
    local_memory = memory;
    local_handleType = handleType;
    sResourceTracker->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)nullptr, 0, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
        *countPtr += sizeof(HANDLE);
    }
    uint32_t packetSize_vkGetMemoryWin32HandleNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMemoryWin32HandleNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMemoryWin32HandleNV = OP_vkGetMemoryWin32HandleNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMemoryWin32HandleNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMemoryWin32HandleNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDeviceMemory((*&local_memory));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkExternalMemoryHandleTypeFlagsNV*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    *streamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagsNV);
    memcpy(*streamPtrPtr, (HANDLE*)pHandle, sizeof(HANDLE));
    *streamPtrPtr += sizeof(HANDLE);
    stream->read((HANDLE*)pHandle, sizeof(HANDLE));
    VkResult vkGetMemoryWin32HandleNV_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryWin32HandleNV_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetMemoryWin32HandleNV_VkResult_return;
}

#endif
#ifdef VK_NV_win32_keyed_mutex
#endif
#ifdef VK_EXT_validation_flags
#endif
#ifdef VK_NN_vi_surface
VkResult VkEncoder::vkCreateViSurfaceNN(
    VkInstance instance,
    const VkViSurfaceCreateInfoNN* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkViSurfaceCreateInfoNN* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkViSurfaceCreateInfoNN*)pool->alloc(sizeof(const VkViSurfaceCreateInfoNN));
        deepcopy_VkViSurfaceCreateInfoNN(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkViSurfaceCreateInfoNN*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkViSurfaceCreateInfoNN(sResourceTracker, (VkViSurfaceCreateInfoNN*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkViSurfaceCreateInfoNN(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkViSurfaceCreateInfoNN*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateViSurfaceNN = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateViSurfaceNN);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateViSurfaceNN = OP_vkCreateViSurfaceNN;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateViSurfaceNN, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateViSurfaceNN, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkViSurfaceCreateInfoNN(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkViSurfaceCreateInfoNN*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_3, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateViSurfaceNN_VkResult_return = (VkResult)0;
    stream->read(&vkCreateViSurfaceNN_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateViSurfaceNN_VkResult_return;
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
#endif
#ifdef VK_EXT_astc_decode_mode
#endif
#ifdef VK_EXT_conditional_rendering
void VkEncoder::vkCmdBeginConditionalRenderingEXT(
    VkCommandBuffer commandBuffer,
    const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkConditionalRenderingBeginInfoEXT* local_pConditionalRenderingBegin;
    local_commandBuffer = commandBuffer;
    local_pConditionalRenderingBegin = nullptr;
    if (pConditionalRenderingBegin)
    {
        local_pConditionalRenderingBegin = (VkConditionalRenderingBeginInfoEXT*)pool->alloc(sizeof(const VkConditionalRenderingBeginInfoEXT));
        deepcopy_VkConditionalRenderingBeginInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pConditionalRenderingBegin, (VkConditionalRenderingBeginInfoEXT*)(local_pConditionalRenderingBegin));
    }
    if (local_pConditionalRenderingBegin)
    {
        transform_tohost_VkConditionalRenderingBeginInfoEXT(sResourceTracker, (VkConditionalRenderingBeginInfoEXT*)(local_pConditionalRenderingBegin));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkConditionalRenderingBeginInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkConditionalRenderingBeginInfoEXT*)(local_pConditionalRenderingBegin), countPtr);
    }
    uint32_t packetSize_vkCmdBeginConditionalRenderingEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBeginConditionalRenderingEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBeginConditionalRenderingEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBeginConditionalRenderingEXT = OP_vkCmdBeginConditionalRenderingEXT;
    memcpy(streamPtr, &opcode_vkCmdBeginConditionalRenderingEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBeginConditionalRenderingEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkConditionalRenderingBeginInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkConditionalRenderingBeginInfoEXT*)(local_pConditionalRenderingBegin), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdEndConditionalRenderingEXT(
    VkCommandBuffer commandBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkCmdEndConditionalRenderingEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdEndConditionalRenderingEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdEndConditionalRenderingEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdEndConditionalRenderingEXT = OP_vkCmdEndConditionalRenderingEXT;
    memcpy(streamPtr, &opcode_vkCmdEndConditionalRenderingEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdEndConditionalRenderingEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void VkEncoder::vkCmdSetViewportWScalingNV(
    VkCommandBuffer commandBuffer,
    uint32_t firstViewport,
    uint32_t viewportCount,
    const VkViewportWScalingNV* pViewportWScalings,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstViewport;
    uint32_t local_viewportCount;
    VkViewportWScalingNV* local_pViewportWScalings;
    local_commandBuffer = commandBuffer;
    local_firstViewport = firstViewport;
    local_viewportCount = viewportCount;
    local_pViewportWScalings = nullptr;
    if (pViewportWScalings)
    {
        local_pViewportWScalings = (VkViewportWScalingNV*)pool->alloc(((viewportCount)) * sizeof(const VkViewportWScalingNV));
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            deepcopy_VkViewportWScalingNV(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pViewportWScalings + i, (VkViewportWScalingNV*)(local_pViewportWScalings + i));
        }
    }
    if (local_pViewportWScalings)
    {
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            transform_tohost_VkViewportWScalingNV(sResourceTracker, (VkViewportWScalingNV*)(local_pViewportWScalings + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            count_VkViewportWScalingNV(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkViewportWScalingNV*)(local_pViewportWScalings + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdSetViewportWScalingNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetViewportWScalingNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetViewportWScalingNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetViewportWScalingNV = OP_vkCmdSetViewportWScalingNV;
    memcpy(streamPtr, &opcode_vkCmdSetViewportWScalingNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetViewportWScalingNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstViewport, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_viewportCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
    {
        reservedmarshal_VkViewportWScalingNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkViewportWScalingNV*)(local_pViewportWScalings + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_EXT_direct_mode_display
VkResult VkEncoder::vkReleaseDisplayEXT(
    VkPhysicalDevice physicalDevice,
    VkDisplayKHR display,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    local_physicalDevice = physicalDevice;
    local_display = display;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkReleaseDisplayEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkReleaseDisplayEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkReleaseDisplayEXT = OP_vkReleaseDisplayEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkReleaseDisplayEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkReleaseDisplayEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDisplayKHR((*&local_display));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkReleaseDisplayEXT_VkResult_return = (VkResult)0;
    stream->read(&vkReleaseDisplayEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkReleaseDisplayEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_acquire_xlib_display
VkResult VkEncoder::vkAcquireXlibDisplayEXT(
    VkPhysicalDevice physicalDevice,
    Display* dpy,
    VkDisplayKHR display,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkDisplayKHR local_display;
    local_physicalDevice = physicalDevice;
    local_display = display;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(Display);
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkAcquireXlibDisplayEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkAcquireXlibDisplayEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkAcquireXlibDisplayEXT = OP_vkAcquireXlibDisplayEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkAcquireXlibDisplayEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkAcquireXlibDisplayEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (Display*)dpy, sizeof(Display));
    *streamPtrPtr += sizeof(Display);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDisplayKHR((*&local_display));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    stream->read((Display*)dpy, sizeof(Display));
    VkResult vkAcquireXlibDisplayEXT_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireXlibDisplayEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkAcquireXlibDisplayEXT_VkResult_return;
}

VkResult VkEncoder::vkGetRandROutputDisplayEXT(
    VkPhysicalDevice physicalDevice,
    Display* dpy,
    RROutput rrOutput,
    VkDisplayKHR* pDisplay,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    RROutput local_rrOutput;
    local_physicalDevice = physicalDevice;
    local_rrOutput = rrOutput;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(Display);
        *countPtr += sizeof(RROutput);
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkGetRandROutputDisplayEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetRandROutputDisplayEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetRandROutputDisplayEXT = OP_vkGetRandROutputDisplayEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetRandROutputDisplayEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetRandROutputDisplayEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (Display*)dpy, sizeof(Display));
    *streamPtrPtr += sizeof(Display);
    memcpy(*streamPtrPtr, (RROutput*)&local_rrOutput, sizeof(RROutput));
    *streamPtrPtr += sizeof(RROutput);
    /* is handle, possibly out */;
    uint64_t cgen_var_1;
    *&cgen_var_1 = (uint64_t)((*pDisplay));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->read((Display*)dpy, sizeof(Display));
    uint64_t cgen_var_2;
    stream->read((uint64_t*)&cgen_var_2, 8);
    stream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_2, (VkDisplayKHR*)pDisplay, 1);
    VkResult vkGetRandROutputDisplayEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetRandROutputDisplayEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetRandROutputDisplayEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_display_surface_counter
VkResult VkEncoder::vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    VkPhysicalDevice physicalDevice,
    VkSurfaceKHR surface,
    VkSurfaceCapabilities2EXT* pSurfaceCapabilities,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkSurfaceKHR local_surface;
    local_physicalDevice = physicalDevice;
    local_surface = surface;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        count_VkSurfaceCapabilities2EXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfaceCapabilities2EXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSurfaceCapabilities2EXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSurfaceCapabilities2EXT = OP_vkGetPhysicalDeviceSurfaceCapabilities2EXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSurfaceCapabilities2EXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSurfaceCapabilities2EXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSurfaceKHR((*&local_surface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkSurfaceCapabilities2EXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities), streamPtrPtr);
    unmarshal_VkSurfaceCapabilities2EXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
    if (pSurfaceCapabilities)
    {
        transform_fromhost_VkSurfaceCapabilities2EXT(sResourceTracker, (VkSurfaceCapabilities2EXT*)(pSurfaceCapabilities));
    }
    VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceSurfaceCapabilities2EXT_VkResult_return;
}

#endif
#ifdef VK_EXT_display_control
VkResult VkEncoder::vkDisplayPowerControlEXT(
    VkDevice device,
    VkDisplayKHR display,
    const VkDisplayPowerInfoEXT* pDisplayPowerInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDisplayKHR local_display;
    VkDisplayPowerInfoEXT* local_pDisplayPowerInfo;
    local_device = device;
    local_display = display;
    local_pDisplayPowerInfo = nullptr;
    if (pDisplayPowerInfo)
    {
        local_pDisplayPowerInfo = (VkDisplayPowerInfoEXT*)pool->alloc(sizeof(const VkDisplayPowerInfoEXT));
        deepcopy_VkDisplayPowerInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pDisplayPowerInfo, (VkDisplayPowerInfoEXT*)(local_pDisplayPowerInfo));
    }
    if (local_pDisplayPowerInfo)
    {
        transform_tohost_VkDisplayPowerInfoEXT(sResourceTracker, (VkDisplayPowerInfoEXT*)(local_pDisplayPowerInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        count_VkDisplayPowerInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPowerInfoEXT*)(local_pDisplayPowerInfo), countPtr);
    }
    uint32_t packetSize_vkDisplayPowerControlEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDisplayPowerControlEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDisplayPowerControlEXT = OP_vkDisplayPowerControlEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDisplayPowerControlEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDisplayPowerControlEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDisplayKHR((*&local_display));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDisplayPowerInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayPowerInfoEXT*)(local_pDisplayPowerInfo), streamPtrPtr);
    VkResult vkDisplayPowerControlEXT_VkResult_return = (VkResult)0;
    stream->read(&vkDisplayPowerControlEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkDisplayPowerControlEXT_VkResult_return;
}

VkResult VkEncoder::vkRegisterDeviceEventEXT(
    VkDevice device,
    const VkDeviceEventInfoEXT* pDeviceEventInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeviceEventInfoEXT* local_pDeviceEventInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pDeviceEventInfo = nullptr;
    if (pDeviceEventInfo)
    {
        local_pDeviceEventInfo = (VkDeviceEventInfoEXT*)pool->alloc(sizeof(const VkDeviceEventInfoEXT));
        deepcopy_VkDeviceEventInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pDeviceEventInfo, (VkDeviceEventInfoEXT*)(local_pDeviceEventInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pDeviceEventInfo)
    {
        transform_tohost_VkDeviceEventInfoEXT(sResourceTracker, (VkDeviceEventInfoEXT*)(local_pDeviceEventInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDeviceEventInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceEventInfoEXT*)(local_pDeviceEventInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkRegisterDeviceEventEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkRegisterDeviceEventEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkRegisterDeviceEventEXT = OP_vkRegisterDeviceEventEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkRegisterDeviceEventEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkRegisterDeviceEventEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDeviceEventInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDeviceEventInfoEXT*)(local_pDeviceEventInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pFence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_3, (VkFence*)pFence, 1);
    VkResult vkRegisterDeviceEventEXT_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterDeviceEventEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkRegisterDeviceEventEXT_VkResult_return;
}

VkResult VkEncoder::vkRegisterDisplayEventEXT(
    VkDevice device,
    VkDisplayKHR display,
    const VkDisplayEventInfoEXT* pDisplayEventInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence* pFence,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDisplayKHR local_display;
    VkDisplayEventInfoEXT* local_pDisplayEventInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_display = display;
    local_pDisplayEventInfo = nullptr;
    if (pDisplayEventInfo)
    {
        local_pDisplayEventInfo = (VkDisplayEventInfoEXT*)pool->alloc(sizeof(const VkDisplayEventInfoEXT));
        deepcopy_VkDisplayEventInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pDisplayEventInfo, (VkDisplayEventInfoEXT*)(local_pDisplayEventInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pDisplayEventInfo)
    {
        transform_tohost_VkDisplayEventInfoEXT(sResourceTracker, (VkDisplayEventInfoEXT*)(local_pDisplayEventInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        count_VkDisplayEventInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayEventInfoEXT*)(local_pDisplayEventInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_2;
        *countPtr += 8;
    }
    uint32_t packetSize_vkRegisterDisplayEventEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkRegisterDisplayEventEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkRegisterDisplayEventEXT = OP_vkRegisterDisplayEventEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkRegisterDisplayEventEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkRegisterDisplayEventEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDisplayKHR((*&local_display));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDisplayEventInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDisplayEventInfoEXT*)(local_pDisplayEventInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    *&cgen_var_3 = (uint64_t)((*pFence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_3, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_4;
    stream->read((uint64_t*)&cgen_var_4, 8);
    stream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_4, (VkFence*)pFence, 1);
    VkResult vkRegisterDisplayEventEXT_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterDisplayEventEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkRegisterDisplayEventEXT_VkResult_return;
}

VkResult VkEncoder::vkGetSwapchainCounterEXT(
    VkDevice device,
    VkSwapchainKHR swapchain,
    VkSurfaceCounterFlagBitsEXT counter,
    uint64_t* pCounterValue,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    VkSurfaceCounterFlagBitsEXT local_counter;
    local_device = device;
    local_swapchain = swapchain;
    local_counter = counter;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkSurfaceCounterFlagBitsEXT);
        *countPtr += sizeof(uint64_t);
    }
    uint32_t packetSize_vkGetSwapchainCounterEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetSwapchainCounterEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetSwapchainCounterEXT = OP_vkGetSwapchainCounterEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetSwapchainCounterEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetSwapchainCounterEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSwapchainKHR((*&local_swapchain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkSurfaceCounterFlagBitsEXT*)&local_counter, sizeof(VkSurfaceCounterFlagBitsEXT));
    *streamPtrPtr += sizeof(VkSurfaceCounterFlagBitsEXT);
    memcpy(*streamPtrPtr, (uint64_t*)pCounterValue, sizeof(uint64_t));
    *streamPtrPtr += sizeof(uint64_t);
    stream->read((uint64_t*)pCounterValue, sizeof(uint64_t));
    VkResult vkGetSwapchainCounterEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetSwapchainCounterEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetSwapchainCounterEXT_VkResult_return;
}

#endif
#ifdef VK_GOOGLE_display_timing
VkResult VkEncoder::vkGetRefreshCycleDurationGOOGLE(
    VkDevice device,
    VkSwapchainKHR swapchain,
    VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    local_device = device;
    local_swapchain = swapchain;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        count_VkRefreshCycleDurationGOOGLE(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties), countPtr);
    }
    uint32_t packetSize_vkGetRefreshCycleDurationGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetRefreshCycleDurationGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetRefreshCycleDurationGOOGLE = OP_vkGetRefreshCycleDurationGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetRefreshCycleDurationGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetRefreshCycleDurationGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSwapchainKHR((*&local_swapchain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkRefreshCycleDurationGOOGLE(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties), streamPtrPtr);
    unmarshal_VkRefreshCycleDurationGOOGLE(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
    if (pDisplayTimingProperties)
    {
        transform_fromhost_VkRefreshCycleDurationGOOGLE(sResourceTracker, (VkRefreshCycleDurationGOOGLE*)(pDisplayTimingProperties));
    }
    VkResult vkGetRefreshCycleDurationGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkGetRefreshCycleDurationGOOGLE_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetRefreshCycleDurationGOOGLE_VkResult_return;
}

VkResult VkEncoder::vkGetPastPresentationTimingGOOGLE(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t* pPresentationTimingCount,
    VkPastPresentationTimingGOOGLE* pPresentationTimings,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    local_device = device;
    local_swapchain = swapchain;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPresentationTimingCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPresentationTimings)
        {
            if (pPresentationTimingCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
                {
                    count_VkPastPresentationTimingGOOGLE(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPastPresentationTimingGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPastPresentationTimingGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPastPresentationTimingGOOGLE = OP_vkGetPastPresentationTimingGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPastPresentationTimingGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPastPresentationTimingGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSwapchainKHR((*&local_swapchain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pPresentationTimingCount;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPresentationTimingCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pPresentationTimings;
    memcpy((*streamPtrPtr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPresentationTimings)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
        {
            reservedmarshal_VkPastPresentationTimingGOOGLE(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPresentationTimingCount;
    check_pPresentationTimingCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPresentationTimingCount)
    {
        if (!(check_pPresentationTimingCount))
        {
            fprintf(stderr, "fatal: pPresentationTimingCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPresentationTimingCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPastPresentationTimingGOOGLE* check_pPresentationTimings;
    check_pPresentationTimings = (VkPastPresentationTimingGOOGLE*)(uintptr_t)stream->getBe64();
    if (pPresentationTimings)
    {
        if (!(check_pPresentationTimings))
        {
            fprintf(stderr, "fatal: pPresentationTimings inconsistent between guest and host\n");
        }
        if (pPresentationTimingCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
            {
                unmarshal_VkPastPresentationTimingGOOGLE(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
            }
        }
    }
    if (pPresentationTimingCount)
    {
        if (pPresentationTimings)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPresentationTimingCount)); ++i)
            {
                transform_fromhost_VkPastPresentationTimingGOOGLE(sResourceTracker, (VkPastPresentationTimingGOOGLE*)(pPresentationTimings + i));
            }
        }
    }
    VkResult vkGetPastPresentationTimingGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkGetPastPresentationTimingGOOGLE_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPastPresentationTimingGOOGLE_VkResult_return;
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
#endif
#ifdef VK_NV_viewport_swizzle
#endif
#ifdef VK_EXT_discard_rectangles
void VkEncoder::vkCmdSetDiscardRectangleEXT(
    VkCommandBuffer commandBuffer,
    uint32_t firstDiscardRectangle,
    uint32_t discardRectangleCount,
    const VkRect2D* pDiscardRectangles,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstDiscardRectangle;
    uint32_t local_discardRectangleCount;
    VkRect2D* local_pDiscardRectangles;
    local_commandBuffer = commandBuffer;
    local_firstDiscardRectangle = firstDiscardRectangle;
    local_discardRectangleCount = discardRectangleCount;
    local_pDiscardRectangles = nullptr;
    if (pDiscardRectangles)
    {
        local_pDiscardRectangles = (VkRect2D*)pool->alloc(((discardRectangleCount)) * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
        {
            deepcopy_VkRect2D(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pDiscardRectangles + i, (VkRect2D*)(local_pDiscardRectangles + i));
        }
    }
    if (local_pDiscardRectangles)
    {
        for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
        {
            transform_tohost_VkRect2D(sResourceTracker, (VkRect2D*)(local_pDiscardRectangles + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
        {
            count_VkRect2D(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRect2D*)(local_pDiscardRectangles + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdSetDiscardRectangleEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetDiscardRectangleEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetDiscardRectangleEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetDiscardRectangleEXT = OP_vkCmdSetDiscardRectangleEXT;
    memcpy(streamPtr, &opcode_vkCmdSetDiscardRectangleEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetDiscardRectangleEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstDiscardRectangle, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_discardRectangleCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((discardRectangleCount)); ++i)
    {
        reservedmarshal_VkRect2D(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRect2D*)(local_pDiscardRectangles + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_EXT_conservative_rasterization
#endif
#ifdef VK_EXT_depth_clip_enable
#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void VkEncoder::vkSetHdrMetadataEXT(
    VkDevice device,
    uint32_t swapchainCount,
    const VkSwapchainKHR* pSwapchains,
    const VkHdrMetadataEXT* pMetadata,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_swapchainCount;
    VkSwapchainKHR* local_pSwapchains;
    VkHdrMetadataEXT* local_pMetadata;
    local_device = device;
    local_swapchainCount = swapchainCount;
    // Avoiding deepcopy for pSwapchains
    local_pSwapchains = (VkSwapchainKHR*)pSwapchains;
    local_pMetadata = nullptr;
    if (pMetadata)
    {
        local_pMetadata = (VkHdrMetadataEXT*)pool->alloc(((swapchainCount)) * sizeof(const VkHdrMetadataEXT));
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            deepcopy_VkHdrMetadataEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pMetadata + i, (VkHdrMetadataEXT*)(local_pMetadata + i));
        }
    }
    if (local_pMetadata)
    {
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            transform_tohost_VkHdrMetadataEXT(sResourceTracker, (VkHdrMetadataEXT*)(local_pMetadata + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        if (((swapchainCount)))
        {
            *countPtr += ((swapchainCount)) * 8;
        }
        for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
        {
            count_VkHdrMetadataEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkHdrMetadataEXT*)(local_pMetadata + i), countPtr);
        }
    }
    uint32_t packetSize_vkSetHdrMetadataEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkSetHdrMetadataEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkSetHdrMetadataEXT = OP_vkSetHdrMetadataEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkSetHdrMetadataEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkSetHdrMetadataEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_swapchainCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((swapchainCount)))
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((swapchainCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkSwapchainKHR(local_pSwapchains[k]);
            memcpy(cgen_var_1_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((swapchainCount));
    }
    for (uint32_t i = 0; i < (uint32_t)((swapchainCount)); ++i)
    {
        reservedmarshal_VkHdrMetadataEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkHdrMetadataEXT*)(local_pMetadata + i), streamPtrPtr);
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_MVK_ios_surface
VkResult VkEncoder::vkCreateIOSSurfaceMVK(
    VkInstance instance,
    const VkIOSSurfaceCreateInfoMVK* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkIOSSurfaceCreateInfoMVK* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkIOSSurfaceCreateInfoMVK*)pool->alloc(sizeof(const VkIOSSurfaceCreateInfoMVK));
        deepcopy_VkIOSSurfaceCreateInfoMVK(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkIOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkIOSSurfaceCreateInfoMVK(sResourceTracker, (VkIOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkIOSSurfaceCreateInfoMVK(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkIOSSurfaceCreateInfoMVK*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateIOSSurfaceMVK = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateIOSSurfaceMVK);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateIOSSurfaceMVK = OP_vkCreateIOSSurfaceMVK;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateIOSSurfaceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateIOSSurfaceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkIOSSurfaceCreateInfoMVK(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkIOSSurfaceCreateInfoMVK*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_3, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateIOSSurfaceMVK_VkResult_return = (VkResult)0;
    stream->read(&vkCreateIOSSurfaceMVK_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateIOSSurfaceMVK_VkResult_return;
}

#endif
#ifdef VK_MVK_macos_surface
VkResult VkEncoder::vkCreateMacOSSurfaceMVK(
    VkInstance instance,
    const VkMacOSSurfaceCreateInfoMVK* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkMacOSSurfaceCreateInfoMVK* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkMacOSSurfaceCreateInfoMVK*)pool->alloc(sizeof(const VkMacOSSurfaceCreateInfoMVK));
        deepcopy_VkMacOSSurfaceCreateInfoMVK(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkMacOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkMacOSSurfaceCreateInfoMVK(sResourceTracker, (VkMacOSSurfaceCreateInfoMVK*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkMacOSSurfaceCreateInfoMVK(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMacOSSurfaceCreateInfoMVK*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateMacOSSurfaceMVK = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateMacOSSurfaceMVK);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateMacOSSurfaceMVK = OP_vkCreateMacOSSurfaceMVK;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateMacOSSurfaceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateMacOSSurfaceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkMacOSSurfaceCreateInfoMVK(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMacOSSurfaceCreateInfoMVK*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_3, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateMacOSSurfaceMVK_VkResult_return = (VkResult)0;
    stream->read(&vkCreateMacOSSurfaceMVK_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateMacOSSurfaceMVK_VkResult_return;
}

#endif
#ifdef VK_MVK_moltenvk
void VkEncoder::vkGetMTLDeviceMVK(
    VkPhysicalDevice physicalDevice,
    void** pMTLDevice,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(void*);
    }
    uint32_t packetSize_vkGetMTLDeviceMVK = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMTLDeviceMVK);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMTLDeviceMVK = OP_vkGetMTLDeviceMVK;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMTLDeviceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMTLDeviceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (void**)pMTLDevice, sizeof(void*));
    *streamPtrPtr += sizeof(void*);
    stream->read((void**)pMTLDevice, sizeof(void*));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkSetMTLTextureMVK(
    VkImage image,
    void* mtlTexture,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkImage local_image;
    local_image = image;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint8_t);
    }
    uint32_t packetSize_vkSetMTLTextureMVK = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkSetMTLTextureMVK);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkSetMTLTextureMVK = OP_vkSetMTLTextureMVK;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkSetMTLTextureMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkSetMTLTextureMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (void*)mtlTexture, sizeof(uint8_t));
    *streamPtrPtr += sizeof(uint8_t);
    stream->read((void*)mtlTexture, sizeof(uint8_t));
    VkResult vkSetMTLTextureMVK_VkResult_return = (VkResult)0;
    stream->read(&vkSetMTLTextureMVK_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkSetMTLTextureMVK_VkResult_return;
}

void VkEncoder::vkGetMTLTextureMVK(
    VkImage image,
    void** pMTLTexture,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkImage local_image;
    local_image = image;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(void*);
    }
    uint32_t packetSize_vkGetMTLTextureMVK = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMTLTextureMVK);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMTLTextureMVK = OP_vkGetMTLTextureMVK;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMTLTextureMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMTLTextureMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (void**)pMTLTexture, sizeof(void*));
    *streamPtrPtr += sizeof(void*);
    stream->read((void**)pMTLTexture, sizeof(void*));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetMTLBufferMVK(
    VkBuffer buffer,
    void** pMTLBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkBuffer local_buffer;
    local_buffer = buffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(void*);
    }
    uint32_t packetSize_vkGetMTLBufferMVK = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMTLBufferMVK);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMTLBufferMVK = OP_vkGetMTLBufferMVK;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMTLBufferMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMTLBufferMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (void**)pMTLBuffer, sizeof(void*));
    *streamPtrPtr += sizeof(void*);
    stream->read((void**)pMTLBuffer, sizeof(void*));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkUseIOSurfaceMVK(
    VkImage image,
    void* ioSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkImage local_image;
    local_image = image;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint8_t);
    }
    uint32_t packetSize_vkUseIOSurfaceMVK = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkUseIOSurfaceMVK);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkUseIOSurfaceMVK = OP_vkUseIOSurfaceMVK;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkUseIOSurfaceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkUseIOSurfaceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (void*)ioSurface, sizeof(uint8_t));
    *streamPtrPtr += sizeof(uint8_t);
    stream->read((void*)ioSurface, sizeof(uint8_t));
    VkResult vkUseIOSurfaceMVK_VkResult_return = (VkResult)0;
    stream->read(&vkUseIOSurfaceMVK_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkUseIOSurfaceMVK_VkResult_return;
}

void VkEncoder::vkGetIOSurfaceMVK(
    VkImage image,
    void** pIOSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkImage local_image;
    local_image = image;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(void*);
    }
    uint32_t packetSize_vkGetIOSurfaceMVK = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetIOSurfaceMVK);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetIOSurfaceMVK = OP_vkGetIOSurfaceMVK;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetIOSurfaceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetIOSurfaceMVK, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (void**)pIOSurface, sizeof(void*));
    *streamPtrPtr += sizeof(void*);
    stream->read((void**)pIOSurface, sizeof(void*));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
VkResult VkEncoder::vkSetDebugUtilsObjectNameEXT(
    VkDevice device,
    const VkDebugUtilsObjectNameInfoEXT* pNameInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDebugUtilsObjectNameInfoEXT* local_pNameInfo;
    local_device = device;
    local_pNameInfo = nullptr;
    if (pNameInfo)
    {
        local_pNameInfo = (VkDebugUtilsObjectNameInfoEXT*)pool->alloc(sizeof(const VkDebugUtilsObjectNameInfoEXT));
        deepcopy_VkDebugUtilsObjectNameInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pNameInfo, (VkDebugUtilsObjectNameInfoEXT*)(local_pNameInfo));
    }
    if (local_pNameInfo)
    {
        transform_tohost_VkDebugUtilsObjectNameInfoEXT(sResourceTracker, (VkDebugUtilsObjectNameInfoEXT*)(local_pNameInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDebugUtilsObjectNameInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsObjectNameInfoEXT*)(local_pNameInfo), countPtr);
    }
    uint32_t packetSize_vkSetDebugUtilsObjectNameEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkSetDebugUtilsObjectNameEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkSetDebugUtilsObjectNameEXT = OP_vkSetDebugUtilsObjectNameEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkSetDebugUtilsObjectNameEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkSetDebugUtilsObjectNameEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDebugUtilsObjectNameInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsObjectNameInfoEXT*)(local_pNameInfo), streamPtrPtr);
    VkResult vkSetDebugUtilsObjectNameEXT_VkResult_return = (VkResult)0;
    stream->read(&vkSetDebugUtilsObjectNameEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkSetDebugUtilsObjectNameEXT_VkResult_return;
}

VkResult VkEncoder::vkSetDebugUtilsObjectTagEXT(
    VkDevice device,
    const VkDebugUtilsObjectTagInfoEXT* pTagInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDebugUtilsObjectTagInfoEXT* local_pTagInfo;
    local_device = device;
    local_pTagInfo = nullptr;
    if (pTagInfo)
    {
        local_pTagInfo = (VkDebugUtilsObjectTagInfoEXT*)pool->alloc(sizeof(const VkDebugUtilsObjectTagInfoEXT));
        deepcopy_VkDebugUtilsObjectTagInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pTagInfo, (VkDebugUtilsObjectTagInfoEXT*)(local_pTagInfo));
    }
    if (local_pTagInfo)
    {
        transform_tohost_VkDebugUtilsObjectTagInfoEXT(sResourceTracker, (VkDebugUtilsObjectTagInfoEXT*)(local_pTagInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDebugUtilsObjectTagInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsObjectTagInfoEXT*)(local_pTagInfo), countPtr);
    }
    uint32_t packetSize_vkSetDebugUtilsObjectTagEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkSetDebugUtilsObjectTagEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkSetDebugUtilsObjectTagEXT = OP_vkSetDebugUtilsObjectTagEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkSetDebugUtilsObjectTagEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkSetDebugUtilsObjectTagEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDebugUtilsObjectTagInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsObjectTagInfoEXT*)(local_pTagInfo), streamPtrPtr);
    VkResult vkSetDebugUtilsObjectTagEXT_VkResult_return = (VkResult)0;
    stream->read(&vkSetDebugUtilsObjectTagEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkSetDebugUtilsObjectTagEXT_VkResult_return;
}

void VkEncoder::vkQueueBeginDebugUtilsLabelEXT(
    VkQueue queue,
    const VkDebugUtilsLabelEXT* pLabelInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    VkDebugUtilsLabelEXT* local_pLabelInfo;
    local_queue = queue;
    local_pLabelInfo = nullptr;
    if (pLabelInfo)
    {
        local_pLabelInfo = (VkDebugUtilsLabelEXT*)pool->alloc(sizeof(const VkDebugUtilsLabelEXT));
        deepcopy_VkDebugUtilsLabelEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pLabelInfo, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    if (local_pLabelInfo)
    {
        transform_tohost_VkDebugUtilsLabelEXT(sResourceTracker, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDebugUtilsLabelEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsLabelEXT*)(local_pLabelInfo), countPtr);
    }
    uint32_t packetSize_vkQueueBeginDebugUtilsLabelEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueBeginDebugUtilsLabelEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueBeginDebugUtilsLabelEXT = OP_vkQueueBeginDebugUtilsLabelEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueBeginDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueBeginDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDebugUtilsLabelEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsLabelEXT*)(local_pLabelInfo), streamPtrPtr);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkQueueEndDebugUtilsLabelEXT(
    VkQueue queue,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    local_queue = queue;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkQueueEndDebugUtilsLabelEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueEndDebugUtilsLabelEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueEndDebugUtilsLabelEXT = OP_vkQueueEndDebugUtilsLabelEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueEndDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueEndDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkQueueInsertDebugUtilsLabelEXT(
    VkQueue queue,
    const VkDebugUtilsLabelEXT* pLabelInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    VkDebugUtilsLabelEXT* local_pLabelInfo;
    local_queue = queue;
    local_pLabelInfo = nullptr;
    if (pLabelInfo)
    {
        local_pLabelInfo = (VkDebugUtilsLabelEXT*)pool->alloc(sizeof(const VkDebugUtilsLabelEXT));
        deepcopy_VkDebugUtilsLabelEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pLabelInfo, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    if (local_pLabelInfo)
    {
        transform_tohost_VkDebugUtilsLabelEXT(sResourceTracker, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDebugUtilsLabelEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsLabelEXT*)(local_pLabelInfo), countPtr);
    }
    uint32_t packetSize_vkQueueInsertDebugUtilsLabelEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueInsertDebugUtilsLabelEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueInsertDebugUtilsLabelEXT = OP_vkQueueInsertDebugUtilsLabelEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueInsertDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueInsertDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDebugUtilsLabelEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsLabelEXT*)(local_pLabelInfo), streamPtrPtr);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBeginDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugUtilsLabelEXT* pLabelInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkDebugUtilsLabelEXT* local_pLabelInfo;
    local_commandBuffer = commandBuffer;
    local_pLabelInfo = nullptr;
    if (pLabelInfo)
    {
        local_pLabelInfo = (VkDebugUtilsLabelEXT*)pool->alloc(sizeof(const VkDebugUtilsLabelEXT));
        deepcopy_VkDebugUtilsLabelEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pLabelInfo, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    if (local_pLabelInfo)
    {
        transform_tohost_VkDebugUtilsLabelEXT(sResourceTracker, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDebugUtilsLabelEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsLabelEXT*)(local_pLabelInfo), countPtr);
    }
    uint32_t packetSize_vkCmdBeginDebugUtilsLabelEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBeginDebugUtilsLabelEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBeginDebugUtilsLabelEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBeginDebugUtilsLabelEXT = OP_vkCmdBeginDebugUtilsLabelEXT;
    memcpy(streamPtr, &opcode_vkCmdBeginDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBeginDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkDebugUtilsLabelEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsLabelEXT*)(local_pLabelInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdEndDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkCmdEndDebugUtilsLabelEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdEndDebugUtilsLabelEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdEndDebugUtilsLabelEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdEndDebugUtilsLabelEXT = OP_vkCmdEndDebugUtilsLabelEXT;
    memcpy(streamPtr, &opcode_vkCmdEndDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdEndDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdInsertDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer,
    const VkDebugUtilsLabelEXT* pLabelInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkDebugUtilsLabelEXT* local_pLabelInfo;
    local_commandBuffer = commandBuffer;
    local_pLabelInfo = nullptr;
    if (pLabelInfo)
    {
        local_pLabelInfo = (VkDebugUtilsLabelEXT*)pool->alloc(sizeof(const VkDebugUtilsLabelEXT));
        deepcopy_VkDebugUtilsLabelEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pLabelInfo, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    if (local_pLabelInfo)
    {
        transform_tohost_VkDebugUtilsLabelEXT(sResourceTracker, (VkDebugUtilsLabelEXT*)(local_pLabelInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDebugUtilsLabelEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsLabelEXT*)(local_pLabelInfo), countPtr);
    }
    uint32_t packetSize_vkCmdInsertDebugUtilsLabelEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdInsertDebugUtilsLabelEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdInsertDebugUtilsLabelEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdInsertDebugUtilsLabelEXT = OP_vkCmdInsertDebugUtilsLabelEXT;
    memcpy(streamPtr, &opcode_vkCmdInsertDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdInsertDebugUtilsLabelEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkDebugUtilsLabelEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsLabelEXT*)(local_pLabelInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateDebugUtilsMessengerEXT(
    VkInstance instance,
    const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDebugUtilsMessengerEXT* pMessenger,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkDebugUtilsMessengerCreateInfoEXT* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDebugUtilsMessengerCreateInfoEXT*)pool->alloc(sizeof(const VkDebugUtilsMessengerCreateInfoEXT));
        deepcopy_VkDebugUtilsMessengerCreateInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkDebugUtilsMessengerCreateInfoEXT*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDebugUtilsMessengerCreateInfoEXT(sResourceTracker, (VkDebugUtilsMessengerCreateInfoEXT*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDebugUtilsMessengerCreateInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsMessengerCreateInfoEXT*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDebugUtilsMessengerEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDebugUtilsMessengerEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDebugUtilsMessengerEXT = OP_vkCreateDebugUtilsMessengerEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDebugUtilsMessengerEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDebugUtilsMessengerEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDebugUtilsMessengerCreateInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsMessengerCreateInfoEXT*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pMessenger));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkDebugUtilsMessengerEXT(&cgen_var_3, (VkDebugUtilsMessengerEXT*)pMessenger, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateDebugUtilsMessengerEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDebugUtilsMessengerEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDebugUtilsMessengerEXT_VkResult_return;
}

void VkEncoder::vkDestroyDebugUtilsMessengerEXT(
    VkInstance instance,
    VkDebugUtilsMessengerEXT messenger,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkDebugUtilsMessengerEXT local_messenger;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_messenger = messenger;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyDebugUtilsMessengerEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyDebugUtilsMessengerEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyDebugUtilsMessengerEXT = OP_vkDestroyDebugUtilsMessengerEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyDebugUtilsMessengerEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyDebugUtilsMessengerEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDebugUtilsMessengerEXT((*&local_messenger));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkDebugUtilsMessengerEXT((VkDebugUtilsMessengerEXT*)&messenger);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkSubmitDebugUtilsMessageEXT(
    VkInstance instance,
    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT messageTypes,
    const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkDebugUtilsMessageSeverityFlagBitsEXT local_messageSeverity;
    VkDebugUtilsMessageTypeFlagsEXT local_messageTypes;
    VkDebugUtilsMessengerCallbackDataEXT* local_pCallbackData;
    local_instance = instance;
    local_messageSeverity = messageSeverity;
    local_messageTypes = messageTypes;
    local_pCallbackData = nullptr;
    if (pCallbackData)
    {
        local_pCallbackData = (VkDebugUtilsMessengerCallbackDataEXT*)pool->alloc(sizeof(const VkDebugUtilsMessengerCallbackDataEXT));
        deepcopy_VkDebugUtilsMessengerCallbackDataEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCallbackData, (VkDebugUtilsMessengerCallbackDataEXT*)(local_pCallbackData));
    }
    if (local_pCallbackData)
    {
        transform_tohost_VkDebugUtilsMessengerCallbackDataEXT(sResourceTracker, (VkDebugUtilsMessengerCallbackDataEXT*)(local_pCallbackData));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT);
        *countPtr += sizeof(VkDebugUtilsMessageTypeFlagsEXT);
        count_VkDebugUtilsMessengerCallbackDataEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsMessengerCallbackDataEXT*)(local_pCallbackData), countPtr);
    }
    uint32_t packetSize_vkSubmitDebugUtilsMessageEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkSubmitDebugUtilsMessageEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkSubmitDebugUtilsMessageEXT = OP_vkSubmitDebugUtilsMessageEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkSubmitDebugUtilsMessageEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkSubmitDebugUtilsMessageEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDebugUtilsMessageSeverityFlagBitsEXT*)&local_messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT));
    *streamPtrPtr += sizeof(VkDebugUtilsMessageSeverityFlagBitsEXT);
    memcpy(*streamPtrPtr, (VkDebugUtilsMessageTypeFlagsEXT*)&local_messageTypes, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
    *streamPtrPtr += sizeof(VkDebugUtilsMessageTypeFlagsEXT);
    reservedmarshal_VkDebugUtilsMessengerCallbackDataEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDebugUtilsMessengerCallbackDataEXT*)(local_pCallbackData), streamPtrPtr);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
VkResult VkEncoder::vkGetAndroidHardwareBufferPropertiesANDROID(
    VkDevice device,
    const AHardwareBuffer* buffer,
    VkAndroidHardwareBufferPropertiesANDROID* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    AHardwareBuffer* local_buffer;
    local_device = device;
    // Avoiding deepcopy for buffer
    local_buffer = (AHardwareBuffer*)buffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(AHardwareBuffer);
        count_VkAndroidHardwareBufferPropertiesANDROID(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties), countPtr);
    }
    uint32_t packetSize_vkGetAndroidHardwareBufferPropertiesANDROID = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetAndroidHardwareBufferPropertiesANDROID);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetAndroidHardwareBufferPropertiesANDROID = OP_vkGetAndroidHardwareBufferPropertiesANDROID;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetAndroidHardwareBufferPropertiesANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetAndroidHardwareBufferPropertiesANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (AHardwareBuffer*)local_buffer, sizeof(AHardwareBuffer));
    *streamPtrPtr += sizeof(AHardwareBuffer);
    reservedmarshal_VkAndroidHardwareBufferPropertiesANDROID(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties), streamPtrPtr);
    unmarshal_VkAndroidHardwareBufferPropertiesANDROID(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
    if (pProperties)
    {
        transform_fromhost_VkAndroidHardwareBufferPropertiesANDROID(sResourceTracker, (VkAndroidHardwareBufferPropertiesANDROID*)(pProperties));
    }
    VkResult vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetAndroidHardwareBufferPropertiesANDROID_VkResult_return;
}

VkResult VkEncoder::vkGetMemoryAndroidHardwareBufferANDROID(
    VkDevice device,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo,
    AHardwareBuffer** pBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkMemoryGetAndroidHardwareBufferInfoANDROID* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkMemoryGetAndroidHardwareBufferInfoANDROID*)pool->alloc(sizeof(const VkMemoryGetAndroidHardwareBufferInfoANDROID));
        deepcopy_VkMemoryGetAndroidHardwareBufferInfoANDROID(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkMemoryGetAndroidHardwareBufferInfoANDROID(sResourceTracker, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkMemoryGetAndroidHardwareBufferInfoANDROID(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(local_pInfo), countPtr);
        *countPtr += sizeof(AHardwareBuffer*);
    }
    uint32_t packetSize_vkGetMemoryAndroidHardwareBufferANDROID = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMemoryAndroidHardwareBufferANDROID);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMemoryAndroidHardwareBufferANDROID = OP_vkGetMemoryAndroidHardwareBufferANDROID;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMemoryAndroidHardwareBufferANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMemoryAndroidHardwareBufferANDROID, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryGetAndroidHardwareBufferInfoANDROID*)(local_pInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
    *streamPtrPtr += sizeof(AHardwareBuffer*);
    stream->read((AHardwareBuffer**)pBuffer, sizeof(AHardwareBuffer*));
    VkResult vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetMemoryAndroidHardwareBufferANDROID_VkResult_return;
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_inline_uniform_block
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void VkEncoder::vkCmdSetSampleLocationsEXT(
    VkCommandBuffer commandBuffer,
    const VkSampleLocationsInfoEXT* pSampleLocationsInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkSampleLocationsInfoEXT* local_pSampleLocationsInfo;
    local_commandBuffer = commandBuffer;
    local_pSampleLocationsInfo = nullptr;
    if (pSampleLocationsInfo)
    {
        local_pSampleLocationsInfo = (VkSampleLocationsInfoEXT*)pool->alloc(sizeof(const VkSampleLocationsInfoEXT));
        deepcopy_VkSampleLocationsInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pSampleLocationsInfo, (VkSampleLocationsInfoEXT*)(local_pSampleLocationsInfo));
    }
    if (local_pSampleLocationsInfo)
    {
        transform_tohost_VkSampleLocationsInfoEXT(sResourceTracker, (VkSampleLocationsInfoEXT*)(local_pSampleLocationsInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkSampleLocationsInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSampleLocationsInfoEXT*)(local_pSampleLocationsInfo), countPtr);
    }
    uint32_t packetSize_vkCmdSetSampleLocationsEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetSampleLocationsEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetSampleLocationsEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetSampleLocationsEXT = OP_vkCmdSetSampleLocationsEXT;
    memcpy(streamPtr, &opcode_vkCmdSetSampleLocationsEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetSampleLocationsEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkSampleLocationsInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSampleLocationsInfoEXT*)(local_pSampleLocationsInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetPhysicalDeviceMultisamplePropertiesEXT(
    VkPhysicalDevice physicalDevice,
    VkSampleCountFlagBits samples,
    VkMultisamplePropertiesEXT* pMultisampleProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkSampleCountFlagBits local_samples;
    local_physicalDevice = physicalDevice;
    local_samples = samples;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkSampleCountFlagBits);
        count_VkMultisamplePropertiesEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMultisamplePropertiesEXT*)(pMultisampleProperties), countPtr);
    }
    uint32_t packetSize_vkGetPhysicalDeviceMultisamplePropertiesEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceMultisamplePropertiesEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceMultisamplePropertiesEXT = OP_vkGetPhysicalDeviceMultisamplePropertiesEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceMultisamplePropertiesEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceMultisamplePropertiesEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkSampleCountFlagBits*)&local_samples, sizeof(VkSampleCountFlagBits));
    *streamPtrPtr += sizeof(VkSampleCountFlagBits);
    reservedmarshal_VkMultisamplePropertiesEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMultisamplePropertiesEXT*)(pMultisampleProperties), streamPtrPtr);
    unmarshal_VkMultisamplePropertiesEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
    if (pMultisampleProperties)
    {
        transform_fromhost_VkMultisamplePropertiesEXT(sResourceTracker, (VkMultisamplePropertiesEXT*)(pMultisampleProperties));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_EXT_blend_operation_advanced
#endif
#ifdef VK_NV_fragment_coverage_to_color
#endif
#ifdef VK_NV_framebuffer_mixed_samples
#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_NV_shader_sm_builtins
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_image_drm_format_modifier
VkResult VkEncoder::vkGetImageDrmFormatModifierPropertiesEXT(
    VkDevice device,
    VkImage image,
    VkImageDrmFormatModifierPropertiesEXT* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImage local_image;
    local_device = device;
    local_image = image;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        count_VkImageDrmFormatModifierPropertiesEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageDrmFormatModifierPropertiesEXT*)(pProperties), countPtr);
    }
    uint32_t packetSize_vkGetImageDrmFormatModifierPropertiesEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetImageDrmFormatModifierPropertiesEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetImageDrmFormatModifierPropertiesEXT = OP_vkGetImageDrmFormatModifierPropertiesEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetImageDrmFormatModifierPropertiesEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetImageDrmFormatModifierPropertiesEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageDrmFormatModifierPropertiesEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageDrmFormatModifierPropertiesEXT*)(pProperties), streamPtrPtr);
    unmarshal_VkImageDrmFormatModifierPropertiesEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageDrmFormatModifierPropertiesEXT*)(pProperties));
    if (pProperties)
    {
        transform_fromhost_VkImageDrmFormatModifierPropertiesEXT(sResourceTracker, (VkImageDrmFormatModifierPropertiesEXT*)(pProperties));
    }
    VkResult vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetImageDrmFormatModifierPropertiesEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_validation_cache
VkResult VkEncoder::vkCreateValidationCacheEXT(
    VkDevice device,
    const VkValidationCacheCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkValidationCacheEXT* pValidationCache,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkValidationCacheCreateInfoEXT* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkValidationCacheCreateInfoEXT*)pool->alloc(sizeof(const VkValidationCacheCreateInfoEXT));
        deepcopy_VkValidationCacheCreateInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkValidationCacheCreateInfoEXT*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkValidationCacheCreateInfoEXT(sResourceTracker, (VkValidationCacheCreateInfoEXT*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkValidationCacheCreateInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkValidationCacheCreateInfoEXT*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateValidationCacheEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateValidationCacheEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateValidationCacheEXT = OP_vkCreateValidationCacheEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateValidationCacheEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateValidationCacheEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkValidationCacheCreateInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkValidationCacheCreateInfoEXT*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pValidationCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(&cgen_var_3, (VkValidationCacheEXT*)pValidationCache, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateValidationCacheEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreateValidationCacheEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateValidationCacheEXT_VkResult_return;
}

void VkEncoder::vkDestroyValidationCacheEXT(
    VkDevice device,
    VkValidationCacheEXT validationCache,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkValidationCacheEXT local_validationCache;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_validationCache = validationCache;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyValidationCacheEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyValidationCacheEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyValidationCacheEXT = OP_vkDestroyValidationCacheEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyValidationCacheEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyValidationCacheEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkValidationCacheEXT((*&local_validationCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkValidationCacheEXT((VkValidationCacheEXT*)&validationCache);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkMergeValidationCachesEXT(
    VkDevice device,
    VkValidationCacheEXT dstCache,
    uint32_t srcCacheCount,
    const VkValidationCacheEXT* pSrcCaches,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkValidationCacheEXT local_dstCache;
    uint32_t local_srcCacheCount;
    VkValidationCacheEXT* local_pSrcCaches;
    local_device = device;
    local_dstCache = dstCache;
    local_srcCacheCount = srcCacheCount;
    // Avoiding deepcopy for pSrcCaches
    local_pSrcCaches = (VkValidationCacheEXT*)pSrcCaches;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        if (((srcCacheCount)))
        {
            *countPtr += ((srcCacheCount)) * 8;
        }
    }
    uint32_t packetSize_vkMergeValidationCachesEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkMergeValidationCachesEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkMergeValidationCachesEXT = OP_vkMergeValidationCachesEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkMergeValidationCachesEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkMergeValidationCachesEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkValidationCacheEXT((*&local_dstCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_srcCacheCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((srcCacheCount)))
    {
        uint8_t* cgen_var_2_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((srcCacheCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkValidationCacheEXT(local_pSrcCaches[k]);
            memcpy(cgen_var_2_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((srcCacheCount));
    }
    VkResult vkMergeValidationCachesEXT_VkResult_return = (VkResult)0;
    stream->read(&vkMergeValidationCachesEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkMergeValidationCachesEXT_VkResult_return;
}

VkResult VkEncoder::vkGetValidationCacheDataEXT(
    VkDevice device,
    VkValidationCacheEXT validationCache,
    size_t* pDataSize,
    void* pData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkValidationCacheEXT local_validationCache;
    local_device = device;
    local_validationCache = validationCache;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pDataSize)
        {
            *countPtr += 8;
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pData)
        {
            if (pDataSize)
            {
                *countPtr += (*(pDataSize)) * sizeof(uint8_t);
            }
        }
    }
    uint32_t packetSize_vkGetValidationCacheDataEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetValidationCacheDataEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetValidationCacheDataEXT = OP_vkGetValidationCacheDataEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetValidationCacheDataEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetValidationCacheDataEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkValidationCacheEXT((*&local_validationCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pDataSize;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pDataSize)
    {
        uint64_t cgen_var_2_0 = (uint64_t)(*pDataSize);
        memcpy((*streamPtrPtr), &cgen_var_2_0, 8);
        android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
        *streamPtrPtr += 8;
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pData;
    memcpy((*streamPtrPtr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pData)
    {
        memcpy(*streamPtrPtr, (void*)pData, (*(pDataSize)) * sizeof(uint8_t));
        *streamPtrPtr += (*(pDataSize)) * sizeof(uint8_t);
    }
    // WARNING PTR CHECK
    size_t* check_pDataSize;
    check_pDataSize = (size_t*)(uintptr_t)stream->getBe64();
    if (pDataSize)
    {
        if (!(check_pDataSize))
        {
            fprintf(stderr, "fatal: pDataSize inconsistent between guest and host\n");
        }
        (*pDataSize) = (size_t)stream->getBe64();
    }
    // WARNING PTR CHECK
    void* check_pData;
    check_pData = (void*)(uintptr_t)stream->getBe64();
    if (pData)
    {
        if (!(check_pData))
        {
            fprintf(stderr, "fatal: pData inconsistent between guest and host\n");
        }
        stream->read((void*)pData, (*(pDataSize)) * sizeof(uint8_t));
    }
    VkResult vkGetValidationCacheDataEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetValidationCacheDataEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetValidationCacheDataEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_NV_shading_rate_image
void VkEncoder::vkCmdBindShadingRateImageNV(
    VkCommandBuffer commandBuffer,
    VkImageView imageView,
    VkImageLayout imageLayout,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkImageView local_imageView;
    VkImageLayout local_imageLayout;
    local_commandBuffer = commandBuffer;
    local_imageView = imageView;
    local_imageLayout = imageLayout;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkImageLayout);
    }
    uint32_t packetSize_vkCmdBindShadingRateImageNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBindShadingRateImageNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBindShadingRateImageNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBindShadingRateImageNV = OP_vkCmdBindShadingRateImageNV;
    memcpy(streamPtr, &opcode_vkCmdBindShadingRateImageNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBindShadingRateImageNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkImageView((*&local_imageView));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkImageLayout*)&local_imageLayout, sizeof(VkImageLayout));
    *streamPtrPtr += sizeof(VkImageLayout);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetViewportShadingRatePaletteNV(
    VkCommandBuffer commandBuffer,
    uint32_t firstViewport,
    uint32_t viewportCount,
    const VkShadingRatePaletteNV* pShadingRatePalettes,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstViewport;
    uint32_t local_viewportCount;
    VkShadingRatePaletteNV* local_pShadingRatePalettes;
    local_commandBuffer = commandBuffer;
    local_firstViewport = firstViewport;
    local_viewportCount = viewportCount;
    local_pShadingRatePalettes = nullptr;
    if (pShadingRatePalettes)
    {
        local_pShadingRatePalettes = (VkShadingRatePaletteNV*)pool->alloc(((viewportCount)) * sizeof(const VkShadingRatePaletteNV));
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            deepcopy_VkShadingRatePaletteNV(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pShadingRatePalettes + i, (VkShadingRatePaletteNV*)(local_pShadingRatePalettes + i));
        }
    }
    if (local_pShadingRatePalettes)
    {
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            transform_tohost_VkShadingRatePaletteNV(sResourceTracker, (VkShadingRatePaletteNV*)(local_pShadingRatePalettes + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            count_VkShadingRatePaletteNV(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkShadingRatePaletteNV*)(local_pShadingRatePalettes + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdSetViewportShadingRatePaletteNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetViewportShadingRatePaletteNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetViewportShadingRatePaletteNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetViewportShadingRatePaletteNV = OP_vkCmdSetViewportShadingRatePaletteNV;
    memcpy(streamPtr, &opcode_vkCmdSetViewportShadingRatePaletteNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetViewportShadingRatePaletteNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstViewport, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_viewportCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
    {
        reservedmarshal_VkShadingRatePaletteNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkShadingRatePaletteNV*)(local_pShadingRatePalettes + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetCoarseSampleOrderNV(
    VkCommandBuffer commandBuffer,
    VkCoarseSampleOrderTypeNV sampleOrderType,
    uint32_t customSampleOrderCount,
    const VkCoarseSampleOrderCustomNV* pCustomSampleOrders,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCoarseSampleOrderTypeNV local_sampleOrderType;
    uint32_t local_customSampleOrderCount;
    VkCoarseSampleOrderCustomNV* local_pCustomSampleOrders;
    local_commandBuffer = commandBuffer;
    local_sampleOrderType = sampleOrderType;
    local_customSampleOrderCount = customSampleOrderCount;
    local_pCustomSampleOrders = nullptr;
    if (pCustomSampleOrders)
    {
        local_pCustomSampleOrders = (VkCoarseSampleOrderCustomNV*)pool->alloc(((customSampleOrderCount)) * sizeof(const VkCoarseSampleOrderCustomNV));
        for (uint32_t i = 0; i < (uint32_t)((customSampleOrderCount)); ++i)
        {
            deepcopy_VkCoarseSampleOrderCustomNV(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCustomSampleOrders + i, (VkCoarseSampleOrderCustomNV*)(local_pCustomSampleOrders + i));
        }
    }
    if (local_pCustomSampleOrders)
    {
        for (uint32_t i = 0; i < (uint32_t)((customSampleOrderCount)); ++i)
        {
            transform_tohost_VkCoarseSampleOrderCustomNV(sResourceTracker, (VkCoarseSampleOrderCustomNV*)(local_pCustomSampleOrders + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkCoarseSampleOrderTypeNV);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((customSampleOrderCount)); ++i)
        {
            count_VkCoarseSampleOrderCustomNV(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCoarseSampleOrderCustomNV*)(local_pCustomSampleOrders + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdSetCoarseSampleOrderNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetCoarseSampleOrderNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetCoarseSampleOrderNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetCoarseSampleOrderNV = OP_vkCmdSetCoarseSampleOrderNV;
    memcpy(streamPtr, &opcode_vkCmdSetCoarseSampleOrderNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetCoarseSampleOrderNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkCoarseSampleOrderTypeNV*)&local_sampleOrderType, sizeof(VkCoarseSampleOrderTypeNV));
    *streamPtrPtr += sizeof(VkCoarseSampleOrderTypeNV);
    memcpy(*streamPtrPtr, (uint32_t*)&local_customSampleOrderCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((customSampleOrderCount)); ++i)
    {
        reservedmarshal_VkCoarseSampleOrderCustomNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCoarseSampleOrderCustomNV*)(local_pCustomSampleOrders + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_NV_ray_tracing
VkResult VkEncoder::vkCreateAccelerationStructureNV(
    VkDevice device,
    const VkAccelerationStructureCreateInfoNV* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkAccelerationStructureNV* pAccelerationStructure,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkAccelerationStructureCreateInfoNV* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkAccelerationStructureCreateInfoNV*)pool->alloc(sizeof(const VkAccelerationStructureCreateInfoNV));
        deepcopy_VkAccelerationStructureCreateInfoNV(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkAccelerationStructureCreateInfoNV*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkAccelerationStructureCreateInfoNV(sResourceTracker, (VkAccelerationStructureCreateInfoNV*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkAccelerationStructureCreateInfoNV(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureCreateInfoNV*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateAccelerationStructureNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateAccelerationStructureNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateAccelerationStructureNV = OP_vkCreateAccelerationStructureNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateAccelerationStructureNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateAccelerationStructureNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkAccelerationStructureCreateInfoNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureCreateInfoNV*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pAccelerationStructure));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkAccelerationStructureNV(&cgen_var_3, (VkAccelerationStructureNV*)pAccelerationStructure, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateAccelerationStructureNV_VkResult_return = (VkResult)0;
    stream->read(&vkCreateAccelerationStructureNV_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateAccelerationStructureNV_VkResult_return;
}

void VkEncoder::vkDestroyAccelerationStructureNV(
    VkDevice device,
    VkAccelerationStructureNV accelerationStructure,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkAccelerationStructureNV local_accelerationStructure;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_accelerationStructure = accelerationStructure;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyAccelerationStructureNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyAccelerationStructureNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyAccelerationStructureNV = OP_vkDestroyAccelerationStructureNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyAccelerationStructureNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyAccelerationStructureNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkAccelerationStructureNV((*&local_accelerationStructure));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkAccelerationStructureNV((VkAccelerationStructureNV*)&accelerationStructure);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetAccelerationStructureMemoryRequirementsNV(
    VkDevice device,
    const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo,
    VkMemoryRequirements2KHR* pMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkAccelerationStructureMemoryRequirementsInfoNV* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkAccelerationStructureMemoryRequirementsInfoNV*)pool->alloc(sizeof(const VkAccelerationStructureMemoryRequirementsInfoNV));
        deepcopy_VkAccelerationStructureMemoryRequirementsInfoNV(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkAccelerationStructureMemoryRequirementsInfoNV*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkAccelerationStructureMemoryRequirementsInfoNV(sResourceTracker, (VkAccelerationStructureMemoryRequirementsInfoNV*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkAccelerationStructureMemoryRequirementsInfoNV(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureMemoryRequirementsInfoNV*)(local_pInfo), countPtr);
        count_VkMemoryRequirements2KHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2KHR*)(pMemoryRequirements), countPtr);
    }
    uint32_t packetSize_vkGetAccelerationStructureMemoryRequirementsNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetAccelerationStructureMemoryRequirementsNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetAccelerationStructureMemoryRequirementsNV = OP_vkGetAccelerationStructureMemoryRequirementsNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetAccelerationStructureMemoryRequirementsNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetAccelerationStructureMemoryRequirementsNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkAccelerationStructureMemoryRequirementsInfoNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureMemoryRequirementsInfoNV*)(local_pInfo), streamPtrPtr);
    reservedmarshal_VkMemoryRequirements2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2KHR*)(pMemoryRequirements), streamPtrPtr);
    unmarshal_VkMemoryRequirements2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2KHR*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements2KHR(sResourceTracker, (VkMemoryRequirements2KHR*)(pMemoryRequirements));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkBindAccelerationStructureMemoryNV(
    VkDevice device,
    uint32_t bindInfoCount,
    const VkBindAccelerationStructureMemoryInfoNV* pBindInfos,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_bindInfoCount;
    VkBindAccelerationStructureMemoryInfoNV* local_pBindInfos;
    local_device = device;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfos = nullptr;
    if (pBindInfos)
    {
        local_pBindInfos = (VkBindAccelerationStructureMemoryInfoNV*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindAccelerationStructureMemoryInfoNV));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindAccelerationStructureMemoryInfoNV(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pBindInfos + i, (VkBindAccelerationStructureMemoryInfoNV*)(local_pBindInfos + i));
        }
    }
    if (local_pBindInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindAccelerationStructureMemoryInfoNV(sResourceTracker, (VkBindAccelerationStructureMemoryInfoNV*)(local_pBindInfos + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            count_VkBindAccelerationStructureMemoryInfoNV(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindAccelerationStructureMemoryInfoNV*)(local_pBindInfos + i), countPtr);
        }
    }
    uint32_t packetSize_vkBindAccelerationStructureMemoryNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkBindAccelerationStructureMemoryNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkBindAccelerationStructureMemoryNV = OP_vkBindAccelerationStructureMemoryNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkBindAccelerationStructureMemoryNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkBindAccelerationStructureMemoryNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        reservedmarshal_VkBindAccelerationStructureMemoryInfoNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindAccelerationStructureMemoryInfoNV*)(local_pBindInfos + i), streamPtrPtr);
    }
    VkResult vkBindAccelerationStructureMemoryNV_VkResult_return = (VkResult)0;
    stream->read(&vkBindAccelerationStructureMemoryNV_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkBindAccelerationStructureMemoryNV_VkResult_return;
}

void VkEncoder::vkCmdBuildAccelerationStructureNV(
    VkCommandBuffer commandBuffer,
    const VkAccelerationStructureInfoNV* pInfo,
    VkBuffer instanceData,
    VkDeviceSize instanceOffset,
    VkBool32 update,
    VkAccelerationStructureNV dst,
    VkAccelerationStructureNV src,
    VkBuffer scratch,
    VkDeviceSize scratchOffset,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkAccelerationStructureInfoNV* local_pInfo;
    VkBuffer local_instanceData;
    VkDeviceSize local_instanceOffset;
    VkBool32 local_update;
    VkAccelerationStructureNV local_dst;
    VkAccelerationStructureNV local_src;
    VkBuffer local_scratch;
    VkDeviceSize local_scratchOffset;
    local_commandBuffer = commandBuffer;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkAccelerationStructureInfoNV*)pool->alloc(sizeof(const VkAccelerationStructureInfoNV));
        deepcopy_VkAccelerationStructureInfoNV(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkAccelerationStructureInfoNV*)(local_pInfo));
    }
    local_instanceData = instanceData;
    local_instanceOffset = instanceOffset;
    local_update = update;
    local_dst = dst;
    local_src = src;
    local_scratch = scratch;
    local_scratchOffset = scratchOffset;
    if (local_pInfo)
    {
        transform_tohost_VkAccelerationStructureInfoNV(sResourceTracker, (VkAccelerationStructureInfoNV*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkAccelerationStructureInfoNV(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureInfoNV*)(local_pInfo), countPtr);
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(VkBool32);
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        uint64_t cgen_var_3;
        *countPtr += 1 * 8;
        uint64_t cgen_var_4;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
    }
    uint32_t packetSize_vkCmdBuildAccelerationStructureNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBuildAccelerationStructureNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBuildAccelerationStructureNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBuildAccelerationStructureNV = OP_vkCmdBuildAccelerationStructureNV;
    memcpy(streamPtr, &opcode_vkCmdBuildAccelerationStructureNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBuildAccelerationStructureNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkAccelerationStructureInfoNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureInfoNV*)(local_pInfo), streamPtrPtr);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_instanceData));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_instanceOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (VkBool32*)&local_update, sizeof(VkBool32));
    *streamPtrPtr += sizeof(VkBool32);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkAccelerationStructureNV((*&local_dst));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_2;
    *&cgen_var_2 = get_host_u64_VkAccelerationStructureNV((*&local_src));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_3;
    *&cgen_var_3 = get_host_u64_VkBuffer((*&local_scratch));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_3, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_scratchOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdCopyAccelerationStructureNV(
    VkCommandBuffer commandBuffer,
    VkAccelerationStructureNV dst,
    VkAccelerationStructureNV src,
    VkCopyAccelerationStructureModeKHR mode,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkAccelerationStructureNV local_dst;
    VkAccelerationStructureNV local_src;
    VkCopyAccelerationStructureModeKHR local_mode;
    local_commandBuffer = commandBuffer;
    local_dst = dst;
    local_src = src;
    local_mode = mode;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkCopyAccelerationStructureModeKHR);
    }
    uint32_t packetSize_vkCmdCopyAccelerationStructureNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdCopyAccelerationStructureNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdCopyAccelerationStructureNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdCopyAccelerationStructureNV = OP_vkCmdCopyAccelerationStructureNV;
    memcpy(streamPtr, &opcode_vkCmdCopyAccelerationStructureNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdCopyAccelerationStructureNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkAccelerationStructureNV((*&local_dst));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkAccelerationStructureNV((*&local_src));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkCopyAccelerationStructureModeKHR*)&local_mode, sizeof(VkCopyAccelerationStructureModeKHR));
    *streamPtrPtr += sizeof(VkCopyAccelerationStructureModeKHR);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdTraceRaysNV(
    VkCommandBuffer commandBuffer,
    VkBuffer raygenShaderBindingTableBuffer,
    VkDeviceSize raygenShaderBindingOffset,
    VkBuffer missShaderBindingTableBuffer,
    VkDeviceSize missShaderBindingOffset,
    VkDeviceSize missShaderBindingStride,
    VkBuffer hitShaderBindingTableBuffer,
    VkDeviceSize hitShaderBindingOffset,
    VkDeviceSize hitShaderBindingStride,
    VkBuffer callableShaderBindingTableBuffer,
    VkDeviceSize callableShaderBindingOffset,
    VkDeviceSize callableShaderBindingStride,
    uint32_t width,
    uint32_t height,
    uint32_t depth,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_raygenShaderBindingTableBuffer;
    VkDeviceSize local_raygenShaderBindingOffset;
    VkBuffer local_missShaderBindingTableBuffer;
    VkDeviceSize local_missShaderBindingOffset;
    VkDeviceSize local_missShaderBindingStride;
    VkBuffer local_hitShaderBindingTableBuffer;
    VkDeviceSize local_hitShaderBindingOffset;
    VkDeviceSize local_hitShaderBindingStride;
    VkBuffer local_callableShaderBindingTableBuffer;
    VkDeviceSize local_callableShaderBindingOffset;
    VkDeviceSize local_callableShaderBindingStride;
    uint32_t local_width;
    uint32_t local_height;
    uint32_t local_depth;
    local_commandBuffer = commandBuffer;
    local_raygenShaderBindingTableBuffer = raygenShaderBindingTableBuffer;
    local_raygenShaderBindingOffset = raygenShaderBindingOffset;
    local_missShaderBindingTableBuffer = missShaderBindingTableBuffer;
    local_missShaderBindingOffset = missShaderBindingOffset;
    local_missShaderBindingStride = missShaderBindingStride;
    local_hitShaderBindingTableBuffer = hitShaderBindingTableBuffer;
    local_hitShaderBindingOffset = hitShaderBindingOffset;
    local_hitShaderBindingStride = hitShaderBindingStride;
    local_callableShaderBindingTableBuffer = callableShaderBindingTableBuffer;
    local_callableShaderBindingOffset = callableShaderBindingOffset;
    local_callableShaderBindingStride = callableShaderBindingStride;
    local_width = width;
    local_height = height;
    local_depth = depth;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(VkDeviceSize);
        uint64_t cgen_var_3;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(VkDeviceSize);
        uint64_t cgen_var_4;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdTraceRaysNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdTraceRaysNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdTraceRaysNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdTraceRaysNV = OP_vkCmdTraceRaysNV;
    memcpy(streamPtr, &opcode_vkCmdTraceRaysNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdTraceRaysNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_raygenShaderBindingTableBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_raygenShaderBindingOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&local_missShaderBindingTableBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_missShaderBindingOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_missShaderBindingStride, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    uint64_t cgen_var_2;
    *&cgen_var_2 = get_host_u64_VkBuffer((*&local_hitShaderBindingTableBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_hitShaderBindingOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_hitShaderBindingStride, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    uint64_t cgen_var_3;
    *&cgen_var_3 = get_host_u64_VkBuffer((*&local_callableShaderBindingTableBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_3, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_callableShaderBindingOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_callableShaderBindingStride, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_width, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_height, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_depth, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateRayTracingPipelinesNV(
    VkDevice device,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkRayTracingPipelineCreateInfoNV* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipelineCache local_pipelineCache;
    uint32_t local_createInfoCount;
    VkRayTracingPipelineCreateInfoNV* local_pCreateInfos;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pipelineCache = pipelineCache;
    local_createInfoCount = createInfoCount;
    local_pCreateInfos = nullptr;
    if (pCreateInfos)
    {
        local_pCreateInfos = (VkRayTracingPipelineCreateInfoNV*)pool->alloc(((createInfoCount)) * sizeof(const VkRayTracingPipelineCreateInfoNV));
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            deepcopy_VkRayTracingPipelineCreateInfoNV(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfos + i, (VkRayTracingPipelineCreateInfoNV*)(local_pCreateInfos + i));
        }
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            transform_tohost_VkRayTracingPipelineCreateInfoNV(sResourceTracker, (VkRayTracingPipelineCreateInfoNV*)(local_pCreateInfos + i));
        }
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            count_VkRayTracingPipelineCreateInfoNV(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRayTracingPipelineCreateInfoNV*)(local_pCreateInfos + i), countPtr);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        if (((createInfoCount)))
        {
            *countPtr += ((createInfoCount)) * 8;
        }
    }
    uint32_t packetSize_vkCreateRayTracingPipelinesNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateRayTracingPipelinesNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateRayTracingPipelinesNV = OP_vkCreateRayTracingPipelinesNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateRayTracingPipelinesNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateRayTracingPipelinesNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkPipelineCache((*&local_pipelineCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_createInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
    {
        reservedmarshal_VkRayTracingPipelineCreateInfoNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRayTracingPipelineCreateInfoNV*)(local_pCreateInfos + i), streamPtrPtr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    if (((createInfoCount)))
    {
        uint8_t* cgen_var_3_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((createInfoCount)); ++k)
        {
            uint64_t tmpval = (uint64_t)(pPipelines[k]);
            memcpy(cgen_var_3_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((createInfoCount));
    }
    /* is handle, possibly out */;
    if (((createInfoCount)))
    {
        uint64_t* cgen_var_4;
        stream->alloc((void**)&cgen_var_4, ((createInfoCount)) * 8);
        stream->read((uint64_t*)cgen_var_4, ((createInfoCount)) * 8);
        stream->handleMapping()->mapHandles_u64_VkPipeline(cgen_var_4, (VkPipeline*)pPipelines, ((createInfoCount)));
    }
    VkResult vkCreateRayTracingPipelinesNV_VkResult_return = (VkResult)0;
    stream->read(&vkCreateRayTracingPipelinesNV_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateRayTracingPipelinesNV_VkResult_return;
}

VkResult VkEncoder::vkGetRayTracingShaderGroupHandlesKHR(
    VkDevice device,
    VkPipeline pipeline,
    uint32_t firstGroup,
    uint32_t groupCount,
    size_t dataSize,
    void* pData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipeline local_pipeline;
    uint32_t local_firstGroup;
    uint32_t local_groupCount;
    size_t local_dataSize;
    local_device = device;
    local_pipeline = pipeline;
    local_firstGroup = firstGroup;
    local_groupCount = groupCount;
    local_dataSize = dataSize;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += 8;
        *countPtr += ((dataSize)) * sizeof(uint8_t);
    }
    uint32_t packetSize_vkGetRayTracingShaderGroupHandlesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetRayTracingShaderGroupHandlesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetRayTracingShaderGroupHandlesKHR = OP_vkGetRayTracingShaderGroupHandlesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetRayTracingShaderGroupHandlesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetRayTracingShaderGroupHandlesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkPipeline((*&local_pipeline));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstGroup, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    uint64_t cgen_var_2 = (uint64_t)local_dataSize;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    memcpy(*streamPtrPtr, (void*)pData, ((dataSize)) * sizeof(uint8_t));
    *streamPtrPtr += ((dataSize)) * sizeof(uint8_t);
    stream->read((void*)pData, ((dataSize)) * sizeof(uint8_t));
    VkResult vkGetRayTracingShaderGroupHandlesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetRayTracingShaderGroupHandlesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetRayTracingShaderGroupHandlesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetRayTracingShaderGroupHandlesNV(
    VkDevice device,
    VkPipeline pipeline,
    uint32_t firstGroup,
    uint32_t groupCount,
    size_t dataSize,
    void* pData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipeline local_pipeline;
    uint32_t local_firstGroup;
    uint32_t local_groupCount;
    size_t local_dataSize;
    local_device = device;
    local_pipeline = pipeline;
    local_firstGroup = firstGroup;
    local_groupCount = groupCount;
    local_dataSize = dataSize;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += 8;
        *countPtr += ((dataSize)) * sizeof(uint8_t);
    }
    uint32_t packetSize_vkGetRayTracingShaderGroupHandlesNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetRayTracingShaderGroupHandlesNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetRayTracingShaderGroupHandlesNV = OP_vkGetRayTracingShaderGroupHandlesNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetRayTracingShaderGroupHandlesNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetRayTracingShaderGroupHandlesNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkPipeline((*&local_pipeline));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstGroup, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    uint64_t cgen_var_2 = (uint64_t)local_dataSize;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    memcpy(*streamPtrPtr, (void*)pData, ((dataSize)) * sizeof(uint8_t));
    *streamPtrPtr += ((dataSize)) * sizeof(uint8_t);
    stream->read((void*)pData, ((dataSize)) * sizeof(uint8_t));
    VkResult vkGetRayTracingShaderGroupHandlesNV_VkResult_return = (VkResult)0;
    stream->read(&vkGetRayTracingShaderGroupHandlesNV_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetRayTracingShaderGroupHandlesNV_VkResult_return;
}

VkResult VkEncoder::vkGetAccelerationStructureHandleNV(
    VkDevice device,
    VkAccelerationStructureNV accelerationStructure,
    size_t dataSize,
    void* pData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkAccelerationStructureNV local_accelerationStructure;
    size_t local_dataSize;
    local_device = device;
    local_accelerationStructure = accelerationStructure;
    local_dataSize = dataSize;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += 8;
        *countPtr += ((dataSize)) * sizeof(uint8_t);
    }
    uint32_t packetSize_vkGetAccelerationStructureHandleNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetAccelerationStructureHandleNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetAccelerationStructureHandleNV = OP_vkGetAccelerationStructureHandleNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetAccelerationStructureHandleNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetAccelerationStructureHandleNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkAccelerationStructureNV((*&local_accelerationStructure));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_2 = (uint64_t)local_dataSize;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    memcpy(*streamPtrPtr, (void*)pData, ((dataSize)) * sizeof(uint8_t));
    *streamPtrPtr += ((dataSize)) * sizeof(uint8_t);
    stream->read((void*)pData, ((dataSize)) * sizeof(uint8_t));
    VkResult vkGetAccelerationStructureHandleNV_VkResult_return = (VkResult)0;
    stream->read(&vkGetAccelerationStructureHandleNV_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetAccelerationStructureHandleNV_VkResult_return;
}

void VkEncoder::vkCmdWriteAccelerationStructuresPropertiesNV(
    VkCommandBuffer commandBuffer,
    uint32_t accelerationStructureCount,
    const VkAccelerationStructureNV* pAccelerationStructures,
    VkQueryType queryType,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_accelerationStructureCount;
    VkAccelerationStructureNV* local_pAccelerationStructures;
    VkQueryType local_queryType;
    VkQueryPool local_queryPool;
    uint32_t local_firstQuery;
    local_commandBuffer = commandBuffer;
    local_accelerationStructureCount = accelerationStructureCount;
    // Avoiding deepcopy for pAccelerationStructures
    local_pAccelerationStructures = (VkAccelerationStructureNV*)pAccelerationStructures;
    local_queryType = queryType;
    local_queryPool = queryPool;
    local_firstQuery = firstQuery;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        if (((accelerationStructureCount)))
        {
            *countPtr += ((accelerationStructureCount)) * 8;
        }
        *countPtr += sizeof(VkQueryType);
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdWriteAccelerationStructuresPropertiesNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdWriteAccelerationStructuresPropertiesNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdWriteAccelerationStructuresPropertiesNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdWriteAccelerationStructuresPropertiesNV = OP_vkCmdWriteAccelerationStructuresPropertiesNV;
    memcpy(streamPtr, &opcode_vkCmdWriteAccelerationStructuresPropertiesNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdWriteAccelerationStructuresPropertiesNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_accelerationStructureCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((accelerationStructureCount)))
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((accelerationStructureCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkAccelerationStructureNV(local_pAccelerationStructures[k]);
            memcpy(cgen_var_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((accelerationStructureCount));
    }
    memcpy(*streamPtrPtr, (VkQueryType*)&local_queryType, sizeof(VkQueryType));
    *streamPtrPtr += sizeof(VkQueryType);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstQuery, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCompileDeferredNV(
    VkDevice device,
    VkPipeline pipeline,
    uint32_t shader,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipeline local_pipeline;
    uint32_t local_shader;
    local_device = device;
    local_pipeline = pipeline;
    local_shader = shader;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCompileDeferredNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCompileDeferredNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCompileDeferredNV = OP_vkCompileDeferredNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCompileDeferredNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCompileDeferredNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkPipeline((*&local_pipeline));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_shader, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    VkResult vkCompileDeferredNV_VkResult_return = (VkResult)0;
    stream->read(&vkCompileDeferredNV_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCompileDeferredNV_VkResult_return;
}

#endif
#ifdef VK_NV_representative_fragment_test
#endif
#ifdef VK_EXT_filter_cubic
#endif
#ifdef VK_QCOM_render_pass_shader_resolve
#endif
#ifdef VK_EXT_global_priority
#endif
#ifdef VK_EXT_external_memory_host
VkResult VkEncoder::vkGetMemoryHostPointerPropertiesEXT(
    VkDevice device,
    VkExternalMemoryHandleTypeFlagBits handleType,
    const void* pHostPointer,
    VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkExternalMemoryHandleTypeFlagBits local_handleType;
    void* local_pHostPointer;
    local_device = device;
    local_handleType = handleType;
    // Avoiding deepcopy for pHostPointer
    local_pHostPointer = (void*)pHostPointer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkExternalMemoryHandleTypeFlagBits);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pHostPointer)
        {
            *countPtr += sizeof(uint8_t);
        }
        count_VkMemoryHostPointerPropertiesEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties), countPtr);
    }
    uint32_t packetSize_vkGetMemoryHostPointerPropertiesEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMemoryHostPointerPropertiesEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMemoryHostPointerPropertiesEXT = OP_vkGetMemoryHostPointerPropertiesEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMemoryHostPointerPropertiesEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMemoryHostPointerPropertiesEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkExternalMemoryHandleTypeFlagBits*)&local_handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    *streamPtrPtr += sizeof(VkExternalMemoryHandleTypeFlagBits);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pHostPointer;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pHostPointer)
    {
        memcpy(*streamPtrPtr, (void*)local_pHostPointer, sizeof(uint8_t));
        *streamPtrPtr += sizeof(uint8_t);
    }
    reservedmarshal_VkMemoryHostPointerPropertiesEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties), streamPtrPtr);
    unmarshal_VkMemoryHostPointerPropertiesEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
    if (pMemoryHostPointerProperties)
    {
        transform_fromhost_VkMemoryHostPointerPropertiesEXT(sResourceTracker, (VkMemoryHostPointerPropertiesEXT*)(pMemoryHostPointerProperties));
    }
    VkResult vkGetMemoryHostPointerPropertiesEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryHostPointerPropertiesEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetMemoryHostPointerPropertiesEXT_VkResult_return;
}

#endif
#ifdef VK_AMD_buffer_marker
void VkEncoder::vkCmdWriteBufferMarkerAMD(
    VkCommandBuffer commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkBuffer dstBuffer,
    VkDeviceSize dstOffset,
    uint32_t marker,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPipelineStageFlagBits local_pipelineStage;
    VkBuffer local_dstBuffer;
    VkDeviceSize local_dstOffset;
    uint32_t local_marker;
    local_commandBuffer = commandBuffer;
    local_pipelineStage = pipelineStage;
    local_dstBuffer = dstBuffer;
    local_dstOffset = dstOffset;
    local_marker = marker;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPipelineStageFlagBits);
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdWriteBufferMarkerAMD = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdWriteBufferMarkerAMD -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdWriteBufferMarkerAMD);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdWriteBufferMarkerAMD = OP_vkCmdWriteBufferMarkerAMD;
    memcpy(streamPtr, &opcode_vkCmdWriteBufferMarkerAMD, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdWriteBufferMarkerAMD, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkPipelineStageFlagBits*)&local_pipelineStage, sizeof(VkPipelineStageFlagBits));
    *streamPtrPtr += sizeof(VkPipelineStageFlagBits);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_dstBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_dstOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_marker, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_AMD_pipeline_compiler_control
#endif
#ifdef VK_EXT_calibrated_timestamps
VkResult VkEncoder::vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(
    VkPhysicalDevice physicalDevice,
    uint32_t* pTimeDomainCount,
    VkTimeDomainEXT* pTimeDomains,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pTimeDomainCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pTimeDomains)
        {
            if (pTimeDomainCount)
            {
                *countPtr += (*(pTimeDomainCount)) * sizeof(VkTimeDomainEXT);
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = OP_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pTimeDomainCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pTimeDomainCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pTimeDomainCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pTimeDomains;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pTimeDomains)
    {
        memcpy(*streamPtrPtr, (VkTimeDomainEXT*)pTimeDomains, (*(pTimeDomainCount)) * sizeof(VkTimeDomainEXT));
        *streamPtrPtr += (*(pTimeDomainCount)) * sizeof(VkTimeDomainEXT);
    }
    // WARNING PTR CHECK
    uint32_t* check_pTimeDomainCount;
    check_pTimeDomainCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pTimeDomainCount)
    {
        if (!(check_pTimeDomainCount))
        {
            fprintf(stderr, "fatal: pTimeDomainCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pTimeDomainCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkTimeDomainEXT* check_pTimeDomains;
    check_pTimeDomains = (VkTimeDomainEXT*)(uintptr_t)stream->getBe64();
    if (pTimeDomains)
    {
        if (!(check_pTimeDomains))
        {
            fprintf(stderr, "fatal: pTimeDomains inconsistent between guest and host\n");
        }
        stream->read((VkTimeDomainEXT*)pTimeDomains, (*(pTimeDomainCount)) * sizeof(VkTimeDomainEXT));
    }
    VkResult vkGetPhysicalDeviceCalibrateableTimeDomainsEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceCalibrateableTimeDomainsEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceCalibrateableTimeDomainsEXT_VkResult_return;
}

VkResult VkEncoder::vkGetCalibratedTimestampsEXT(
    VkDevice device,
    uint32_t timestampCount,
    const VkCalibratedTimestampInfoEXT* pTimestampInfos,
    uint64_t* pTimestamps,
    uint64_t* pMaxDeviation,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_timestampCount;
    VkCalibratedTimestampInfoEXT* local_pTimestampInfos;
    local_device = device;
    local_timestampCount = timestampCount;
    local_pTimestampInfos = nullptr;
    if (pTimestampInfos)
    {
        local_pTimestampInfos = (VkCalibratedTimestampInfoEXT*)pool->alloc(((timestampCount)) * sizeof(const VkCalibratedTimestampInfoEXT));
        for (uint32_t i = 0; i < (uint32_t)((timestampCount)); ++i)
        {
            deepcopy_VkCalibratedTimestampInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pTimestampInfos + i, (VkCalibratedTimestampInfoEXT*)(local_pTimestampInfos + i));
        }
    }
    if (local_pTimestampInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((timestampCount)); ++i)
        {
            transform_tohost_VkCalibratedTimestampInfoEXT(sResourceTracker, (VkCalibratedTimestampInfoEXT*)(local_pTimestampInfos + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((timestampCount)); ++i)
        {
            count_VkCalibratedTimestampInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCalibratedTimestampInfoEXT*)(local_pTimestampInfos + i), countPtr);
        }
        *countPtr += ((timestampCount)) * sizeof(uint64_t);
        *countPtr += sizeof(uint64_t);
    }
    uint32_t packetSize_vkGetCalibratedTimestampsEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetCalibratedTimestampsEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetCalibratedTimestampsEXT = OP_vkGetCalibratedTimestampsEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetCalibratedTimestampsEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetCalibratedTimestampsEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_timestampCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((timestampCount)); ++i)
    {
        reservedmarshal_VkCalibratedTimestampInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCalibratedTimestampInfoEXT*)(local_pTimestampInfos + i), streamPtrPtr);
    }
    memcpy(*streamPtrPtr, (uint64_t*)pTimestamps, ((timestampCount)) * sizeof(uint64_t));
    *streamPtrPtr += ((timestampCount)) * sizeof(uint64_t);
    memcpy(*streamPtrPtr, (uint64_t*)pMaxDeviation, sizeof(uint64_t));
    *streamPtrPtr += sizeof(uint64_t);
    stream->read((uint64_t*)pTimestamps, ((timestampCount)) * sizeof(uint64_t));
    stream->read((uint64_t*)pMaxDeviation, sizeof(uint64_t));
    VkResult vkGetCalibratedTimestampsEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetCalibratedTimestampsEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetCalibratedTimestampsEXT_VkResult_return;
}

#endif
#ifdef VK_AMD_shader_core_properties
#endif
#ifdef VK_AMD_memory_overallocation_behavior
#endif
#ifdef VK_EXT_vertex_attribute_divisor
#endif
#ifdef VK_GGP_frame_token
#endif
#ifdef VK_EXT_pipeline_creation_feedback
#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_compute_shader_derivatives
#endif
#ifdef VK_NV_mesh_shader
void VkEncoder::vkCmdDrawMeshTasksNV(
    VkCommandBuffer commandBuffer,
    uint32_t taskCount,
    uint32_t firstTask,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_taskCount;
    uint32_t local_firstTask;
    local_commandBuffer = commandBuffer;
    local_taskCount = taskCount;
    local_firstTask = firstTask;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawMeshTasksNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawMeshTasksNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawMeshTasksNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawMeshTasksNV = OP_vkCmdDrawMeshTasksNV;
    memcpy(streamPtr, &opcode_vkCmdDrawMeshTasksNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawMeshTasksNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_taskCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstTask, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDrawMeshTasksIndirectNV(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    uint32_t drawCount,
    uint32_t stride,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    uint32_t local_drawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_drawCount = drawCount;
    local_stride = stride;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawMeshTasksIndirectNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawMeshTasksIndirectNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawMeshTasksIndirectNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawMeshTasksIndirectNV = OP_vkCmdDrawMeshTasksIndirectNV;
    memcpy(streamPtr, &opcode_vkCmdDrawMeshTasksIndirectNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawMeshTasksIndirectNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_drawCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_stride, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdDrawMeshTasksIndirectCountNV(
    VkCommandBuffer commandBuffer,
    VkBuffer buffer,
    VkDeviceSize offset,
    VkBuffer countBuffer,
    VkDeviceSize countBufferOffset,
    uint32_t maxDrawCount,
    uint32_t stride,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBuffer local_buffer;
    VkDeviceSize local_offset;
    VkBuffer local_countBuffer;
    VkDeviceSize local_countBufferOffset;
    uint32_t local_maxDrawCount;
    uint32_t local_stride;
    local_commandBuffer = commandBuffer;
    local_buffer = buffer;
    local_offset = offset;
    local_countBuffer = countBuffer;
    local_countBufferOffset = countBufferOffset;
    local_maxDrawCount = maxDrawCount;
    local_stride = stride;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdDrawMeshTasksIndirectCountNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdDrawMeshTasksIndirectCountNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdDrawMeshTasksIndirectCountNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdDrawMeshTasksIndirectCountNV = OP_vkCmdDrawMeshTasksIndirectCountNV;
    memcpy(streamPtr, &opcode_vkCmdDrawMeshTasksIndirectCountNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdDrawMeshTasksIndirectCountNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_offset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&local_countBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkDeviceSize*)&local_countBufferOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (uint32_t*)&local_maxDrawCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_stride, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_NV_fragment_shader_barycentric
#endif
#ifdef VK_NV_shader_image_footprint
#endif
#ifdef VK_NV_scissor_exclusive
void VkEncoder::vkCmdSetExclusiveScissorNV(
    VkCommandBuffer commandBuffer,
    uint32_t firstExclusiveScissor,
    uint32_t exclusiveScissorCount,
    const VkRect2D* pExclusiveScissors,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstExclusiveScissor;
    uint32_t local_exclusiveScissorCount;
    VkRect2D* local_pExclusiveScissors;
    local_commandBuffer = commandBuffer;
    local_firstExclusiveScissor = firstExclusiveScissor;
    local_exclusiveScissorCount = exclusiveScissorCount;
    local_pExclusiveScissors = nullptr;
    if (pExclusiveScissors)
    {
        local_pExclusiveScissors = (VkRect2D*)pool->alloc(((exclusiveScissorCount)) * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)((exclusiveScissorCount)); ++i)
        {
            deepcopy_VkRect2D(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pExclusiveScissors + i, (VkRect2D*)(local_pExclusiveScissors + i));
        }
    }
    if (local_pExclusiveScissors)
    {
        for (uint32_t i = 0; i < (uint32_t)((exclusiveScissorCount)); ++i)
        {
            transform_tohost_VkRect2D(sResourceTracker, (VkRect2D*)(local_pExclusiveScissors + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((exclusiveScissorCount)); ++i)
        {
            count_VkRect2D(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRect2D*)(local_pExclusiveScissors + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdSetExclusiveScissorNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetExclusiveScissorNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetExclusiveScissorNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetExclusiveScissorNV = OP_vkCmdSetExclusiveScissorNV;
    memcpy(streamPtr, &opcode_vkCmdSetExclusiveScissorNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetExclusiveScissorNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstExclusiveScissor, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_exclusiveScissorCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((exclusiveScissorCount)); ++i)
    {
        reservedmarshal_VkRect2D(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRect2D*)(local_pExclusiveScissors + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void VkEncoder::vkCmdSetCheckpointNV(
    VkCommandBuffer commandBuffer,
    const void* pCheckpointMarker,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    void* local_pCheckpointMarker;
    local_commandBuffer = commandBuffer;
    // Avoiding deepcopy for pCheckpointMarker
    local_pCheckpointMarker = (void*)pCheckpointMarker;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pCheckpointMarker)
        {
            *countPtr += sizeof(uint8_t);
        }
    }
    uint32_t packetSize_vkCmdSetCheckpointNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetCheckpointNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetCheckpointNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetCheckpointNV = OP_vkCmdSetCheckpointNV;
    memcpy(streamPtr, &opcode_vkCmdSetCheckpointNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetCheckpointNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)local_pCheckpointMarker;
    memcpy((*streamPtrPtr), &cgen_var_0, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pCheckpointMarker)
    {
        memcpy(*streamPtrPtr, (void*)local_pCheckpointMarker, sizeof(uint8_t));
        *streamPtrPtr += sizeof(uint8_t);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetQueueCheckpointDataNV(
    VkQueue queue,
    uint32_t* pCheckpointDataCount,
    VkCheckpointDataNV* pCheckpointData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    local_queue = queue;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pCheckpointDataCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pCheckpointData)
        {
            if (pCheckpointDataCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
                {
                    count_VkCheckpointDataNV(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCheckpointDataNV*)(pCheckpointData + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetQueueCheckpointDataNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetQueueCheckpointDataNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetQueueCheckpointDataNV = OP_vkGetQueueCheckpointDataNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetQueueCheckpointDataNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetQueueCheckpointDataNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pCheckpointDataCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pCheckpointDataCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pCheckpointData;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pCheckpointData)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
        {
            reservedmarshal_VkCheckpointDataNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCheckpointDataNV*)(pCheckpointData + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pCheckpointDataCount;
    check_pCheckpointDataCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pCheckpointDataCount)
    {
        if (!(check_pCheckpointDataCount))
        {
            fprintf(stderr, "fatal: pCheckpointDataCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pCheckpointDataCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkCheckpointDataNV* check_pCheckpointData;
    check_pCheckpointData = (VkCheckpointDataNV*)(uintptr_t)stream->getBe64();
    if (pCheckpointData)
    {
        if (!(check_pCheckpointData))
        {
            fprintf(stderr, "fatal: pCheckpointData inconsistent between guest and host\n");
        }
        if (pCheckpointDataCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
            {
                unmarshal_VkCheckpointDataNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCheckpointDataNV*)(pCheckpointData + i));
            }
        }
    }
    if (pCheckpointDataCount)
    {
        if (pCheckpointData)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pCheckpointDataCount)); ++i)
            {
                transform_fromhost_VkCheckpointDataNV(sResourceTracker, (VkCheckpointDataNV*)(pCheckpointData + i));
            }
        }
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_INTEL_shader_integer_functions2
#endif
#ifdef VK_INTEL_performance_query
VkResult VkEncoder::vkInitializePerformanceApiINTEL(
    VkDevice device,
    const VkInitializePerformanceApiInfoINTEL* pInitializeInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkInitializePerformanceApiInfoINTEL* local_pInitializeInfo;
    local_device = device;
    local_pInitializeInfo = nullptr;
    if (pInitializeInfo)
    {
        local_pInitializeInfo = (VkInitializePerformanceApiInfoINTEL*)pool->alloc(sizeof(const VkInitializePerformanceApiInfoINTEL));
        deepcopy_VkInitializePerformanceApiInfoINTEL(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInitializeInfo, (VkInitializePerformanceApiInfoINTEL*)(local_pInitializeInfo));
    }
    if (local_pInitializeInfo)
    {
        transform_tohost_VkInitializePerformanceApiInfoINTEL(sResourceTracker, (VkInitializePerformanceApiInfoINTEL*)(local_pInitializeInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkInitializePerformanceApiInfoINTEL(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkInitializePerformanceApiInfoINTEL*)(local_pInitializeInfo), countPtr);
    }
    uint32_t packetSize_vkInitializePerformanceApiINTEL = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkInitializePerformanceApiINTEL);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkInitializePerformanceApiINTEL = OP_vkInitializePerformanceApiINTEL;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkInitializePerformanceApiINTEL, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkInitializePerformanceApiINTEL, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkInitializePerformanceApiInfoINTEL(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkInitializePerformanceApiInfoINTEL*)(local_pInitializeInfo), streamPtrPtr);
    VkResult vkInitializePerformanceApiINTEL_VkResult_return = (VkResult)0;
    stream->read(&vkInitializePerformanceApiINTEL_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkInitializePerformanceApiINTEL_VkResult_return;
}

void VkEncoder::vkUninitializePerformanceApiINTEL(
    VkDevice device,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    local_device = device;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkUninitializePerformanceApiINTEL = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkUninitializePerformanceApiINTEL);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkUninitializePerformanceApiINTEL = OP_vkUninitializePerformanceApiINTEL;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkUninitializePerformanceApiINTEL, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkUninitializePerformanceApiINTEL, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCmdSetPerformanceMarkerINTEL(
    VkCommandBuffer commandBuffer,
    const VkPerformanceMarkerInfoINTEL* pMarkerInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPerformanceMarkerInfoINTEL* local_pMarkerInfo;
    local_commandBuffer = commandBuffer;
    local_pMarkerInfo = nullptr;
    if (pMarkerInfo)
    {
        local_pMarkerInfo = (VkPerformanceMarkerInfoINTEL*)pool->alloc(sizeof(const VkPerformanceMarkerInfoINTEL));
        deepcopy_VkPerformanceMarkerInfoINTEL(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pMarkerInfo, (VkPerformanceMarkerInfoINTEL*)(local_pMarkerInfo));
    }
    if (local_pMarkerInfo)
    {
        transform_tohost_VkPerformanceMarkerInfoINTEL(sResourceTracker, (VkPerformanceMarkerInfoINTEL*)(local_pMarkerInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPerformanceMarkerInfoINTEL(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceMarkerInfoINTEL*)(local_pMarkerInfo), countPtr);
    }
    uint32_t packetSize_vkCmdSetPerformanceMarkerINTEL = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetPerformanceMarkerINTEL -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetPerformanceMarkerINTEL);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetPerformanceMarkerINTEL = OP_vkCmdSetPerformanceMarkerINTEL;
    memcpy(streamPtr, &opcode_vkCmdSetPerformanceMarkerINTEL, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetPerformanceMarkerINTEL, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkPerformanceMarkerInfoINTEL(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceMarkerInfoINTEL*)(local_pMarkerInfo), streamPtrPtr);
    VkResult vkCmdSetPerformanceMarkerINTEL_VkResult_return = (VkResult)0;
    stream->read(&vkCmdSetPerformanceMarkerINTEL_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCmdSetPerformanceMarkerINTEL_VkResult_return;
}

VkResult VkEncoder::vkCmdSetPerformanceStreamMarkerINTEL(
    VkCommandBuffer commandBuffer,
    const VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPerformanceStreamMarkerInfoINTEL* local_pMarkerInfo;
    local_commandBuffer = commandBuffer;
    local_pMarkerInfo = nullptr;
    if (pMarkerInfo)
    {
        local_pMarkerInfo = (VkPerformanceStreamMarkerInfoINTEL*)pool->alloc(sizeof(const VkPerformanceStreamMarkerInfoINTEL));
        deepcopy_VkPerformanceStreamMarkerInfoINTEL(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pMarkerInfo, (VkPerformanceStreamMarkerInfoINTEL*)(local_pMarkerInfo));
    }
    if (local_pMarkerInfo)
    {
        transform_tohost_VkPerformanceStreamMarkerInfoINTEL(sResourceTracker, (VkPerformanceStreamMarkerInfoINTEL*)(local_pMarkerInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPerformanceStreamMarkerInfoINTEL(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceStreamMarkerInfoINTEL*)(local_pMarkerInfo), countPtr);
    }
    uint32_t packetSize_vkCmdSetPerformanceStreamMarkerINTEL = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetPerformanceStreamMarkerINTEL -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetPerformanceStreamMarkerINTEL);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetPerformanceStreamMarkerINTEL = OP_vkCmdSetPerformanceStreamMarkerINTEL;
    memcpy(streamPtr, &opcode_vkCmdSetPerformanceStreamMarkerINTEL, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetPerformanceStreamMarkerINTEL, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkPerformanceStreamMarkerInfoINTEL(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceStreamMarkerInfoINTEL*)(local_pMarkerInfo), streamPtrPtr);
    VkResult vkCmdSetPerformanceStreamMarkerINTEL_VkResult_return = (VkResult)0;
    stream->read(&vkCmdSetPerformanceStreamMarkerINTEL_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCmdSetPerformanceStreamMarkerINTEL_VkResult_return;
}

VkResult VkEncoder::vkCmdSetPerformanceOverrideINTEL(
    VkCommandBuffer commandBuffer,
    const VkPerformanceOverrideInfoINTEL* pOverrideInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPerformanceOverrideInfoINTEL* local_pOverrideInfo;
    local_commandBuffer = commandBuffer;
    local_pOverrideInfo = nullptr;
    if (pOverrideInfo)
    {
        local_pOverrideInfo = (VkPerformanceOverrideInfoINTEL*)pool->alloc(sizeof(const VkPerformanceOverrideInfoINTEL));
        deepcopy_VkPerformanceOverrideInfoINTEL(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pOverrideInfo, (VkPerformanceOverrideInfoINTEL*)(local_pOverrideInfo));
    }
    if (local_pOverrideInfo)
    {
        transform_tohost_VkPerformanceOverrideInfoINTEL(sResourceTracker, (VkPerformanceOverrideInfoINTEL*)(local_pOverrideInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPerformanceOverrideInfoINTEL(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceOverrideInfoINTEL*)(local_pOverrideInfo), countPtr);
    }
    uint32_t packetSize_vkCmdSetPerformanceOverrideINTEL = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetPerformanceOverrideINTEL -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetPerformanceOverrideINTEL);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetPerformanceOverrideINTEL = OP_vkCmdSetPerformanceOverrideINTEL;
    memcpy(streamPtr, &opcode_vkCmdSetPerformanceOverrideINTEL, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetPerformanceOverrideINTEL, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkPerformanceOverrideInfoINTEL(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceOverrideInfoINTEL*)(local_pOverrideInfo), streamPtrPtr);
    VkResult vkCmdSetPerformanceOverrideINTEL_VkResult_return = (VkResult)0;
    stream->read(&vkCmdSetPerformanceOverrideINTEL_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCmdSetPerformanceOverrideINTEL_VkResult_return;
}

VkResult VkEncoder::vkAcquirePerformanceConfigurationINTEL(
    VkDevice device,
    const VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo,
    VkPerformanceConfigurationINTEL* pConfiguration,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPerformanceConfigurationAcquireInfoINTEL* local_pAcquireInfo;
    local_device = device;
    local_pAcquireInfo = nullptr;
    if (pAcquireInfo)
    {
        local_pAcquireInfo = (VkPerformanceConfigurationAcquireInfoINTEL*)pool->alloc(sizeof(const VkPerformanceConfigurationAcquireInfoINTEL));
        deepcopy_VkPerformanceConfigurationAcquireInfoINTEL(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAcquireInfo, (VkPerformanceConfigurationAcquireInfoINTEL*)(local_pAcquireInfo));
    }
    if (local_pAcquireInfo)
    {
        transform_tohost_VkPerformanceConfigurationAcquireInfoINTEL(sResourceTracker, (VkPerformanceConfigurationAcquireInfoINTEL*)(local_pAcquireInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPerformanceConfigurationAcquireInfoINTEL(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceConfigurationAcquireInfoINTEL*)(local_pAcquireInfo), countPtr);
        *countPtr += 8;
    }
    uint32_t packetSize_vkAcquirePerformanceConfigurationINTEL = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkAcquirePerformanceConfigurationINTEL);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkAcquirePerformanceConfigurationINTEL = OP_vkAcquirePerformanceConfigurationINTEL;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkAcquirePerformanceConfigurationINTEL, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkAcquirePerformanceConfigurationINTEL, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPerformanceConfigurationAcquireInfoINTEL(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceConfigurationAcquireInfoINTEL*)(local_pAcquireInfo), streamPtrPtr);
    uint64_t cgen_var_1 = (uint64_t)(*pConfiguration);
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    (*pConfiguration) = (VkPerformanceConfigurationINTEL)stream->getBe64();
    VkResult vkAcquirePerformanceConfigurationINTEL_VkResult_return = (VkResult)0;
    stream->read(&vkAcquirePerformanceConfigurationINTEL_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkAcquirePerformanceConfigurationINTEL_VkResult_return;
}

VkResult VkEncoder::vkReleasePerformanceConfigurationINTEL(
    VkDevice device,
    VkPerformanceConfigurationINTEL configuration,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPerformanceConfigurationINTEL local_configuration;
    local_device = device;
    local_configuration = configuration;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += 8;
    }
    uint32_t packetSize_vkReleasePerformanceConfigurationINTEL = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkReleasePerformanceConfigurationINTEL);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkReleasePerformanceConfigurationINTEL = OP_vkReleasePerformanceConfigurationINTEL;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkReleasePerformanceConfigurationINTEL, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkReleasePerformanceConfigurationINTEL, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1 = (uint64_t)local_configuration;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    VkResult vkReleasePerformanceConfigurationINTEL_VkResult_return = (VkResult)0;
    stream->read(&vkReleasePerformanceConfigurationINTEL_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkReleasePerformanceConfigurationINTEL_VkResult_return;
}

VkResult VkEncoder::vkQueueSetPerformanceConfigurationINTEL(
    VkQueue queue,
    VkPerformanceConfigurationINTEL configuration,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    VkPerformanceConfigurationINTEL local_configuration;
    local_queue = queue;
    local_configuration = configuration;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += 8;
    }
    uint32_t packetSize_vkQueueSetPerformanceConfigurationINTEL = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueSetPerformanceConfigurationINTEL);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueSetPerformanceConfigurationINTEL = OP_vkQueueSetPerformanceConfigurationINTEL;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueSetPerformanceConfigurationINTEL, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueSetPerformanceConfigurationINTEL, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1 = (uint64_t)local_configuration;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    VkResult vkQueueSetPerformanceConfigurationINTEL_VkResult_return = (VkResult)0;
    stream->read(&vkQueueSetPerformanceConfigurationINTEL_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkQueueSetPerformanceConfigurationINTEL_VkResult_return;
}

VkResult VkEncoder::vkGetPerformanceParameterINTEL(
    VkDevice device,
    VkPerformanceParameterTypeINTEL parameter,
    VkPerformanceValueINTEL* pValue,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPerformanceParameterTypeINTEL local_parameter;
    local_device = device;
    local_parameter = parameter;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPerformanceParameterTypeINTEL);
        count_VkPerformanceValueINTEL(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceValueINTEL*)(pValue), countPtr);
    }
    uint32_t packetSize_vkGetPerformanceParameterINTEL = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPerformanceParameterINTEL);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPerformanceParameterINTEL = OP_vkGetPerformanceParameterINTEL;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPerformanceParameterINTEL, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPerformanceParameterINTEL, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkPerformanceParameterTypeINTEL*)&local_parameter, sizeof(VkPerformanceParameterTypeINTEL));
    *streamPtrPtr += sizeof(VkPerformanceParameterTypeINTEL);
    reservedmarshal_VkPerformanceValueINTEL(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceValueINTEL*)(pValue), streamPtrPtr);
    unmarshal_VkPerformanceValueINTEL(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPerformanceValueINTEL*)(pValue));
    if (pValue)
    {
        transform_fromhost_VkPerformanceValueINTEL(sResourceTracker, (VkPerformanceValueINTEL*)(pValue));
    }
    VkResult vkGetPerformanceParameterINTEL_VkResult_return = (VkResult)0;
    stream->read(&vkGetPerformanceParameterINTEL_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPerformanceParameterINTEL_VkResult_return;
}

#endif
#ifdef VK_EXT_pci_bus_info
#endif
#ifdef VK_AMD_display_native_hdr
void VkEncoder::vkSetLocalDimmingAMD(
    VkDevice device,
    VkSwapchainKHR swapChain,
    VkBool32 localDimmingEnable,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainKHR local_swapChain;
    VkBool32 local_localDimmingEnable;
    local_device = device;
    local_swapChain = swapChain;
    local_localDimmingEnable = localDimmingEnable;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkBool32);
    }
    uint32_t packetSize_vkSetLocalDimmingAMD = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkSetLocalDimmingAMD);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkSetLocalDimmingAMD = OP_vkSetLocalDimmingAMD;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkSetLocalDimmingAMD, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkSetLocalDimmingAMD, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSwapchainKHR((*&local_swapChain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkBool32*)&local_localDimmingEnable, sizeof(VkBool32));
    *streamPtrPtr += sizeof(VkBool32);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_FUCHSIA_imagepipe_surface
VkResult VkEncoder::vkCreateImagePipeSurfaceFUCHSIA(
    VkInstance instance,
    const VkImagePipeSurfaceCreateInfoFUCHSIA* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkImagePipeSurfaceCreateInfoFUCHSIA* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkImagePipeSurfaceCreateInfoFUCHSIA*)pool->alloc(sizeof(const VkImagePipeSurfaceCreateInfoFUCHSIA));
        deepcopy_VkImagePipeSurfaceCreateInfoFUCHSIA(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkImagePipeSurfaceCreateInfoFUCHSIA*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkImagePipeSurfaceCreateInfoFUCHSIA(sResourceTracker, (VkImagePipeSurfaceCreateInfoFUCHSIA*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkImagePipeSurfaceCreateInfoFUCHSIA(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImagePipeSurfaceCreateInfoFUCHSIA*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateImagePipeSurfaceFUCHSIA = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateImagePipeSurfaceFUCHSIA);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateImagePipeSurfaceFUCHSIA = OP_vkCreateImagePipeSurfaceFUCHSIA;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateImagePipeSurfaceFUCHSIA, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateImagePipeSurfaceFUCHSIA, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImagePipeSurfaceCreateInfoFUCHSIA(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImagePipeSurfaceCreateInfoFUCHSIA*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_3, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateImagePipeSurfaceFUCHSIA_VkResult_return = (VkResult)0;
    stream->read(&vkCreateImagePipeSurfaceFUCHSIA_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateImagePipeSurfaceFUCHSIA_VkResult_return;
}

#endif
#ifdef VK_EXT_metal_surface
VkResult VkEncoder::vkCreateMetalSurfaceEXT(
    VkInstance instance,
    const VkMetalSurfaceCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkMetalSurfaceCreateInfoEXT* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkMetalSurfaceCreateInfoEXT*)pool->alloc(sizeof(const VkMetalSurfaceCreateInfoEXT));
        deepcopy_VkMetalSurfaceCreateInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkMetalSurfaceCreateInfoEXT*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkMetalSurfaceCreateInfoEXT(sResourceTracker, (VkMetalSurfaceCreateInfoEXT*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkMetalSurfaceCreateInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMetalSurfaceCreateInfoEXT*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateMetalSurfaceEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateMetalSurfaceEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateMetalSurfaceEXT = OP_vkCreateMetalSurfaceEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateMetalSurfaceEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateMetalSurfaceEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkMetalSurfaceCreateInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMetalSurfaceCreateInfoEXT*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_3, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateMetalSurfaceEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreateMetalSurfaceEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateMetalSurfaceEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_fragment_density_map
#endif
#ifdef VK_EXT_scalar_block_layout
#endif
#ifdef VK_GOOGLE_hlsl_functionality1
#endif
#ifdef VK_GOOGLE_decorate_string
#endif
#ifdef VK_EXT_subgroup_size_control
#endif
#ifdef VK_AMD_shader_core_properties2
#endif
#ifdef VK_AMD_device_coherent_memory
#endif
#ifdef VK_EXT_shader_image_atomic_int64
#endif
#ifdef VK_EXT_memory_budget
#endif
#ifdef VK_EXT_memory_priority
#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
#endif
#ifdef VK_EXT_buffer_device_address
VkDeviceAddress VkEncoder::vkGetBufferDeviceAddressEXT(
    VkDevice device,
    const VkBufferDeviceAddressInfo* pInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBufferDeviceAddressInfo* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkBufferDeviceAddressInfo*)pool->alloc(sizeof(const VkBufferDeviceAddressInfo));
        deepcopy_VkBufferDeviceAddressInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkBufferDeviceAddressInfo*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkBufferDeviceAddressInfo(sResourceTracker, (VkBufferDeviceAddressInfo*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkBufferDeviceAddressInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferDeviceAddressInfo*)(local_pInfo), countPtr);
    }
    uint32_t packetSize_vkGetBufferDeviceAddressEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetBufferDeviceAddressEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetBufferDeviceAddressEXT = OP_vkGetBufferDeviceAddressEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetBufferDeviceAddressEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetBufferDeviceAddressEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkBufferDeviceAddressInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferDeviceAddressInfo*)(local_pInfo), streamPtrPtr);
    VkDeviceAddress vkGetBufferDeviceAddressEXT_VkDeviceAddress_return = (VkDeviceAddress)0;
    stream->read(&vkGetBufferDeviceAddressEXT_VkDeviceAddress_return, sizeof(VkDeviceAddress));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetBufferDeviceAddressEXT_VkDeviceAddress_return;
}

#endif
#ifdef VK_EXT_tooling_info
VkResult VkEncoder::vkGetPhysicalDeviceToolPropertiesEXT(
    VkPhysicalDevice physicalDevice,
    uint32_t* pToolCount,
    VkPhysicalDeviceToolPropertiesEXT* pToolProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pToolCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pToolProperties)
        {
            if (pToolCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pToolCount)); ++i)
                {
                    count_VkPhysicalDeviceToolPropertiesEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceToolPropertiesEXT*)(pToolProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceToolPropertiesEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceToolPropertiesEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceToolPropertiesEXT = OP_vkGetPhysicalDeviceToolPropertiesEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceToolPropertiesEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceToolPropertiesEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pToolCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pToolCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pToolCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pToolProperties;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pToolProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pToolCount)); ++i)
        {
            reservedmarshal_VkPhysicalDeviceToolPropertiesEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceToolPropertiesEXT*)(pToolProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pToolCount;
    check_pToolCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pToolCount)
    {
        if (!(check_pToolCount))
        {
            fprintf(stderr, "fatal: pToolCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pToolCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPhysicalDeviceToolPropertiesEXT* check_pToolProperties;
    check_pToolProperties = (VkPhysicalDeviceToolPropertiesEXT*)(uintptr_t)stream->getBe64();
    if (pToolProperties)
    {
        if (!(check_pToolProperties))
        {
            fprintf(stderr, "fatal: pToolProperties inconsistent between guest and host\n");
        }
        if (pToolCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pToolCount)); ++i)
            {
                unmarshal_VkPhysicalDeviceToolPropertiesEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceToolPropertiesEXT*)(pToolProperties + i));
            }
        }
    }
    if (pToolCount)
    {
        if (pToolProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pToolCount)); ++i)
            {
                transform_fromhost_VkPhysicalDeviceToolPropertiesEXT(sResourceTracker, (VkPhysicalDeviceToolPropertiesEXT*)(pToolProperties + i));
            }
        }
    }
    VkResult vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceToolPropertiesEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_separate_stencil_usage
#endif
#ifdef VK_EXT_validation_features
#endif
#ifdef VK_NV_cooperative_matrix
VkResult VkEncoder::vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(
    VkPhysicalDevice physicalDevice,
    uint32_t* pPropertyCount,
    VkCooperativeMatrixPropertiesNV* pProperties,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPropertyCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pProperties)
        {
            if (pPropertyCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
                {
                    count_VkCooperativeMatrixPropertiesNV(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCooperativeMatrixPropertiesNV*)(pProperties + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = OP_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pPropertyCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPropertyCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPropertyCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pProperties;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pProperties)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
        {
            reservedmarshal_VkCooperativeMatrixPropertiesNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCooperativeMatrixPropertiesNV*)(pProperties + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pPropertyCount;
    check_pPropertyCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPropertyCount)
    {
        if (!(check_pPropertyCount))
        {
            fprintf(stderr, "fatal: pPropertyCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPropertyCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkCooperativeMatrixPropertiesNV* check_pProperties;
    check_pProperties = (VkCooperativeMatrixPropertiesNV*)(uintptr_t)stream->getBe64();
    if (pProperties)
    {
        if (!(check_pProperties))
        {
            fprintf(stderr, "fatal: pProperties inconsistent between guest and host\n");
        }
        if (pPropertyCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                unmarshal_VkCooperativeMatrixPropertiesNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCooperativeMatrixPropertiesNV*)(pProperties + i));
            }
        }
    }
    if (pPropertyCount)
    {
        if (pProperties)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pPropertyCount)); ++i)
            {
                transform_fromhost_VkCooperativeMatrixPropertiesNV(sResourceTracker, (VkCooperativeMatrixPropertiesNV*)(pProperties + i));
            }
        }
    }
    VkResult vkGetPhysicalDeviceCooperativeMatrixPropertiesNV_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceCooperativeMatrixPropertiesNV_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceCooperativeMatrixPropertiesNV_VkResult_return;
}

#endif
#ifdef VK_NV_coverage_reduction_mode
VkResult VkEncoder::vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(
    VkPhysicalDevice physicalDevice,
    uint32_t* pCombinationCount,
    VkFramebufferMixedSamplesCombinationNV* pCombinations,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    local_physicalDevice = physicalDevice;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pCombinationCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pCombinations)
        {
            if (pCombinationCount)
            {
                for (uint32_t i = 0; i < (uint32_t)(*(pCombinationCount)); ++i)
                {
                    count_VkFramebufferMixedSamplesCombinationNV(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFramebufferMixedSamplesCombinationNV*)(pCombinations + i), countPtr);
                }
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = OP_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pCombinationCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pCombinationCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pCombinationCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pCombinations;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pCombinations)
    {
        for (uint32_t i = 0; i < (uint32_t)(*(pCombinationCount)); ++i)
        {
            reservedmarshal_VkFramebufferMixedSamplesCombinationNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFramebufferMixedSamplesCombinationNV*)(pCombinations + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint32_t* check_pCombinationCount;
    check_pCombinationCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pCombinationCount)
    {
        if (!(check_pCombinationCount))
        {
            fprintf(stderr, "fatal: pCombinationCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pCombinationCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkFramebufferMixedSamplesCombinationNV* check_pCombinations;
    check_pCombinations = (VkFramebufferMixedSamplesCombinationNV*)(uintptr_t)stream->getBe64();
    if (pCombinations)
    {
        if (!(check_pCombinations))
        {
            fprintf(stderr, "fatal: pCombinations inconsistent between guest and host\n");
        }
        if (pCombinationCount)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pCombinationCount)); ++i)
            {
                unmarshal_VkFramebufferMixedSamplesCombinationNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkFramebufferMixedSamplesCombinationNV*)(pCombinations + i));
            }
        }
    }
    if (pCombinationCount)
    {
        if (pCombinations)
        {
            for (uint32_t i = 0; i < (uint32_t)(*(pCombinationCount)); ++i)
            {
                transform_fromhost_VkFramebufferMixedSamplesCombinationNV(sResourceTracker, (VkFramebufferMixedSamplesCombinationNV*)(pCombinations + i));
            }
        }
    }
    VkResult vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV_VkResult_return;
}

#endif
#ifdef VK_EXT_fragment_shader_interlock
#endif
#ifdef VK_EXT_ycbcr_image_arrays
#endif
#ifdef VK_EXT_full_screen_exclusive
VkResult VkEncoder::vkGetPhysicalDeviceSurfacePresentModes2EXT(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    uint32_t* pPresentModeCount,
    VkPresentModeKHR* pPresentModes,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    VkPhysicalDeviceSurfaceInfo2KHR* local_pSurfaceInfo;
    local_physicalDevice = physicalDevice;
    local_pSurfaceInfo = nullptr;
    if (pSurfaceInfo)
    {
        local_pSurfaceInfo = (VkPhysicalDeviceSurfaceInfo2KHR*)pool->alloc(sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
        deepcopy_VkPhysicalDeviceSurfaceInfo2KHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pSurfaceInfo, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    if (local_pSurfaceInfo)
    {
        transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(sResourceTracker, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceSurfaceInfo2KHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPresentModeCount)
        {
            *countPtr += sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPresentModes)
        {
            if (pPresentModeCount)
            {
                *countPtr += (*(pPresentModeCount)) * sizeof(VkPresentModeKHR);
            }
        }
    }
    uint32_t packetSize_vkGetPhysicalDeviceSurfacePresentModes2EXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceSurfacePresentModes2EXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceSurfacePresentModes2EXT = OP_vkGetPhysicalDeviceSurfacePresentModes2EXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceSurfacePresentModes2EXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceSurfacePresentModes2EXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceSurfaceInfo2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pPresentModeCount;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPresentModeCount)
    {
        memcpy(*streamPtrPtr, (uint32_t*)pPresentModeCount, sizeof(uint32_t));
        *streamPtrPtr += sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pPresentModes;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPresentModes)
    {
        memcpy(*streamPtrPtr, (VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
        *streamPtrPtr += (*(pPresentModeCount)) * sizeof(VkPresentModeKHR);
    }
    // WARNING PTR CHECK
    uint32_t* check_pPresentModeCount;
    check_pPresentModeCount = (uint32_t*)(uintptr_t)stream->getBe64();
    if (pPresentModeCount)
    {
        if (!(check_pPresentModeCount))
        {
            fprintf(stderr, "fatal: pPresentModeCount inconsistent between guest and host\n");
        }
        stream->read((uint32_t*)pPresentModeCount, sizeof(uint32_t));
    }
    // WARNING PTR CHECK
    VkPresentModeKHR* check_pPresentModes;
    check_pPresentModes = (VkPresentModeKHR*)(uintptr_t)stream->getBe64();
    if (pPresentModes)
    {
        if (!(check_pPresentModes))
        {
            fprintf(stderr, "fatal: pPresentModes inconsistent between guest and host\n");
        }
        stream->read((VkPresentModeKHR*)pPresentModes, (*(pPresentModeCount)) * sizeof(VkPresentModeKHR));
    }
    VkResult vkGetPhysicalDeviceSurfacePresentModes2EXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetPhysicalDeviceSurfacePresentModes2EXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceSurfacePresentModes2EXT_VkResult_return;
}

VkResult VkEncoder::vkAcquireFullScreenExclusiveModeEXT(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    local_device = device;
    local_swapchain = swapchain;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkAcquireFullScreenExclusiveModeEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkAcquireFullScreenExclusiveModeEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkAcquireFullScreenExclusiveModeEXT = OP_vkAcquireFullScreenExclusiveModeEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkAcquireFullScreenExclusiveModeEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkAcquireFullScreenExclusiveModeEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSwapchainKHR((*&local_swapchain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkAcquireFullScreenExclusiveModeEXT_VkResult_return = (VkResult)0;
    stream->read(&vkAcquireFullScreenExclusiveModeEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkAcquireFullScreenExclusiveModeEXT_VkResult_return;
}

VkResult VkEncoder::vkReleaseFullScreenExclusiveModeEXT(
    VkDevice device,
    VkSwapchainKHR swapchain,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkSwapchainKHR local_swapchain;
    local_device = device;
    local_swapchain = swapchain;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkReleaseFullScreenExclusiveModeEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkReleaseFullScreenExclusiveModeEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkReleaseFullScreenExclusiveModeEXT = OP_vkReleaseFullScreenExclusiveModeEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkReleaseFullScreenExclusiveModeEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkReleaseFullScreenExclusiveModeEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkSwapchainKHR((*&local_swapchain));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    VkResult vkReleaseFullScreenExclusiveModeEXT_VkResult_return = (VkResult)0;
    stream->read(&vkReleaseFullScreenExclusiveModeEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkReleaseFullScreenExclusiveModeEXT_VkResult_return;
}

VkResult VkEncoder::vkGetDeviceGroupSurfacePresentModes2EXT(
    VkDevice device,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    VkDeviceGroupPresentModeFlagsKHR* pModes,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPhysicalDeviceSurfaceInfo2KHR* local_pSurfaceInfo;
    local_device = device;
    local_pSurfaceInfo = nullptr;
    if (pSurfaceInfo)
    {
        local_pSurfaceInfo = (VkPhysicalDeviceSurfaceInfo2KHR*)pool->alloc(sizeof(const VkPhysicalDeviceSurfaceInfo2KHR));
        deepcopy_VkPhysicalDeviceSurfaceInfo2KHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pSurfaceInfo, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    if (local_pSurfaceInfo)
    {
        transform_tohost_VkPhysicalDeviceSurfaceInfo2KHR(sResourceTracker, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPhysicalDeviceSurfaceInfo2KHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pModes)
        {
            *countPtr += sizeof(VkDeviceGroupPresentModeFlagsKHR);
        }
    }
    uint32_t packetSize_vkGetDeviceGroupSurfacePresentModes2EXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceGroupSurfacePresentModes2EXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceGroupSurfacePresentModes2EXT = OP_vkGetDeviceGroupSurfacePresentModes2EXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceGroupSurfacePresentModes2EXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceGroupSurfacePresentModes2EXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPhysicalDeviceSurfaceInfo2KHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPhysicalDeviceSurfaceInfo2KHR*)(local_pSurfaceInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)pModes;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pModes)
    {
        memcpy(*streamPtrPtr, (VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
        *streamPtrPtr += sizeof(VkDeviceGroupPresentModeFlagsKHR);
    }
    // WARNING PTR CHECK
    VkDeviceGroupPresentModeFlagsKHR* check_pModes;
    check_pModes = (VkDeviceGroupPresentModeFlagsKHR*)(uintptr_t)stream->getBe64();
    if (pModes)
    {
        if (!(check_pModes))
        {
            fprintf(stderr, "fatal: pModes inconsistent between guest and host\n");
        }
        stream->read((VkDeviceGroupPresentModeFlagsKHR*)pModes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
    }
    VkResult vkGetDeviceGroupSurfacePresentModes2EXT_VkResult_return = (VkResult)0;
    stream->read(&vkGetDeviceGroupSurfacePresentModes2EXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetDeviceGroupSurfacePresentModes2EXT_VkResult_return;
}

#endif
#ifdef VK_EXT_headless_surface
VkResult VkEncoder::vkCreateHeadlessSurfaceEXT(
    VkInstance instance,
    const VkHeadlessSurfaceCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkHeadlessSurfaceCreateInfoEXT* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkHeadlessSurfaceCreateInfoEXT*)pool->alloc(sizeof(const VkHeadlessSurfaceCreateInfoEXT));
        deepcopy_VkHeadlessSurfaceCreateInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkHeadlessSurfaceCreateInfoEXT*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkHeadlessSurfaceCreateInfoEXT(sResourceTracker, (VkHeadlessSurfaceCreateInfoEXT*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkHeadlessSurfaceCreateInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkHeadlessSurfaceCreateInfoEXT*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateHeadlessSurfaceEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateHeadlessSurfaceEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateHeadlessSurfaceEXT = OP_vkCreateHeadlessSurfaceEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateHeadlessSurfaceEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateHeadlessSurfaceEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkHeadlessSurfaceCreateInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkHeadlessSurfaceCreateInfoEXT*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_3, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateHeadlessSurfaceEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreateHeadlessSurfaceEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateHeadlessSurfaceEXT_VkResult_return;
}

#endif
#ifdef VK_EXT_line_rasterization
void VkEncoder::vkCmdSetLineStippleEXT(
    VkCommandBuffer commandBuffer,
    uint32_t lineStippleFactor,
    uint16_t lineStipplePattern,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_lineStippleFactor;
    uint16_t local_lineStipplePattern;
    local_commandBuffer = commandBuffer;
    local_lineStippleFactor = lineStippleFactor;
    local_lineStipplePattern = lineStipplePattern;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint16_t);
    }
    uint32_t packetSize_vkCmdSetLineStippleEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetLineStippleEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetLineStippleEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetLineStippleEXT = OP_vkCmdSetLineStippleEXT;
    memcpy(streamPtr, &opcode_vkCmdSetLineStippleEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetLineStippleEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_lineStippleFactor, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint16_t*)&local_lineStipplePattern, sizeof(uint16_t));
    *streamPtrPtr += sizeof(uint16_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_EXT_shader_atomic_float
#endif
#ifdef VK_EXT_host_query_reset
void VkEncoder::vkResetQueryPoolEXT(
    VkDevice device,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t queryCount,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkQueryPool local_queryPool;
    uint32_t local_firstQuery;
    uint32_t local_queryCount;
    local_device = device;
    local_queryPool = queryPool;
    local_firstQuery = firstQuery;
    local_queryCount = queryCount;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkResetQueryPoolEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkResetQueryPoolEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkResetQueryPoolEXT = OP_vkResetQueryPoolEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkResetQueryPoolEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkResetQueryPoolEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstQuery, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_queryCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_EXT_index_type_uint8
#endif
#ifdef VK_EXT_extended_dynamic_state
void VkEncoder::vkCmdSetCullModeEXT(
    VkCommandBuffer commandBuffer,
    VkCullModeFlags cullMode,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCullModeFlags local_cullMode;
    local_commandBuffer = commandBuffer;
    local_cullMode = cullMode;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkCullModeFlags);
    }
    uint32_t packetSize_vkCmdSetCullModeEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetCullModeEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetCullModeEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetCullModeEXT = OP_vkCmdSetCullModeEXT;
    memcpy(streamPtr, &opcode_vkCmdSetCullModeEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetCullModeEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkCullModeFlags*)&local_cullMode, sizeof(VkCullModeFlags));
    *streamPtrPtr += sizeof(VkCullModeFlags);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetFrontFaceEXT(
    VkCommandBuffer commandBuffer,
    VkFrontFace frontFace,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkFrontFace local_frontFace;
    local_commandBuffer = commandBuffer;
    local_frontFace = frontFace;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkFrontFace);
    }
    uint32_t packetSize_vkCmdSetFrontFaceEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetFrontFaceEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetFrontFaceEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetFrontFaceEXT = OP_vkCmdSetFrontFaceEXT;
    memcpy(streamPtr, &opcode_vkCmdSetFrontFaceEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetFrontFaceEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkFrontFace*)&local_frontFace, sizeof(VkFrontFace));
    *streamPtrPtr += sizeof(VkFrontFace);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetPrimitiveTopologyEXT(
    VkCommandBuffer commandBuffer,
    VkPrimitiveTopology primitiveTopology,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPrimitiveTopology local_primitiveTopology;
    local_commandBuffer = commandBuffer;
    local_primitiveTopology = primitiveTopology;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPrimitiveTopology);
    }
    uint32_t packetSize_vkCmdSetPrimitiveTopologyEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetPrimitiveTopologyEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetPrimitiveTopologyEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetPrimitiveTopologyEXT = OP_vkCmdSetPrimitiveTopologyEXT;
    memcpy(streamPtr, &opcode_vkCmdSetPrimitiveTopologyEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetPrimitiveTopologyEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkPrimitiveTopology*)&local_primitiveTopology, sizeof(VkPrimitiveTopology));
    *streamPtrPtr += sizeof(VkPrimitiveTopology);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetViewportWithCountEXT(
    VkCommandBuffer commandBuffer,
    uint32_t viewportCount,
    const VkViewport* pViewports,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_viewportCount;
    VkViewport* local_pViewports;
    local_commandBuffer = commandBuffer;
    local_viewportCount = viewportCount;
    local_pViewports = nullptr;
    if (pViewports)
    {
        local_pViewports = (VkViewport*)pool->alloc(((viewportCount)) * sizeof(const VkViewport));
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            deepcopy_VkViewport(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pViewports + i, (VkViewport*)(local_pViewports + i));
        }
    }
    if (local_pViewports)
    {
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            transform_tohost_VkViewport(sResourceTracker, (VkViewport*)(local_pViewports + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
        {
            count_VkViewport(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkViewport*)(local_pViewports + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdSetViewportWithCountEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetViewportWithCountEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetViewportWithCountEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetViewportWithCountEXT = OP_vkCmdSetViewportWithCountEXT;
    memcpy(streamPtr, &opcode_vkCmdSetViewportWithCountEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetViewportWithCountEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_viewportCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((viewportCount)); ++i)
    {
        reservedmarshal_VkViewport(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkViewport*)(local_pViewports + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetScissorWithCountEXT(
    VkCommandBuffer commandBuffer,
    uint32_t scissorCount,
    const VkRect2D* pScissors,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_scissorCount;
    VkRect2D* local_pScissors;
    local_commandBuffer = commandBuffer;
    local_scissorCount = scissorCount;
    local_pScissors = nullptr;
    if (pScissors)
    {
        local_pScissors = (VkRect2D*)pool->alloc(((scissorCount)) * sizeof(const VkRect2D));
        for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
        {
            deepcopy_VkRect2D(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pScissors + i, (VkRect2D*)(local_pScissors + i));
        }
    }
    if (local_pScissors)
    {
        for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
        {
            transform_tohost_VkRect2D(sResourceTracker, (VkRect2D*)(local_pScissors + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
        {
            count_VkRect2D(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRect2D*)(local_pScissors + i), countPtr);
        }
    }
    uint32_t packetSize_vkCmdSetScissorWithCountEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetScissorWithCountEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetScissorWithCountEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetScissorWithCountEXT = OP_vkCmdSetScissorWithCountEXT;
    memcpy(streamPtr, &opcode_vkCmdSetScissorWithCountEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetScissorWithCountEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_scissorCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((scissorCount)); ++i)
    {
        reservedmarshal_VkRect2D(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRect2D*)(local_pScissors + i), streamPtrPtr);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBindVertexBuffers2EXT(
    VkCommandBuffer commandBuffer,
    uint32_t firstBinding,
    uint32_t bindingCount,
    const VkBuffer* pBuffers,
    const VkDeviceSize* pOffsets,
    const VkDeviceSize* pSizes,
    const VkDeviceSize* pStrides,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_firstBinding;
    uint32_t local_bindingCount;
    VkBuffer* local_pBuffers;
    VkDeviceSize* local_pOffsets;
    VkDeviceSize* local_pSizes;
    VkDeviceSize* local_pStrides;
    local_commandBuffer = commandBuffer;
    local_firstBinding = firstBinding;
    local_bindingCount = bindingCount;
    // Avoiding deepcopy for pBuffers
    local_pBuffers = (VkBuffer*)pBuffers;
    // Avoiding deepcopy for pOffsets
    local_pOffsets = (VkDeviceSize*)pOffsets;
    // Avoiding deepcopy for pSizes
    local_pSizes = (VkDeviceSize*)pSizes;
    // Avoiding deepcopy for pStrides
    local_pStrides = (VkDeviceSize*)pStrides;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        if (((bindingCount)))
        {
            *countPtr += ((bindingCount)) * 8;
        }
        *countPtr += ((bindingCount)) * sizeof(VkDeviceSize);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pSizes)
        {
            *countPtr += ((bindingCount)) * sizeof(VkDeviceSize);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pStrides)
        {
            *countPtr += ((bindingCount)) * sizeof(VkDeviceSize);
        }
    }
    uint32_t packetSize_vkCmdBindVertexBuffers2EXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBindVertexBuffers2EXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBindVertexBuffers2EXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBindVertexBuffers2EXT = OP_vkCmdBindVertexBuffers2EXT;
    memcpy(streamPtr, &opcode_vkCmdBindVertexBuffers2EXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBindVertexBuffers2EXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstBinding, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_bindingCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((bindingCount)))
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((bindingCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkBuffer(local_pBuffers[k]);
            memcpy(cgen_var_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((bindingCount));
    }
    memcpy(*streamPtrPtr, (VkDeviceSize*)local_pOffsets, ((bindingCount)) * sizeof(VkDeviceSize));
    *streamPtrPtr += ((bindingCount)) * sizeof(VkDeviceSize);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pSizes;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pSizes)
    {
        memcpy(*streamPtrPtr, (VkDeviceSize*)local_pSizes, ((bindingCount)) * sizeof(VkDeviceSize));
        *streamPtrPtr += ((bindingCount)) * sizeof(VkDeviceSize);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pStrides;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pStrides)
    {
        memcpy(*streamPtrPtr, (VkDeviceSize*)local_pStrides, ((bindingCount)) * sizeof(VkDeviceSize));
        *streamPtrPtr += ((bindingCount)) * sizeof(VkDeviceSize);
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetDepthTestEnableEXT(
    VkCommandBuffer commandBuffer,
    VkBool32 depthTestEnable,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBool32 local_depthTestEnable;
    local_commandBuffer = commandBuffer;
    local_depthTestEnable = depthTestEnable;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkBool32);
    }
    uint32_t packetSize_vkCmdSetDepthTestEnableEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetDepthTestEnableEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetDepthTestEnableEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetDepthTestEnableEXT = OP_vkCmdSetDepthTestEnableEXT;
    memcpy(streamPtr, &opcode_vkCmdSetDepthTestEnableEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetDepthTestEnableEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkBool32*)&local_depthTestEnable, sizeof(VkBool32));
    *streamPtrPtr += sizeof(VkBool32);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetDepthWriteEnableEXT(
    VkCommandBuffer commandBuffer,
    VkBool32 depthWriteEnable,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBool32 local_depthWriteEnable;
    local_commandBuffer = commandBuffer;
    local_depthWriteEnable = depthWriteEnable;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkBool32);
    }
    uint32_t packetSize_vkCmdSetDepthWriteEnableEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetDepthWriteEnableEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetDepthWriteEnableEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetDepthWriteEnableEXT = OP_vkCmdSetDepthWriteEnableEXT;
    memcpy(streamPtr, &opcode_vkCmdSetDepthWriteEnableEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetDepthWriteEnableEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkBool32*)&local_depthWriteEnable, sizeof(VkBool32));
    *streamPtrPtr += sizeof(VkBool32);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetDepthCompareOpEXT(
    VkCommandBuffer commandBuffer,
    VkCompareOp depthCompareOp,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCompareOp local_depthCompareOp;
    local_commandBuffer = commandBuffer;
    local_depthCompareOp = depthCompareOp;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkCompareOp);
    }
    uint32_t packetSize_vkCmdSetDepthCompareOpEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetDepthCompareOpEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetDepthCompareOpEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetDepthCompareOpEXT = OP_vkCmdSetDepthCompareOpEXT;
    memcpy(streamPtr, &opcode_vkCmdSetDepthCompareOpEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetDepthCompareOpEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkCompareOp*)&local_depthCompareOp, sizeof(VkCompareOp));
    *streamPtrPtr += sizeof(VkCompareOp);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetDepthBoundsTestEnableEXT(
    VkCommandBuffer commandBuffer,
    VkBool32 depthBoundsTestEnable,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBool32 local_depthBoundsTestEnable;
    local_commandBuffer = commandBuffer;
    local_depthBoundsTestEnable = depthBoundsTestEnable;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkBool32);
    }
    uint32_t packetSize_vkCmdSetDepthBoundsTestEnableEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetDepthBoundsTestEnableEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetDepthBoundsTestEnableEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetDepthBoundsTestEnableEXT = OP_vkCmdSetDepthBoundsTestEnableEXT;
    memcpy(streamPtr, &opcode_vkCmdSetDepthBoundsTestEnableEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetDepthBoundsTestEnableEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkBool32*)&local_depthBoundsTestEnable, sizeof(VkBool32));
    *streamPtrPtr += sizeof(VkBool32);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetStencilTestEnableEXT(
    VkCommandBuffer commandBuffer,
    VkBool32 stencilTestEnable,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBool32 local_stencilTestEnable;
    local_commandBuffer = commandBuffer;
    local_stencilTestEnable = stencilTestEnable;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkBool32);
    }
    uint32_t packetSize_vkCmdSetStencilTestEnableEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetStencilTestEnableEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetStencilTestEnableEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetStencilTestEnableEXT = OP_vkCmdSetStencilTestEnableEXT;
    memcpy(streamPtr, &opcode_vkCmdSetStencilTestEnableEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetStencilTestEnableEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkBool32*)&local_stencilTestEnable, sizeof(VkBool32));
    *streamPtrPtr += sizeof(VkBool32);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdSetStencilOpEXT(
    VkCommandBuffer commandBuffer,
    VkStencilFaceFlags faceMask,
    VkStencilOp failOp,
    VkStencilOp passOp,
    VkStencilOp depthFailOp,
    VkCompareOp compareOp,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkStencilFaceFlags local_faceMask;
    VkStencilOp local_failOp;
    VkStencilOp local_passOp;
    VkStencilOp local_depthFailOp;
    VkCompareOp local_compareOp;
    local_commandBuffer = commandBuffer;
    local_faceMask = faceMask;
    local_failOp = failOp;
    local_passOp = passOp;
    local_depthFailOp = depthFailOp;
    local_compareOp = compareOp;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkStencilFaceFlags);
        *countPtr += sizeof(VkStencilOp);
        *countPtr += sizeof(VkStencilOp);
        *countPtr += sizeof(VkStencilOp);
        *countPtr += sizeof(VkCompareOp);
    }
    uint32_t packetSize_vkCmdSetStencilOpEXT = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetStencilOpEXT -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetStencilOpEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetStencilOpEXT = OP_vkCmdSetStencilOpEXT;
    memcpy(streamPtr, &opcode_vkCmdSetStencilOpEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetStencilOpEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkStencilFaceFlags*)&local_faceMask, sizeof(VkStencilFaceFlags));
    *streamPtrPtr += sizeof(VkStencilFaceFlags);
    memcpy(*streamPtrPtr, (VkStencilOp*)&local_failOp, sizeof(VkStencilOp));
    *streamPtrPtr += sizeof(VkStencilOp);
    memcpy(*streamPtrPtr, (VkStencilOp*)&local_passOp, sizeof(VkStencilOp));
    *streamPtrPtr += sizeof(VkStencilOp);
    memcpy(*streamPtrPtr, (VkStencilOp*)&local_depthFailOp, sizeof(VkStencilOp));
    *streamPtrPtr += sizeof(VkStencilOp);
    memcpy(*streamPtrPtr, (VkCompareOp*)&local_compareOp, sizeof(VkCompareOp));
    *streamPtrPtr += sizeof(VkCompareOp);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
#endif
#ifdef VK_NV_device_generated_commands
void VkEncoder::vkGetGeneratedCommandsMemoryRequirementsNV(
    VkDevice device,
    const VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo,
    VkMemoryRequirements2* pMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkGeneratedCommandsMemoryRequirementsInfoNV* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkGeneratedCommandsMemoryRequirementsInfoNV*)pool->alloc(sizeof(const VkGeneratedCommandsMemoryRequirementsInfoNV));
        deepcopy_VkGeneratedCommandsMemoryRequirementsInfoNV(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkGeneratedCommandsMemoryRequirementsInfoNV*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkGeneratedCommandsMemoryRequirementsInfoNV(sResourceTracker, (VkGeneratedCommandsMemoryRequirementsInfoNV*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkGeneratedCommandsMemoryRequirementsInfoNV(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkGeneratedCommandsMemoryRequirementsInfoNV*)(local_pInfo), countPtr);
        count_VkMemoryRequirements2(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements), countPtr);
    }
    uint32_t packetSize_vkGetGeneratedCommandsMemoryRequirementsNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetGeneratedCommandsMemoryRequirementsNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetGeneratedCommandsMemoryRequirementsNV = OP_vkGetGeneratedCommandsMemoryRequirementsNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetGeneratedCommandsMemoryRequirementsNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetGeneratedCommandsMemoryRequirementsNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkGeneratedCommandsMemoryRequirementsInfoNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkGeneratedCommandsMemoryRequirementsInfoNV*)(local_pInfo), streamPtrPtr);
    reservedmarshal_VkMemoryRequirements2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements), streamPtrPtr);
    unmarshal_VkMemoryRequirements2(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements2*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements2(sResourceTracker, (VkMemoryRequirements2*)(pMemoryRequirements));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdPreprocessGeneratedCommandsNV(
    VkCommandBuffer commandBuffer,
    const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkGeneratedCommandsInfoNV* local_pGeneratedCommandsInfo;
    local_commandBuffer = commandBuffer;
    local_pGeneratedCommandsInfo = nullptr;
    if (pGeneratedCommandsInfo)
    {
        local_pGeneratedCommandsInfo = (VkGeneratedCommandsInfoNV*)pool->alloc(sizeof(const VkGeneratedCommandsInfoNV));
        deepcopy_VkGeneratedCommandsInfoNV(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pGeneratedCommandsInfo, (VkGeneratedCommandsInfoNV*)(local_pGeneratedCommandsInfo));
    }
    if (local_pGeneratedCommandsInfo)
    {
        transform_tohost_VkGeneratedCommandsInfoNV(sResourceTracker, (VkGeneratedCommandsInfoNV*)(local_pGeneratedCommandsInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkGeneratedCommandsInfoNV(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkGeneratedCommandsInfoNV*)(local_pGeneratedCommandsInfo), countPtr);
    }
    uint32_t packetSize_vkCmdPreprocessGeneratedCommandsNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdPreprocessGeneratedCommandsNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdPreprocessGeneratedCommandsNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdPreprocessGeneratedCommandsNV = OP_vkCmdPreprocessGeneratedCommandsNV;
    memcpy(streamPtr, &opcode_vkCmdPreprocessGeneratedCommandsNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdPreprocessGeneratedCommandsNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkGeneratedCommandsInfoNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkGeneratedCommandsInfoNV*)(local_pGeneratedCommandsInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdExecuteGeneratedCommandsNV(
    VkCommandBuffer commandBuffer,
    VkBool32 isPreprocessed,
    const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkBool32 local_isPreprocessed;
    VkGeneratedCommandsInfoNV* local_pGeneratedCommandsInfo;
    local_commandBuffer = commandBuffer;
    local_isPreprocessed = isPreprocessed;
    local_pGeneratedCommandsInfo = nullptr;
    if (pGeneratedCommandsInfo)
    {
        local_pGeneratedCommandsInfo = (VkGeneratedCommandsInfoNV*)pool->alloc(sizeof(const VkGeneratedCommandsInfoNV));
        deepcopy_VkGeneratedCommandsInfoNV(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pGeneratedCommandsInfo, (VkGeneratedCommandsInfoNV*)(local_pGeneratedCommandsInfo));
    }
    if (local_pGeneratedCommandsInfo)
    {
        transform_tohost_VkGeneratedCommandsInfoNV(sResourceTracker, (VkGeneratedCommandsInfoNV*)(local_pGeneratedCommandsInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkBool32);
        count_VkGeneratedCommandsInfoNV(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkGeneratedCommandsInfoNV*)(local_pGeneratedCommandsInfo), countPtr);
    }
    uint32_t packetSize_vkCmdExecuteGeneratedCommandsNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdExecuteGeneratedCommandsNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdExecuteGeneratedCommandsNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdExecuteGeneratedCommandsNV = OP_vkCmdExecuteGeneratedCommandsNV;
    memcpy(streamPtr, &opcode_vkCmdExecuteGeneratedCommandsNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdExecuteGeneratedCommandsNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkBool32*)&local_isPreprocessed, sizeof(VkBool32));
    *streamPtrPtr += sizeof(VkBool32);
    reservedmarshal_VkGeneratedCommandsInfoNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkGeneratedCommandsInfoNV*)(local_pGeneratedCommandsInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBindPipelineShaderGroupNV(
    VkCommandBuffer commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipeline pipeline,
    uint32_t groupIndex,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkPipelineBindPoint local_pipelineBindPoint;
    VkPipeline local_pipeline;
    uint32_t local_groupIndex;
    local_commandBuffer = commandBuffer;
    local_pipelineBindPoint = pipelineBindPoint;
    local_pipeline = pipeline;
    local_groupIndex = groupIndex;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkPipelineBindPoint);
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdBindPipelineShaderGroupNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBindPipelineShaderGroupNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBindPipelineShaderGroupNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBindPipelineShaderGroupNV = OP_vkCmdBindPipelineShaderGroupNV;
    memcpy(streamPtr, &opcode_vkCmdBindPipelineShaderGroupNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBindPipelineShaderGroupNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkPipelineBindPoint*)&local_pipelineBindPoint, sizeof(VkPipelineBindPoint));
    *streamPtrPtr += sizeof(VkPipelineBindPoint);
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPipeline((*&local_pipeline));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateIndirectCommandsLayoutNV(
    VkDevice device,
    const VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkIndirectCommandsLayoutNV* pIndirectCommandsLayout,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkIndirectCommandsLayoutCreateInfoNV* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkIndirectCommandsLayoutCreateInfoNV*)pool->alloc(sizeof(const VkIndirectCommandsLayoutCreateInfoNV));
        deepcopy_VkIndirectCommandsLayoutCreateInfoNV(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkIndirectCommandsLayoutCreateInfoNV*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkIndirectCommandsLayoutCreateInfoNV(sResourceTracker, (VkIndirectCommandsLayoutCreateInfoNV*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkIndirectCommandsLayoutCreateInfoNV(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkIndirectCommandsLayoutCreateInfoNV*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateIndirectCommandsLayoutNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateIndirectCommandsLayoutNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateIndirectCommandsLayoutNV = OP_vkCreateIndirectCommandsLayoutNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateIndirectCommandsLayoutNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateIndirectCommandsLayoutNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkIndirectCommandsLayoutCreateInfoNV(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkIndirectCommandsLayoutCreateInfoNV*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pIndirectCommandsLayout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkIndirectCommandsLayoutNV(&cgen_var_3, (VkIndirectCommandsLayoutNV*)pIndirectCommandsLayout, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateIndirectCommandsLayoutNV_VkResult_return = (VkResult)0;
    stream->read(&vkCreateIndirectCommandsLayoutNV_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateIndirectCommandsLayoutNV_VkResult_return;
}

void VkEncoder::vkDestroyIndirectCommandsLayoutNV(
    VkDevice device,
    VkIndirectCommandsLayoutNV indirectCommandsLayout,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkIndirectCommandsLayoutNV local_indirectCommandsLayout;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_indirectCommandsLayout = indirectCommandsLayout;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyIndirectCommandsLayoutNV = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyIndirectCommandsLayoutNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyIndirectCommandsLayoutNV = OP_vkDestroyIndirectCommandsLayoutNV;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyIndirectCommandsLayoutNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyIndirectCommandsLayoutNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkIndirectCommandsLayoutNV((*&local_indirectCommandsLayout));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkIndirectCommandsLayoutNV((VkIndirectCommandsLayoutNV*)&indirectCommandsLayout);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_EXT_texel_buffer_alignment
#endif
#ifdef VK_QCOM_render_pass_transform
#endif
#ifdef VK_EXT_device_memory_report
#endif
#ifdef VK_EXT_robustness2
#endif
#ifdef VK_EXT_custom_border_color
#endif
#ifdef VK_GOOGLE_user_type
#endif
#ifdef VK_EXT_private_data
VkResult VkEncoder::vkCreatePrivateDataSlotEXT(
    VkDevice device,
    const VkPrivateDataSlotCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkPrivateDataSlotEXT* pPrivateDataSlot,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPrivateDataSlotCreateInfoEXT* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkPrivateDataSlotCreateInfoEXT*)pool->alloc(sizeof(const VkPrivateDataSlotCreateInfoEXT));
        deepcopy_VkPrivateDataSlotCreateInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkPrivateDataSlotCreateInfoEXT*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkPrivateDataSlotCreateInfoEXT(sResourceTracker, (VkPrivateDataSlotCreateInfoEXT*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkPrivateDataSlotCreateInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPrivateDataSlotCreateInfoEXT*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreatePrivateDataSlotEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreatePrivateDataSlotEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreatePrivateDataSlotEXT = OP_vkCreatePrivateDataSlotEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreatePrivateDataSlotEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreatePrivateDataSlotEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkPrivateDataSlotCreateInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkPrivateDataSlotCreateInfoEXT*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    uint64_t cgen_var_2 = (uint64_t)(*pPrivateDataSlot);
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    (*pPrivateDataSlot) = (VkPrivateDataSlotEXT)stream->getBe64();
    VkResult vkCreatePrivateDataSlotEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreatePrivateDataSlotEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreatePrivateDataSlotEXT_VkResult_return;
}

void VkEncoder::vkDestroyPrivateDataSlotEXT(
    VkDevice device,
    VkPrivateDataSlotEXT privateDataSlot,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPrivateDataSlotEXT local_privateDataSlot;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_privateDataSlot = privateDataSlot;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyPrivateDataSlotEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyPrivateDataSlotEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyPrivateDataSlotEXT = OP_vkDestroyPrivateDataSlotEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyPrivateDataSlotEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyPrivateDataSlotEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1 = (uint64_t)local_privateDataSlot;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkSetPrivateDataEXT(
    VkDevice device,
    VkObjectType objectType,
    uint64_t objectHandle,
    VkPrivateDataSlotEXT privateDataSlot,
    uint64_t data,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkObjectType local_objectType;
    uint64_t local_objectHandle;
    VkPrivateDataSlotEXT local_privateDataSlot;
    uint64_t local_data;
    local_device = device;
    local_objectType = objectType;
    local_objectHandle = objectHandle;
    local_privateDataSlot = privateDataSlot;
    local_data = data;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkObjectType);
        *countPtr += sizeof(uint64_t);
        *countPtr += 8;
        *countPtr += sizeof(uint64_t);
    }
    uint32_t packetSize_vkSetPrivateDataEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkSetPrivateDataEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkSetPrivateDataEXT = OP_vkSetPrivateDataEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkSetPrivateDataEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkSetPrivateDataEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkObjectType*)&local_objectType, sizeof(VkObjectType));
    *streamPtrPtr += sizeof(VkObjectType);
    memcpy(*streamPtrPtr, (uint64_t*)&local_objectHandle, sizeof(uint64_t));
    *streamPtrPtr += sizeof(uint64_t);
    uint64_t cgen_var_1 = (uint64_t)local_privateDataSlot;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    memcpy(*streamPtrPtr, (uint64_t*)&local_data, sizeof(uint64_t));
    *streamPtrPtr += sizeof(uint64_t);
    VkResult vkSetPrivateDataEXT_VkResult_return = (VkResult)0;
    stream->read(&vkSetPrivateDataEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkSetPrivateDataEXT_VkResult_return;
}

void VkEncoder::vkGetPrivateDataEXT(
    VkDevice device,
    VkObjectType objectType,
    uint64_t objectHandle,
    VkPrivateDataSlotEXT privateDataSlot,
    uint64_t* pData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkObjectType local_objectType;
    uint64_t local_objectHandle;
    VkPrivateDataSlotEXT local_privateDataSlot;
    local_device = device;
    local_objectType = objectType;
    local_objectHandle = objectHandle;
    local_privateDataSlot = privateDataSlot;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkObjectType);
        *countPtr += sizeof(uint64_t);
        *countPtr += 8;
        *countPtr += sizeof(uint64_t);
    }
    uint32_t packetSize_vkGetPrivateDataEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPrivateDataEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPrivateDataEXT = OP_vkGetPrivateDataEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPrivateDataEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPrivateDataEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkObjectType*)&local_objectType, sizeof(VkObjectType));
    *streamPtrPtr += sizeof(VkObjectType);
    memcpy(*streamPtrPtr, (uint64_t*)&local_objectHandle, sizeof(uint64_t));
    *streamPtrPtr += sizeof(uint64_t);
    uint64_t cgen_var_1 = (uint64_t)local_privateDataSlot;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    memcpy(*streamPtrPtr, (uint64_t*)pData, sizeof(uint64_t));
    *streamPtrPtr += sizeof(uint64_t);
    stream->read((uint64_t*)pData, sizeof(uint64_t));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_EXT_pipeline_creation_cache_control
#endif
#ifdef VK_NV_device_diagnostics_config
#endif
#ifdef VK_QCOM_render_pass_store_ops
#endif
#ifdef VK_NV_fragment_shading_rate_enums
void VkEncoder::vkCmdSetFragmentShadingRateEnumNV(
    VkCommandBuffer commandBuffer,
    VkFragmentShadingRateNV shadingRate,
    const VkFragmentShadingRateCombinerOpKHR combinerOps[2],
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkFragmentShadingRateNV local_shadingRate;
    VkFragmentShadingRateCombinerOpKHR local_combinerOps[2];
    local_commandBuffer = commandBuffer;
    local_shadingRate = shadingRate;
    memcpy(local_combinerOps, combinerOps, 2 * sizeof(const VkFragmentShadingRateCombinerOpKHR));
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkFragmentShadingRateNV);
        *countPtr += 2 * sizeof(VkFragmentShadingRateCombinerOpKHR);
    }
    uint32_t packetSize_vkCmdSetFragmentShadingRateEnumNV = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetFragmentShadingRateEnumNV -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetFragmentShadingRateEnumNV);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetFragmentShadingRateEnumNV = OP_vkCmdSetFragmentShadingRateEnumNV;
    memcpy(streamPtr, &opcode_vkCmdSetFragmentShadingRateEnumNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetFragmentShadingRateEnumNV, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkFragmentShadingRateNV*)&local_shadingRate, sizeof(VkFragmentShadingRateNV));
    *streamPtrPtr += sizeof(VkFragmentShadingRateNV);
    memcpy(*streamPtrPtr, (VkFragmentShadingRateCombinerOpKHR*)local_combinerOps, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
    *streamPtrPtr += 2 * sizeof(VkFragmentShadingRateCombinerOpKHR);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_EXT_fragment_density_map2
#endif
#ifdef VK_QCOM_rotated_copy_commands
#endif
#ifdef VK_EXT_image_robustness
#endif
#ifdef VK_EXT_4444_formats
#endif
#ifdef VK_EXT_directfb_surface
VkResult VkEncoder::vkCreateDirectFBSurfaceEXT(
    VkInstance instance,
    const VkDirectFBSurfaceCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSurfaceKHR* pSurface,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkInstance local_instance;
    VkDirectFBSurfaceCreateInfoEXT* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_instance = instance;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkDirectFBSurfaceCreateInfoEXT*)pool->alloc(sizeof(const VkDirectFBSurfaceCreateInfoEXT));
        deepcopy_VkDirectFBSurfaceCreateInfoEXT(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkDirectFBSurfaceCreateInfoEXT*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkDirectFBSurfaceCreateInfoEXT(sResourceTracker, (VkDirectFBSurfaceCreateInfoEXT*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkDirectFBSurfaceCreateInfoEXT(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDirectFBSurfaceCreateInfoEXT*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateDirectFBSurfaceEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateDirectFBSurfaceEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateDirectFBSurfaceEXT = OP_vkCreateDirectFBSurfaceEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateDirectFBSurfaceEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateDirectFBSurfaceEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkInstance((*&local_instance));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkDirectFBSurfaceCreateInfoEXT(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDirectFBSurfaceCreateInfoEXT*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pSurface));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_3, (VkSurfaceKHR*)pSurface, 1);
    VkResult vkCreateDirectFBSurfaceEXT_VkResult_return = (VkResult)0;
    stream->read(&vkCreateDirectFBSurfaceEXT_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateDirectFBSurfaceEXT_VkResult_return;
}

VkBool32 VkEncoder::vkGetPhysicalDeviceDirectFBPresentationSupportEXT(
    VkPhysicalDevice physicalDevice,
    uint32_t queueFamilyIndex,
    IDirectFB* dfb,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkPhysicalDevice local_physicalDevice;
    uint32_t local_queueFamilyIndex;
    local_physicalDevice = physicalDevice;
    local_queueFamilyIndex = queueFamilyIndex;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(IDirectFB);
    }
    uint32_t packetSize_vkGetPhysicalDeviceDirectFBPresentationSupportEXT = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetPhysicalDeviceDirectFBPresentationSupportEXT);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetPhysicalDeviceDirectFBPresentationSupportEXT = OP_vkGetPhysicalDeviceDirectFBPresentationSupportEXT;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetPhysicalDeviceDirectFBPresentationSupportEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetPhysicalDeviceDirectFBPresentationSupportEXT, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkPhysicalDevice((*&local_physicalDevice));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_queueFamilyIndex, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (IDirectFB*)dfb, sizeof(IDirectFB));
    *streamPtrPtr += sizeof(IDirectFB);
    stream->read((IDirectFB*)dfb, sizeof(IDirectFB));
    VkBool32 vkGetPhysicalDeviceDirectFBPresentationSupportEXT_VkBool32_return = (VkBool32)0;
    stream->read(&vkGetPhysicalDeviceDirectFBPresentationSupportEXT_VkBool32_return, sizeof(VkBool32));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetPhysicalDeviceDirectFBPresentationSupportEXT_VkBool32_return;
}

#endif
#ifdef VK_GOOGLE_gfxstream
VkResult VkEncoder::vkRegisterImageColorBufferGOOGLE(
    VkDevice device,
    VkImage image,
    uint32_t colorBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImage local_image;
    uint32_t local_colorBuffer;
    local_device = device;
    local_image = image;
    local_colorBuffer = colorBuffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkRegisterImageColorBufferGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkRegisterImageColorBufferGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkRegisterImageColorBufferGOOGLE = OP_vkRegisterImageColorBufferGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkRegisterImageColorBufferGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkRegisterImageColorBufferGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkImage((*&local_image));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_colorBuffer, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    VkResult vkRegisterImageColorBufferGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterImageColorBufferGOOGLE_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkRegisterImageColorBufferGOOGLE_VkResult_return;
}

VkResult VkEncoder::vkRegisterBufferColorBufferGOOGLE(
    VkDevice device,
    VkBuffer buffer,
    uint32_t colorBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBuffer local_buffer;
    uint32_t local_colorBuffer;
    local_device = device;
    local_buffer = buffer;
    local_colorBuffer = colorBuffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkRegisterBufferColorBufferGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkRegisterBufferColorBufferGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkRegisterBufferColorBufferGOOGLE = OP_vkRegisterBufferColorBufferGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkRegisterBufferColorBufferGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkRegisterBufferColorBufferGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkBuffer((*&local_buffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_colorBuffer, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    VkResult vkRegisterBufferColorBufferGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkRegisterBufferColorBufferGOOGLE_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkRegisterBufferColorBufferGOOGLE_VkResult_return;
}

VkResult VkEncoder::vkMapMemoryIntoAddressSpaceGOOGLE(
    VkDevice device,
    VkDeviceMemory memory,
    uint64_t* pAddress,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    sResourceTracker->on_vkMapMemoryIntoAddressSpaceGOOGLE_pre(this, VK_SUCCESS, device, memory, pAddress);
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeviceMemory local_memory;
    local_device = device;
    local_memory = memory;
    sResourceTracker->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)nullptr, 0, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pAddress)
        {
            *countPtr += sizeof(uint64_t);
        }
    }
    uint32_t packetSize_vkMapMemoryIntoAddressSpaceGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkMapMemoryIntoAddressSpaceGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkMapMemoryIntoAddressSpaceGOOGLE = OP_vkMapMemoryIntoAddressSpaceGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkMapMemoryIntoAddressSpaceGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkMapMemoryIntoAddressSpaceGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDeviceMemory((*&local_memory));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pAddress;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pAddress)
    {
        memcpy(*streamPtrPtr, (uint64_t*)pAddress, sizeof(uint64_t));
        *streamPtrPtr += sizeof(uint64_t);
    }
    // WARNING PTR CHECK
    uint64_t* check_pAddress;
    check_pAddress = (uint64_t*)(uintptr_t)stream->getBe64();
    if (pAddress)
    {
        if (!(check_pAddress))
        {
            fprintf(stderr, "fatal: pAddress inconsistent between guest and host\n");
        }
        stream->read((uint64_t*)pAddress, sizeof(uint64_t));
    }
    VkResult vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return, sizeof(VkResult));
    sResourceTracker->on_vkMapMemoryIntoAddressSpaceGOOGLE(this, vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return, device, memory, pAddress);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkMapMemoryIntoAddressSpaceGOOGLE_VkResult_return;
}

void VkEncoder::vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
    VkDevice device,
    VkDescriptorSet descriptorSet,
    VkDescriptorUpdateTemplate descriptorUpdateTemplate,
    uint32_t imageInfoCount,
    uint32_t bufferInfoCount,
    uint32_t bufferViewCount,
    const uint32_t* pImageInfoEntryIndices,
    const uint32_t* pBufferInfoEntryIndices,
    const uint32_t* pBufferViewEntryIndices,
    const VkDescriptorImageInfo* pImageInfos,
    const VkDescriptorBufferInfo* pBufferInfos,
    const VkBufferView* pBufferViews,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorSet local_descriptorSet;
    VkDescriptorUpdateTemplate local_descriptorUpdateTemplate;
    uint32_t local_imageInfoCount;
    uint32_t local_bufferInfoCount;
    uint32_t local_bufferViewCount;
    uint32_t* local_pImageInfoEntryIndices;
    uint32_t* local_pBufferInfoEntryIndices;
    uint32_t* local_pBufferViewEntryIndices;
    VkDescriptorImageInfo* local_pImageInfos;
    VkDescriptorBufferInfo* local_pBufferInfos;
    VkBufferView* local_pBufferViews;
    local_device = device;
    local_descriptorSet = descriptorSet;
    local_descriptorUpdateTemplate = descriptorUpdateTemplate;
    local_imageInfoCount = imageInfoCount;
    local_bufferInfoCount = bufferInfoCount;
    local_bufferViewCount = bufferViewCount;
    // Avoiding deepcopy for pImageInfoEntryIndices
    local_pImageInfoEntryIndices = (uint32_t*)pImageInfoEntryIndices;
    // Avoiding deepcopy for pBufferInfoEntryIndices
    local_pBufferInfoEntryIndices = (uint32_t*)pBufferInfoEntryIndices;
    // Avoiding deepcopy for pBufferViewEntryIndices
    local_pBufferViewEntryIndices = (uint32_t*)pBufferViewEntryIndices;
    local_pImageInfos = nullptr;
    if (pImageInfos)
    {
        local_pImageInfos = (VkDescriptorImageInfo*)pool->alloc(((imageInfoCount)) * sizeof(const VkDescriptorImageInfo));
        for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
        {
            deepcopy_VkDescriptorImageInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pImageInfos + i, (VkDescriptorImageInfo*)(local_pImageInfos + i));
        }
    }
    local_pBufferInfos = nullptr;
    if (pBufferInfos)
    {
        local_pBufferInfos = (VkDescriptorBufferInfo*)pool->alloc(((bufferInfoCount)) * sizeof(const VkDescriptorBufferInfo));
        for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
        {
            deepcopy_VkDescriptorBufferInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pBufferInfos + i, (VkDescriptorBufferInfo*)(local_pBufferInfos + i));
        }
    }
    // Avoiding deepcopy for pBufferViews
    local_pBufferViews = (VkBufferView*)pBufferViews;
    if (local_pImageInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
        {
            transform_tohost_VkDescriptorImageInfo(sResourceTracker, (VkDescriptorImageInfo*)(local_pImageInfos + i));
        }
    }
    if (local_pBufferInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
        {
            transform_tohost_VkDescriptorBufferInfo(sResourceTracker, (VkDescriptorBufferInfo*)(local_pBufferInfos + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pImageInfoEntryIndices)
        {
            *countPtr += ((imageInfoCount)) * sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pBufferInfoEntryIndices)
        {
            *countPtr += ((bufferInfoCount)) * sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pBufferViewEntryIndices)
        {
            *countPtr += ((bufferViewCount)) * sizeof(uint32_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pImageInfos)
        {
            for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
            {
                count_VkDescriptorImageInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorImageInfo*)(local_pImageInfos + i), countPtr);
            }
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pBufferInfos)
        {
            for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
            {
                count_VkDescriptorBufferInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorBufferInfo*)(local_pBufferInfos + i), countPtr);
            }
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pBufferViews)
        {
            if (((bufferViewCount)))
            {
                *countPtr += ((bufferViewCount)) * 8;
            }
        }
    }
    uint32_t packetSize_vkUpdateDescriptorSetWithTemplateSizedGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkUpdateDescriptorSetWithTemplateSizedGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkUpdateDescriptorSetWithTemplateSizedGOOGLE = OP_vkUpdateDescriptorSetWithTemplateSizedGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkUpdateDescriptorSetWithTemplateSizedGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkUpdateDescriptorSetWithTemplateSizedGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDescriptorSet((*&local_descriptorSet));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_2;
    *&cgen_var_2 = get_host_u64_VkDescriptorUpdateTemplate((*&local_descriptorUpdateTemplate));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_imageInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_bufferInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_bufferViewCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)local_pImageInfoEntryIndices;
    memcpy((*streamPtrPtr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pImageInfoEntryIndices)
    {
        memcpy(*streamPtrPtr, (uint32_t*)local_pImageInfoEntryIndices, ((imageInfoCount)) * sizeof(uint32_t));
        *streamPtrPtr += ((imageInfoCount)) * sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_4 = (uint64_t)(uintptr_t)local_pBufferInfoEntryIndices;
    memcpy((*streamPtrPtr), &cgen_var_4, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pBufferInfoEntryIndices)
    {
        memcpy(*streamPtrPtr, (uint32_t*)local_pBufferInfoEntryIndices, ((bufferInfoCount)) * sizeof(uint32_t));
        *streamPtrPtr += ((bufferInfoCount)) * sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_5 = (uint64_t)(uintptr_t)local_pBufferViewEntryIndices;
    memcpy((*streamPtrPtr), &cgen_var_5, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pBufferViewEntryIndices)
    {
        memcpy(*streamPtrPtr, (uint32_t*)local_pBufferViewEntryIndices, ((bufferViewCount)) * sizeof(uint32_t));
        *streamPtrPtr += ((bufferViewCount)) * sizeof(uint32_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_6 = (uint64_t)(uintptr_t)local_pImageInfos;
    memcpy((*streamPtrPtr), &cgen_var_6, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pImageInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((imageInfoCount)); ++i)
        {
            reservedmarshal_VkDescriptorImageInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorImageInfo*)(local_pImageInfos + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_7 = (uint64_t)(uintptr_t)local_pBufferInfos;
    memcpy((*streamPtrPtr), &cgen_var_7, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pBufferInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((bufferInfoCount)); ++i)
        {
            reservedmarshal_VkDescriptorBufferInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkDescriptorBufferInfo*)(local_pBufferInfos + i), streamPtrPtr);
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_8 = (uint64_t)(uintptr_t)local_pBufferViews;
    memcpy((*streamPtrPtr), &cgen_var_8, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pBufferViews)
    {
        if (((bufferViewCount)))
        {
            uint8_t* cgen_var_8_0_ptr = (uint8_t*)(*streamPtrPtr);
            for (uint32_t k = 0; k < ((bufferViewCount)); ++k)
            {
                uint64_t tmpval = get_host_u64_VkBufferView(local_pBufferViews[k]);
                memcpy(cgen_var_8_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
            }
            *streamPtrPtr += 8 * ((bufferViewCount));
        }
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkBeginCommandBufferAsyncGOOGLE(
    VkCommandBuffer commandBuffer,
    const VkCommandBufferBeginInfo* pBeginInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCommandBufferBeginInfo* local_pBeginInfo;
    local_commandBuffer = commandBuffer;
    local_pBeginInfo = nullptr;
    if (pBeginInfo)
    {
        local_pBeginInfo = (VkCommandBufferBeginInfo*)pool->alloc(sizeof(const VkCommandBufferBeginInfo));
        deepcopy_VkCommandBufferBeginInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pBeginInfo, (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    }
    if (local_pBeginInfo)
    {
        transform_tohost_VkCommandBufferBeginInfo(sResourceTracker, (VkCommandBufferBeginInfo*)(local_pBeginInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkCommandBufferBeginInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCommandBufferBeginInfo*)(local_pBeginInfo), countPtr);
    }
    uint32_t packetSize_vkBeginCommandBufferAsyncGOOGLE = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkBeginCommandBufferAsyncGOOGLE -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkBeginCommandBufferAsyncGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkBeginCommandBufferAsyncGOOGLE = OP_vkBeginCommandBufferAsyncGOOGLE;
    memcpy(streamPtr, &opcode_vkBeginCommandBufferAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkBeginCommandBufferAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkCommandBufferBeginInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCommandBufferBeginInfo*)(local_pBeginInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkEndCommandBufferAsyncGOOGLE(
    VkCommandBuffer commandBuffer,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    local_commandBuffer = commandBuffer;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkEndCommandBufferAsyncGOOGLE = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkEndCommandBufferAsyncGOOGLE -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkEndCommandBufferAsyncGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkEndCommandBufferAsyncGOOGLE = OP_vkEndCommandBufferAsyncGOOGLE;
    memcpy(streamPtr, &opcode_vkEndCommandBufferAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkEndCommandBufferAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkResetCommandBufferAsyncGOOGLE(
    VkCommandBuffer commandBuffer,
    VkCommandBufferResetFlags flags,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCommandBufferResetFlags local_flags;
    local_commandBuffer = commandBuffer;
    local_flags = flags;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkCommandBufferResetFlags);
    }
    uint32_t packetSize_vkResetCommandBufferAsyncGOOGLE = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkResetCommandBufferAsyncGOOGLE -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkResetCommandBufferAsyncGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkResetCommandBufferAsyncGOOGLE = OP_vkResetCommandBufferAsyncGOOGLE;
    memcpy(streamPtr, &opcode_vkResetCommandBufferAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkResetCommandBufferAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (VkCommandBufferResetFlags*)&local_flags, sizeof(VkCommandBufferResetFlags));
    *streamPtrPtr += sizeof(VkCommandBufferResetFlags);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCommandBufferHostSyncGOOGLE(
    VkCommandBuffer commandBuffer,
    uint32_t needHostSync,
    uint32_t sequenceNumber,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_needHostSync;
    uint32_t local_sequenceNumber;
    local_commandBuffer = commandBuffer;
    local_needHostSync = needHostSync;
    local_sequenceNumber = sequenceNumber;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCommandBufferHostSyncGOOGLE = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCommandBufferHostSyncGOOGLE -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCommandBufferHostSyncGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCommandBufferHostSyncGOOGLE = OP_vkCommandBufferHostSyncGOOGLE;
    memcpy(streamPtr, &opcode_vkCommandBufferHostSyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCommandBufferHostSyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_needHostSync, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_sequenceNumber, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateImageWithRequirementsGOOGLE(
    VkDevice device,
    const VkImageCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage* pImage,
    VkMemoryRequirements* pMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkImageCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkImageCreateInfo*)pool->alloc(sizeof(const VkImageCreateInfo));
        deepcopy_VkImageCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkImageCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    sResourceTracker->unwrap_VkNativeBufferANDROID(pCreateInfo, local_pCreateInfo);
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkImageCreateInfo(sResourceTracker, (VkImageCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkImageCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
        count_VkMemoryRequirements(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements), countPtr);
    }
    uint32_t packetSize_vkCreateImageWithRequirementsGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateImageWithRequirementsGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateImageWithRequirementsGOOGLE = OP_vkCreateImageWithRequirementsGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateImageWithRequirementsGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateImageWithRequirementsGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkImageCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkImageCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pImage));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    reservedmarshal_VkMemoryRequirements(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements), streamPtrPtr);
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_3, (VkImage*)pImage, 1);
    stream->unsetHandleMapping();
    unmarshal_VkMemoryRequirements(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements(sResourceTracker, (VkMemoryRequirements*)(pMemoryRequirements));
    }
    VkResult vkCreateImageWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkCreateImageWithRequirementsGOOGLE_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateImageWithRequirementsGOOGLE_VkResult_return;
}

VkResult VkEncoder::vkCreateBufferWithRequirementsGOOGLE(
    VkDevice device,
    const VkBufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBuffer* pBuffer,
    VkMemoryRequirements* pMemoryRequirements,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkBufferCreateInfo* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkBufferCreateInfo*)pool->alloc(sizeof(const VkBufferCreateInfo));
        deepcopy_VkBufferCreateInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkBufferCreateInfo*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkBufferCreateInfo(sResourceTracker, (VkBufferCreateInfo*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkBufferCreateInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferCreateInfo*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
        count_VkMemoryRequirements(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements), countPtr);
    }
    uint32_t packetSize_vkCreateBufferWithRequirementsGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateBufferWithRequirementsGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateBufferWithRequirementsGOOGLE = OP_vkCreateBufferWithRequirementsGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateBufferWithRequirementsGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateBufferWithRequirementsGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkBufferCreateInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBufferCreateInfo*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pBuffer));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    reservedmarshal_VkMemoryRequirements(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements), streamPtrPtr);
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_3, (VkBuffer*)pBuffer, 1);
    stream->unsetHandleMapping();
    unmarshal_VkMemoryRequirements(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkMemoryRequirements*)(pMemoryRequirements));
    if (pMemoryRequirements)
    {
        transform_fromhost_VkMemoryRequirements(sResourceTracker, (VkMemoryRequirements*)(pMemoryRequirements));
    }
    VkResult vkCreateBufferWithRequirementsGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkCreateBufferWithRequirementsGOOGLE_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateBufferWithRequirementsGOOGLE_VkResult_return;
}

VkResult VkEncoder::vkGetMemoryHostAddressInfoGOOGLE(
    VkDevice device,
    VkDeviceMemory memory,
    uint64_t* pAddress,
    uint64_t* pSize,
    uint64_t* pHostmemId,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeviceMemory local_memory;
    local_device = device;
    local_memory = memory;
    sResourceTracker->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)nullptr, 0, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pAddress)
        {
            *countPtr += sizeof(uint64_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pSize)
        {
            *countPtr += sizeof(uint64_t);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pHostmemId)
        {
            *countPtr += sizeof(uint64_t);
        }
    }
    uint32_t packetSize_vkGetMemoryHostAddressInfoGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetMemoryHostAddressInfoGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetMemoryHostAddressInfoGOOGLE = OP_vkGetMemoryHostAddressInfoGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetMemoryHostAddressInfoGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetMemoryHostAddressInfoGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDeviceMemory((*&local_memory));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pAddress;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pAddress)
    {
        memcpy(*streamPtrPtr, (uint64_t*)pAddress, sizeof(uint64_t));
        *streamPtrPtr += sizeof(uint64_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)pSize;
    memcpy((*streamPtrPtr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pSize)
    {
        memcpy(*streamPtrPtr, (uint64_t*)pSize, sizeof(uint64_t));
        *streamPtrPtr += sizeof(uint64_t);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_4 = (uint64_t)(uintptr_t)pHostmemId;
    memcpy((*streamPtrPtr), &cgen_var_4, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pHostmemId)
    {
        memcpy(*streamPtrPtr, (uint64_t*)pHostmemId, sizeof(uint64_t));
        *streamPtrPtr += sizeof(uint64_t);
    }
    // WARNING PTR CHECK
    uint64_t* check_pAddress;
    check_pAddress = (uint64_t*)(uintptr_t)stream->getBe64();
    if (pAddress)
    {
        if (!(check_pAddress))
        {
            fprintf(stderr, "fatal: pAddress inconsistent between guest and host\n");
        }
        stream->read((uint64_t*)pAddress, sizeof(uint64_t));
    }
    // WARNING PTR CHECK
    uint64_t* check_pSize;
    check_pSize = (uint64_t*)(uintptr_t)stream->getBe64();
    if (pSize)
    {
        if (!(check_pSize))
        {
            fprintf(stderr, "fatal: pSize inconsistent between guest and host\n");
        }
        stream->read((uint64_t*)pSize, sizeof(uint64_t));
    }
    // WARNING PTR CHECK
    uint64_t* check_pHostmemId;
    check_pHostmemId = (uint64_t*)(uintptr_t)stream->getBe64();
    if (pHostmemId)
    {
        if (!(check_pHostmemId))
        {
            fprintf(stderr, "fatal: pHostmemId inconsistent between guest and host\n");
        }
        stream->read((uint64_t*)pHostmemId, sizeof(uint64_t));
    }
    VkResult vkGetMemoryHostAddressInfoGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkGetMemoryHostAddressInfoGOOGLE_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetMemoryHostAddressInfoGOOGLE_VkResult_return;
}

VkResult VkEncoder::vkFreeMemorySyncGOOGLE(
    VkDevice device,
    VkDeviceMemory memory,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeviceMemory local_memory;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_memory = memory;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    sResourceTracker->deviceMemoryTransform_tohost((VkDeviceMemory*)&local_memory, 1, (VkDeviceSize*)nullptr, 0, (VkDeviceSize*)nullptr, 0, (uint32_t*)nullptr, 0, (uint32_t*)nullptr, 0);
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkFreeMemorySyncGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkFreeMemorySyncGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkFreeMemorySyncGOOGLE = OP_vkFreeMemorySyncGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkFreeMemorySyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkFreeMemorySyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDeviceMemory((*&local_memory));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    VkResult vkFreeMemorySyncGOOGLE_VkResult_return = (VkResult)0;
    stream->read(&vkFreeMemorySyncGOOGLE_VkResult_return, sizeof(VkResult));
    sResourceTracker->destroyMapping()->mapHandles_VkDeviceMemory((VkDeviceMemory*)&memory);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkFreeMemorySyncGOOGLE_VkResult_return;
}

void VkEncoder::vkQueueHostSyncGOOGLE(
    VkQueue queue,
    uint32_t needHostSync,
    uint32_t sequenceNumber,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    uint32_t local_needHostSync;
    uint32_t local_sequenceNumber;
    local_queue = queue;
    local_needHostSync = needHostSync;
    local_sequenceNumber = sequenceNumber;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkQueueHostSyncGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueHostSyncGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueHostSyncGOOGLE = OP_vkQueueHostSyncGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueHostSyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueHostSyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_needHostSync, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_sequenceNumber, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkQueueSubmitAsyncGOOGLE(
    VkQueue queue,
    uint32_t submitCount,
    const VkSubmitInfo* pSubmits,
    VkFence fence,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    uint32_t local_submitCount;
    VkSubmitInfo* local_pSubmits;
    VkFence local_fence;
    local_queue = queue;
    local_submitCount = submitCount;
    local_pSubmits = nullptr;
    if (pSubmits)
    {
        local_pSubmits = (VkSubmitInfo*)pool->alloc(((submitCount)) * sizeof(const VkSubmitInfo));
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            deepcopy_VkSubmitInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pSubmits + i, (VkSubmitInfo*)(local_pSubmits + i));
        }
    }
    local_fence = fence;
    if (local_pSubmits)
    {
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            transform_tohost_VkSubmitInfo(sResourceTracker, (VkSubmitInfo*)(local_pSubmits + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
        {
            count_VkSubmitInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubmitInfo*)(local_pSubmits + i), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkQueueSubmitAsyncGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueSubmitAsyncGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueSubmitAsyncGOOGLE = OP_vkQueueSubmitAsyncGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueSubmitAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueSubmitAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_submitCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((submitCount)); ++i)
    {
        reservedmarshal_VkSubmitInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkSubmitInfo*)(local_pSubmits + i), streamPtrPtr);
    }
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkFence((*&local_fence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkQueueWaitIdleAsyncGOOGLE(
    VkQueue queue,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    local_queue = queue;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkQueueWaitIdleAsyncGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueWaitIdleAsyncGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueWaitIdleAsyncGOOGLE = OP_vkQueueWaitIdleAsyncGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueWaitIdleAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueWaitIdleAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkQueueBindSparseAsyncGOOGLE(
    VkQueue queue,
    uint32_t bindInfoCount,
    const VkBindSparseInfo* pBindInfo,
    VkFence fence,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    uint32_t local_bindInfoCount;
    VkBindSparseInfo* local_pBindInfo;
    VkFence local_fence;
    local_queue = queue;
    local_bindInfoCount = bindInfoCount;
    local_pBindInfo = nullptr;
    if (pBindInfo)
    {
        local_pBindInfo = (VkBindSparseInfo*)pool->alloc(((bindInfoCount)) * sizeof(const VkBindSparseInfo));
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            deepcopy_VkBindSparseInfo(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pBindInfo + i, (VkBindSparseInfo*)(local_pBindInfo + i));
        }
    }
    local_fence = fence;
    if (local_pBindInfo)
    {
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            transform_tohost_VkBindSparseInfo(sResourceTracker, (VkBindSparseInfo*)(local_pBindInfo + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
        {
            count_VkBindSparseInfo(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindSparseInfo*)(local_pBindInfo + i), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
    }
    uint32_t packetSize_vkQueueBindSparseAsyncGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueBindSparseAsyncGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueBindSparseAsyncGOOGLE = OP_vkQueueBindSparseAsyncGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueBindSparseAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueBindSparseAsyncGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_bindInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((bindInfoCount)); ++i)
    {
        reservedmarshal_VkBindSparseInfo(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkBindSparseInfo*)(local_pBindInfo + i), streamPtrPtr);
    }
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkFence((*&local_fence));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetLinearImageLayoutGOOGLE(
    VkDevice device,
    VkFormat format,
    VkDeviceSize* pOffset,
    VkDeviceSize* pRowPitchAlignment,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkFormat local_format;
    local_device = device;
    local_format = format;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkFormat);
        *countPtr += sizeof(VkDeviceSize);
        *countPtr += sizeof(VkDeviceSize);
    }
    uint32_t packetSize_vkGetLinearImageLayoutGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetLinearImageLayoutGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetLinearImageLayoutGOOGLE = OP_vkGetLinearImageLayoutGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetLinearImageLayoutGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetLinearImageLayoutGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkFormat*)&local_format, sizeof(VkFormat));
    *streamPtrPtr += sizeof(VkFormat);
    memcpy(*streamPtrPtr, (VkDeviceSize*)pOffset, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    memcpy(*streamPtrPtr, (VkDeviceSize*)pRowPitchAlignment, sizeof(VkDeviceSize));
    *streamPtrPtr += sizeof(VkDeviceSize);
    stream->read((VkDeviceSize*)pOffset, sizeof(VkDeviceSize));
    stream->read((VkDeviceSize*)pRowPitchAlignment, sizeof(VkDeviceSize));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkQueueFlushCommandsGOOGLE(
    VkQueue queue,
    VkCommandBuffer commandBuffer,
    VkDeviceSize dataSize,
    const void* pData,
    uint32_t doLock)
{
    #include "vkQueueFlushCommandsGOOGLE_encode_impl.cpp.inl"
}

void VkEncoder::vkQueueCommitDescriptorSetUpdatesGOOGLE(
    VkQueue queue,
    uint32_t descriptorPoolCount,
    const VkDescriptorPool* pDescriptorPools,
    uint32_t descriptorSetCount,
    const VkDescriptorSetLayout* pSetLayouts,
    const uint64_t* pDescriptorSetPoolIds,
    const uint32_t* pDescriptorSetWhichPool,
    const uint32_t* pDescriptorSetPendingAllocation,
    const uint32_t* pDescriptorWriteStartingIndices,
    uint32_t pendingDescriptorWriteCount,
    const VkWriteDescriptorSet* pPendingDescriptorWrites,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkQueue local_queue;
    uint32_t local_descriptorPoolCount;
    VkDescriptorPool* local_pDescriptorPools;
    uint32_t local_descriptorSetCount;
    VkDescriptorSetLayout* local_pSetLayouts;
    uint64_t* local_pDescriptorSetPoolIds;
    uint32_t* local_pDescriptorSetWhichPool;
    uint32_t* local_pDescriptorSetPendingAllocation;
    uint32_t* local_pDescriptorWriteStartingIndices;
    uint32_t local_pendingDescriptorWriteCount;
    VkWriteDescriptorSet* local_pPendingDescriptorWrites;
    local_queue = queue;
    local_descriptorPoolCount = descriptorPoolCount;
    // Avoiding deepcopy for pDescriptorPools
    local_pDescriptorPools = (VkDescriptorPool*)pDescriptorPools;
    local_descriptorSetCount = descriptorSetCount;
    // Avoiding deepcopy for pSetLayouts
    local_pSetLayouts = (VkDescriptorSetLayout*)pSetLayouts;
    // Avoiding deepcopy for pDescriptorSetPoolIds
    local_pDescriptorSetPoolIds = (uint64_t*)pDescriptorSetPoolIds;
    // Avoiding deepcopy for pDescriptorSetWhichPool
    local_pDescriptorSetWhichPool = (uint32_t*)pDescriptorSetWhichPool;
    // Avoiding deepcopy for pDescriptorSetPendingAllocation
    local_pDescriptorSetPendingAllocation = (uint32_t*)pDescriptorSetPendingAllocation;
    // Avoiding deepcopy for pDescriptorWriteStartingIndices
    local_pDescriptorWriteStartingIndices = (uint32_t*)pDescriptorWriteStartingIndices;
    local_pendingDescriptorWriteCount = pendingDescriptorWriteCount;
    local_pPendingDescriptorWrites = nullptr;
    if (pPendingDescriptorWrites)
    {
        local_pPendingDescriptorWrites = (VkWriteDescriptorSet*)pool->alloc(((pendingDescriptorWriteCount)) * sizeof(const VkWriteDescriptorSet));
        for (uint32_t i = 0; i < (uint32_t)((pendingDescriptorWriteCount)); ++i)
        {
            deepcopy_VkWriteDescriptorSet(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pPendingDescriptorWrites + i, (VkWriteDescriptorSet*)(local_pPendingDescriptorWrites + i));
        }
    }
    if (local_pPendingDescriptorWrites)
    {
        for (uint32_t i = 0; i < (uint32_t)((pendingDescriptorWriteCount)); ++i)
        {
            transform_tohost_VkWriteDescriptorSet(sResourceTracker, (VkWriteDescriptorSet*)(local_pPendingDescriptorWrites + i));
        }
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        if (((descriptorPoolCount)))
        {
            *countPtr += ((descriptorPoolCount)) * 8;
        }
        *countPtr += sizeof(uint32_t);
        if (((descriptorSetCount)))
        {
            *countPtr += ((descriptorSetCount)) * 8;
        }
        *countPtr += ((descriptorSetCount)) * sizeof(uint64_t);
        *countPtr += ((descriptorSetCount)) * sizeof(uint32_t);
        *countPtr += ((descriptorSetCount)) * sizeof(uint32_t);
        *countPtr += ((descriptorSetCount)) * sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((pendingDescriptorWriteCount)); ++i)
        {
            count_VkWriteDescriptorSet(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkWriteDescriptorSet*)(local_pPendingDescriptorWrites + i), countPtr);
        }
    }
    uint32_t packetSize_vkQueueCommitDescriptorSetUpdatesGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkQueueCommitDescriptorSetUpdatesGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkQueueCommitDescriptorSetUpdatesGOOGLE = OP_vkQueueCommitDescriptorSetUpdatesGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkQueueCommitDescriptorSetUpdatesGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkQueueCommitDescriptorSetUpdatesGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkQueue((*&local_queue));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_descriptorPoolCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((descriptorPoolCount)))
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((descriptorPoolCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkDescriptorPool(local_pDescriptorPools[k]);
            memcpy(cgen_var_1_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((descriptorPoolCount));
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_descriptorSetCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((descriptorSetCount)))
    {
        uint8_t* cgen_var_2_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((descriptorSetCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkDescriptorSetLayout(local_pSetLayouts[k]);
            memcpy(cgen_var_2_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((descriptorSetCount));
    }
    memcpy(*streamPtrPtr, (uint64_t*)local_pDescriptorSetPoolIds, ((descriptorSetCount)) * sizeof(uint64_t));
    *streamPtrPtr += ((descriptorSetCount)) * sizeof(uint64_t);
    memcpy(*streamPtrPtr, (uint32_t*)local_pDescriptorSetWhichPool, ((descriptorSetCount)) * sizeof(uint32_t));
    *streamPtrPtr += ((descriptorSetCount)) * sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)local_pDescriptorSetPendingAllocation, ((descriptorSetCount)) * sizeof(uint32_t));
    *streamPtrPtr += ((descriptorSetCount)) * sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)local_pDescriptorWriteStartingIndices, ((descriptorSetCount)) * sizeof(uint32_t));
    *streamPtrPtr += ((descriptorSetCount)) * sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_pendingDescriptorWriteCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((pendingDescriptorWriteCount)); ++i)
    {
        reservedmarshal_VkWriteDescriptorSet(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkWriteDescriptorSet*)(local_pPendingDescriptorWrites + i), streamPtrPtr);
    }
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCollectDescriptorPoolIdsGOOGLE(
    VkDevice device,
    VkDescriptorPool descriptorPool,
    uint32_t* pPoolIdCount,
    uint64_t* pPoolIds,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDescriptorPool local_descriptorPool;
    local_device = device;
    local_descriptorPool = descriptorPool;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (pPoolIds)
        {
            if (pPoolIdCount)
            {
                *countPtr += (*(pPoolIdCount)) * sizeof(uint64_t);
            }
        }
    }
    uint32_t packetSize_vkCollectDescriptorPoolIdsGOOGLE = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCollectDescriptorPoolIdsGOOGLE);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCollectDescriptorPoolIdsGOOGLE = OP_vkCollectDescriptorPoolIdsGOOGLE;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCollectDescriptorPoolIdsGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCollectDescriptorPoolIdsGOOGLE, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkDescriptorPool((*&local_descriptorPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)pPoolIdCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)pPoolIds;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (pPoolIds)
    {
        memcpy(*streamPtrPtr, (uint64_t*)pPoolIds, (*(pPoolIdCount)) * sizeof(uint64_t));
        *streamPtrPtr += (*(pPoolIdCount)) * sizeof(uint64_t);
    }
    stream->read((uint32_t*)pPoolIdCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t* check_pPoolIds;
    check_pPoolIds = (uint64_t*)(uintptr_t)stream->getBe64();
    if (pPoolIds)
    {
        if (!(check_pPoolIds))
        {
            fprintf(stderr, "fatal: pPoolIds inconsistent between guest and host\n");
        }
        stream->read((uint64_t*)pPoolIds, (*(pPoolIdCount)) * sizeof(uint64_t));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_acceleration_structure
VkResult VkEncoder::vkCreateAccelerationStructureKHR(
    VkDevice device,
    const VkAccelerationStructureCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkAccelerationStructureKHR* pAccelerationStructure,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkAccelerationStructureCreateInfoKHR* local_pCreateInfo;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_pCreateInfo = nullptr;
    if (pCreateInfo)
    {
        local_pCreateInfo = (VkAccelerationStructureCreateInfoKHR*)pool->alloc(sizeof(const VkAccelerationStructureCreateInfoKHR));
        deepcopy_VkAccelerationStructureCreateInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfo, (VkAccelerationStructureCreateInfoKHR*)(local_pCreateInfo));
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfo)
    {
        transform_tohost_VkAccelerationStructureCreateInfoKHR(sResourceTracker, (VkAccelerationStructureCreateInfoKHR*)(local_pCreateInfo));
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkAccelerationStructureCreateInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureCreateInfoKHR*)(local_pCreateInfo), countPtr);
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        uint64_t cgen_var_1;
        *countPtr += 8;
    }
    uint32_t packetSize_vkCreateAccelerationStructureKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateAccelerationStructureKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateAccelerationStructureKHR = OP_vkCreateAccelerationStructureKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateAccelerationStructureKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateAccelerationStructureKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkAccelerationStructureCreateInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureCreateInfoKHR*)(local_pCreateInfo), streamPtrPtr);
    // WARNING PTR CHECK
    uint64_t cgen_var_1 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    uint64_t cgen_var_2;
    *&cgen_var_2 = (uint64_t)((*pAccelerationStructure));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 8);
    *streamPtrPtr += 8;
    /* is handle, possibly out */;
    stream->setHandleMapping(sResourceTracker->createMapping());
    uint64_t cgen_var_3;
    stream->read((uint64_t*)&cgen_var_3, 8);
    stream->handleMapping()->mapHandles_u64_VkAccelerationStructureKHR(&cgen_var_3, (VkAccelerationStructureKHR*)pAccelerationStructure, 1);
    stream->unsetHandleMapping();
    VkResult vkCreateAccelerationStructureKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateAccelerationStructureKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateAccelerationStructureKHR_VkResult_return;
}

void VkEncoder::vkDestroyAccelerationStructureKHR(
    VkDevice device,
    VkAccelerationStructureKHR accelerationStructure,
    const VkAllocationCallbacks* pAllocator,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkAccelerationStructureKHR local_accelerationStructure;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_accelerationStructure = accelerationStructure;
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
    }
    uint32_t packetSize_vkDestroyAccelerationStructureKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkDestroyAccelerationStructureKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkDestroyAccelerationStructureKHR = OP_vkDestroyAccelerationStructureKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkDestroyAccelerationStructureKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkDestroyAccelerationStructureKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkAccelerationStructureKHR((*&local_accelerationStructure));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    sResourceTracker->destroyMapping()->mapHandles_VkAccelerationStructureKHR((VkAccelerationStructureKHR*)&accelerationStructure);
    stream->flush();
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBuildAccelerationStructuresKHR(
    VkCommandBuffer commandBuffer,
    uint32_t infoCount,
    const VkAccelerationStructureBuildGeometryInfoKHR* pInfos,
    const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_infoCount;
    VkAccelerationStructureBuildGeometryInfoKHR* local_pInfos;
    VkAccelerationStructureBuildRangeInfoKHR** local_ppBuildRangeInfos;
    local_commandBuffer = commandBuffer;
    local_infoCount = infoCount;
    local_pInfos = nullptr;
    if (pInfos)
    {
        local_pInfos = (VkAccelerationStructureBuildGeometryInfoKHR*)pool->alloc(((infoCount)) * sizeof(const VkAccelerationStructureBuildGeometryInfoKHR));
        for (uint32_t i = 0; i < (uint32_t)((infoCount)); ++i)
        {
            deepcopy_VkAccelerationStructureBuildGeometryInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfos + i, (VkAccelerationStructureBuildGeometryInfoKHR*)(local_pInfos + i));
        }
    }
    (void)ppBuildRangeInfos;
    if (local_pInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((infoCount)); ++i)
        {
            transform_tohost_VkAccelerationStructureBuildGeometryInfoKHR(sResourceTracker, (VkAccelerationStructureBuildGeometryInfoKHR*)(local_pInfos + i));
        }
    }
    (void)local_ppBuildRangeInfos;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((infoCount)); ++i)
        {
            count_VkAccelerationStructureBuildGeometryInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureBuildGeometryInfoKHR*)(local_pInfos + i), countPtr);
        }
        (void)local_ppBuildRangeInfos;
    }
    uint32_t packetSize_vkCmdBuildAccelerationStructuresKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBuildAccelerationStructuresKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBuildAccelerationStructuresKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBuildAccelerationStructuresKHR = OP_vkCmdBuildAccelerationStructuresKHR;
    memcpy(streamPtr, &opcode_vkCmdBuildAccelerationStructuresKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBuildAccelerationStructuresKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_infoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((infoCount)); ++i)
    {
        reservedmarshal_VkAccelerationStructureBuildGeometryInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureBuildGeometryInfoKHR*)(local_pInfos + i), streamPtrPtr);
    }
    (void)local_ppBuildRangeInfos;
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdBuildAccelerationStructuresIndirectKHR(
    VkCommandBuffer commandBuffer,
    uint32_t infoCount,
    const VkAccelerationStructureBuildGeometryInfoKHR* pInfos,
    const VkDeviceAddress* pIndirectDeviceAddresses,
    const uint32_t* pIndirectStrides,
    const uint32_t* const* ppMaxPrimitiveCounts,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_infoCount;
    VkAccelerationStructureBuildGeometryInfoKHR* local_pInfos;
    VkDeviceAddress* local_pIndirectDeviceAddresses;
    uint32_t* local_pIndirectStrides;
    uint32_t** local_ppMaxPrimitiveCounts;
    local_commandBuffer = commandBuffer;
    local_infoCount = infoCount;
    local_pInfos = nullptr;
    if (pInfos)
    {
        local_pInfos = (VkAccelerationStructureBuildGeometryInfoKHR*)pool->alloc(((infoCount)) * sizeof(const VkAccelerationStructureBuildGeometryInfoKHR));
        for (uint32_t i = 0; i < (uint32_t)((infoCount)); ++i)
        {
            deepcopy_VkAccelerationStructureBuildGeometryInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfos + i, (VkAccelerationStructureBuildGeometryInfoKHR*)(local_pInfos + i));
        }
    }
    // Avoiding deepcopy for pIndirectDeviceAddresses
    local_pIndirectDeviceAddresses = (VkDeviceAddress*)pIndirectDeviceAddresses;
    // Avoiding deepcopy for pIndirectStrides
    local_pIndirectStrides = (uint32_t*)pIndirectStrides;
    (void)ppMaxPrimitiveCounts;
    if (local_pInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((infoCount)); ++i)
        {
            transform_tohost_VkAccelerationStructureBuildGeometryInfoKHR(sResourceTracker, (VkAccelerationStructureBuildGeometryInfoKHR*)(local_pInfos + i));
        }
    }
    (void)local_ppMaxPrimitiveCounts;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((infoCount)); ++i)
        {
            count_VkAccelerationStructureBuildGeometryInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureBuildGeometryInfoKHR*)(local_pInfos + i), countPtr);
        }
        *countPtr += ((infoCount)) * sizeof(VkDeviceAddress);
        *countPtr += ((infoCount)) * sizeof(uint32_t);
        (void)local_ppMaxPrimitiveCounts;
    }
    uint32_t packetSize_vkCmdBuildAccelerationStructuresIndirectKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdBuildAccelerationStructuresIndirectKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdBuildAccelerationStructuresIndirectKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdBuildAccelerationStructuresIndirectKHR = OP_vkCmdBuildAccelerationStructuresIndirectKHR;
    memcpy(streamPtr, &opcode_vkCmdBuildAccelerationStructuresIndirectKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdBuildAccelerationStructuresIndirectKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_infoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((infoCount)); ++i)
    {
        reservedmarshal_VkAccelerationStructureBuildGeometryInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureBuildGeometryInfoKHR*)(local_pInfos + i), streamPtrPtr);
    }
    memcpy(*streamPtrPtr, (VkDeviceAddress*)local_pIndirectDeviceAddresses, ((infoCount)) * sizeof(VkDeviceAddress));
    *streamPtrPtr += ((infoCount)) * sizeof(VkDeviceAddress);
    memcpy(*streamPtrPtr, (uint32_t*)local_pIndirectStrides, ((infoCount)) * sizeof(uint32_t));
    *streamPtrPtr += ((infoCount)) * sizeof(uint32_t);
    (void)local_ppMaxPrimitiveCounts;
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkBuildAccelerationStructuresKHR(
    VkDevice device,
    VkDeferredOperationKHR deferredOperation,
    uint32_t infoCount,
    const VkAccelerationStructureBuildGeometryInfoKHR* pInfos,
    const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeferredOperationKHR local_deferredOperation;
    uint32_t local_infoCount;
    VkAccelerationStructureBuildGeometryInfoKHR* local_pInfos;
    VkAccelerationStructureBuildRangeInfoKHR** local_ppBuildRangeInfos;
    local_device = device;
    local_deferredOperation = deferredOperation;
    local_infoCount = infoCount;
    local_pInfos = nullptr;
    if (pInfos)
    {
        local_pInfos = (VkAccelerationStructureBuildGeometryInfoKHR*)pool->alloc(((infoCount)) * sizeof(const VkAccelerationStructureBuildGeometryInfoKHR));
        for (uint32_t i = 0; i < (uint32_t)((infoCount)); ++i)
        {
            deepcopy_VkAccelerationStructureBuildGeometryInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfos + i, (VkAccelerationStructureBuildGeometryInfoKHR*)(local_pInfos + i));
        }
    }
    (void)ppBuildRangeInfos;
    if (local_pInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((infoCount)); ++i)
        {
            transform_tohost_VkAccelerationStructureBuildGeometryInfoKHR(sResourceTracker, (VkAccelerationStructureBuildGeometryInfoKHR*)(local_pInfos + i));
        }
    }
    (void)local_ppBuildRangeInfos;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((infoCount)); ++i)
        {
            count_VkAccelerationStructureBuildGeometryInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureBuildGeometryInfoKHR*)(local_pInfos + i), countPtr);
        }
        (void)local_ppBuildRangeInfos;
    }
    uint32_t packetSize_vkBuildAccelerationStructuresKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkBuildAccelerationStructuresKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkBuildAccelerationStructuresKHR = OP_vkBuildAccelerationStructuresKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkBuildAccelerationStructuresKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkBuildAccelerationStructuresKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1 = (uint64_t)local_deferredOperation;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_infoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((infoCount)); ++i)
    {
        reservedmarshal_VkAccelerationStructureBuildGeometryInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureBuildGeometryInfoKHR*)(local_pInfos + i), streamPtrPtr);
    }
    (void)local_ppBuildRangeInfos;
    VkResult vkBuildAccelerationStructuresKHR_VkResult_return = (VkResult)0;
    stream->read(&vkBuildAccelerationStructuresKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkBuildAccelerationStructuresKHR_VkResult_return;
}

VkResult VkEncoder::vkCopyAccelerationStructureKHR(
    VkDevice device,
    VkDeferredOperationKHR deferredOperation,
    const VkCopyAccelerationStructureInfoKHR* pInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeferredOperationKHR local_deferredOperation;
    VkCopyAccelerationStructureInfoKHR* local_pInfo;
    local_device = device;
    local_deferredOperation = deferredOperation;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkCopyAccelerationStructureInfoKHR*)pool->alloc(sizeof(const VkCopyAccelerationStructureInfoKHR));
        deepcopy_VkCopyAccelerationStructureInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkCopyAccelerationStructureInfoKHR*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkCopyAccelerationStructureInfoKHR(sResourceTracker, (VkCopyAccelerationStructureInfoKHR*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += 8;
        count_VkCopyAccelerationStructureInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyAccelerationStructureInfoKHR*)(local_pInfo), countPtr);
    }
    uint32_t packetSize_vkCopyAccelerationStructureKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCopyAccelerationStructureKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCopyAccelerationStructureKHR = OP_vkCopyAccelerationStructureKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCopyAccelerationStructureKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCopyAccelerationStructureKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1 = (uint64_t)local_deferredOperation;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    reservedmarshal_VkCopyAccelerationStructureInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyAccelerationStructureInfoKHR*)(local_pInfo), streamPtrPtr);
    VkResult vkCopyAccelerationStructureKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCopyAccelerationStructureKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCopyAccelerationStructureKHR_VkResult_return;
}

VkResult VkEncoder::vkCopyAccelerationStructureToMemoryKHR(
    VkDevice device,
    VkDeferredOperationKHR deferredOperation,
    const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeferredOperationKHR local_deferredOperation;
    VkCopyAccelerationStructureToMemoryInfoKHR* local_pInfo;
    local_device = device;
    local_deferredOperation = deferredOperation;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkCopyAccelerationStructureToMemoryInfoKHR*)pool->alloc(sizeof(const VkCopyAccelerationStructureToMemoryInfoKHR));
        deepcopy_VkCopyAccelerationStructureToMemoryInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkCopyAccelerationStructureToMemoryInfoKHR*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkCopyAccelerationStructureToMemoryInfoKHR(sResourceTracker, (VkCopyAccelerationStructureToMemoryInfoKHR*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += 8;
        count_VkCopyAccelerationStructureToMemoryInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyAccelerationStructureToMemoryInfoKHR*)(local_pInfo), countPtr);
    }
    uint32_t packetSize_vkCopyAccelerationStructureToMemoryKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCopyAccelerationStructureToMemoryKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCopyAccelerationStructureToMemoryKHR = OP_vkCopyAccelerationStructureToMemoryKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCopyAccelerationStructureToMemoryKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCopyAccelerationStructureToMemoryKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1 = (uint64_t)local_deferredOperation;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    reservedmarshal_VkCopyAccelerationStructureToMemoryInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyAccelerationStructureToMemoryInfoKHR*)(local_pInfo), streamPtrPtr);
    VkResult vkCopyAccelerationStructureToMemoryKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCopyAccelerationStructureToMemoryKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCopyAccelerationStructureToMemoryKHR_VkResult_return;
}

VkResult VkEncoder::vkCopyMemoryToAccelerationStructureKHR(
    VkDevice device,
    VkDeferredOperationKHR deferredOperation,
    const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeferredOperationKHR local_deferredOperation;
    VkCopyMemoryToAccelerationStructureInfoKHR* local_pInfo;
    local_device = device;
    local_deferredOperation = deferredOperation;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkCopyMemoryToAccelerationStructureInfoKHR*)pool->alloc(sizeof(const VkCopyMemoryToAccelerationStructureInfoKHR));
        deepcopy_VkCopyMemoryToAccelerationStructureInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkCopyMemoryToAccelerationStructureInfoKHR*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkCopyMemoryToAccelerationStructureInfoKHR(sResourceTracker, (VkCopyMemoryToAccelerationStructureInfoKHR*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += 8;
        count_VkCopyMemoryToAccelerationStructureInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyMemoryToAccelerationStructureInfoKHR*)(local_pInfo), countPtr);
    }
    uint32_t packetSize_vkCopyMemoryToAccelerationStructureKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCopyMemoryToAccelerationStructureKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCopyMemoryToAccelerationStructureKHR = OP_vkCopyMemoryToAccelerationStructureKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCopyMemoryToAccelerationStructureKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCopyMemoryToAccelerationStructureKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1 = (uint64_t)local_deferredOperation;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    reservedmarshal_VkCopyMemoryToAccelerationStructureInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyMemoryToAccelerationStructureInfoKHR*)(local_pInfo), streamPtrPtr);
    VkResult vkCopyMemoryToAccelerationStructureKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCopyMemoryToAccelerationStructureKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCopyMemoryToAccelerationStructureKHR_VkResult_return;
}

VkResult VkEncoder::vkWriteAccelerationStructuresPropertiesKHR(
    VkDevice device,
    uint32_t accelerationStructureCount,
    const VkAccelerationStructureKHR* pAccelerationStructures,
    VkQueryType queryType,
    size_t dataSize,
    void* pData,
    size_t stride,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    uint32_t local_accelerationStructureCount;
    VkAccelerationStructureKHR* local_pAccelerationStructures;
    VkQueryType local_queryType;
    size_t local_dataSize;
    size_t local_stride;
    local_device = device;
    local_accelerationStructureCount = accelerationStructureCount;
    // Avoiding deepcopy for pAccelerationStructures
    local_pAccelerationStructures = (VkAccelerationStructureKHR*)pAccelerationStructures;
    local_queryType = queryType;
    local_dataSize = dataSize;
    local_stride = stride;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        if (((accelerationStructureCount)))
        {
            *countPtr += ((accelerationStructureCount)) * 8;
        }
        *countPtr += sizeof(VkQueryType);
        *countPtr += 8;
        *countPtr += ((dataSize)) * sizeof(uint8_t);
        *countPtr += 8;
    }
    uint32_t packetSize_vkWriteAccelerationStructuresPropertiesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkWriteAccelerationStructuresPropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkWriteAccelerationStructuresPropertiesKHR = OP_vkWriteAccelerationStructuresPropertiesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkWriteAccelerationStructuresPropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkWriteAccelerationStructuresPropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_accelerationStructureCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((accelerationStructureCount)))
    {
        uint8_t* cgen_var_1_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((accelerationStructureCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkAccelerationStructureKHR(local_pAccelerationStructures[k]);
            memcpy(cgen_var_1_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((accelerationStructureCount));
    }
    memcpy(*streamPtrPtr, (VkQueryType*)&local_queryType, sizeof(VkQueryType));
    *streamPtrPtr += sizeof(VkQueryType);
    uint64_t cgen_var_2 = (uint64_t)local_dataSize;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    memcpy(*streamPtrPtr, (void*)pData, ((dataSize)) * sizeof(uint8_t));
    *streamPtrPtr += ((dataSize)) * sizeof(uint8_t);
    uint64_t cgen_var_3 = (uint64_t)local_stride;
    memcpy((*streamPtrPtr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    stream->read((void*)pData, ((dataSize)) * sizeof(uint8_t));
    VkResult vkWriteAccelerationStructuresPropertiesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkWriteAccelerationStructuresPropertiesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkWriteAccelerationStructuresPropertiesKHR_VkResult_return;
}

void VkEncoder::vkCmdCopyAccelerationStructureKHR(
    VkCommandBuffer commandBuffer,
    const VkCopyAccelerationStructureInfoKHR* pInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCopyAccelerationStructureInfoKHR* local_pInfo;
    local_commandBuffer = commandBuffer;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkCopyAccelerationStructureInfoKHR*)pool->alloc(sizeof(const VkCopyAccelerationStructureInfoKHR));
        deepcopy_VkCopyAccelerationStructureInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkCopyAccelerationStructureInfoKHR*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkCopyAccelerationStructureInfoKHR(sResourceTracker, (VkCopyAccelerationStructureInfoKHR*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkCopyAccelerationStructureInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyAccelerationStructureInfoKHR*)(local_pInfo), countPtr);
    }
    uint32_t packetSize_vkCmdCopyAccelerationStructureKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdCopyAccelerationStructureKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdCopyAccelerationStructureKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdCopyAccelerationStructureKHR = OP_vkCmdCopyAccelerationStructureKHR;
    memcpy(streamPtr, &opcode_vkCmdCopyAccelerationStructureKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdCopyAccelerationStructureKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkCopyAccelerationStructureInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyAccelerationStructureInfoKHR*)(local_pInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdCopyAccelerationStructureToMemoryKHR(
    VkCommandBuffer commandBuffer,
    const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCopyAccelerationStructureToMemoryInfoKHR* local_pInfo;
    local_commandBuffer = commandBuffer;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkCopyAccelerationStructureToMemoryInfoKHR*)pool->alloc(sizeof(const VkCopyAccelerationStructureToMemoryInfoKHR));
        deepcopy_VkCopyAccelerationStructureToMemoryInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkCopyAccelerationStructureToMemoryInfoKHR*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkCopyAccelerationStructureToMemoryInfoKHR(sResourceTracker, (VkCopyAccelerationStructureToMemoryInfoKHR*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkCopyAccelerationStructureToMemoryInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyAccelerationStructureToMemoryInfoKHR*)(local_pInfo), countPtr);
    }
    uint32_t packetSize_vkCmdCopyAccelerationStructureToMemoryKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdCopyAccelerationStructureToMemoryKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdCopyAccelerationStructureToMemoryKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdCopyAccelerationStructureToMemoryKHR = OP_vkCmdCopyAccelerationStructureToMemoryKHR;
    memcpy(streamPtr, &opcode_vkCmdCopyAccelerationStructureToMemoryKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdCopyAccelerationStructureToMemoryKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkCopyAccelerationStructureToMemoryInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyAccelerationStructureToMemoryInfoKHR*)(local_pInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkCmdCopyMemoryToAccelerationStructureKHR(
    VkCommandBuffer commandBuffer,
    const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkCopyMemoryToAccelerationStructureInfoKHR* local_pInfo;
    local_commandBuffer = commandBuffer;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkCopyMemoryToAccelerationStructureInfoKHR*)pool->alloc(sizeof(const VkCopyMemoryToAccelerationStructureInfoKHR));
        deepcopy_VkCopyMemoryToAccelerationStructureInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkCopyMemoryToAccelerationStructureInfoKHR*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkCopyMemoryToAccelerationStructureInfoKHR(sResourceTracker, (VkCopyMemoryToAccelerationStructureInfoKHR*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkCopyMemoryToAccelerationStructureInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyMemoryToAccelerationStructureInfoKHR*)(local_pInfo), countPtr);
    }
    uint32_t packetSize_vkCmdCopyMemoryToAccelerationStructureKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdCopyMemoryToAccelerationStructureKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdCopyMemoryToAccelerationStructureKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdCopyMemoryToAccelerationStructureKHR = OP_vkCmdCopyMemoryToAccelerationStructureKHR;
    memcpy(streamPtr, &opcode_vkCmdCopyMemoryToAccelerationStructureKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdCopyMemoryToAccelerationStructureKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkCopyMemoryToAccelerationStructureInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkCopyMemoryToAccelerationStructureInfoKHR*)(local_pInfo), streamPtrPtr);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkDeviceAddress VkEncoder::vkGetAccelerationStructureDeviceAddressKHR(
    VkDevice device,
    const VkAccelerationStructureDeviceAddressInfoKHR* pInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkAccelerationStructureDeviceAddressInfoKHR* local_pInfo;
    local_device = device;
    local_pInfo = nullptr;
    if (pInfo)
    {
        local_pInfo = (VkAccelerationStructureDeviceAddressInfoKHR*)pool->alloc(sizeof(const VkAccelerationStructureDeviceAddressInfoKHR));
        deepcopy_VkAccelerationStructureDeviceAddressInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pInfo, (VkAccelerationStructureDeviceAddressInfoKHR*)(local_pInfo));
    }
    if (local_pInfo)
    {
        transform_tohost_VkAccelerationStructureDeviceAddressInfoKHR(sResourceTracker, (VkAccelerationStructureDeviceAddressInfoKHR*)(local_pInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkAccelerationStructureDeviceAddressInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureDeviceAddressInfoKHR*)(local_pInfo), countPtr);
    }
    uint32_t packetSize_vkGetAccelerationStructureDeviceAddressKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetAccelerationStructureDeviceAddressKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetAccelerationStructureDeviceAddressKHR = OP_vkGetAccelerationStructureDeviceAddressKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetAccelerationStructureDeviceAddressKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetAccelerationStructureDeviceAddressKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkAccelerationStructureDeviceAddressInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureDeviceAddressInfoKHR*)(local_pInfo), streamPtrPtr);
    VkDeviceAddress vkGetAccelerationStructureDeviceAddressKHR_VkDeviceAddress_return = (VkDeviceAddress)0;
    stream->read(&vkGetAccelerationStructureDeviceAddressKHR_VkDeviceAddress_return, sizeof(VkDeviceAddress));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetAccelerationStructureDeviceAddressKHR_VkDeviceAddress_return;
}

void VkEncoder::vkCmdWriteAccelerationStructuresPropertiesKHR(
    VkCommandBuffer commandBuffer,
    uint32_t accelerationStructureCount,
    const VkAccelerationStructureKHR* pAccelerationStructures,
    VkQueryType queryType,
    VkQueryPool queryPool,
    uint32_t firstQuery,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_accelerationStructureCount;
    VkAccelerationStructureKHR* local_pAccelerationStructures;
    VkQueryType local_queryType;
    VkQueryPool local_queryPool;
    uint32_t local_firstQuery;
    local_commandBuffer = commandBuffer;
    local_accelerationStructureCount = accelerationStructureCount;
    // Avoiding deepcopy for pAccelerationStructures
    local_pAccelerationStructures = (VkAccelerationStructureKHR*)pAccelerationStructures;
    local_queryType = queryType;
    local_queryPool = queryPool;
    local_firstQuery = firstQuery;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        if (((accelerationStructureCount)))
        {
            *countPtr += ((accelerationStructureCount)) * 8;
        }
        *countPtr += sizeof(VkQueryType);
        uint64_t cgen_var_2;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdWriteAccelerationStructuresPropertiesKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdWriteAccelerationStructuresPropertiesKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdWriteAccelerationStructuresPropertiesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdWriteAccelerationStructuresPropertiesKHR = OP_vkCmdWriteAccelerationStructuresPropertiesKHR;
    memcpy(streamPtr, &opcode_vkCmdWriteAccelerationStructuresPropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdWriteAccelerationStructuresPropertiesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_accelerationStructureCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    if (((accelerationStructureCount)))
    {
        uint8_t* cgen_var_0_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((accelerationStructureCount)); ++k)
        {
            uint64_t tmpval = get_host_u64_VkAccelerationStructureKHR(local_pAccelerationStructures[k]);
            memcpy(cgen_var_0_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((accelerationStructureCount));
    }
    memcpy(*streamPtrPtr, (VkQueryType*)&local_queryType, sizeof(VkQueryType));
    *streamPtrPtr += sizeof(VkQueryType);
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkQueryPool((*&local_queryPool));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstQuery, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetDeviceAccelerationStructureCompatibilityKHR(
    VkDevice device,
    const VkAccelerationStructureVersionInfoKHR* pVersionInfo,
    VkAccelerationStructureCompatibilityKHR* pCompatibility,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkAccelerationStructureVersionInfoKHR* local_pVersionInfo;
    local_device = device;
    local_pVersionInfo = nullptr;
    if (pVersionInfo)
    {
        local_pVersionInfo = (VkAccelerationStructureVersionInfoKHR*)pool->alloc(sizeof(const VkAccelerationStructureVersionInfoKHR));
        deepcopy_VkAccelerationStructureVersionInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pVersionInfo, (VkAccelerationStructureVersionInfoKHR*)(local_pVersionInfo));
    }
    if (local_pVersionInfo)
    {
        transform_tohost_VkAccelerationStructureVersionInfoKHR(sResourceTracker, (VkAccelerationStructureVersionInfoKHR*)(local_pVersionInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkAccelerationStructureVersionInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureVersionInfoKHR*)(local_pVersionInfo), countPtr);
        *countPtr += sizeof(VkAccelerationStructureCompatibilityKHR);
    }
    uint32_t packetSize_vkGetDeviceAccelerationStructureCompatibilityKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetDeviceAccelerationStructureCompatibilityKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetDeviceAccelerationStructureCompatibilityKHR = OP_vkGetDeviceAccelerationStructureCompatibilityKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetDeviceAccelerationStructureCompatibilityKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetDeviceAccelerationStructureCompatibilityKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    reservedmarshal_VkAccelerationStructureVersionInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureVersionInfoKHR*)(local_pVersionInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (VkAccelerationStructureCompatibilityKHR*)pCompatibility, sizeof(VkAccelerationStructureCompatibilityKHR));
    *streamPtrPtr += sizeof(VkAccelerationStructureCompatibilityKHR);
    stream->read((VkAccelerationStructureCompatibilityKHR*)pCompatibility, sizeof(VkAccelerationStructureCompatibilityKHR));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

void VkEncoder::vkGetAccelerationStructureBuildSizesKHR(
    VkDevice device,
    VkAccelerationStructureBuildTypeKHR buildType,
    const VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo,
    const uint32_t* pMaxPrimitiveCounts,
    VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkAccelerationStructureBuildTypeKHR local_buildType;
    VkAccelerationStructureBuildGeometryInfoKHR* local_pBuildInfo;
    uint32_t* local_pMaxPrimitiveCounts;
    local_device = device;
    local_buildType = buildType;
    local_pBuildInfo = nullptr;
    if (pBuildInfo)
    {
        local_pBuildInfo = (VkAccelerationStructureBuildGeometryInfoKHR*)pool->alloc(sizeof(const VkAccelerationStructureBuildGeometryInfoKHR));
        deepcopy_VkAccelerationStructureBuildGeometryInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pBuildInfo, (VkAccelerationStructureBuildGeometryInfoKHR*)(local_pBuildInfo));
    }
    // Avoiding deepcopy for pMaxPrimitiveCounts
    local_pMaxPrimitiveCounts = (uint32_t*)pMaxPrimitiveCounts;
    if (local_pBuildInfo)
    {
        transform_tohost_VkAccelerationStructureBuildGeometryInfoKHR(sResourceTracker, (VkAccelerationStructureBuildGeometryInfoKHR*)(local_pBuildInfo));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(VkAccelerationStructureBuildTypeKHR);
        count_VkAccelerationStructureBuildGeometryInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureBuildGeometryInfoKHR*)(local_pBuildInfo), countPtr);
        *countPtr += pBuildInfo->geometryCount * sizeof(uint32_t);
        count_VkAccelerationStructureBuildSizesInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureBuildSizesInfoKHR*)(pSizeInfo), countPtr);
    }
    uint32_t packetSize_vkGetAccelerationStructureBuildSizesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetAccelerationStructureBuildSizesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetAccelerationStructureBuildSizesKHR = OP_vkGetAccelerationStructureBuildSizesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetAccelerationStructureBuildSizesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetAccelerationStructureBuildSizesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (VkAccelerationStructureBuildTypeKHR*)&local_buildType, sizeof(VkAccelerationStructureBuildTypeKHR));
    *streamPtrPtr += sizeof(VkAccelerationStructureBuildTypeKHR);
    reservedmarshal_VkAccelerationStructureBuildGeometryInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureBuildGeometryInfoKHR*)(local_pBuildInfo), streamPtrPtr);
    memcpy(*streamPtrPtr, (uint32_t*)local_pMaxPrimitiveCounts, pBuildInfo->geometryCount * sizeof(uint32_t));
    *streamPtrPtr += pBuildInfo->geometryCount * sizeof(uint32_t);
    reservedmarshal_VkAccelerationStructureBuildSizesInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureBuildSizesInfoKHR*)(pSizeInfo), streamPtrPtr);
    unmarshal_VkAccelerationStructureBuildSizesInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAccelerationStructureBuildSizesInfoKHR*)(pSizeInfo));
    if (pSizeInfo)
    {
        transform_fromhost_VkAccelerationStructureBuildSizesInfoKHR(sResourceTracker, (VkAccelerationStructureBuildSizesInfoKHR*)(pSizeInfo));
    }
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_ray_tracing_pipeline
void VkEncoder::vkCmdTraceRaysKHR(
    VkCommandBuffer commandBuffer,
    const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable,
    uint32_t width,
    uint32_t height,
    uint32_t depth,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkStridedDeviceAddressRegionKHR* local_pRaygenShaderBindingTable;
    VkStridedDeviceAddressRegionKHR* local_pMissShaderBindingTable;
    VkStridedDeviceAddressRegionKHR* local_pHitShaderBindingTable;
    VkStridedDeviceAddressRegionKHR* local_pCallableShaderBindingTable;
    uint32_t local_width;
    uint32_t local_height;
    uint32_t local_depth;
    local_commandBuffer = commandBuffer;
    local_pRaygenShaderBindingTable = nullptr;
    if (pRaygenShaderBindingTable)
    {
        local_pRaygenShaderBindingTable = (VkStridedDeviceAddressRegionKHR*)pool->alloc(sizeof(const VkStridedDeviceAddressRegionKHR));
        deepcopy_VkStridedDeviceAddressRegionKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pRaygenShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)(local_pRaygenShaderBindingTable));
    }
    local_pMissShaderBindingTable = nullptr;
    if (pMissShaderBindingTable)
    {
        local_pMissShaderBindingTable = (VkStridedDeviceAddressRegionKHR*)pool->alloc(sizeof(const VkStridedDeviceAddressRegionKHR));
        deepcopy_VkStridedDeviceAddressRegionKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pMissShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)(local_pMissShaderBindingTable));
    }
    local_pHitShaderBindingTable = nullptr;
    if (pHitShaderBindingTable)
    {
        local_pHitShaderBindingTable = (VkStridedDeviceAddressRegionKHR*)pool->alloc(sizeof(const VkStridedDeviceAddressRegionKHR));
        deepcopy_VkStridedDeviceAddressRegionKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pHitShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)(local_pHitShaderBindingTable));
    }
    local_pCallableShaderBindingTable = nullptr;
    if (pCallableShaderBindingTable)
    {
        local_pCallableShaderBindingTable = (VkStridedDeviceAddressRegionKHR*)pool->alloc(sizeof(const VkStridedDeviceAddressRegionKHR));
        deepcopy_VkStridedDeviceAddressRegionKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCallableShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)(local_pCallableShaderBindingTable));
    }
    local_width = width;
    local_height = height;
    local_depth = depth;
    if (local_pRaygenShaderBindingTable)
    {
        transform_tohost_VkStridedDeviceAddressRegionKHR(sResourceTracker, (VkStridedDeviceAddressRegionKHR*)(local_pRaygenShaderBindingTable));
    }
    if (local_pMissShaderBindingTable)
    {
        transform_tohost_VkStridedDeviceAddressRegionKHR(sResourceTracker, (VkStridedDeviceAddressRegionKHR*)(local_pMissShaderBindingTable));
    }
    if (local_pHitShaderBindingTable)
    {
        transform_tohost_VkStridedDeviceAddressRegionKHR(sResourceTracker, (VkStridedDeviceAddressRegionKHR*)(local_pHitShaderBindingTable));
    }
    if (local_pCallableShaderBindingTable)
    {
        transform_tohost_VkStridedDeviceAddressRegionKHR(sResourceTracker, (VkStridedDeviceAddressRegionKHR*)(local_pCallableShaderBindingTable));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkStridedDeviceAddressRegionKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(local_pRaygenShaderBindingTable), countPtr);
        count_VkStridedDeviceAddressRegionKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(local_pMissShaderBindingTable), countPtr);
        count_VkStridedDeviceAddressRegionKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(local_pHitShaderBindingTable), countPtr);
        count_VkStridedDeviceAddressRegionKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(local_pCallableShaderBindingTable), countPtr);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdTraceRaysKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdTraceRaysKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdTraceRaysKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdTraceRaysKHR = OP_vkCmdTraceRaysKHR;
    memcpy(streamPtr, &opcode_vkCmdTraceRaysKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdTraceRaysKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkStridedDeviceAddressRegionKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(local_pRaygenShaderBindingTable), streamPtrPtr);
    reservedmarshal_VkStridedDeviceAddressRegionKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(local_pMissShaderBindingTable), streamPtrPtr);
    reservedmarshal_VkStridedDeviceAddressRegionKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(local_pHitShaderBindingTable), streamPtrPtr);
    reservedmarshal_VkStridedDeviceAddressRegionKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(local_pCallableShaderBindingTable), streamPtrPtr);
    memcpy(*streamPtrPtr, (uint32_t*)&local_width, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_height, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_depth, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkResult VkEncoder::vkCreateRayTracingPipelinesKHR(
    VkDevice device,
    VkDeferredOperationKHR deferredOperation,
    VkPipelineCache pipelineCache,
    uint32_t createInfoCount,
    const VkRayTracingPipelineCreateInfoKHR* pCreateInfos,
    const VkAllocationCallbacks* pAllocator,
    VkPipeline* pPipelines,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkDeferredOperationKHR local_deferredOperation;
    VkPipelineCache local_pipelineCache;
    uint32_t local_createInfoCount;
    VkRayTracingPipelineCreateInfoKHR* local_pCreateInfos;
    VkAllocationCallbacks* local_pAllocator;
    local_device = device;
    local_deferredOperation = deferredOperation;
    local_pipelineCache = pipelineCache;
    local_createInfoCount = createInfoCount;
    local_pCreateInfos = nullptr;
    if (pCreateInfos)
    {
        local_pCreateInfos = (VkRayTracingPipelineCreateInfoKHR*)pool->alloc(((createInfoCount)) * sizeof(const VkRayTracingPipelineCreateInfoKHR));
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            deepcopy_VkRayTracingPipelineCreateInfoKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCreateInfos + i, (VkRayTracingPipelineCreateInfoKHR*)(local_pCreateInfos + i));
        }
    }
    local_pAllocator = nullptr;
    if (pAllocator)
    {
        local_pAllocator = (VkAllocationCallbacks*)pool->alloc(sizeof(const VkAllocationCallbacks));
        deepcopy_VkAllocationCallbacks(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pAllocator, (VkAllocationCallbacks*)(local_pAllocator));
    }
    local_pAllocator = nullptr;
    if (local_pCreateInfos)
    {
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            transform_tohost_VkRayTracingPipelineCreateInfoKHR(sResourceTracker, (VkRayTracingPipelineCreateInfoKHR*)(local_pCreateInfos + i));
        }
    }
    if (local_pAllocator)
    {
        transform_tohost_VkAllocationCallbacks(sResourceTracker, (VkAllocationCallbacks*)(local_pAllocator));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
        {
            count_VkRayTracingPipelineCreateInfoKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRayTracingPipelineCreateInfoKHR*)(local_pCreateInfos + i), countPtr);
        }
        // WARNING PTR CHECK
        *countPtr += 8;
        if (local_pAllocator)
        {
            count_VkAllocationCallbacks(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), countPtr);
        }
        if (((createInfoCount)))
        {
            *countPtr += ((createInfoCount)) * 8;
        }
    }
    uint32_t packetSize_vkCreateRayTracingPipelinesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCreateRayTracingPipelinesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCreateRayTracingPipelinesKHR = OP_vkCreateRayTracingPipelinesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkCreateRayTracingPipelinesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCreateRayTracingPipelinesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1 = (uint64_t)local_deferredOperation;
    memcpy((*streamPtrPtr), &cgen_var_1, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    uint64_t cgen_var_2;
    *&cgen_var_2 = get_host_u64_VkPipelineCache((*&local_pipelineCache));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_2, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_createInfoCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)((createInfoCount)); ++i)
    {
        reservedmarshal_VkRayTracingPipelineCreateInfoKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkRayTracingPipelineCreateInfoKHR*)(local_pCreateInfos + i), streamPtrPtr);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_3 = (uint64_t)(uintptr_t)local_pAllocator;
    memcpy((*streamPtrPtr), &cgen_var_3, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    if (local_pAllocator)
    {
        reservedmarshal_VkAllocationCallbacks(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkAllocationCallbacks*)(local_pAllocator), streamPtrPtr);
    }
    /* is handle, possibly out */;
    if (((createInfoCount)))
    {
        uint8_t* cgen_var_4_ptr = (uint8_t*)(*streamPtrPtr);
        for (uint32_t k = 0; k < ((createInfoCount)); ++k)
        {
            uint64_t tmpval = (uint64_t)(pPipelines[k]);
            memcpy(cgen_var_4_ptr + k * 8, &tmpval, sizeof(uint64_t));
        }
        *streamPtrPtr += 8 * ((createInfoCount));
    }
    /* is handle, possibly out */;
    if (((createInfoCount)))
    {
        uint64_t* cgen_var_5;
        stream->alloc((void**)&cgen_var_5, ((createInfoCount)) * 8);
        stream->read((uint64_t*)cgen_var_5, ((createInfoCount)) * 8);
        stream->handleMapping()->mapHandles_u64_VkPipeline(cgen_var_5, (VkPipeline*)pPipelines, ((createInfoCount)));
    }
    VkResult vkCreateRayTracingPipelinesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkCreateRayTracingPipelinesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkCreateRayTracingPipelinesKHR_VkResult_return;
}

VkResult VkEncoder::vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(
    VkDevice device,
    VkPipeline pipeline,
    uint32_t firstGroup,
    uint32_t groupCount,
    size_t dataSize,
    void* pData,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipeline local_pipeline;
    uint32_t local_firstGroup;
    uint32_t local_groupCount;
    size_t local_dataSize;
    local_device = device;
    local_pipeline = pipeline;
    local_firstGroup = firstGroup;
    local_groupCount = groupCount;
    local_dataSize = dataSize;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(uint32_t);
        *countPtr += 8;
        *countPtr += ((dataSize)) * sizeof(uint8_t);
    }
    uint32_t packetSize_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = OP_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkPipeline((*&local_pipeline));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_firstGroup, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (uint32_t*)&local_groupCount, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    uint64_t cgen_var_2 = (uint64_t)local_dataSize;
    memcpy((*streamPtrPtr), &cgen_var_2, 8);
    android::base::Stream::toBe64((uint8_t*)(*streamPtrPtr));
    *streamPtrPtr += 8;
    memcpy(*streamPtrPtr, (void*)pData, ((dataSize)) * sizeof(uint8_t));
    *streamPtrPtr += ((dataSize)) * sizeof(uint8_t);
    stream->read((void*)pData, ((dataSize)) * sizeof(uint8_t));
    VkResult vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return = (VkResult)0;
    stream->read(&vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return, sizeof(VkResult));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_VkResult_return;
}

void VkEncoder::vkCmdTraceRaysIndirectKHR(
    VkCommandBuffer commandBuffer,
    const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable,
    VkDeviceAddress indirectDeviceAddress,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    VkStridedDeviceAddressRegionKHR* local_pRaygenShaderBindingTable;
    VkStridedDeviceAddressRegionKHR* local_pMissShaderBindingTable;
    VkStridedDeviceAddressRegionKHR* local_pHitShaderBindingTable;
    VkStridedDeviceAddressRegionKHR* local_pCallableShaderBindingTable;
    VkDeviceAddress local_indirectDeviceAddress;
    local_commandBuffer = commandBuffer;
    local_pRaygenShaderBindingTable = nullptr;
    if (pRaygenShaderBindingTable)
    {
        local_pRaygenShaderBindingTable = (VkStridedDeviceAddressRegionKHR*)pool->alloc(sizeof(const VkStridedDeviceAddressRegionKHR));
        deepcopy_VkStridedDeviceAddressRegionKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pRaygenShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)(local_pRaygenShaderBindingTable));
    }
    local_pMissShaderBindingTable = nullptr;
    if (pMissShaderBindingTable)
    {
        local_pMissShaderBindingTable = (VkStridedDeviceAddressRegionKHR*)pool->alloc(sizeof(const VkStridedDeviceAddressRegionKHR));
        deepcopy_VkStridedDeviceAddressRegionKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pMissShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)(local_pMissShaderBindingTable));
    }
    local_pHitShaderBindingTable = nullptr;
    if (pHitShaderBindingTable)
    {
        local_pHitShaderBindingTable = (VkStridedDeviceAddressRegionKHR*)pool->alloc(sizeof(const VkStridedDeviceAddressRegionKHR));
        deepcopy_VkStridedDeviceAddressRegionKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pHitShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)(local_pHitShaderBindingTable));
    }
    local_pCallableShaderBindingTable = nullptr;
    if (pCallableShaderBindingTable)
    {
        local_pCallableShaderBindingTable = (VkStridedDeviceAddressRegionKHR*)pool->alloc(sizeof(const VkStridedDeviceAddressRegionKHR));
        deepcopy_VkStridedDeviceAddressRegionKHR(pool, VK_STRUCTURE_TYPE_MAX_ENUM, pCallableShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)(local_pCallableShaderBindingTable));
    }
    local_indirectDeviceAddress = indirectDeviceAddress;
    if (local_pRaygenShaderBindingTable)
    {
        transform_tohost_VkStridedDeviceAddressRegionKHR(sResourceTracker, (VkStridedDeviceAddressRegionKHR*)(local_pRaygenShaderBindingTable));
    }
    if (local_pMissShaderBindingTable)
    {
        transform_tohost_VkStridedDeviceAddressRegionKHR(sResourceTracker, (VkStridedDeviceAddressRegionKHR*)(local_pMissShaderBindingTable));
    }
    if (local_pHitShaderBindingTable)
    {
        transform_tohost_VkStridedDeviceAddressRegionKHR(sResourceTracker, (VkStridedDeviceAddressRegionKHR*)(local_pHitShaderBindingTable));
    }
    if (local_pCallableShaderBindingTable)
    {
        transform_tohost_VkStridedDeviceAddressRegionKHR(sResourceTracker, (VkStridedDeviceAddressRegionKHR*)(local_pCallableShaderBindingTable));
    }
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        count_VkStridedDeviceAddressRegionKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(local_pRaygenShaderBindingTable), countPtr);
        count_VkStridedDeviceAddressRegionKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(local_pMissShaderBindingTable), countPtr);
        count_VkStridedDeviceAddressRegionKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(local_pHitShaderBindingTable), countPtr);
        count_VkStridedDeviceAddressRegionKHR(sFeatureBits, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(local_pCallableShaderBindingTable), countPtr);
        *countPtr += sizeof(VkDeviceAddress);
    }
    uint32_t packetSize_vkCmdTraceRaysIndirectKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdTraceRaysIndirectKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdTraceRaysIndirectKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdTraceRaysIndirectKHR = OP_vkCmdTraceRaysIndirectKHR;
    memcpy(streamPtr, &opcode_vkCmdTraceRaysIndirectKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdTraceRaysIndirectKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    reservedmarshal_VkStridedDeviceAddressRegionKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(local_pRaygenShaderBindingTable), streamPtrPtr);
    reservedmarshal_VkStridedDeviceAddressRegionKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(local_pMissShaderBindingTable), streamPtrPtr);
    reservedmarshal_VkStridedDeviceAddressRegionKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(local_pHitShaderBindingTable), streamPtrPtr);
    reservedmarshal_VkStridedDeviceAddressRegionKHR(stream, VK_STRUCTURE_TYPE_MAX_ENUM, (VkStridedDeviceAddressRegionKHR*)(local_pCallableShaderBindingTable), streamPtrPtr);
    memcpy(*streamPtrPtr, (VkDeviceAddress*)&local_indirectDeviceAddress, sizeof(VkDeviceAddress));
    *streamPtrPtr += sizeof(VkDeviceAddress);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

VkDeviceSize VkEncoder::vkGetRayTracingShaderGroupStackSizeKHR(
    VkDevice device,
    VkPipeline pipeline,
    uint32_t group,
    VkShaderGroupShaderKHR groupShader,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkDevice local_device;
    VkPipeline local_pipeline;
    uint32_t local_group;
    VkShaderGroupShaderKHR local_groupShader;
    local_device = device;
    local_pipeline = pipeline;
    local_group = group;
    local_groupShader = groupShader;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        uint64_t cgen_var_1;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
        *countPtr += sizeof(VkShaderGroupShaderKHR);
    }
    uint32_t packetSize_vkGetRayTracingShaderGroupStackSizeKHR = 4 + 4 + (queueSubmitWithCommandsEnabled ? 4 : 0) + count;
    uint8_t* streamPtr = stream->reserve(packetSize_vkGetRayTracingShaderGroupStackSizeKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkGetRayTracingShaderGroupStackSizeKHR = OP_vkGetRayTracingShaderGroupStackSizeKHR;
    uint32_t seqno; if (queueSubmitWithCommandsEnabled) seqno = ResourceTracker::nextSeqno();
    memcpy(streamPtr, &opcode_vkGetRayTracingShaderGroupStackSizeKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkGetRayTracingShaderGroupStackSizeKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (queueSubmitWithCommandsEnabled) { memcpy(streamPtr, &seqno, sizeof(uint32_t)); streamPtr += sizeof(uint32_t); }
    uint64_t cgen_var_0;
    *&cgen_var_0 = get_host_u64_VkDevice((*&local_device));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
    *streamPtrPtr += 1 * 8;
    uint64_t cgen_var_1;
    *&cgen_var_1 = get_host_u64_VkPipeline((*&local_pipeline));
    memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_1, 1 * 8);
    *streamPtrPtr += 1 * 8;
    memcpy(*streamPtrPtr, (uint32_t*)&local_group, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    memcpy(*streamPtrPtr, (VkShaderGroupShaderKHR*)&local_groupShader, sizeof(VkShaderGroupShaderKHR));
    *streamPtrPtr += sizeof(VkShaderGroupShaderKHR);
    VkDeviceSize vkGetRayTracingShaderGroupStackSizeKHR_VkDeviceSize_return = (VkDeviceSize)0;
    stream->read(&vkGetRayTracingShaderGroupStackSizeKHR_VkDeviceSize_return, sizeof(VkDeviceSize));
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
    return vkGetRayTracingShaderGroupStackSizeKHR_VkDeviceSize_return;
}

void VkEncoder::vkCmdSetRayTracingPipelineStackSizeKHR(
    VkCommandBuffer commandBuffer,
    uint32_t pipelineStackSize,
    uint32_t doLock)
{
    (void)doLock;
    bool queueSubmitWithCommandsEnabled = sFeatureBits & VULKAN_STREAM_FEATURE_QUEUE_SUBMIT_WITH_COMMANDS_BIT;
    if (!queueSubmitWithCommandsEnabled && doLock) this->lock();
    auto stream = mImpl->stream();
    auto pool = mImpl->pool();
    VkCommandBuffer local_commandBuffer;
    uint32_t local_pipelineStackSize;
    local_commandBuffer = commandBuffer;
    local_pipelineStackSize = pipelineStackSize;
    size_t count = 0;
    size_t* countPtr = &count;
    {
        uint64_t cgen_var_0;
        *countPtr += 1 * 8;
        *countPtr += sizeof(uint32_t);
    }
    uint32_t packetSize_vkCmdSetRayTracingPipelineStackSizeKHR = 4 + 4 + count;
    if (queueSubmitWithCommandsEnabled) packetSize_vkCmdSetRayTracingPipelineStackSizeKHR -= 8;
    uint8_t* streamPtr = stream->reserve(packetSize_vkCmdSetRayTracingPipelineStackSizeKHR);
    uint8_t** streamPtrPtr = &streamPtr;
    uint32_t opcode_vkCmdSetRayTracingPipelineStackSizeKHR = OP_vkCmdSetRayTracingPipelineStackSizeKHR;
    memcpy(streamPtr, &opcode_vkCmdSetRayTracingPipelineStackSizeKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    memcpy(streamPtr, &packetSize_vkCmdSetRayTracingPipelineStackSizeKHR, sizeof(uint32_t)); streamPtr += sizeof(uint32_t);
    if (!queueSubmitWithCommandsEnabled)
    {
        uint64_t cgen_var_0;
        *&cgen_var_0 = get_host_u64_VkCommandBuffer((*&local_commandBuffer));
        memcpy(*streamPtrPtr, (uint64_t*)&cgen_var_0, 1 * 8);
        *streamPtrPtr += 1 * 8;
    }
    memcpy(*streamPtrPtr, (uint32_t*)&local_pipelineStackSize, sizeof(uint32_t));
    *streamPtrPtr += sizeof(uint32_t);
    ++encodeCount;;
    if (0 == encodeCount % POOL_CLEAR_INTERVAL)
    {
        pool->freeAll();
        stream->clearPool();
    }
    if (!queueSubmitWithCommandsEnabled && doLock) this->unlock();
}

#endif
#ifdef VK_KHR_ray_query
#endif

} // namespace goldfish_vk
