// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module goldfish_vk_counting_guest
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "goldfish_vk_counting_guest.h"


#include "goldfish_vk_extension_structs_guest.h"
#include "goldfish_vk_private_defs.h"


namespace goldfish_vk {

void count_extension_struct(
    uint32_t featureBits,
    VkStructureType rootType,
    const void* structExtension,
    size_t* count);

#ifdef VK_VERSION_1_0
void count_VkExtent2D(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExtent2D* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkExtent3D(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExtent3D* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkOffset2D(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkOffset2D* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(int32_t);
    *count += sizeof(int32_t);
}

void count_VkOffset3D(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkOffset3D* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(int32_t);
    *count += sizeof(int32_t);
    *count += sizeof(int32_t);
}

void count_VkRect2D(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkRect2D* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    count_VkOffset2D(featureBits, rootType, (VkOffset2D*)(&toCount->offset), count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->extent), count);
}

void count_VkBaseInStructure(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBaseInStructure* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
}

void count_VkBaseOutStructure(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBaseOutStructure* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
}

void count_VkBufferMemoryBarrier(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBufferMemoryBarrier* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkAccessFlags);
    *count += sizeof(VkAccessFlags);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
}

void count_VkDispatchIndirectCommand(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDispatchIndirectCommand* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkDrawIndexedIndirectCommand(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDrawIndexedIndirectCommand* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(int32_t);
    *count += sizeof(uint32_t);
}

void count_VkDrawIndirectCommand(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDrawIndirectCommand* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkImageSubresourceRange(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageSubresourceRange* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkImageAspectFlags);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkImageMemoryBarrier(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageMemoryBarrier* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkAccessFlags);
    *count += sizeof(VkAccessFlags);
    *count += sizeof(VkImageLayout);
    *count += sizeof(VkImageLayout);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    count_VkImageSubresourceRange(featureBits, rootType, (VkImageSubresourceRange*)(&toCount->subresourceRange), count);
}

void count_VkMemoryBarrier(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMemoryBarrier* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkAccessFlags);
    *count += sizeof(VkAccessFlags);
}

void count_VkAllocationCallbacks(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAllocationCallbacks* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pUserData)
    {
        *count += sizeof(uint8_t);
    }
    *count += 8;
    *count += 8;
    *count += 8;
    *count += 8;
    *count += 8;
}

void count_VkApplicationInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkApplicationInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    if (featureBits & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        *count += 8;
        if (toCount->pApplicationName)
        {
            *count += sizeof(uint32_t) + (toCount->pApplicationName ? strlen(toCount->pApplicationName) : 0);
        }
    }
    else
    {
        *count += sizeof(uint32_t) + (toCount->pApplicationName ? strlen(toCount->pApplicationName) : 0);
    }
    *count += sizeof(uint32_t);
    if (featureBits & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        *count += 8;
        if (toCount->pEngineName)
        {
            *count += sizeof(uint32_t) + (toCount->pEngineName ? strlen(toCount->pEngineName) : 0);
        }
    }
    else
    {
        *count += sizeof(uint32_t) + (toCount->pEngineName ? strlen(toCount->pEngineName) : 0);
    }
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkFormatProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkFormatProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkFormatFeatureFlags);
    *count += sizeof(VkFormatFeatureFlags);
    *count += sizeof(VkFormatFeatureFlags);
}

void count_VkImageFormatProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageFormatProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    count_VkExtent3D(featureBits, rootType, (VkExtent3D*)(&toCount->maxExtent), count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkSampleCountFlags);
    *count += sizeof(VkDeviceSize);
}

void count_VkInstanceCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkInstanceCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkInstanceCreateFlags);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pApplicationInfo)
    {
        count_VkApplicationInfo(featureBits, rootType, (const VkApplicationInfo*)(toCount->pApplicationInfo), count);
    }
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < toCount->enabledLayerCount; ++i)
        {
            size_t l = toCount->ppEnabledLayerNames[i] ? strlen(toCount->ppEnabledLayerNames[i]) : 0;
            *count += sizeof(uint32_t) + (toCount->ppEnabledLayerNames[i] ? strlen(toCount->ppEnabledLayerNames[i]) : 0);
        }
    }
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < toCount->enabledExtensionCount; ++i)
        {
            size_t l = toCount->ppEnabledExtensionNames[i] ? strlen(toCount->ppEnabledExtensionNames[i]) : 0;
            *count += sizeof(uint32_t) + (toCount->ppEnabledExtensionNames[i] ? strlen(toCount->ppEnabledExtensionNames[i]) : 0);
        }
    }
}

void count_VkMemoryHeap(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMemoryHeap* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkMemoryHeapFlags);
}

void count_VkMemoryType(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMemoryType* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkMemoryPropertyFlags);
    *count += sizeof(uint32_t);
}

void count_VkPhysicalDeviceFeatures(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceFeatures* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceLimits(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceLimits* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += 3 * sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += 3 * sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(float);
    *count += sizeof(float);
    *count += sizeof(uint32_t);
    *count += 2 * sizeof(uint32_t);
    *count += 2 * sizeof(float);
    *count += sizeof(uint32_t);
    *count += 8;
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(int32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(int32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(float);
    *count += sizeof(float);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkSampleCountFlags);
    *count += sizeof(VkSampleCountFlags);
    *count += sizeof(VkSampleCountFlags);
    *count += sizeof(VkSampleCountFlags);
    *count += sizeof(uint32_t);
    *count += sizeof(VkSampleCountFlags);
    *count += sizeof(VkSampleCountFlags);
    *count += sizeof(VkSampleCountFlags);
    *count += sizeof(VkSampleCountFlags);
    *count += sizeof(VkSampleCountFlags);
    *count += sizeof(uint32_t);
    *count += sizeof(VkBool32);
    *count += sizeof(float);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += 2 * sizeof(float);
    *count += 2 * sizeof(float);
    *count += sizeof(float);
    *count += sizeof(float);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
}

void count_VkPhysicalDeviceMemoryProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceMemoryProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i)
    {
        count_VkMemoryType(featureBits, rootType, (VkMemoryType*)(toCount->memoryTypes + i), count);
    }
    *count += sizeof(uint32_t);
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i)
    {
        count_VkMemoryHeap(featureBits, rootType, (VkMemoryHeap*)(toCount->memoryHeaps + i), count);
    }
}

void count_VkPhysicalDeviceSparseProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceSparseProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkPhysicalDeviceType);
    *count += VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char);
    *count += VK_UUID_SIZE * sizeof(uint8_t);
    count_VkPhysicalDeviceLimits(featureBits, rootType, (VkPhysicalDeviceLimits*)(&toCount->limits), count);
    count_VkPhysicalDeviceSparseProperties(featureBits, rootType, (VkPhysicalDeviceSparseProperties*)(&toCount->sparseProperties), count);
}

void count_VkQueueFamilyProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkQueueFamilyProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkQueueFlags);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    count_VkExtent3D(featureBits, rootType, (VkExtent3D*)(&toCount->minImageTransferGranularity), count);
}

void count_VkDeviceQueueCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceQueueCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceQueueCreateFlags);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->queueCount * sizeof(const float);
    }
}

void count_VkDeviceCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceCreateFlags);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->queueCreateInfoCount; ++i)
        {
            count_VkDeviceQueueCreateInfo(featureBits, rootType, (const VkDeviceQueueCreateInfo*)(toCount->pQueueCreateInfos + i), count);
        }
    }
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < toCount->enabledLayerCount; ++i)
        {
            size_t l = toCount->ppEnabledLayerNames[i] ? strlen(toCount->ppEnabledLayerNames[i]) : 0;
            *count += sizeof(uint32_t) + (toCount->ppEnabledLayerNames[i] ? strlen(toCount->ppEnabledLayerNames[i]) : 0);
        }
    }
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < toCount->enabledExtensionCount; ++i)
        {
            size_t l = toCount->ppEnabledExtensionNames[i] ? strlen(toCount->ppEnabledExtensionNames[i]) : 0;
            *count += sizeof(uint32_t) + (toCount->ppEnabledExtensionNames[i] ? strlen(toCount->ppEnabledExtensionNames[i]) : 0);
        }
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pEnabledFeatures)
    {
        count_VkPhysicalDeviceFeatures(featureBits, rootType, (const VkPhysicalDeviceFeatures*)(toCount->pEnabledFeatures), count);
    }
}

void count_VkExtensionProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExtensionProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
    *count += sizeof(uint32_t);
}

void count_VkLayerProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkLayerProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
}

void count_VkSubmitInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSubmitInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount->waitSemaphoreCount)
    {
        *count += toCount->waitSemaphoreCount * 8;
    }
    if (toCount)
    {
        *count += toCount->waitSemaphoreCount * sizeof(const VkPipelineStageFlags);
    }
    *count += sizeof(uint32_t);
    if (toCount->commandBufferCount)
    {
        *count += toCount->commandBufferCount * 8;
    }
    *count += sizeof(uint32_t);
    if (toCount->signalSemaphoreCount)
    {
        *count += toCount->signalSemaphoreCount * 8;
    }
}

void count_VkMappedMemoryRange(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMappedMemoryRange* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
}

void count_VkMemoryAllocateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMemoryAllocateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(uint32_t);
}

void count_VkMemoryRequirements(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMemoryRequirements* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(uint32_t);
}

void count_VkSparseMemoryBind(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSparseMemoryBind* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkSparseMemoryBindFlags);
}

void count_VkSparseBufferMemoryBindInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSparseBufferMemoryBindInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->bindCount; ++i)
        {
            count_VkSparseMemoryBind(featureBits, rootType, (const VkSparseMemoryBind*)(toCount->pBinds + i), count);
        }
    }
}

void count_VkSparseImageOpaqueMemoryBindInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSparseImageOpaqueMemoryBindInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->bindCount; ++i)
        {
            count_VkSparseMemoryBind(featureBits, rootType, (const VkSparseMemoryBind*)(toCount->pBinds + i), count);
        }
    }
}

void count_VkImageSubresource(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageSubresource* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkImageAspectFlags);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkSparseImageMemoryBind(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSparseImageMemoryBind* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    count_VkImageSubresource(featureBits, rootType, (VkImageSubresource*)(&toCount->subresource), count);
    count_VkOffset3D(featureBits, rootType, (VkOffset3D*)(&toCount->offset), count);
    count_VkExtent3D(featureBits, rootType, (VkExtent3D*)(&toCount->extent), count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkSparseMemoryBindFlags);
}

void count_VkSparseImageMemoryBindInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSparseImageMemoryBindInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->bindCount; ++i)
        {
            count_VkSparseImageMemoryBind(featureBits, rootType, (const VkSparseImageMemoryBind*)(toCount->pBinds + i), count);
        }
    }
}

void count_VkBindSparseInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBindSparseInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount->waitSemaphoreCount)
    {
        *count += toCount->waitSemaphoreCount * 8;
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->bufferBindCount; ++i)
        {
            count_VkSparseBufferMemoryBindInfo(featureBits, rootType, (const VkSparseBufferMemoryBindInfo*)(toCount->pBufferBinds + i), count);
        }
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->imageOpaqueBindCount; ++i)
        {
            count_VkSparseImageOpaqueMemoryBindInfo(featureBits, rootType, (const VkSparseImageOpaqueMemoryBindInfo*)(toCount->pImageOpaqueBinds + i), count);
        }
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->imageBindCount; ++i)
        {
            count_VkSparseImageMemoryBindInfo(featureBits, rootType, (const VkSparseImageMemoryBindInfo*)(toCount->pImageBinds + i), count);
        }
    }
    *count += sizeof(uint32_t);
    if (toCount->signalSemaphoreCount)
    {
        *count += toCount->signalSemaphoreCount * 8;
    }
}

void count_VkSparseImageFormatProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSparseImageFormatProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkImageAspectFlags);
    count_VkExtent3D(featureBits, rootType, (VkExtent3D*)(&toCount->imageGranularity), count);
    *count += sizeof(VkSparseImageFormatFlags);
}

void count_VkSparseImageMemoryRequirements(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSparseImageMemoryRequirements* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    count_VkSparseImageFormatProperties(featureBits, rootType, (VkSparseImageFormatProperties*)(&toCount->formatProperties), count);
    *count += sizeof(uint32_t);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
}

void count_VkFenceCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkFenceCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkFenceCreateFlags);
}

void count_VkSemaphoreCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSemaphoreCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkSemaphoreCreateFlags);
}

void count_VkEventCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkEventCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkEventCreateFlags);
}

void count_VkQueryPoolCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkQueryPoolCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkQueryPoolCreateFlags);
    *count += sizeof(VkQueryType);
    *count += sizeof(uint32_t);
    *count += sizeof(VkQueryPipelineStatisticFlags);
}

void count_VkBufferCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBufferCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBufferCreateFlags);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkBufferUsageFlags);
    *count += sizeof(VkSharingMode);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pQueueFamilyIndices)
    {
        if (toCount)
        {
            *count += toCount->queueFamilyIndexCount * sizeof(const uint32_t);
        }
    }
}

void count_VkBufferViewCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBufferViewCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBufferViewCreateFlags);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkFormat);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
}

void count_VkImageCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkImageCreateFlags);
    *count += sizeof(VkImageType);
    *count += sizeof(VkFormat);
    count_VkExtent3D(featureBits, rootType, (VkExtent3D*)(&toCount->extent), count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkSampleCountFlagBits);
    *count += sizeof(VkImageTiling);
    *count += sizeof(VkImageUsageFlags);
    *count += sizeof(VkSharingMode);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pQueueFamilyIndices)
    {
        if (toCount)
        {
            *count += toCount->queueFamilyIndexCount * sizeof(const uint32_t);
        }
    }
    *count += sizeof(VkImageLayout);
}

void count_VkSubresourceLayout(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSubresourceLayout* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
}

void count_VkComponentMapping(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkComponentMapping* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkComponentSwizzle);
    *count += sizeof(VkComponentSwizzle);
    *count += sizeof(VkComponentSwizzle);
    *count += sizeof(VkComponentSwizzle);
}

void count_VkImageViewCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageViewCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkImageViewCreateFlags);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkImageViewType);
    *count += sizeof(VkFormat);
    count_VkComponentMapping(featureBits, rootType, (VkComponentMapping*)(&toCount->components), count);
    count_VkImageSubresourceRange(featureBits, rootType, (VkImageSubresourceRange*)(&toCount->subresourceRange), count);
}

void count_VkShaderModuleCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkShaderModuleCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkShaderModuleCreateFlags);
    *count += 8;
    if (toCount)
    {
        *count += (toCount->codeSize / 4) * sizeof(const uint32_t);
    }
}

void count_VkPipelineCacheCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineCacheCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineCacheCreateFlags);
    *count += 8;
    if (toCount)
    {
        *count += toCount->initialDataSize * sizeof(const uint8_t);
    }
}

void count_VkSpecializationMapEntry(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSpecializationMapEntry* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += 8;
}

void count_VkSpecializationInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSpecializationInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->mapEntryCount; ++i)
        {
            count_VkSpecializationMapEntry(featureBits, rootType, (const VkSpecializationMapEntry*)(toCount->pMapEntries + i), count);
        }
    }
    *count += 8;
    if (toCount)
    {
        *count += toCount->dataSize * sizeof(const uint8_t);
    }
}

void count_VkPipelineShaderStageCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineShaderStageCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineShaderStageCreateFlags);
    *count += sizeof(VkShaderStageFlagBits);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint32_t) + (toCount->pName ? strlen(toCount->pName) : 0);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pSpecializationInfo)
    {
        count_VkSpecializationInfo(featureBits, rootType, (const VkSpecializationInfo*)(toCount->pSpecializationInfo), count);
    }
}

void count_VkComputePipelineCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkComputePipelineCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineCreateFlags);
    count_VkPipelineShaderStageCreateInfo(featureBits, rootType, (VkPipelineShaderStageCreateInfo*)(&toCount->stage), count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(int32_t);
}

void count_VkVertexInputBindingDescription(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkVertexInputBindingDescription* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkVertexInputRate);
}

void count_VkVertexInputAttributeDescription(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkVertexInputAttributeDescription* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkFormat);
    *count += sizeof(uint32_t);
}

void count_VkPipelineVertexInputStateCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineVertexInputStateCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineVertexInputStateCreateFlags);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->vertexBindingDescriptionCount; ++i)
        {
            count_VkVertexInputBindingDescription(featureBits, rootType, (const VkVertexInputBindingDescription*)(toCount->pVertexBindingDescriptions + i), count);
        }
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->vertexAttributeDescriptionCount; ++i)
        {
            count_VkVertexInputAttributeDescription(featureBits, rootType, (const VkVertexInputAttributeDescription*)(toCount->pVertexAttributeDescriptions + i), count);
        }
    }
}

void count_VkPipelineInputAssemblyStateCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineInputAssemblyStateCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineInputAssemblyStateCreateFlags);
    *count += sizeof(VkPrimitiveTopology);
    *count += sizeof(VkBool32);
}

void count_VkPipelineTessellationStateCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineTessellationStateCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineTessellationStateCreateFlags);
    *count += sizeof(uint32_t);
}

void count_VkViewport(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkViewport* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(float);
    *count += sizeof(float);
    *count += sizeof(float);
    *count += sizeof(float);
    *count += sizeof(float);
    *count += sizeof(float);
}

void count_VkPipelineViewportStateCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineViewportStateCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineViewportStateCreateFlags);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pViewports)
    {
        if (toCount)
        {
            for (uint32_t i = 0; i < (uint32_t)toCount->viewportCount; ++i)
            {
                count_VkViewport(featureBits, rootType, (const VkViewport*)(toCount->pViewports + i), count);
            }
        }
    }
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pScissors)
    {
        if (toCount)
        {
            for (uint32_t i = 0; i < (uint32_t)toCount->scissorCount; ++i)
            {
                count_VkRect2D(featureBits, rootType, (const VkRect2D*)(toCount->pScissors + i), count);
            }
        }
    }
}

void count_VkPipelineRasterizationStateCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineRasterizationStateCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineRasterizationStateCreateFlags);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkPolygonMode);
    *count += sizeof(VkCullModeFlags);
    *count += sizeof(VkFrontFace);
    *count += sizeof(VkBool32);
    *count += sizeof(float);
    *count += sizeof(float);
    *count += sizeof(float);
    *count += sizeof(float);
}

void count_VkPipelineMultisampleStateCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineMultisampleStateCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineMultisampleStateCreateFlags);
    *count += sizeof(VkSampleCountFlagBits);
    *count += sizeof(VkBool32);
    *count += sizeof(float);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pSampleMask)
    {
        if (toCount)
        {
            *count += (((toCount->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask);
        }
    }
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkStencilOpState(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkStencilOpState* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStencilOp);
    *count += sizeof(VkStencilOp);
    *count += sizeof(VkStencilOp);
    *count += sizeof(VkCompareOp);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkPipelineDepthStencilStateCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineDepthStencilStateCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineDepthStencilStateCreateFlags);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkCompareOp);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    count_VkStencilOpState(featureBits, rootType, (VkStencilOpState*)(&toCount->front), count);
    count_VkStencilOpState(featureBits, rootType, (VkStencilOpState*)(&toCount->back), count);
    *count += sizeof(float);
    *count += sizeof(float);
}

void count_VkPipelineColorBlendAttachmentState(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineColorBlendAttachmentState* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkBool32);
    *count += sizeof(VkBlendFactor);
    *count += sizeof(VkBlendFactor);
    *count += sizeof(VkBlendOp);
    *count += sizeof(VkBlendFactor);
    *count += sizeof(VkBlendFactor);
    *count += sizeof(VkBlendOp);
    *count += sizeof(VkColorComponentFlags);
}

void count_VkPipelineColorBlendStateCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineColorBlendStateCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineColorBlendStateCreateFlags);
    *count += sizeof(VkBool32);
    *count += sizeof(VkLogicOp);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->attachmentCount; ++i)
        {
            count_VkPipelineColorBlendAttachmentState(featureBits, rootType, (const VkPipelineColorBlendAttachmentState*)(toCount->pAttachments + i), count);
        }
    }
    *count += 4 * sizeof(float);
}

void count_VkPipelineDynamicStateCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineDynamicStateCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineDynamicStateCreateFlags);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->dynamicStateCount * sizeof(const VkDynamicState);
    }
}

void count_VkGraphicsPipelineCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkGraphicsPipelineCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    uint32_t hasRasterization = 1;
    if (featureBits & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        hasRasterization = (((0 == toCount->pRasterizationState)) ? (0) : (!((*(toCount->pRasterizationState)).rasterizerDiscardEnable)));
        *count += 4;
    }
    uint32_t hasTessellation = 1;
    if (featureBits & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        hasTessellation = arrayany(toCount->pStages, 0, toCount->stageCount, [](VkPipelineShaderStageCreateInfo s) { return ((s.stage == VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT) || (s.stage == VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT)); });
        *count += 4;
    }
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineCreateFlags);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->stageCount; ++i)
        {
            count_VkPipelineShaderStageCreateInfo(featureBits, rootType, (const VkPipelineShaderStageCreateInfo*)(toCount->pStages + i), count);
        }
    }
    // WARNING PTR CHECK
    if (featureBits & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        *count += 8;
    }
    if ((!(featureBits & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || toCount->pVertexInputState))
    {
        count_VkPipelineVertexInputStateCreateInfo(featureBits, rootType, (const VkPipelineVertexInputStateCreateInfo*)(toCount->pVertexInputState), count);
    }
    // WARNING PTR CHECK
    if (featureBits & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        *count += 8;
    }
    if ((!(featureBits & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || toCount->pInputAssemblyState))
    {
        count_VkPipelineInputAssemblyStateCreateInfo(featureBits, rootType, (const VkPipelineInputAssemblyStateCreateInfo*)(toCount->pInputAssemblyState), count);
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pTessellationState)
    {
        if (hasTessellation)
        {
            count_VkPipelineTessellationStateCreateInfo(featureBits, rootType, (const VkPipelineTessellationStateCreateInfo*)(toCount->pTessellationState), count);
        }
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pViewportState)
    {
        if (hasRasterization)
        {
            count_VkPipelineViewportStateCreateInfo(featureBits, rootType, (const VkPipelineViewportStateCreateInfo*)(toCount->pViewportState), count);
        }
    }
    // WARNING PTR CHECK
    if (featureBits & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT)
    {
        *count += 8;
    }
    if ((!(featureBits & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || toCount->pRasterizationState))
    {
        count_VkPipelineRasterizationStateCreateInfo(featureBits, rootType, (const VkPipelineRasterizationStateCreateInfo*)(toCount->pRasterizationState), count);
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pMultisampleState)
    {
        if (hasRasterization)
        {
            count_VkPipelineMultisampleStateCreateInfo(featureBits, rootType, (const VkPipelineMultisampleStateCreateInfo*)(toCount->pMultisampleState), count);
        }
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pDepthStencilState)
    {
        if (hasRasterization)
        {
            count_VkPipelineDepthStencilStateCreateInfo(featureBits, rootType, (const VkPipelineDepthStencilStateCreateInfo*)(toCount->pDepthStencilState), count);
        }
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pColorBlendState)
    {
        if (hasRasterization)
        {
            count_VkPipelineColorBlendStateCreateInfo(featureBits, rootType, (const VkPipelineColorBlendStateCreateInfo*)(toCount->pColorBlendState), count);
        }
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pDynamicState)
    {
        count_VkPipelineDynamicStateCreateInfo(featureBits, rootType, (const VkPipelineDynamicStateCreateInfo*)(toCount->pDynamicState), count);
    }
    uint64_t cgen_var_0;
    *count += 1 * 8;
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
    uint64_t cgen_var_2;
    *count += 1 * 8;
    *count += sizeof(int32_t);
}

void count_VkPushConstantRange(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPushConstantRange* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkShaderStageFlags);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkPipelineLayoutCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineLayoutCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineLayoutCreateFlags);
    *count += sizeof(uint32_t);
    if (toCount->setLayoutCount)
    {
        *count += toCount->setLayoutCount * 8;
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->pushConstantRangeCount; ++i)
        {
            count_VkPushConstantRange(featureBits, rootType, (const VkPushConstantRange*)(toCount->pPushConstantRanges + i), count);
        }
    }
}

void count_VkSamplerCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSamplerCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkSamplerCreateFlags);
    *count += sizeof(VkFilter);
    *count += sizeof(VkFilter);
    *count += sizeof(VkSamplerMipmapMode);
    *count += sizeof(VkSamplerAddressMode);
    *count += sizeof(VkSamplerAddressMode);
    *count += sizeof(VkSamplerAddressMode);
    *count += sizeof(float);
    *count += sizeof(VkBool32);
    *count += sizeof(float);
    *count += sizeof(VkBool32);
    *count += sizeof(VkCompareOp);
    *count += sizeof(float);
    *count += sizeof(float);
    *count += sizeof(VkBorderColor);
    *count += sizeof(VkBool32);
}

void count_VkCopyDescriptorSet(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCopyDescriptorSet* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkDescriptorBufferInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDescriptorBufferInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
}

void count_VkDescriptorImageInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDescriptorImageInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    uint64_t cgen_var_0;
    *count += 1 * 8;
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(VkImageLayout);
}

void count_VkDescriptorPoolSize(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDescriptorPoolSize* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkDescriptorType);
    *count += sizeof(uint32_t);
}

void count_VkDescriptorPoolCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDescriptorPoolCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDescriptorPoolCreateFlags);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->poolSizeCount; ++i)
        {
            count_VkDescriptorPoolSize(featureBits, rootType, (const VkDescriptorPoolSize*)(toCount->pPoolSizes + i), count);
        }
    }
}

void count_VkDescriptorSetAllocateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDescriptorSetAllocateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
    if (toCount->descriptorSetCount)
    {
        *count += toCount->descriptorSetCount * 8;
    }
}

void count_VkDescriptorSetLayoutBinding(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDescriptorSetLayoutBinding* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(VkDescriptorType);
    *count += sizeof(uint32_t);
    *count += sizeof(VkShaderStageFlags);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pImmutableSamplers)
    {
        if (toCount->descriptorCount)
        {
            *count += toCount->descriptorCount * 8;
        }
    }
}

void count_VkDescriptorSetLayoutCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDescriptorSetLayoutCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDescriptorSetLayoutCreateFlags);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->bindingCount; ++i)
        {
            count_VkDescriptorSetLayoutBinding(featureBits, rootType, (const VkDescriptorSetLayoutBinding*)(toCount->pBindings + i), count);
        }
    }
}

void count_VkWriteDescriptorSet(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkWriteDescriptorSet* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkDescriptorType);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pImageInfo)
    {
        if ((!(featureBits & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_SAMPLER == toCount->descriptorType) || (VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER == toCount->descriptorType) || (VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE == toCount->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_IMAGE == toCount->descriptorType) || (VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT == toCount->descriptorType))))
        {
            if (toCount)
            {
                for (uint32_t i = 0; i < (uint32_t)toCount->descriptorCount; ++i)
                {
                    count_VkDescriptorImageInfo(featureBits, rootType, (const VkDescriptorImageInfo*)(toCount->pImageInfo + i), count);
                }
            }
        }
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pBufferInfo)
    {
        if ((!(featureBits & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER == toCount->descriptorType) || (VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC == toCount->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_BUFFER == toCount->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC == toCount->descriptorType))))
        {
            if (toCount)
            {
                for (uint32_t i = 0; i < (uint32_t)toCount->descriptorCount; ++i)
                {
                    count_VkDescriptorBufferInfo(featureBits, rootType, (const VkDescriptorBufferInfo*)(toCount->pBufferInfo + i), count);
                }
            }
        }
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pTexelBufferView)
    {
        if ((!(featureBits & VULKAN_STREAM_FEATURE_IGNORED_HANDLES_BIT) || ((VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER == toCount->descriptorType) || (VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER == toCount->descriptorType))))
        {
            if (toCount->descriptorCount)
            {
                *count += toCount->descriptorCount * 8;
            }
        }
    }
}

void count_VkAttachmentDescription(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAttachmentDescription* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkAttachmentDescriptionFlags);
    *count += sizeof(VkFormat);
    *count += sizeof(VkSampleCountFlagBits);
    *count += sizeof(VkAttachmentLoadOp);
    *count += sizeof(VkAttachmentStoreOp);
    *count += sizeof(VkAttachmentLoadOp);
    *count += sizeof(VkAttachmentStoreOp);
    *count += sizeof(VkImageLayout);
    *count += sizeof(VkImageLayout);
}

void count_VkAttachmentReference(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAttachmentReference* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(VkImageLayout);
}

void count_VkFramebufferCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkFramebufferCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkFramebufferCreateFlags);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
    if (toCount->attachmentCount)
    {
        *count += toCount->attachmentCount * 8;
    }
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkSubpassDescription(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSubpassDescription* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkSubpassDescriptionFlags);
    *count += sizeof(VkPipelineBindPoint);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->inputAttachmentCount; ++i)
        {
            count_VkAttachmentReference(featureBits, rootType, (const VkAttachmentReference*)(toCount->pInputAttachments + i), count);
        }
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->colorAttachmentCount; ++i)
        {
            count_VkAttachmentReference(featureBits, rootType, (const VkAttachmentReference*)(toCount->pColorAttachments + i), count);
        }
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pResolveAttachments)
    {
        if (toCount)
        {
            for (uint32_t i = 0; i < (uint32_t)toCount->colorAttachmentCount; ++i)
            {
                count_VkAttachmentReference(featureBits, rootType, (const VkAttachmentReference*)(toCount->pResolveAttachments + i), count);
            }
        }
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pDepthStencilAttachment)
    {
        count_VkAttachmentReference(featureBits, rootType, (const VkAttachmentReference*)(toCount->pDepthStencilAttachment), count);
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->preserveAttachmentCount * sizeof(const uint32_t);
    }
}

void count_VkSubpassDependency(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSubpassDependency* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkPipelineStageFlags);
    *count += sizeof(VkPipelineStageFlags);
    *count += sizeof(VkAccessFlags);
    *count += sizeof(VkAccessFlags);
    *count += sizeof(VkDependencyFlags);
}

void count_VkRenderPassCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkRenderPassCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkRenderPassCreateFlags);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->attachmentCount; ++i)
        {
            count_VkAttachmentDescription(featureBits, rootType, (const VkAttachmentDescription*)(toCount->pAttachments + i), count);
        }
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->subpassCount; ++i)
        {
            count_VkSubpassDescription(featureBits, rootType, (const VkSubpassDescription*)(toCount->pSubpasses + i), count);
        }
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->dependencyCount; ++i)
        {
            count_VkSubpassDependency(featureBits, rootType, (const VkSubpassDependency*)(toCount->pDependencies + i), count);
        }
    }
}

void count_VkCommandPoolCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCommandPoolCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkCommandPoolCreateFlags);
    *count += sizeof(uint32_t);
}

void count_VkCommandBufferAllocateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCommandBufferAllocateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkCommandBufferLevel);
    *count += sizeof(uint32_t);
}

void count_VkCommandBufferInheritanceInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCommandBufferInheritanceInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(VkBool32);
    *count += sizeof(VkQueryControlFlags);
    *count += sizeof(VkQueryPipelineStatisticFlags);
}

void count_VkCommandBufferBeginInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCommandBufferBeginInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkCommandBufferUsageFlags);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pInheritanceInfo)
    {
        count_VkCommandBufferInheritanceInfo(featureBits, rootType, (const VkCommandBufferInheritanceInfo*)(toCount->pInheritanceInfo), count);
    }
}

void count_VkBufferCopy(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBufferCopy* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
}

void count_VkImageSubresourceLayers(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageSubresourceLayers* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkImageAspectFlags);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkBufferImageCopy(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBufferImageCopy* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkDeviceSize);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    count_VkImageSubresourceLayers(featureBits, rootType, (VkImageSubresourceLayers*)(&toCount->imageSubresource), count);
    count_VkOffset3D(featureBits, rootType, (VkOffset3D*)(&toCount->imageOffset), count);
    count_VkExtent3D(featureBits, rootType, (VkExtent3D*)(&toCount->imageExtent), count);
}

void count_VkClearColorValue(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkClearColorValue* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += 4 * sizeof(float);
}

void count_VkClearDepthStencilValue(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkClearDepthStencilValue* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(float);
    *count += sizeof(uint32_t);
}

void count_VkClearValue(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkClearValue* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    count_VkClearColorValue(featureBits, rootType, (VkClearColorValue*)(&toCount->color), count);
}

void count_VkClearAttachment(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkClearAttachment* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkImageAspectFlags);
    *count += sizeof(uint32_t);
    count_VkClearValue(featureBits, rootType, (VkClearValue*)(&toCount->clearValue), count);
}

void count_VkClearRect(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkClearRect* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    count_VkRect2D(featureBits, rootType, (VkRect2D*)(&toCount->rect), count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkImageBlit(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageBlit* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    count_VkImageSubresourceLayers(featureBits, rootType, (VkImageSubresourceLayers*)(&toCount->srcSubresource), count);
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        count_VkOffset3D(featureBits, rootType, (VkOffset3D*)(toCount->srcOffsets + i), count);
    }
    count_VkImageSubresourceLayers(featureBits, rootType, (VkImageSubresourceLayers*)(&toCount->dstSubresource), count);
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        count_VkOffset3D(featureBits, rootType, (VkOffset3D*)(toCount->dstOffsets + i), count);
    }
}

void count_VkImageCopy(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageCopy* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    count_VkImageSubresourceLayers(featureBits, rootType, (VkImageSubresourceLayers*)(&toCount->srcSubresource), count);
    count_VkOffset3D(featureBits, rootType, (VkOffset3D*)(&toCount->srcOffset), count);
    count_VkImageSubresourceLayers(featureBits, rootType, (VkImageSubresourceLayers*)(&toCount->dstSubresource), count);
    count_VkOffset3D(featureBits, rootType, (VkOffset3D*)(&toCount->dstOffset), count);
    count_VkExtent3D(featureBits, rootType, (VkExtent3D*)(&toCount->extent), count);
}

void count_VkImageResolve(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageResolve* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    count_VkImageSubresourceLayers(featureBits, rootType, (VkImageSubresourceLayers*)(&toCount->srcSubresource), count);
    count_VkOffset3D(featureBits, rootType, (VkOffset3D*)(&toCount->srcOffset), count);
    count_VkImageSubresourceLayers(featureBits, rootType, (VkImageSubresourceLayers*)(&toCount->dstSubresource), count);
    count_VkOffset3D(featureBits, rootType, (VkOffset3D*)(&toCount->dstOffset), count);
    count_VkExtent3D(featureBits, rootType, (VkExtent3D*)(&toCount->extent), count);
}

void count_VkRenderPassBeginInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkRenderPassBeginInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    uint64_t cgen_var_1;
    *count += 1 * 8;
    count_VkRect2D(featureBits, rootType, (VkRect2D*)(&toCount->renderArea), count);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pClearValues)
    {
        if (toCount)
        {
            for (uint32_t i = 0; i < (uint32_t)toCount->clearValueCount; ++i)
            {
                count_VkClearValue(featureBits, rootType, (const VkClearValue*)(toCount->pClearValues + i), count);
            }
        }
    }
}

#endif
#ifdef VK_VERSION_1_1
void count_VkPhysicalDeviceSubgroupProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceSubgroupProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(VkShaderStageFlags);
    *count += sizeof(VkSubgroupFeatureFlags);
    *count += sizeof(VkBool32);
}

void count_VkBindBufferMemoryInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBindBufferMemoryInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(VkDeviceSize);
}

void count_VkBindImageMemoryInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBindImageMemoryInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(VkDeviceSize);
}

void count_VkPhysicalDevice16BitStorageFeatures(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDevice16BitStorageFeatures* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkMemoryDedicatedRequirements(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMemoryDedicatedRequirements* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkMemoryDedicatedAllocateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMemoryDedicatedAllocateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    uint64_t cgen_var_1;
    *count += 1 * 8;
}

void count_VkMemoryAllocateFlagsInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMemoryAllocateFlagsInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkMemoryAllocateFlags);
    *count += sizeof(uint32_t);
}

void count_VkDeviceGroupRenderPassBeginInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceGroupRenderPassBeginInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->deviceRenderAreaCount; ++i)
        {
            count_VkRect2D(featureBits, rootType, (const VkRect2D*)(toCount->pDeviceRenderAreas + i), count);
        }
    }
}

void count_VkDeviceGroupCommandBufferBeginInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceGroupCommandBufferBeginInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

void count_VkDeviceGroupSubmitInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceGroupSubmitInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->waitSemaphoreCount * sizeof(const uint32_t);
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->commandBufferCount * sizeof(const uint32_t);
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->signalSemaphoreCount * sizeof(const uint32_t);
    }
}

void count_VkDeviceGroupBindSparseInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceGroupBindSparseInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkBindBufferMemoryDeviceGroupInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBindBufferMemoryDeviceGroupInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->deviceIndexCount * sizeof(const uint32_t);
    }
}

void count_VkBindImageMemoryDeviceGroupInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBindImageMemoryDeviceGroupInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->deviceIndexCount * sizeof(const uint32_t);
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->splitInstanceBindRegionCount; ++i)
        {
            count_VkRect2D(featureBits, rootType, (const VkRect2D*)(toCount->pSplitInstanceBindRegions + i), count);
        }
    }
}

void count_VkPhysicalDeviceGroupProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceGroupProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += VK_MAX_DEVICE_GROUP_SIZE * sizeof(VkPhysicalDevice);
    *count += sizeof(VkBool32);
}

void count_VkDeviceGroupDeviceCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceGroupDeviceCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount->physicalDeviceCount)
    {
        *count += toCount->physicalDeviceCount * 8;
    }
}

void count_VkBufferMemoryRequirementsInfo2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBufferMemoryRequirementsInfo2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
}

void count_VkImageMemoryRequirementsInfo2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageMemoryRequirementsInfo2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
}

void count_VkImageSparseMemoryRequirementsInfo2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageSparseMemoryRequirementsInfo2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
}

void count_VkMemoryRequirements2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMemoryRequirements2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkMemoryRequirements(featureBits, rootType, (VkMemoryRequirements*)(&toCount->memoryRequirements), count);
}

void count_VkSparseImageMemoryRequirements2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSparseImageMemoryRequirements2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkSparseImageMemoryRequirements(featureBits, rootType, (VkSparseImageMemoryRequirements*)(&toCount->memoryRequirements), count);
}

void count_VkPhysicalDeviceFeatures2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceFeatures2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkPhysicalDeviceFeatures(featureBits, rootType, (VkPhysicalDeviceFeatures*)(&toCount->features), count);
}

void count_VkPhysicalDeviceProperties2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceProperties2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkPhysicalDeviceProperties(featureBits, rootType, (VkPhysicalDeviceProperties*)(&toCount->properties), count);
}

void count_VkFormatProperties2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkFormatProperties2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkFormatProperties(featureBits, rootType, (VkFormatProperties*)(&toCount->formatProperties), count);
}

void count_VkImageFormatProperties2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageFormatProperties2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkImageFormatProperties(featureBits, rootType, (VkImageFormatProperties*)(&toCount->imageFormatProperties), count);
}

void count_VkPhysicalDeviceImageFormatInfo2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceImageFormatInfo2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkFormat);
    *count += sizeof(VkImageType);
    *count += sizeof(VkImageTiling);
    *count += sizeof(VkImageUsageFlags);
    *count += sizeof(VkImageCreateFlags);
}

void count_VkQueueFamilyProperties2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkQueueFamilyProperties2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkQueueFamilyProperties(featureBits, rootType, (VkQueueFamilyProperties*)(&toCount->queueFamilyProperties), count);
}

void count_VkPhysicalDeviceMemoryProperties2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceMemoryProperties2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkPhysicalDeviceMemoryProperties(featureBits, rootType, (VkPhysicalDeviceMemoryProperties*)(&toCount->memoryProperties), count);
}

void count_VkSparseImageFormatProperties2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSparseImageFormatProperties2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkSparseImageFormatProperties(featureBits, rootType, (VkSparseImageFormatProperties*)(&toCount->properties), count);
}

void count_VkPhysicalDeviceSparseImageFormatInfo2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceSparseImageFormatInfo2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkFormat);
    *count += sizeof(VkImageType);
    *count += sizeof(VkSampleCountFlagBits);
    *count += sizeof(VkImageUsageFlags);
    *count += sizeof(VkImageTiling);
}

void count_VkPhysicalDevicePointClippingProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDevicePointClippingProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPointClippingBehavior);
}

void count_VkInputAttachmentAspectReference(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkInputAttachmentAspectReference* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkImageAspectFlags);
}

void count_VkRenderPassInputAttachmentAspectCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkRenderPassInputAttachmentAspectCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->aspectReferenceCount; ++i)
        {
            count_VkInputAttachmentAspectReference(featureBits, rootType, (const VkInputAttachmentAspectReference*)(toCount->pAspectReferences + i), count);
        }
    }
}

void count_VkImageViewUsageCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageViewUsageCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkImageUsageFlags);
}

void count_VkPipelineTessellationDomainOriginStateCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineTessellationDomainOriginStateCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkTessellationDomainOrigin);
}

void count_VkRenderPassMultiviewCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkRenderPassMultiviewCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->subpassCount * sizeof(const uint32_t);
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->dependencyCount * sizeof(const int32_t);
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->correlationMaskCount * sizeof(const uint32_t);
    }
}

void count_VkPhysicalDeviceMultiviewFeatures(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceMultiviewFeatures* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceMultiviewProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceMultiviewProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkPhysicalDeviceVariablePointersFeatures(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceVariablePointersFeatures* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceProtectedMemoryFeatures(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceProtectedMemoryFeatures* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceProtectedMemoryProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceProtectedMemoryProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkDeviceQueueInfo2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceQueueInfo2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceQueueCreateFlags);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkProtectedSubmitInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkProtectedSubmitInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkSamplerYcbcrConversionCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSamplerYcbcrConversionCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkFormat);
    *count += sizeof(VkSamplerYcbcrModelConversion);
    *count += sizeof(VkSamplerYcbcrRange);
    count_VkComponentMapping(featureBits, rootType, (VkComponentMapping*)(&toCount->components), count);
    *count += sizeof(VkChromaLocation);
    *count += sizeof(VkChromaLocation);
    *count += sizeof(VkFilter);
    *count += sizeof(VkBool32);
}

void count_VkSamplerYcbcrConversionInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSamplerYcbcrConversionInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
}

void count_VkBindImagePlaneMemoryInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBindImagePlaneMemoryInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkImageAspectFlagBits);
}

void count_VkImagePlaneMemoryRequirementsInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImagePlaneMemoryRequirementsInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkImageAspectFlagBits);
}

void count_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkSamplerYcbcrConversionImageFormatProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSamplerYcbcrConversionImageFormatProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

void count_VkDescriptorUpdateTemplateEntry(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDescriptorUpdateTemplateEntry* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkDescriptorType);
    *count += 8;
    *count += 8;
}

void count_VkDescriptorUpdateTemplateCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDescriptorUpdateTemplateCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDescriptorUpdateTemplateCreateFlags);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->descriptorUpdateEntryCount; ++i)
        {
            count_VkDescriptorUpdateTemplateEntry(featureBits, rootType, (const VkDescriptorUpdateTemplateEntry*)(toCount->pDescriptorUpdateEntries + i), count);
        }
    }
    *count += sizeof(VkDescriptorUpdateTemplateType);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkPipelineBindPoint);
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
}

void count_VkExternalMemoryProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExternalMemoryProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkExternalMemoryFeatureFlags);
    *count += sizeof(VkExternalMemoryHandleTypeFlags);
    *count += sizeof(VkExternalMemoryHandleTypeFlags);
}

void count_VkPhysicalDeviceExternalImageFormatInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceExternalImageFormatInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

void count_VkExternalImageFormatProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExternalImageFormatProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkExternalMemoryProperties(featureBits, rootType, (VkExternalMemoryProperties*)(&toCount->externalMemoryProperties), count);
}

void count_VkPhysicalDeviceExternalBufferInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceExternalBufferInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBufferCreateFlags);
    *count += sizeof(VkBufferUsageFlags);
    *count += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

void count_VkExternalBufferProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExternalBufferProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkExternalMemoryProperties(featureBits, rootType, (VkExternalMemoryProperties*)(&toCount->externalMemoryProperties), count);
}

void count_VkPhysicalDeviceIDProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceIDProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += VK_UUID_SIZE * sizeof(uint8_t);
    *count += VK_UUID_SIZE * sizeof(uint8_t);
    *count += VK_LUID_SIZE * sizeof(uint8_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkBool32);
}

void count_VkExternalMemoryImageCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExternalMemoryImageCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkExternalMemoryHandleTypeFlags);
}

void count_VkExternalMemoryBufferCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExternalMemoryBufferCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkExternalMemoryHandleTypeFlags);
}

void count_VkExportMemoryAllocateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExportMemoryAllocateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkExternalMemoryHandleTypeFlags);
}

void count_VkPhysicalDeviceExternalFenceInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceExternalFenceInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkExternalFenceHandleTypeFlagBits);
}

void count_VkExternalFenceProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExternalFenceProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkExternalFenceHandleTypeFlags);
    *count += sizeof(VkExternalFenceHandleTypeFlags);
    *count += sizeof(VkExternalFenceFeatureFlags);
}

void count_VkExportFenceCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExportFenceCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkExternalFenceHandleTypeFlags);
}

void count_VkExportSemaphoreCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExportSemaphoreCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkExternalSemaphoreHandleTypeFlags);
}

void count_VkPhysicalDeviceExternalSemaphoreInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceExternalSemaphoreInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
}

void count_VkExternalSemaphoreProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExternalSemaphoreProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkExternalSemaphoreHandleTypeFlags);
    *count += sizeof(VkExternalSemaphoreHandleTypeFlags);
    *count += sizeof(VkExternalSemaphoreFeatureFlags);
}

void count_VkPhysicalDeviceMaintenance3Properties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceMaintenance3Properties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(VkDeviceSize);
}

void count_VkDescriptorSetLayoutSupport(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDescriptorSetLayoutSupport* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceShaderDrawParametersFeatures(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderDrawParametersFeatures* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_VERSION_1_2
void count_VkPhysicalDeviceVulkan11Features(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceVulkan11Features* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceVulkan11Properties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceVulkan11Properties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += VK_UUID_SIZE * sizeof(uint8_t);
    *count += VK_UUID_SIZE * sizeof(uint8_t);
    *count += VK_LUID_SIZE * sizeof(uint8_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkBool32);
    *count += sizeof(uint32_t);
    *count += sizeof(VkShaderStageFlags);
    *count += sizeof(VkSubgroupFeatureFlags);
    *count += sizeof(VkBool32);
    *count += sizeof(VkPointClippingBehavior);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkBool32);
    *count += sizeof(uint32_t);
    *count += sizeof(VkDeviceSize);
}

void count_VkPhysicalDeviceVulkan12Features(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceVulkan12Features* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkConformanceVersion(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkConformanceVersion* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint8_t);
    *count += sizeof(uint8_t);
    *count += sizeof(uint8_t);
    *count += sizeof(uint8_t);
}

void count_VkPhysicalDeviceVulkan12Properties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceVulkan12Properties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDriverId);
    *count += VK_MAX_DRIVER_NAME_SIZE * sizeof(char);
    *count += VK_MAX_DRIVER_INFO_SIZE * sizeof(char);
    count_VkConformanceVersion(featureBits, rootType, (VkConformanceVersion*)(&toCount->conformanceVersion), count);
    *count += sizeof(VkShaderFloatControlsIndependence);
    *count += sizeof(VkShaderFloatControlsIndependence);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(uint32_t);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkResolveModeFlags);
    *count += sizeof(VkResolveModeFlags);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(uint64_t);
    *count += sizeof(VkSampleCountFlags);
}

void count_VkImageFormatListCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageFormatListCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->viewFormatCount * sizeof(const VkFormat);
    }
}

void count_VkAttachmentDescription2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAttachmentDescription2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkAttachmentDescriptionFlags);
    *count += sizeof(VkFormat);
    *count += sizeof(VkSampleCountFlagBits);
    *count += sizeof(VkAttachmentLoadOp);
    *count += sizeof(VkAttachmentStoreOp);
    *count += sizeof(VkAttachmentLoadOp);
    *count += sizeof(VkAttachmentStoreOp);
    *count += sizeof(VkImageLayout);
    *count += sizeof(VkImageLayout);
}

void count_VkAttachmentReference2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAttachmentReference2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(VkImageLayout);
    *count += sizeof(VkImageAspectFlags);
}

void count_VkSubpassDescription2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSubpassDescription2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkSubpassDescriptionFlags);
    *count += sizeof(VkPipelineBindPoint);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->inputAttachmentCount; ++i)
        {
            count_VkAttachmentReference2(featureBits, rootType, (const VkAttachmentReference2*)(toCount->pInputAttachments + i), count);
        }
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->colorAttachmentCount; ++i)
        {
            count_VkAttachmentReference2(featureBits, rootType, (const VkAttachmentReference2*)(toCount->pColorAttachments + i), count);
        }
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pResolveAttachments)
    {
        if (toCount)
        {
            for (uint32_t i = 0; i < (uint32_t)toCount->colorAttachmentCount; ++i)
            {
                count_VkAttachmentReference2(featureBits, rootType, (const VkAttachmentReference2*)(toCount->pResolveAttachments + i), count);
            }
        }
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pDepthStencilAttachment)
    {
        count_VkAttachmentReference2(featureBits, rootType, (const VkAttachmentReference2*)(toCount->pDepthStencilAttachment), count);
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->preserveAttachmentCount * sizeof(const uint32_t);
    }
}

void count_VkSubpassDependency2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSubpassDependency2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkPipelineStageFlags);
    *count += sizeof(VkPipelineStageFlags);
    *count += sizeof(VkAccessFlags);
    *count += sizeof(VkAccessFlags);
    *count += sizeof(VkDependencyFlags);
    *count += sizeof(int32_t);
}

void count_VkRenderPassCreateInfo2(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkRenderPassCreateInfo2* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkRenderPassCreateFlags);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->attachmentCount; ++i)
        {
            count_VkAttachmentDescription2(featureBits, rootType, (const VkAttachmentDescription2*)(toCount->pAttachments + i), count);
        }
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->subpassCount; ++i)
        {
            count_VkSubpassDescription2(featureBits, rootType, (const VkSubpassDescription2*)(toCount->pSubpasses + i), count);
        }
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->dependencyCount; ++i)
        {
            count_VkSubpassDependency2(featureBits, rootType, (const VkSubpassDependency2*)(toCount->pDependencies + i), count);
        }
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->correlatedViewMaskCount * sizeof(const uint32_t);
    }
}

void count_VkSubpassBeginInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSubpassBeginInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkSubpassContents);
}

void count_VkSubpassEndInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSubpassEndInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
}

void count_VkPhysicalDevice8BitStorageFeatures(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDevice8BitStorageFeatures* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceDriverProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceDriverProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDriverId);
    *count += VK_MAX_DRIVER_NAME_SIZE * sizeof(char);
    *count += VK_MAX_DRIVER_INFO_SIZE * sizeof(char);
    count_VkConformanceVersion(featureBits, rootType, (VkConformanceVersion*)(&toCount->conformanceVersion), count);
}

void count_VkPhysicalDeviceShaderAtomicInt64Features(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderAtomicInt64Features* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceShaderFloat16Int8Features(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderFloat16Int8Features* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceFloatControlsProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceFloatControlsProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkShaderFloatControlsIndependence);
    *count += sizeof(VkShaderFloatControlsIndependence);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkDescriptorSetLayoutBindingFlagsCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDescriptorSetLayoutBindingFlagsCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pBindingFlags)
    {
        if (toCount)
        {
            *count += toCount->bindingCount * sizeof(const VkDescriptorBindingFlags);
        }
    }
}

void count_VkPhysicalDeviceDescriptorIndexingFeatures(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceDescriptorIndexingFeatures* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceDescriptorIndexingProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceDescriptorIndexingProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkDescriptorSetVariableDescriptorCountAllocateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDescriptorSetVariableDescriptorCountAllocateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->descriptorSetCount * sizeof(const uint32_t);
    }
}

void count_VkDescriptorSetVariableDescriptorCountLayoutSupport(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDescriptorSetVariableDescriptorCountLayoutSupport* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

void count_VkSubpassDescriptionDepthStencilResolve(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSubpassDescriptionDepthStencilResolve* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkResolveModeFlagBits);
    *count += sizeof(VkResolveModeFlagBits);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pDepthStencilResolveAttachment)
    {
        count_VkAttachmentReference2(featureBits, rootType, (const VkAttachmentReference2*)(toCount->pDepthStencilResolveAttachment), count);
    }
}

void count_VkPhysicalDeviceDepthStencilResolveProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceDepthStencilResolveProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkResolveModeFlags);
    *count += sizeof(VkResolveModeFlags);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceScalarBlockLayoutFeatures(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceScalarBlockLayoutFeatures* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkImageStencilUsageCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageStencilUsageCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkImageUsageFlags);
}

void count_VkSamplerReductionModeCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSamplerReductionModeCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkSamplerReductionMode);
}

void count_VkPhysicalDeviceSamplerFilterMinmaxProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceSamplerFilterMinmaxProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceVulkanMemoryModelFeatures(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceVulkanMemoryModelFeatures* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceImagelessFramebufferFeatures(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceImagelessFramebufferFeatures* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkFramebufferAttachmentImageInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkFramebufferAttachmentImageInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkImageCreateFlags);
    *count += sizeof(VkImageUsageFlags);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->viewFormatCount * sizeof(const VkFormat);
    }
}

void count_VkFramebufferAttachmentsCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkFramebufferAttachmentsCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->attachmentImageInfoCount; ++i)
        {
            count_VkFramebufferAttachmentImageInfo(featureBits, rootType, (const VkFramebufferAttachmentImageInfo*)(toCount->pAttachmentImageInfos + i), count);
        }
    }
}

void count_VkRenderPassAttachmentBeginInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkRenderPassAttachmentBeginInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount->attachmentCount)
    {
        *count += toCount->attachmentCount * 8;
    }
}

void count_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceUniformBufferStandardLayoutFeatures* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkAttachmentReferenceStencilLayout(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAttachmentReferenceStencilLayout* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkImageLayout);
}

void count_VkAttachmentDescriptionStencilLayout(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAttachmentDescriptionStencilLayout* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkImageLayout);
    *count += sizeof(VkImageLayout);
}

void count_VkPhysicalDeviceHostQueryResetFeatures(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceHostQueryResetFeatures* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceTimelineSemaphoreFeatures(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceTimelineSemaphoreFeatures* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceTimelineSemaphoreProperties(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceTimelineSemaphoreProperties* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint64_t);
}

void count_VkSemaphoreTypeCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSemaphoreTypeCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkSemaphoreType);
    *count += sizeof(uint64_t);
}

void count_VkTimelineSemaphoreSubmitInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkTimelineSemaphoreSubmitInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pWaitSemaphoreValues)
    {
        if (toCount)
        {
            *count += toCount->waitSemaphoreValueCount * sizeof(const uint64_t);
        }
    }
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pSignalSemaphoreValues)
    {
        if (toCount)
        {
            *count += toCount->signalSemaphoreValueCount * sizeof(const uint64_t);
        }
    }
}

void count_VkSemaphoreWaitInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSemaphoreWaitInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkSemaphoreWaitFlags);
    *count += sizeof(uint32_t);
    if (toCount->semaphoreCount)
    {
        *count += toCount->semaphoreCount * 8;
    }
    if (toCount)
    {
        *count += toCount->semaphoreCount * sizeof(const uint64_t);
    }
}

void count_VkSemaphoreSignalInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSemaphoreSignalInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint64_t);
}

void count_VkPhysicalDeviceBufferDeviceAddressFeatures(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceBufferDeviceAddressFeatures* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkBufferDeviceAddressInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBufferDeviceAddressInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
}

void count_VkBufferOpaqueCaptureAddressCreateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBufferOpaqueCaptureAddressCreateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint64_t);
}

void count_VkMemoryOpaqueCaptureAddressAllocateInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMemoryOpaqueCaptureAddressAllocateInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint64_t);
}

void count_VkDeviceMemoryOpaqueCaptureAddressInfo(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceMemoryOpaqueCaptureAddressInfo* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
}

#endif
#ifdef VK_KHR_surface
void count_VkSurfaceCapabilitiesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSurfaceCapabilitiesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->currentExtent), count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->minImageExtent), count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->maxImageExtent), count);
    *count += sizeof(uint32_t);
    *count += sizeof(VkSurfaceTransformFlagsKHR);
    *count += sizeof(VkSurfaceTransformFlagBitsKHR);
    *count += sizeof(VkCompositeAlphaFlagsKHR);
    *count += sizeof(VkImageUsageFlags);
}

void count_VkSurfaceFormatKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSurfaceFormatKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkFormat);
    *count += sizeof(VkColorSpaceKHR);
}

#endif
#ifdef VK_KHR_swapchain
void count_VkSwapchainCreateInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSwapchainCreateInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkSwapchainCreateFlagsKHR);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
    *count += sizeof(VkFormat);
    *count += sizeof(VkColorSpaceKHR);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->imageExtent), count);
    *count += sizeof(uint32_t);
    *count += sizeof(VkImageUsageFlags);
    *count += sizeof(VkSharingMode);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pQueueFamilyIndices)
    {
        if (toCount)
        {
            *count += toCount->queueFamilyIndexCount * sizeof(const uint32_t);
        }
    }
    *count += sizeof(VkSurfaceTransformFlagBitsKHR);
    *count += sizeof(VkCompositeAlphaFlagBitsKHR);
    *count += sizeof(VkPresentModeKHR);
    *count += sizeof(VkBool32);
    uint64_t cgen_var_1;
    *count += 1 * 8;
}

void count_VkPresentInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPresentInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount->waitSemaphoreCount)
    {
        *count += toCount->waitSemaphoreCount * 8;
    }
    *count += sizeof(uint32_t);
    if (toCount->swapchainCount)
    {
        *count += toCount->swapchainCount * 8;
    }
    if (toCount)
    {
        *count += toCount->swapchainCount * sizeof(const uint32_t);
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pResults)
    {
        if (toCount)
        {
            *count += toCount->swapchainCount * sizeof(VkResult);
        }
    }
}

void count_VkImageSwapchainCreateInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageSwapchainCreateInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
}

void count_VkBindImageMemorySwapchainInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBindImageMemorySwapchainInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
}

void count_VkAcquireNextImageInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAcquireNextImageInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint64_t);
    uint64_t cgen_var_1;
    *count += 1 * 8;
    uint64_t cgen_var_2;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
}

void count_VkDeviceGroupPresentCapabilitiesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceGroupPresentCapabilitiesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t);
    *count += sizeof(VkDeviceGroupPresentModeFlagsKHR);
}

void count_VkDeviceGroupPresentInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceGroupPresentInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->swapchainCount * sizeof(const uint32_t);
    }
    *count += sizeof(VkDeviceGroupPresentModeFlagBitsKHR);
}

void count_VkDeviceGroupSwapchainCreateInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceGroupSwapchainCreateInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceGroupPresentModeFlagsKHR);
}

#endif
#ifdef VK_KHR_display
void count_VkDisplayModeParametersKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDisplayModeParametersKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->visibleRegion), count);
    *count += sizeof(uint32_t);
}

void count_VkDisplayModeCreateInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDisplayModeCreateInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDisplayModeCreateFlagsKHR);
    count_VkDisplayModeParametersKHR(featureBits, rootType, (VkDisplayModeParametersKHR*)(&toCount->parameters), count);
}

void count_VkDisplayModePropertiesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDisplayModePropertiesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    uint64_t cgen_var_0;
    *count += 1 * 8;
    count_VkDisplayModeParametersKHR(featureBits, rootType, (VkDisplayModeParametersKHR*)(&toCount->parameters), count);
}

void count_VkDisplayPlaneCapabilitiesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDisplayPlaneCapabilitiesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkDisplayPlaneAlphaFlagsKHR);
    count_VkOffset2D(featureBits, rootType, (VkOffset2D*)(&toCount->minSrcPosition), count);
    count_VkOffset2D(featureBits, rootType, (VkOffset2D*)(&toCount->maxSrcPosition), count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->minSrcExtent), count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->maxSrcExtent), count);
    count_VkOffset2D(featureBits, rootType, (VkOffset2D*)(&toCount->minDstPosition), count);
    count_VkOffset2D(featureBits, rootType, (VkOffset2D*)(&toCount->maxDstPosition), count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->minDstExtent), count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->maxDstExtent), count);
}

void count_VkDisplayPlanePropertiesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDisplayPlanePropertiesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
}

void count_VkDisplayPropertiesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDisplayPropertiesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint32_t) + (toCount->displayName ? strlen(toCount->displayName) : 0);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->physicalDimensions), count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->physicalResolution), count);
    *count += sizeof(VkSurfaceTransformFlagsKHR);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkDisplaySurfaceCreateInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDisplaySurfaceCreateInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDisplaySurfaceCreateFlagsKHR);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkSurfaceTransformFlagBitsKHR);
    *count += sizeof(float);
    *count += sizeof(VkDisplayPlaneAlphaFlagBitsKHR);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->imageExtent), count);
}

#endif
#ifdef VK_KHR_display_swapchain
void count_VkDisplayPresentInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDisplayPresentInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkRect2D(featureBits, rootType, (VkRect2D*)(&toCount->srcRect), count);
    count_VkRect2D(featureBits, rootType, (VkRect2D*)(&toCount->dstRect), count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_KHR_xlib_surface
void count_VkXlibSurfaceCreateInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkXlibSurfaceCreateInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkXlibSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->dpy)
    {
        *count += sizeof(Display);
    }
    *count += sizeof(Window);
}

#endif
#ifdef VK_KHR_xcb_surface
void count_VkXcbSurfaceCreateInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkXcbSurfaceCreateInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkXcbSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->connection)
    {
        *count += sizeof(xcb_connection_t);
    }
    *count += sizeof(xcb_window_t);
}

#endif
#ifdef VK_KHR_wayland_surface
void count_VkWaylandSurfaceCreateInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkWaylandSurfaceCreateInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkWaylandSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->display)
    {
        *count += sizeof(wl_display);
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->surface)
    {
        *count += sizeof(wl_surface);
    }
}

#endif
#ifdef VK_KHR_android_surface
void count_VkAndroidSurfaceCreateInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAndroidSurfaceCreateInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkAndroidSurfaceCreateFlagsKHR);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->window)
    {
        *count += sizeof(ANativeWindow);
    }
}

#endif
#ifdef VK_KHR_win32_surface
void count_VkWin32SurfaceCreateInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkWin32SurfaceCreateInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkWin32SurfaceCreateFlagsKHR);
    *count += sizeof(HINSTANCE);
    *count += sizeof(HWND);
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
#endif
#ifdef VK_KHR_device_group
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
#endif
#ifdef VK_KHR_device_group_creation
#endif
#ifdef VK_KHR_external_memory_capabilities
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
void count_VkImportMemoryWin32HandleInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImportMemoryWin32HandleInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkExternalMemoryHandleTypeFlagBits);
    *count += sizeof(HANDLE);
    *count += sizeof(LPCWSTR);
}

void count_VkExportMemoryWin32HandleInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExportMemoryWin32HandleInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pAttributes)
    {
        *count += sizeof(const SECURITY_ATTRIBUTES);
    }
    *count += sizeof(DWORD);
    *count += sizeof(LPCWSTR);
}

void count_VkMemoryWin32HandlePropertiesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMemoryWin32HandlePropertiesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

void count_VkMemoryGetWin32HandleInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMemoryGetWin32HandleInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_external_memory_fd
void count_VkImportMemoryFdInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImportMemoryFdInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkExternalMemoryHandleTypeFlagBits);
    *count += sizeof(int);
}

void count_VkMemoryFdPropertiesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMemoryFdPropertiesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

void count_VkMemoryGetFdInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMemoryGetFdInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkExternalMemoryHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
void count_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkWin32KeyedMutexAcquireReleaseInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount->acquireCount)
    {
        *count += toCount->acquireCount * 8;
    }
    if (toCount)
    {
        *count += toCount->acquireCount * sizeof(const uint64_t);
    }
    if (toCount)
    {
        *count += toCount->acquireCount * sizeof(const uint32_t);
    }
    *count += sizeof(uint32_t);
    if (toCount->releaseCount)
    {
        *count += toCount->releaseCount * 8;
    }
    if (toCount)
    {
        *count += toCount->releaseCount * sizeof(const uint64_t);
    }
}

#endif
#ifdef VK_KHR_external_semaphore_capabilities
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
void count_VkImportSemaphoreWin32HandleInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImportSemaphoreWin32HandleInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkSemaphoreImportFlags);
    *count += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
    *count += sizeof(HANDLE);
    *count += sizeof(LPCWSTR);
}

void count_VkExportSemaphoreWin32HandleInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExportSemaphoreWin32HandleInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pAttributes)
    {
        *count += sizeof(const SECURITY_ATTRIBUTES);
    }
    *count += sizeof(DWORD);
    *count += sizeof(LPCWSTR);
}

void count_VkD3D12FenceSubmitInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkD3D12FenceSubmitInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pWaitSemaphoreValues)
    {
        if (toCount)
        {
            *count += toCount->waitSemaphoreValuesCount * sizeof(const uint64_t);
        }
    }
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pSignalSemaphoreValues)
    {
        if (toCount)
        {
            *count += toCount->signalSemaphoreValuesCount * sizeof(const uint64_t);
        }
    }
}

void count_VkSemaphoreGetWin32HandleInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSemaphoreGetWin32HandleInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_external_semaphore_fd
void count_VkImportSemaphoreFdInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImportSemaphoreFdInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkSemaphoreImportFlags);
    *count += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
    *count += sizeof(int);
}

void count_VkSemaphoreGetFdInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSemaphoreGetFdInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkExternalSemaphoreHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_push_descriptor
void count_VkPhysicalDevicePushDescriptorPropertiesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDevicePushDescriptorPropertiesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

#endif
#ifdef VK_KHR_shader_float16_int8
#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
void count_VkRectLayerKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkRectLayerKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    count_VkOffset2D(featureBits, rootType, (VkOffset2D*)(&toCount->offset), count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->extent), count);
    *count += sizeof(uint32_t);
}

void count_VkPresentRegionKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPresentRegionKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pRectangles)
    {
        if (toCount)
        {
            for (uint32_t i = 0; i < (uint32_t)toCount->rectangleCount; ++i)
            {
                count_VkRectLayerKHR(featureBits, rootType, (const VkRectLayerKHR*)(toCount->pRectangles + i), count);
            }
        }
    }
}

void count_VkPresentRegionsKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPresentRegionsKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pRegions)
    {
        if (toCount)
        {
            for (uint32_t i = 0; i < (uint32_t)toCount->swapchainCount; ++i)
            {
                count_VkPresentRegionKHR(featureBits, rootType, (const VkPresentRegionKHR*)(toCount->pRegions + i), count);
            }
        }
    }
}

#endif
#ifdef VK_KHR_descriptor_update_template
#endif
#ifdef VK_KHR_imageless_framebuffer
#endif
#ifdef VK_KHR_create_renderpass2
#endif
#ifdef VK_KHR_shared_presentable_image
void count_VkSharedPresentSurfaceCapabilitiesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSharedPresentSurfaceCapabilitiesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkImageUsageFlags);
}

#endif
#ifdef VK_KHR_external_fence_capabilities
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
void count_VkImportFenceWin32HandleInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImportFenceWin32HandleInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkFenceImportFlags);
    *count += sizeof(VkExternalFenceHandleTypeFlagBits);
    *count += sizeof(HANDLE);
    *count += sizeof(LPCWSTR);
}

void count_VkExportFenceWin32HandleInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExportFenceWin32HandleInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pAttributes)
    {
        *count += sizeof(const SECURITY_ATTRIBUTES);
    }
    *count += sizeof(DWORD);
    *count += sizeof(LPCWSTR);
}

void count_VkFenceGetWin32HandleInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkFenceGetWin32HandleInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkExternalFenceHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_external_fence_fd
void count_VkImportFenceFdInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImportFenceFdInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkFenceImportFlags);
    *count += sizeof(VkExternalFenceHandleTypeFlagBits);
    *count += sizeof(int);
}

void count_VkFenceGetFdInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkFenceGetFdInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkExternalFenceHandleTypeFlagBits);
}

#endif
#ifdef VK_KHR_performance_query
void count_VkPhysicalDevicePerformanceQueryFeaturesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDevicePerformanceQueryFeaturesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDevicePerformanceQueryPropertiesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDevicePerformanceQueryPropertiesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkPerformanceCounterKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPerformanceCounterKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPerformanceCounterUnitKHR);
    *count += sizeof(VkPerformanceCounterScopeKHR);
    *count += sizeof(VkPerformanceCounterStorageKHR);
    *count += VK_UUID_SIZE * sizeof(uint8_t);
}

void count_VkPerformanceCounterDescriptionKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPerformanceCounterDescriptionKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPerformanceCounterDescriptionFlagsKHR);
    *count += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    *count += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    *count += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
}

void count_VkQueryPoolPerformanceCreateInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkQueryPoolPerformanceCreateInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->counterIndexCount * sizeof(const uint32_t);
    }
}

void count_VkPerformanceCounterResultKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPerformanceCounterResultKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(int32_t);
}

void count_VkAcquireProfilingLockInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAcquireProfilingLockInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkAcquireProfilingLockFlagsKHR);
    *count += sizeof(uint64_t);
}

void count_VkPerformanceQuerySubmitInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPerformanceQuerySubmitInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
void count_VkPhysicalDeviceSurfaceInfo2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceSurfaceInfo2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
}

void count_VkSurfaceCapabilities2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSurfaceCapabilities2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkSurfaceCapabilitiesKHR(featureBits, rootType, (VkSurfaceCapabilitiesKHR*)(&toCount->surfaceCapabilities), count);
}

void count_VkSurfaceFormat2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSurfaceFormat2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkSurfaceFormatKHR(featureBits, rootType, (VkSurfaceFormatKHR*)(&toCount->surfaceFormat), count);
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
void count_VkDisplayProperties2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDisplayProperties2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkDisplayPropertiesKHR(featureBits, rootType, (VkDisplayPropertiesKHR*)(&toCount->displayProperties), count);
}

void count_VkDisplayPlaneProperties2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDisplayPlaneProperties2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkDisplayPlanePropertiesKHR(featureBits, rootType, (VkDisplayPlanePropertiesKHR*)(&toCount->displayPlaneProperties), count);
}

void count_VkDisplayModeProperties2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDisplayModeProperties2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkDisplayModePropertiesKHR(featureBits, rootType, (VkDisplayModePropertiesKHR*)(&toCount->displayModeProperties), count);
}

void count_VkDisplayPlaneInfo2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDisplayPlaneInfo2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
}

void count_VkDisplayPlaneCapabilities2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDisplayPlaneCapabilities2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkDisplayPlaneCapabilitiesKHR(featureBits, rootType, (VkDisplayPlaneCapabilitiesKHR*)(&toCount->capabilities), count);
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
#endif
#ifdef VK_KHR_image_format_list
#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
#endif
#ifdef VK_KHR_bind_memory2
#endif
#ifdef VK_KHR_portability_subset
void count_VkPhysicalDevicePortabilitySubsetFeaturesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDevicePortabilitySubsetFeaturesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDevicePortabilitySubsetPropertiesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDevicePortabilitySubsetPropertiesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

#endif
#ifdef VK_KHR_maintenance3
#endif
#ifdef VK_KHR_draw_indirect_count
#endif
#ifdef VK_KHR_shader_subgroup_extended_types
#endif
#ifdef VK_KHR_8bit_storage
#endif
#ifdef VK_KHR_shader_atomic_int64
#endif
#ifdef VK_KHR_shader_clock
void count_VkPhysicalDeviceShaderClockFeaturesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderClockFeaturesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_KHR_driver_properties
#endif
#ifdef VK_KHR_shader_float_controls
#endif
#ifdef VK_KHR_depth_stencil_resolve
#endif
#ifdef VK_KHR_swapchain_mutable_format
#endif
#ifdef VK_KHR_timeline_semaphore
#endif
#ifdef VK_KHR_vulkan_memory_model
#endif
#ifdef VK_KHR_shader_terminate_invocation
void count_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_KHR_fragment_shading_rate
void count_VkFragmentShadingRateAttachmentInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkFragmentShadingRateAttachmentInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkAttachmentReference2(featureBits, rootType, (const VkAttachmentReference2*)(toCount->pFragmentShadingRateAttachment), count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->shadingRateAttachmentTexelSize), count);
}

void count_VkPipelineFragmentShadingRateStateCreateInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineFragmentShadingRateStateCreateInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->fragmentSize), count);
    *count += 2 * sizeof(VkFragmentShadingRateCombinerOpKHR);
}

void count_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentShadingRateFeaturesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentShadingRatePropertiesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->minFragmentShadingRateAttachmentTexelSize), count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->maxFragmentShadingRateAttachmentTexelSize), count);
    *count += sizeof(uint32_t);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->maxFragmentSize), count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkSampleCountFlagBits);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceFragmentShadingRateKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentShadingRateKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkSampleCountFlags);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->fragmentSize), count);
}

#endif
#ifdef VK_KHR_spirv_1_4
#endif
#ifdef VK_KHR_surface_protected_capabilities
void count_VkSurfaceProtectedCapabilitiesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSurfaceProtectedCapabilitiesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_KHR_separate_depth_stencil_layouts
#endif
#ifdef VK_KHR_uniform_buffer_standard_layout
#endif
#ifdef VK_KHR_buffer_device_address
#endif
#ifdef VK_KHR_deferred_host_operations
#endif
#ifdef VK_KHR_pipeline_executable_properties
void count_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkPipelineInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
}

void count_VkPipelineExecutablePropertiesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineExecutablePropertiesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkShaderStageFlags);
    *count += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    *count += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    *count += sizeof(uint32_t);
}

void count_VkPipelineExecutableInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineExecutableInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
}

void count_VkPipelineExecutableStatisticValueKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineExecutableStatisticValueKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkBool32);
}

void count_VkPipelineExecutableStatisticKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineExecutableStatisticKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    *count += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    *count += sizeof(VkPipelineExecutableStatisticFormatKHR);
    count_VkPipelineExecutableStatisticValueKHR(featureBits, rootType, (VkPipelineExecutableStatisticValueKHR*)(&toCount->value), count);
}

void count_VkPipelineExecutableInternalRepresentationKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineExecutableInternalRepresentationKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    *count += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    *count += sizeof(VkBool32);
    *count += 8;
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pData)
    {
        if (toCount)
        {
            *count += toCount->dataSize * sizeof(uint8_t);
        }
    }
}

#endif
#ifdef VK_KHR_pipeline_library
void count_VkPipelineLibraryCreateInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineLibraryCreateInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount->libraryCount)
    {
        *count += toCount->libraryCount * 8;
    }
}

#endif
#ifdef VK_KHR_shader_non_semantic_info
#endif
#ifdef VK_KHR_copy_commands2
void count_VkBufferCopy2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBufferCopy2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
}

void count_VkCopyBufferInfo2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCopyBufferInfo2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->regionCount; ++i)
        {
            count_VkBufferCopy2KHR(featureBits, rootType, (const VkBufferCopy2KHR*)(toCount->pRegions + i), count);
        }
    }
}

void count_VkImageCopy2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageCopy2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkImageSubresourceLayers(featureBits, rootType, (VkImageSubresourceLayers*)(&toCount->srcSubresource), count);
    count_VkOffset3D(featureBits, rootType, (VkOffset3D*)(&toCount->srcOffset), count);
    count_VkImageSubresourceLayers(featureBits, rootType, (VkImageSubresourceLayers*)(&toCount->dstSubresource), count);
    count_VkOffset3D(featureBits, rootType, (VkOffset3D*)(&toCount->dstOffset), count);
    count_VkExtent3D(featureBits, rootType, (VkExtent3D*)(&toCount->extent), count);
}

void count_VkCopyImageInfo2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCopyImageInfo2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkImageLayout);
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(VkImageLayout);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->regionCount; ++i)
        {
            count_VkImageCopy2KHR(featureBits, rootType, (const VkImageCopy2KHR*)(toCount->pRegions + i), count);
        }
    }
}

void count_VkBufferImageCopy2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBufferImageCopy2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    count_VkImageSubresourceLayers(featureBits, rootType, (VkImageSubresourceLayers*)(&toCount->imageSubresource), count);
    count_VkOffset3D(featureBits, rootType, (VkOffset3D*)(&toCount->imageOffset), count);
    count_VkExtent3D(featureBits, rootType, (VkExtent3D*)(&toCount->imageExtent), count);
}

void count_VkCopyBufferToImageInfo2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCopyBufferToImageInfo2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(VkImageLayout);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->regionCount; ++i)
        {
            count_VkBufferImageCopy2KHR(featureBits, rootType, (const VkBufferImageCopy2KHR*)(toCount->pRegions + i), count);
        }
    }
}

void count_VkCopyImageToBufferInfo2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCopyImageToBufferInfo2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkImageLayout);
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->regionCount; ++i)
        {
            count_VkBufferImageCopy2KHR(featureBits, rootType, (const VkBufferImageCopy2KHR*)(toCount->pRegions + i), count);
        }
    }
}

void count_VkImageBlit2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageBlit2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkImageSubresourceLayers(featureBits, rootType, (VkImageSubresourceLayers*)(&toCount->srcSubresource), count);
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        count_VkOffset3D(featureBits, rootType, (VkOffset3D*)(toCount->srcOffsets + i), count);
    }
    count_VkImageSubresourceLayers(featureBits, rootType, (VkImageSubresourceLayers*)(&toCount->dstSubresource), count);
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        count_VkOffset3D(featureBits, rootType, (VkOffset3D*)(toCount->dstOffsets + i), count);
    }
}

void count_VkBlitImageInfo2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBlitImageInfo2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkImageLayout);
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(VkImageLayout);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->regionCount; ++i)
        {
            count_VkImageBlit2KHR(featureBits, rootType, (const VkImageBlit2KHR*)(toCount->pRegions + i), count);
        }
    }
    *count += sizeof(VkFilter);
}

void count_VkImageResolve2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageResolve2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkImageSubresourceLayers(featureBits, rootType, (VkImageSubresourceLayers*)(&toCount->srcSubresource), count);
    count_VkOffset3D(featureBits, rootType, (VkOffset3D*)(&toCount->srcOffset), count);
    count_VkImageSubresourceLayers(featureBits, rootType, (VkImageSubresourceLayers*)(&toCount->dstSubresource), count);
    count_VkOffset3D(featureBits, rootType, (VkOffset3D*)(&toCount->dstOffset), count);
    count_VkExtent3D(featureBits, rootType, (VkExtent3D*)(&toCount->extent), count);
}

void count_VkResolveImageInfo2KHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkResolveImageInfo2KHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkImageLayout);
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(VkImageLayout);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->regionCount; ++i)
        {
            count_VkImageResolve2KHR(featureBits, rootType, (const VkImageResolve2KHR*)(toCount->pRegions + i), count);
        }
    }
}

#endif
#ifdef VK_ANDROID_native_buffer
void count_VkNativeBufferANDROID(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkNativeBufferANDROID* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->handle)
    {
        *count += sizeof(const uint32_t);
    }
    *count += sizeof(int);
    *count += sizeof(int);
    *count += sizeof(int);
    *count += sizeof(uint64_t);
    *count += sizeof(uint64_t);
}

#endif
#ifdef VK_EXT_debug_report
void count_VkDebugReportCallbackCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDebugReportCallbackCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDebugReportFlagsEXT);
    *count += 8;
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pUserData)
    {
        *count += sizeof(uint8_t);
    }
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
void count_VkPipelineRasterizationStateRasterizationOrderAMD(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineRasterizationStateRasterizationOrderAMD* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkRasterizationOrderAMD);
}

#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
void count_VkDebugMarkerObjectNameInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDebugMarkerObjectNameInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDebugReportObjectTypeEXT);
    *count += sizeof(uint64_t);
    *count += sizeof(uint32_t) + (toCount->pObjectName ? strlen(toCount->pObjectName) : 0);
}

void count_VkDebugMarkerObjectTagInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDebugMarkerObjectTagInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDebugReportObjectTypeEXT);
    *count += sizeof(uint64_t);
    *count += sizeof(uint64_t);
    *count += 8;
    if (toCount)
    {
        *count += toCount->tagSize * sizeof(const uint8_t);
    }
}

void count_VkDebugMarkerMarkerInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDebugMarkerMarkerInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t) + (toCount->pMarkerName ? strlen(toCount->pMarkerName) : 0);
    *count += 4 * sizeof(float);
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
void count_VkDedicatedAllocationImageCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDedicatedAllocationImageCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkDedicatedAllocationBufferCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDedicatedAllocationBufferCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkDedicatedAllocationMemoryAllocateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDedicatedAllocationMemoryAllocateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    uint64_t cgen_var_1;
    *count += 1 * 8;
}

#endif
#ifdef VK_EXT_transform_feedback
void count_VkPhysicalDeviceTransformFeedbackFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceTransformFeedbackFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceTransformFeedbackPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceTransformFeedbackPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPipelineRasterizationStateStreamCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineRasterizationStateStreamCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineRasterizationStateStreamCreateFlagsEXT);
    *count += sizeof(uint32_t);
}

#endif
#ifdef VK_NVX_image_view_handle
void count_VkImageViewHandleInfoNVX(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageViewHandleInfoNVX* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkDescriptorType);
    uint64_t cgen_var_1;
    *count += 1 * 8;
}

void count_VkImageViewAddressPropertiesNVX(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageViewAddressPropertiesNVX* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceAddress);
    *count += sizeof(VkDeviceSize);
}

#endif
#ifdef VK_AMD_draw_indirect_count
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
void count_VkTextureLODGatherFormatPropertiesAMD(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkTextureLODGatherFormatPropertiesAMD* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_AMD_shader_info
void count_VkShaderResourceUsageAMD(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkShaderResourceUsageAMD* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += 8;
    *count += 8;
}

void count_VkShaderStatisticsInfoAMD(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkShaderStatisticsInfoAMD* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkShaderStageFlags);
    count_VkShaderResourceUsageAMD(featureBits, rootType, (VkShaderResourceUsageAMD*)(&toCount->resourceUsage), count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += 3 * sizeof(uint32_t);
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_GGP_stream_descriptor_surface
void count_VkStreamDescriptorSurfaceCreateInfoGGP(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkStreamDescriptorSurfaceCreateInfoGGP* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkStreamDescriptorSurfaceCreateFlagsGGP);
    *count += sizeof(GgpStreamDescriptor);
}

#endif
#ifdef VK_NV_corner_sampled_image
void count_VkPhysicalDeviceCornerSampledImageFeaturesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceCornerSampledImageFeaturesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
void count_VkExternalImageFormatPropertiesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExternalImageFormatPropertiesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    count_VkImageFormatProperties(featureBits, rootType, (VkImageFormatProperties*)(&toCount->imageFormatProperties), count);
    *count += sizeof(VkExternalMemoryFeatureFlagsNV);
    *count += sizeof(VkExternalMemoryHandleTypeFlagsNV);
    *count += sizeof(VkExternalMemoryHandleTypeFlagsNV);
}

#endif
#ifdef VK_NV_external_memory
void count_VkExternalMemoryImageCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExternalMemoryImageCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkExternalMemoryHandleTypeFlagsNV);
}

void count_VkExportMemoryAllocateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExportMemoryAllocateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkExternalMemoryHandleTypeFlagsNV);
}

#endif
#ifdef VK_NV_external_memory_win32
void count_VkImportMemoryWin32HandleInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImportMemoryWin32HandleInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkExternalMemoryHandleTypeFlagsNV);
    *count += sizeof(HANDLE);
}

void count_VkExportMemoryWin32HandleInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExportMemoryWin32HandleInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pAttributes)
    {
        *count += sizeof(const SECURITY_ATTRIBUTES);
    }
    *count += sizeof(DWORD);
}

#endif
#ifdef VK_NV_win32_keyed_mutex
void count_VkWin32KeyedMutexAcquireReleaseInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkWin32KeyedMutexAcquireReleaseInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount->acquireCount)
    {
        *count += toCount->acquireCount * 8;
    }
    if (toCount)
    {
        *count += toCount->acquireCount * sizeof(const uint64_t);
    }
    if (toCount)
    {
        *count += toCount->acquireCount * sizeof(const uint32_t);
    }
    *count += sizeof(uint32_t);
    if (toCount->releaseCount)
    {
        *count += toCount->releaseCount * 8;
    }
    if (toCount)
    {
        *count += toCount->releaseCount * sizeof(const uint64_t);
    }
}

#endif
#ifdef VK_EXT_validation_flags
void count_VkValidationFlagsEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkValidationFlagsEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT);
    }
}

#endif
#ifdef VK_NN_vi_surface
void count_VkViSurfaceCreateInfoNN(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkViSurfaceCreateInfoNN* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkViSurfaceCreateFlagsNN);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->window)
    {
        *count += sizeof(uint8_t);
    }
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
void count_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_astc_decode_mode
void count_VkImageViewASTCDecodeModeEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageViewASTCDecodeModeEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkFormat);
}

void count_VkPhysicalDeviceASTCDecodeFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceASTCDecodeFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_conditional_rendering
void count_VkConditionalRenderingBeginInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkConditionalRenderingBeginInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkConditionalRenderingFlagsEXT);
}

void count_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void count_VkViewportWScalingNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkViewportWScalingNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(float);
    *count += sizeof(float);
}

void count_VkPipelineViewportWScalingStateCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineViewportWScalingStateCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pViewportWScalings)
    {
        if (toCount)
        {
            for (uint32_t i = 0; i < (uint32_t)toCount->viewportCount; ++i)
            {
                count_VkViewportWScalingNV(featureBits, rootType, (const VkViewportWScalingNV*)(toCount->pViewportWScalings + i), count);
            }
        }
    }
}

#endif
#ifdef VK_EXT_direct_mode_display
#endif
#ifdef VK_EXT_acquire_xlib_display
#endif
#ifdef VK_EXT_display_surface_counter
void count_VkSurfaceCapabilities2EXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSurfaceCapabilities2EXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->currentExtent), count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->minImageExtent), count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->maxImageExtent), count);
    *count += sizeof(uint32_t);
    *count += sizeof(VkSurfaceTransformFlagsKHR);
    *count += sizeof(VkSurfaceTransformFlagBitsKHR);
    *count += sizeof(VkCompositeAlphaFlagsKHR);
    *count += sizeof(VkImageUsageFlags);
    *count += sizeof(VkSurfaceCounterFlagsEXT);
}

#endif
#ifdef VK_EXT_display_control
void count_VkDisplayPowerInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDisplayPowerInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDisplayPowerStateEXT);
}

void count_VkDeviceEventInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceEventInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceEventTypeEXT);
}

void count_VkDisplayEventInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDisplayEventInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDisplayEventTypeEXT);
}

void count_VkSwapchainCounterCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSwapchainCounterCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkSurfaceCounterFlagsEXT);
}

#endif
#ifdef VK_GOOGLE_display_timing
void count_VkRefreshCycleDurationGOOGLE(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkRefreshCycleDurationGOOGLE* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint64_t);
}

void count_VkPastPresentationTimingGOOGLE(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPastPresentationTimingGOOGLE* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint64_t);
    *count += sizeof(uint64_t);
    *count += sizeof(uint64_t);
    *count += sizeof(uint64_t);
}

void count_VkPresentTimeGOOGLE(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPresentTimeGOOGLE* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint64_t);
}

void count_VkPresentTimesInfoGOOGLE(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPresentTimesInfoGOOGLE* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pTimes)
    {
        if (toCount)
        {
            for (uint32_t i = 0; i < (uint32_t)toCount->swapchainCount; ++i)
            {
                count_VkPresentTimeGOOGLE(featureBits, rootType, (const VkPresentTimeGOOGLE*)(toCount->pTimes + i), count);
            }
        }
    }
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
void count_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_viewport_swizzle
void count_VkViewportSwizzleNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkViewportSwizzleNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkViewportCoordinateSwizzleNV);
    *count += sizeof(VkViewportCoordinateSwizzleNV);
    *count += sizeof(VkViewportCoordinateSwizzleNV);
    *count += sizeof(VkViewportCoordinateSwizzleNV);
}

void count_VkPipelineViewportSwizzleStateCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineViewportSwizzleStateCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineViewportSwizzleStateCreateFlagsNV);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pViewportSwizzles)
    {
        if (toCount)
        {
            for (uint32_t i = 0; i < (uint32_t)toCount->viewportCount; ++i)
            {
                count_VkViewportSwizzleNV(featureBits, rootType, (const VkViewportSwizzleNV*)(toCount->pViewportSwizzles + i), count);
            }
        }
    }
}

#endif
#ifdef VK_EXT_discard_rectangles
void count_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

void count_VkPipelineDiscardRectangleStateCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineDiscardRectangleStateCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineDiscardRectangleStateCreateFlagsEXT);
    *count += sizeof(VkDiscardRectangleModeEXT);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pDiscardRectangles)
    {
        if (toCount)
        {
            for (uint32_t i = 0; i < (uint32_t)toCount->discardRectangleCount; ++i)
            {
                count_VkRect2D(featureBits, rootType, (const VkRect2D*)(toCount->pDiscardRectangles + i), count);
            }
        }
    }
}

#endif
#ifdef VK_EXT_conservative_rasterization
void count_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceConservativeRasterizationPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(float);
    *count += sizeof(float);
    *count += sizeof(float);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineRasterizationConservativeStateCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineRasterizationConservativeStateCreateFlagsEXT);
    *count += sizeof(VkConservativeRasterizationModeEXT);
    *count += sizeof(float);
}

#endif
#ifdef VK_EXT_depth_clip_enable
void count_VkPhysicalDeviceDepthClipEnableFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceDepthClipEnableFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkPipelineRasterizationDepthClipStateCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineRasterizationDepthClipStateCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineRasterizationDepthClipStateCreateFlagsEXT);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void count_VkXYColorEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkXYColorEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(float);
    *count += sizeof(float);
}

void count_VkHdrMetadataEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkHdrMetadataEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkXYColorEXT(featureBits, rootType, (VkXYColorEXT*)(&toCount->displayPrimaryRed), count);
    count_VkXYColorEXT(featureBits, rootType, (VkXYColorEXT*)(&toCount->displayPrimaryGreen), count);
    count_VkXYColorEXT(featureBits, rootType, (VkXYColorEXT*)(&toCount->displayPrimaryBlue), count);
    count_VkXYColorEXT(featureBits, rootType, (VkXYColorEXT*)(&toCount->whitePoint), count);
    *count += sizeof(float);
    *count += sizeof(float);
    *count += sizeof(float);
    *count += sizeof(float);
}

#endif
#ifdef VK_MVK_ios_surface
void count_VkIOSSurfaceCreateInfoMVK(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkIOSSurfaceCreateInfoMVK* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkIOSSurfaceCreateFlagsMVK);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pView)
    {
        *count += sizeof(const uint8_t);
    }
}

#endif
#ifdef VK_MVK_macos_surface
void count_VkMacOSSurfaceCreateInfoMVK(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMacOSSurfaceCreateInfoMVK* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkMacOSSurfaceCreateFlagsMVK);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pView)
    {
        *count += sizeof(const uint8_t);
    }
}

#endif
#ifdef VK_MVK_moltenvk
#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
void count_VkDebugUtilsLabelEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDebugUtilsLabelEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t) + (toCount->pLabelName ? strlen(toCount->pLabelName) : 0);
    *count += 4 * sizeof(float);
}

void count_VkDebugUtilsObjectNameInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDebugUtilsObjectNameInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkObjectType);
    *count += sizeof(uint64_t);
    if (featureBits & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        *count += 8;
        if (toCount->pObjectName)
        {
            *count += sizeof(uint32_t) + (toCount->pObjectName ? strlen(toCount->pObjectName) : 0);
        }
    }
    else
    {
        *count += sizeof(uint32_t) + (toCount->pObjectName ? strlen(toCount->pObjectName) : 0);
    }
}

void count_VkDebugUtilsMessengerCallbackDataEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDebugUtilsMessengerCallbackDataEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDebugUtilsMessengerCallbackDataFlagsEXT);
    if (featureBits & VULKAN_STREAM_FEATURE_NULL_OPTIONAL_STRINGS_BIT)
    {
        // WARNING PTR CHECK
        *count += 8;
        if (toCount->pMessageIdName)
        {
            *count += sizeof(uint32_t) + (toCount->pMessageIdName ? strlen(toCount->pMessageIdName) : 0);
        }
    }
    else
    {
        *count += sizeof(uint32_t) + (toCount->pMessageIdName ? strlen(toCount->pMessageIdName) : 0);
    }
    *count += sizeof(int32_t);
    *count += sizeof(uint32_t) + (toCount->pMessage ? strlen(toCount->pMessage) : 0);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pQueueLabels)
    {
        if (toCount)
        {
            for (uint32_t i = 0; i < (uint32_t)toCount->queueLabelCount; ++i)
            {
                count_VkDebugUtilsLabelEXT(featureBits, rootType, (VkDebugUtilsLabelEXT*)(toCount->pQueueLabels + i), count);
            }
        }
    }
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pCmdBufLabels)
    {
        if (toCount)
        {
            for (uint32_t i = 0; i < (uint32_t)toCount->cmdBufLabelCount; ++i)
            {
                count_VkDebugUtilsLabelEXT(featureBits, rootType, (VkDebugUtilsLabelEXT*)(toCount->pCmdBufLabels + i), count);
            }
        }
    }
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pObjects)
    {
        if (toCount)
        {
            for (uint32_t i = 0; i < (uint32_t)toCount->objectCount; ++i)
            {
                count_VkDebugUtilsObjectNameInfoEXT(featureBits, rootType, (VkDebugUtilsObjectNameInfoEXT*)(toCount->pObjects + i), count);
            }
        }
    }
}

void count_VkDebugUtilsMessengerCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDebugUtilsMessengerCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDebugUtilsMessengerCreateFlagsEXT);
    *count += sizeof(VkDebugUtilsMessageSeverityFlagsEXT);
    *count += sizeof(VkDebugUtilsMessageTypeFlagsEXT);
    *count += 8;
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pUserData)
    {
        *count += sizeof(uint8_t);
    }
}

void count_VkDebugUtilsObjectTagInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDebugUtilsObjectTagInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkObjectType);
    *count += sizeof(uint64_t);
    *count += sizeof(uint64_t);
    *count += 8;
    if (toCount)
    {
        *count += toCount->tagSize * sizeof(const uint8_t);
    }
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
void count_VkAndroidHardwareBufferUsageANDROID(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAndroidHardwareBufferUsageANDROID* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint64_t);
}

void count_VkAndroidHardwareBufferPropertiesANDROID(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAndroidHardwareBufferPropertiesANDROID* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(uint32_t);
}

void count_VkAndroidHardwareBufferFormatPropertiesANDROID(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAndroidHardwareBufferFormatPropertiesANDROID* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkFormat);
    *count += sizeof(uint64_t);
    *count += sizeof(VkFormatFeatureFlags);
    count_VkComponentMapping(featureBits, rootType, (VkComponentMapping*)(&toCount->samplerYcbcrConversionComponents), count);
    *count += sizeof(VkSamplerYcbcrModelConversion);
    *count += sizeof(VkSamplerYcbcrRange);
    *count += sizeof(VkChromaLocation);
    *count += sizeof(VkChromaLocation);
}

void count_VkImportAndroidHardwareBufferInfoANDROID(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImportAndroidHardwareBufferInfoANDROID* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(AHardwareBuffer);
}

void count_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
}

void count_VkExternalFormatANDROID(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkExternalFormatANDROID* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint64_t);
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_inline_uniform_block
void count_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceInlineUniformBlockFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceInlineUniformBlockPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkWriteDescriptorSetInlineUniformBlockEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkWriteDescriptorSetInlineUniformBlockEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->dataSize * sizeof(const uint8_t);
    }
}

void count_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDescriptorPoolInlineUniformBlockCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void count_VkSampleLocationEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSampleLocationEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(float);
    *count += sizeof(float);
}

void count_VkSampleLocationsInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSampleLocationsInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkSampleCountFlagBits);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->sampleLocationGridSize), count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->sampleLocationsCount; ++i)
        {
            count_VkSampleLocationEXT(featureBits, rootType, (const VkSampleLocationEXT*)(toCount->pSampleLocations + i), count);
        }
    }
}

void count_VkAttachmentSampleLocationsEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAttachmentSampleLocationsEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    count_VkSampleLocationsInfoEXT(featureBits, rootType, (VkSampleLocationsInfoEXT*)(&toCount->sampleLocationsInfo), count);
}

void count_VkSubpassSampleLocationsEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSubpassSampleLocationsEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    count_VkSampleLocationsInfoEXT(featureBits, rootType, (VkSampleLocationsInfoEXT*)(&toCount->sampleLocationsInfo), count);
}

void count_VkRenderPassSampleLocationsBeginInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkRenderPassSampleLocationsBeginInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->attachmentInitialSampleLocationsCount; ++i)
        {
            count_VkAttachmentSampleLocationsEXT(featureBits, rootType, (const VkAttachmentSampleLocationsEXT*)(toCount->pAttachmentInitialSampleLocations + i), count);
        }
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->postSubpassSampleLocationsCount; ++i)
        {
            count_VkSubpassSampleLocationsEXT(featureBits, rootType, (const VkSubpassSampleLocationsEXT*)(toCount->pPostSubpassSampleLocations + i), count);
        }
    }
}

void count_VkPipelineSampleLocationsStateCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineSampleLocationsStateCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    count_VkSampleLocationsInfoEXT(featureBits, rootType, (VkSampleLocationsInfoEXT*)(&toCount->sampleLocationsInfo), count);
}

void count_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceSampleLocationsPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkSampleCountFlags);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->maxSampleLocationGridSize), count);
    *count += 2 * sizeof(float);
    *count += sizeof(uint32_t);
    *count += sizeof(VkBool32);
}

void count_VkMultisamplePropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMultisamplePropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->maxSampleLocationGridSize), count);
}

#endif
#ifdef VK_EXT_blend_operation_advanced
void count_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineColorBlendAdvancedStateCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBlendOverlapEXT);
}

#endif
#ifdef VK_NV_fragment_coverage_to_color
void count_VkPipelineCoverageToColorStateCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineCoverageToColorStateCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineCoverageToColorStateCreateFlagsNV);
    *count += sizeof(VkBool32);
    *count += sizeof(uint32_t);
}

#endif
#ifdef VK_NV_framebuffer_mixed_samples
void count_VkPipelineCoverageModulationStateCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineCoverageModulationStateCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineCoverageModulationStateCreateFlagsNV);
    *count += sizeof(VkCoverageModulationModeNV);
    *count += sizeof(VkBool32);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pCoverageModulationTable)
    {
        if (toCount)
        {
            *count += toCount->coverageModulationTableCount * sizeof(const float);
        }
    }
}

#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_NV_shader_sm_builtins
void count_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_image_drm_format_modifier
void count_VkDrmFormatModifierPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDrmFormatModifierPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint64_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkFormatFeatureFlags);
}

void count_VkDrmFormatModifierPropertiesListEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDrmFormatModifierPropertiesListEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pDrmFormatModifierProperties)
    {
        if (toCount)
        {
            for (uint32_t i = 0; i < (uint32_t)toCount->drmFormatModifierCount; ++i)
            {
                count_VkDrmFormatModifierPropertiesEXT(featureBits, rootType, (VkDrmFormatModifierPropertiesEXT*)(toCount->pDrmFormatModifierProperties + i), count);
            }
        }
    }
}

void count_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceImageDrmFormatModifierInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint64_t);
    *count += sizeof(VkSharingMode);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pQueueFamilyIndices)
    {
        if (toCount)
        {
            *count += toCount->queueFamilyIndexCount * sizeof(const uint32_t);
        }
    }
}

void count_VkImageDrmFormatModifierListCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageDrmFormatModifierListCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->drmFormatModifierCount * sizeof(const uint64_t);
    }
}

void count_VkImageDrmFormatModifierExplicitCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageDrmFormatModifierExplicitCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint64_t);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->drmFormatModifierPlaneCount; ++i)
        {
            count_VkSubresourceLayout(featureBits, rootType, (const VkSubresourceLayout*)(toCount->pPlaneLayouts + i), count);
        }
    }
}

void count_VkImageDrmFormatModifierPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImageDrmFormatModifierPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint64_t);
}

#endif
#ifdef VK_EXT_validation_cache
void count_VkValidationCacheCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkValidationCacheCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkValidationCacheCreateFlagsEXT);
    *count += 8;
    if (toCount)
    {
        *count += toCount->initialDataSize * sizeof(const uint8_t);
    }
}

void count_VkShaderModuleValidationCacheCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkShaderModuleValidationCacheCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
}

#endif
#ifdef VK_EXT_descriptor_indexing
#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_NV_shading_rate_image
void count_VkShadingRatePaletteNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkShadingRatePaletteNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->shadingRatePaletteEntryCount * sizeof(const VkShadingRatePaletteEntryNV);
    }
}

void count_VkPipelineViewportShadingRateImageStateCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineViewportShadingRateImageStateCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pShadingRatePalettes)
    {
        if (toCount)
        {
            for (uint32_t i = 0; i < (uint32_t)toCount->viewportCount; ++i)
            {
                count_VkShadingRatePaletteNV(featureBits, rootType, (const VkShadingRatePaletteNV*)(toCount->pShadingRatePalettes + i), count);
            }
        }
    }
}

void count_VkPhysicalDeviceShadingRateImageFeaturesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceShadingRateImageFeaturesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceShadingRateImagePropertiesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceShadingRateImagePropertiesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->shadingRateTexelSize), count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkCoarseSampleLocationNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCoarseSampleLocationNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkCoarseSampleOrderCustomNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCoarseSampleOrderCustomNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkShadingRatePaletteEntryNV);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->sampleLocationCount; ++i)
        {
            count_VkCoarseSampleLocationNV(featureBits, rootType, (const VkCoarseSampleLocationNV*)(toCount->pSampleLocations + i), count);
        }
    }
}

void count_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkCoarseSampleOrderTypeNV);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->customSampleOrderCount; ++i)
        {
            count_VkCoarseSampleOrderCustomNV(featureBits, rootType, (const VkCoarseSampleOrderCustomNV*)(toCount->pCustomSampleOrders + i), count);
        }
    }
}

#endif
#ifdef VK_NV_ray_tracing
void count_VkRayTracingShaderGroupCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkRayTracingShaderGroupCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkRayTracingShaderGroupTypeKHR);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkRayTracingPipelineCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkRayTracingPipelineCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineCreateFlags);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->stageCount; ++i)
        {
            count_VkPipelineShaderStageCreateInfo(featureBits, rootType, (const VkPipelineShaderStageCreateInfo*)(toCount->pStages + i), count);
        }
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->groupCount; ++i)
        {
            count_VkRayTracingShaderGroupCreateInfoNV(featureBits, rootType, (const VkRayTracingShaderGroupCreateInfoNV*)(toCount->pGroups + i), count);
        }
    }
    *count += sizeof(uint32_t);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(int32_t);
}

void count_VkGeometryTrianglesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkGeometryTrianglesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkDeviceSize);
    *count += sizeof(uint32_t);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkFormat);
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(VkDeviceSize);
    *count += sizeof(uint32_t);
    *count += sizeof(VkIndexType);
    uint64_t cgen_var_2;
    *count += 1 * 8;
    *count += sizeof(VkDeviceSize);
}

void count_VkGeometryAABBNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkGeometryAABBNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkDeviceSize);
}

void count_VkGeometryDataNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkGeometryDataNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    count_VkGeometryTrianglesNV(featureBits, rootType, (VkGeometryTrianglesNV*)(&toCount->triangles), count);
    count_VkGeometryAABBNV(featureBits, rootType, (VkGeometryAABBNV*)(&toCount->aabbs), count);
}

void count_VkGeometryNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkGeometryNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkGeometryTypeKHR);
    count_VkGeometryDataNV(featureBits, rootType, (VkGeometryDataNV*)(&toCount->geometry), count);
    *count += sizeof(VkGeometryFlagsKHR);
}

void count_VkAccelerationStructureInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAccelerationStructureInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkAccelerationStructureTypeNV);
    *count += sizeof(VkBuildAccelerationStructureFlagsNV);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->geometryCount; ++i)
        {
            count_VkGeometryNV(featureBits, rootType, (const VkGeometryNV*)(toCount->pGeometries + i), count);
        }
    }
}

void count_VkAccelerationStructureCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAccelerationStructureCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceSize);
    count_VkAccelerationStructureInfoNV(featureBits, rootType, (VkAccelerationStructureInfoNV*)(&toCount->info), count);
}

void count_VkBindAccelerationStructureMemoryInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBindAccelerationStructureMemoryInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(VkDeviceSize);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->deviceIndexCount * sizeof(const uint32_t);
    }
}

void count_VkWriteDescriptorSetAccelerationStructureNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkWriteDescriptorSetAccelerationStructureNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pAccelerationStructures)
    {
        if (toCount->accelerationStructureCount)
        {
            *count += toCount->accelerationStructureCount * 8;
        }
    }
}

void count_VkAccelerationStructureMemoryRequirementsInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAccelerationStructureMemoryRequirementsInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkAccelerationStructureMemoryRequirementsTypeNV);
    uint64_t cgen_var_0;
    *count += 1 * 8;
}

void count_VkPhysicalDeviceRayTracingPropertiesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceRayTracingPropertiesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint64_t);
    *count += sizeof(uint64_t);
    *count += sizeof(uint64_t);
    *count += sizeof(uint32_t);
}

void count_VkTransformMatrixKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkTransformMatrixKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += ((3)*(4)) * sizeof(float);
}

void count_VkAabbPositionsKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAabbPositionsKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(float);
    *count += sizeof(float);
    *count += sizeof(float);
    *count += sizeof(float);
    *count += sizeof(float);
    *count += sizeof(float);
}

void count_VkAccelerationStructureInstanceKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAccelerationStructureInstanceKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    count_VkTransformMatrixKHR(featureBits, rootType, (VkTransformMatrixKHR*)(&toCount->transform), count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkGeometryInstanceFlagsKHR);
    *count += sizeof(uint64_t);
}

#endif
#ifdef VK_NV_representative_fragment_test
void count_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineRepresentativeFragmentTestStateCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_filter_cubic
void count_VkPhysicalDeviceImageViewImageFormatInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceImageViewImageFormatInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkImageViewType);
}

void count_VkFilterCubicImageViewImageFormatPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkFilterCubicImageViewImageFormatPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_QCOM_render_pass_shader_resolve
#endif
#ifdef VK_EXT_global_priority
void count_VkDeviceQueueGlobalPriorityCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceQueueGlobalPriorityCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkQueueGlobalPriorityEXT);
}

#endif
#ifdef VK_EXT_external_memory_host
void count_VkImportMemoryHostPointerInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImportMemoryHostPointerInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkExternalMemoryHandleTypeFlagBits);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pHostPointer)
    {
        *count += sizeof(uint8_t);
    }
}

void count_VkMemoryHostPointerPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMemoryHostPointerPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

void count_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceSize);
}

#endif
#ifdef VK_AMD_buffer_marker
#endif
#ifdef VK_AMD_pipeline_compiler_control
void count_VkPipelineCompilerControlCreateInfoAMD(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineCompilerControlCreateInfoAMD* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineCompilerControlFlagsAMD);
}

#endif
#ifdef VK_EXT_calibrated_timestamps
void count_VkCalibratedTimestampInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCalibratedTimestampInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkTimeDomainEXT);
}

#endif
#ifdef VK_AMD_shader_core_properties
void count_VkPhysicalDeviceShaderCorePropertiesAMD(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderCorePropertiesAMD* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

#endif
#ifdef VK_AMD_memory_overallocation_behavior
void count_VkDeviceMemoryOverallocationCreateInfoAMD(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceMemoryOverallocationCreateInfoAMD* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkMemoryOverallocationBehaviorAMD);
}

#endif
#ifdef VK_EXT_vertex_attribute_divisor
void count_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

void count_VkVertexInputBindingDivisorDescriptionEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkVertexInputBindingDivisorDescriptionEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineVertexInputDivisorStateCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->vertexBindingDivisorCount; ++i)
        {
            count_VkVertexInputBindingDivisorDescriptionEXT(featureBits, rootType, (const VkVertexInputBindingDivisorDescriptionEXT*)(toCount->pVertexBindingDivisors + i), count);
        }
    }
}

void count_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_GGP_frame_token
void count_VkPresentFrameTokenGGP(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPresentFrameTokenGGP* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(GgpFrameToken);
}

#endif
#ifdef VK_EXT_pipeline_creation_feedback
void count_VkPipelineCreationFeedbackEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineCreationFeedbackEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkPipelineCreationFeedbackFlagsEXT);
    *count += sizeof(uint64_t);
}

void count_VkPipelineCreationFeedbackCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineCreationFeedbackCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkPipelineCreationFeedbackEXT(featureBits, rootType, (VkPipelineCreationFeedbackEXT*)(toCount->pPipelineCreationFeedback), count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->pipelineStageCreationFeedbackCount; ++i)
        {
            count_VkPipelineCreationFeedbackEXT(featureBits, rootType, (VkPipelineCreationFeedbackEXT*)(toCount->pPipelineStageCreationFeedbacks + i), count);
        }
    }
}

#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_compute_shader_derivatives
void count_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_mesh_shader
void count_VkPhysicalDeviceMeshShaderFeaturesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceMeshShaderFeaturesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceMeshShaderPropertiesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceMeshShaderPropertiesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += 3 * sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += 3 * sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkDrawMeshTasksIndirectCommandNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDrawMeshTasksIndirectCommandNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

#endif
#ifdef VK_NV_fragment_shader_barycentric
void count_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_shader_image_footprint
void count_VkPhysicalDeviceShaderImageFootprintFeaturesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderImageFootprintFeaturesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_scissor_exclusive
void count_VkPipelineViewportExclusiveScissorStateCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineViewportExclusiveScissorStateCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pExclusiveScissors)
    {
        if (toCount)
        {
            for (uint32_t i = 0; i < (uint32_t)toCount->exclusiveScissorCount; ++i)
            {
                count_VkRect2D(featureBits, rootType, (const VkRect2D*)(toCount->pExclusiveScissors + i), count);
            }
        }
    }
}

void count_VkPhysicalDeviceExclusiveScissorFeaturesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceExclusiveScissorFeaturesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void count_VkQueueFamilyCheckpointPropertiesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkQueueFamilyCheckpointPropertiesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineStageFlags);
}

void count_VkCheckpointDataNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCheckpointDataNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineStageFlagBits);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pCheckpointMarker)
    {
        *count += sizeof(uint8_t);
    }
}

#endif
#ifdef VK_INTEL_shader_integer_functions2
void count_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_INTEL_performance_query
void count_VkPerformanceValueDataINTEL(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPerformanceValueDataINTEL* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
}

void count_VkPerformanceValueINTEL(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPerformanceValueINTEL* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkPerformanceValueTypeINTEL);
    count_VkPerformanceValueDataINTEL(featureBits, rootType, (VkPerformanceValueDataINTEL*)(&toCount->data), count);
}

void count_VkInitializePerformanceApiInfoINTEL(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkInitializePerformanceApiInfoINTEL* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pUserData)
    {
        *count += sizeof(uint8_t);
    }
}

void count_VkQueryPoolPerformanceQueryCreateInfoINTEL(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkQueryPoolPerformanceQueryCreateInfoINTEL* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkQueryPoolSamplingModeINTEL);
}

void count_VkPerformanceMarkerInfoINTEL(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPerformanceMarkerInfoINTEL* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint64_t);
}

void count_VkPerformanceStreamMarkerInfoINTEL(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPerformanceStreamMarkerInfoINTEL* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

void count_VkPerformanceOverrideInfoINTEL(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPerformanceOverrideInfoINTEL* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPerformanceOverrideTypeINTEL);
    *count += sizeof(VkBool32);
    *count += sizeof(uint64_t);
}

void count_VkPerformanceConfigurationAcquireInfoINTEL(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPerformanceConfigurationAcquireInfoINTEL* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPerformanceConfigurationTypeINTEL);
}

#endif
#ifdef VK_EXT_pci_bus_info
void count_VkPhysicalDevicePCIBusInfoPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDevicePCIBusInfoPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

#endif
#ifdef VK_AMD_display_native_hdr
void count_VkDisplayNativeHdrSurfaceCapabilitiesAMD(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDisplayNativeHdrSurfaceCapabilitiesAMD* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkSwapchainDisplayNativeHdrCreateInfoAMD(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSwapchainDisplayNativeHdrCreateInfoAMD* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_FUCHSIA_imagepipe_surface
void count_VkImagePipeSurfaceCreateInfoFUCHSIA(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImagePipeSurfaceCreateInfoFUCHSIA* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkImagePipeSurfaceCreateFlagsFUCHSIA);
    *count += sizeof(zx_handle_t);
}

#endif
#ifdef VK_EXT_metal_surface
void count_VkMetalSurfaceCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMetalSurfaceCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkMetalSurfaceCreateFlagsEXT);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pLayer)
    {
        *count += sizeof(const CAMetalLayer);
    }
}

#endif
#ifdef VK_EXT_fragment_density_map
void count_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentDensityMapFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentDensityMapPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->minFragmentDensityTexelSize), count);
    count_VkExtent2D(featureBits, rootType, (VkExtent2D*)(&toCount->maxFragmentDensityTexelSize), count);
    *count += sizeof(VkBool32);
}

void count_VkRenderPassFragmentDensityMapCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkRenderPassFragmentDensityMapCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkAttachmentReference(featureBits, rootType, (VkAttachmentReference*)(&toCount->fragmentDensityMapAttachment), count);
}

#endif
#ifdef VK_EXT_scalar_block_layout
#endif
#ifdef VK_GOOGLE_hlsl_functionality1
#endif
#ifdef VK_GOOGLE_decorate_string
#endif
#ifdef VK_EXT_subgroup_size_control
void count_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkShaderStageFlags);
}

void count_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

#endif
#ifdef VK_AMD_shader_core_properties2
void count_VkPhysicalDeviceShaderCoreProperties2AMD(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderCoreProperties2AMD* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkShaderCorePropertiesFlagsAMD);
    *count += sizeof(uint32_t);
}

#endif
#ifdef VK_AMD_device_coherent_memory
void count_VkPhysicalDeviceCoherentMemoryFeaturesAMD(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceCoherentMemoryFeaturesAMD* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_shader_image_atomic_int64
void count_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_memory_budget
void count_VkPhysicalDeviceMemoryBudgetPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceMemoryBudgetPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize);
    *count += VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize);
}

#endif
#ifdef VK_EXT_memory_priority
void count_VkPhysicalDeviceMemoryPriorityFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceMemoryPriorityFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkMemoryPriorityAllocateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkMemoryPriorityAllocateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(float);
}

#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
void count_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_buffer_device_address
void count_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkBufferDeviceAddressCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBufferDeviceAddressCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceAddress);
}

#endif
#ifdef VK_EXT_tooling_info
void count_VkPhysicalDeviceToolPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceToolPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
    *count += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
    *count += sizeof(VkToolPurposeFlagsEXT);
    *count += VK_MAX_DESCRIPTION_SIZE * sizeof(char);
    *count += VK_MAX_EXTENSION_NAME_SIZE * sizeof(char);
}

#endif
#ifdef VK_EXT_separate_stencil_usage
#endif
#ifdef VK_EXT_validation_features
void count_VkValidationFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkValidationFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->enabledValidationFeatureCount * sizeof(const VkValidationFeatureEnableEXT);
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->disabledValidationFeatureCount * sizeof(const VkValidationFeatureDisableEXT);
    }
}

#endif
#ifdef VK_NV_cooperative_matrix
void count_VkCooperativeMatrixPropertiesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCooperativeMatrixPropertiesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkComponentTypeNV);
    *count += sizeof(VkComponentTypeNV);
    *count += sizeof(VkComponentTypeNV);
    *count += sizeof(VkComponentTypeNV);
    *count += sizeof(VkScopeNV);
}

void count_VkPhysicalDeviceCooperativeMatrixFeaturesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceCooperativeMatrixFeaturesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceCooperativeMatrixPropertiesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceCooperativeMatrixPropertiesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkShaderStageFlags);
}

#endif
#ifdef VK_NV_coverage_reduction_mode
void count_VkPhysicalDeviceCoverageReductionModeFeaturesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceCoverageReductionModeFeaturesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkPipelineCoverageReductionStateCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineCoverageReductionStateCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineCoverageReductionStateCreateFlagsNV);
    *count += sizeof(VkCoverageReductionModeNV);
}

void count_VkFramebufferMixedSamplesCombinationNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkFramebufferMixedSamplesCombinationNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkCoverageReductionModeNV);
    *count += sizeof(VkSampleCountFlagBits);
    *count += sizeof(VkSampleCountFlags);
    *count += sizeof(VkSampleCountFlags);
}

#endif
#ifdef VK_EXT_fragment_shader_interlock
void count_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_ycbcr_image_arrays
void count_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_full_screen_exclusive
void count_VkSurfaceFullScreenExclusiveInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSurfaceFullScreenExclusiveInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkFullScreenExclusiveEXT);
}

void count_VkSurfaceCapabilitiesFullScreenExclusiveEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSurfaceCapabilitiesFullScreenExclusiveEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkSurfaceFullScreenExclusiveWin32InfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSurfaceFullScreenExclusiveWin32InfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(HMONITOR);
}

#endif
#ifdef VK_EXT_headless_surface
void count_VkHeadlessSurfaceCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkHeadlessSurfaceCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkHeadlessSurfaceCreateFlagsEXT);
}

#endif
#ifdef VK_EXT_line_rasterization
void count_VkPhysicalDeviceLineRasterizationFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceLineRasterizationFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceLineRasterizationPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceLineRasterizationPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

void count_VkPipelineRasterizationLineStateCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineRasterizationLineStateCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkLineRasterizationModeEXT);
    *count += sizeof(VkBool32);
    *count += sizeof(uint32_t);
    *count += sizeof(uint16_t);
}

#endif
#ifdef VK_EXT_shader_atomic_float
void count_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_host_query_reset
#endif
#ifdef VK_EXT_index_type_uint8
void count_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceIndexTypeUint8FeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_extended_dynamic_state
void count_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
void count_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_device_generated_commands
void count_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkGraphicsShaderGroupCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkGraphicsShaderGroupCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->stageCount; ++i)
        {
            count_VkPipelineShaderStageCreateInfo(featureBits, rootType, (const VkPipelineShaderStageCreateInfo*)(toCount->pStages + i), count);
        }
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pVertexInputState)
    {
        count_VkPipelineVertexInputStateCreateInfo(featureBits, rootType, (const VkPipelineVertexInputStateCreateInfo*)(toCount->pVertexInputState), count);
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pTessellationState)
    {
        count_VkPipelineTessellationStateCreateInfo(featureBits, rootType, (const VkPipelineTessellationStateCreateInfo*)(toCount->pTessellationState), count);
    }
}

void count_VkGraphicsPipelineShaderGroupsCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkGraphicsPipelineShaderGroupsCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->groupCount; ++i)
        {
            count_VkGraphicsShaderGroupCreateInfoNV(featureBits, rootType, (const VkGraphicsShaderGroupCreateInfoNV*)(toCount->pGroups + i), count);
        }
    }
    *count += sizeof(uint32_t);
    if (toCount->pipelineCount)
    {
        *count += toCount->pipelineCount * 8;
    }
}

void count_VkBindShaderGroupIndirectCommandNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBindShaderGroupIndirectCommandNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
}

void count_VkBindIndexBufferIndirectCommandNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBindIndexBufferIndirectCommandNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkDeviceAddress);
    *count += sizeof(uint32_t);
    *count += sizeof(VkIndexType);
}

void count_VkBindVertexBufferIndirectCommandNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkBindVertexBufferIndirectCommandNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkDeviceAddress);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkSetStateFlagsIndirectCommandNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSetStateFlagsIndirectCommandNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
}

void count_VkIndirectCommandsStreamNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkIndirectCommandsStreamNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkDeviceSize);
}

void count_VkIndirectCommandsLayoutTokenNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkIndirectCommandsLayoutTokenNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkIndirectCommandsTokenTypeNV);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkBool32);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkShaderStageFlags);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(VkIndirectStateFlagsNV);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->indexTypeCount * sizeof(const VkIndexType);
    }
    if (toCount)
    {
        *count += toCount->indexTypeCount * sizeof(const uint32_t);
    }
}

void count_VkIndirectCommandsLayoutCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkIndirectCommandsLayoutCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkIndirectCommandsLayoutUsageFlagsNV);
    *count += sizeof(VkPipelineBindPoint);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->tokenCount; ++i)
        {
            count_VkIndirectCommandsLayoutTokenNV(featureBits, rootType, (const VkIndirectCommandsLayoutTokenNV*)(toCount->pTokens + i), count);
        }
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        *count += toCount->streamCount * sizeof(const uint32_t);
    }
}

void count_VkGeneratedCommandsInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkGeneratedCommandsInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineBindPoint);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->streamCount; ++i)
        {
            count_VkIndirectCommandsStreamNV(featureBits, rootType, (const VkIndirectCommandsStreamNV*)(toCount->pStreams + i), count);
        }
    }
    *count += sizeof(uint32_t);
    uint64_t cgen_var_2;
    *count += 1 * 8;
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
    uint64_t cgen_var_3;
    *count += 1 * 8;
    *count += sizeof(VkDeviceSize);
    uint64_t cgen_var_4;
    *count += 1 * 8;
    *count += sizeof(VkDeviceSize);
}

void count_VkGeneratedCommandsMemoryRequirementsInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkGeneratedCommandsMemoryRequirementsInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineBindPoint);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
}

#endif
#ifdef VK_EXT_texel_buffer_alignment
void count_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkBool32);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_QCOM_render_pass_transform
void count_VkRenderPassTransformBeginInfoQCOM(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkRenderPassTransformBeginInfoQCOM* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkSurfaceTransformFlagBitsKHR);
}

void count_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCommandBufferInheritanceRenderPassTransformInfoQCOM* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkSurfaceTransformFlagBitsKHR);
    count_VkRect2D(featureBits, rootType, (VkRect2D*)(&toCount->renderArea), count);
}

#endif
#ifdef VK_EXT_device_memory_report
void count_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkDeviceMemoryReportCallbackDataEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceMemoryReportCallbackDataEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceMemoryReportFlagsEXT);
    *count += sizeof(VkDeviceMemoryReportEventTypeEXT);
    *count += sizeof(uint64_t);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkObjectType);
    *count += sizeof(uint64_t);
    *count += sizeof(uint32_t);
}

void count_VkDeviceDeviceMemoryReportCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceDeviceMemoryReportCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceMemoryReportFlagsEXT);
    *count += 8;
    *count += sizeof(uint8_t);
}

#endif
#ifdef VK_EXT_robustness2
void count_VkPhysicalDeviceRobustness2FeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceRobustness2FeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceRobustness2PropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceRobustness2PropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
}

#endif
#ifdef VK_EXT_custom_border_color
void count_VkSamplerCustomBorderColorCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkSamplerCustomBorderColorCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkClearColorValue(featureBits, rootType, (VkClearColorValue*)(&toCount->customBorderColor), count);
    *count += sizeof(VkFormat);
}

void count_VkPhysicalDeviceCustomBorderColorPropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceCustomBorderColorPropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

void count_VkPhysicalDeviceCustomBorderColorFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceCustomBorderColorFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_GOOGLE_user_type
#endif
#ifdef VK_EXT_private_data
void count_VkPhysicalDevicePrivateDataFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDevicePrivateDataFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkDevicePrivateDataCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDevicePrivateDataCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

void count_VkPrivateDataSlotCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPrivateDataSlotCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPrivateDataSlotCreateFlagsEXT);
}

#endif
#ifdef VK_EXT_pipeline_creation_cache_control
void count_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_NV_device_diagnostics_config
void count_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceDiagnosticsConfigFeaturesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkDeviceDiagnosticsConfigCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceDiagnosticsConfigCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceDiagnosticsConfigFlagsNV);
}

#endif
#ifdef VK_QCOM_render_pass_store_ops
#endif
#ifdef VK_NV_fragment_shading_rate_enums
void count_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkSampleCountFlagBits);
}

void count_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPipelineFragmentShadingRateEnumStateCreateInfoNV* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkFragmentShadingRateTypeNV);
    *count += sizeof(VkFragmentShadingRateNV);
    *count += 2 * sizeof(VkFragmentShadingRateCombinerOpKHR);
}

#endif
#ifdef VK_EXT_fragment_density_map2
void count_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

#endif
#ifdef VK_QCOM_rotated_copy_commands
void count_VkCopyCommandTransformInfoQCOM(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCopyCommandTransformInfoQCOM* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkSurfaceTransformFlagBitsKHR);
}

#endif
#ifdef VK_EXT_image_robustness
void count_VkPhysicalDeviceImageRobustnessFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceImageRobustnessFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_4444_formats
void count_VkPhysicalDevice4444FormatsFeaturesEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDevice4444FormatsFeaturesEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

#endif
#ifdef VK_EXT_directfb_surface
void count_VkDirectFBSurfaceCreateInfoEXT(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDirectFBSurfaceCreateInfoEXT* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDirectFBSurfaceCreateFlagsEXT);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->dfb)
    {
        *count += sizeof(IDirectFB);
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->surface)
    {
        *count += sizeof(IDirectFBSurface);
    }
}

#endif
#ifdef VK_GOOGLE_gfxstream
void count_VkImportColorBufferGOOGLE(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImportColorBufferGOOGLE* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

void count_VkImportBufferGOOGLE(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImportBufferGOOGLE* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
}

void count_VkImportPhysicalAddressGOOGLE(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkImportPhysicalAddressGOOGLE* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint64_t);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkFormat);
    *count += sizeof(VkImageTiling);
    *count += sizeof(uint32_t);
}

#endif
#ifdef VK_KHR_acceleration_structure
void count_VkDeviceOrHostAddressKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceOrHostAddressKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkDeviceAddress);
}

void count_VkDeviceOrHostAddressConstKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkDeviceOrHostAddressConstKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkDeviceAddress);
}

void count_VkAccelerationStructureBuildRangeInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAccelerationStructureBuildRangeInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkAccelerationStructureGeometryTrianglesDataKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAccelerationStructureGeometryTrianglesDataKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkFormat);
    count_VkDeviceOrHostAddressConstKHR(featureBits, rootType, (VkDeviceOrHostAddressConstKHR*)(&toCount->vertexData), count);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(uint32_t);
    *count += sizeof(VkIndexType);
    count_VkDeviceOrHostAddressConstKHR(featureBits, rootType, (VkDeviceOrHostAddressConstKHR*)(&toCount->indexData), count);
    count_VkDeviceOrHostAddressConstKHR(featureBits, rootType, (VkDeviceOrHostAddressConstKHR*)(&toCount->transformData), count);
}

void count_VkAccelerationStructureGeometryAabbsDataKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAccelerationStructureGeometryAabbsDataKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkDeviceOrHostAddressConstKHR(featureBits, rootType, (VkDeviceOrHostAddressConstKHR*)(&toCount->data), count);
    *count += sizeof(VkDeviceSize);
}

void count_VkAccelerationStructureGeometryInstancesDataKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAccelerationStructureGeometryInstancesDataKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    count_VkDeviceOrHostAddressConstKHR(featureBits, rootType, (VkDeviceOrHostAddressConstKHR*)(&toCount->data), count);
}

void count_VkAccelerationStructureGeometryDataKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAccelerationStructureGeometryDataKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    count_VkAccelerationStructureGeometryTrianglesDataKHR(featureBits, rootType, (VkAccelerationStructureGeometryTrianglesDataKHR*)(&toCount->triangles), count);
}

void count_VkAccelerationStructureGeometryKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAccelerationStructureGeometryKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkGeometryTypeKHR);
    count_VkAccelerationStructureGeometryDataKHR(featureBits, rootType, (VkAccelerationStructureGeometryDataKHR*)(&toCount->geometry), count);
    *count += sizeof(VkGeometryFlagsKHR);
}

void count_VkAccelerationStructureBuildGeometryInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAccelerationStructureBuildGeometryInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkAccelerationStructureTypeKHR);
    *count += sizeof(VkBuildAccelerationStructureFlagsKHR);
    *count += sizeof(VkBuildAccelerationStructureModeKHR);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pGeometries)
    {
        if (toCount)
        {
            for (uint32_t i = 0; i < (uint32_t)toCount->geometryCount; ++i)
            {
                count_VkAccelerationStructureGeometryKHR(featureBits, rootType, (const VkAccelerationStructureGeometryKHR*)(toCount->pGeometries + i), count);
            }
        }
    }
    count_VkDeviceOrHostAddressKHR(featureBits, rootType, (VkDeviceOrHostAddressKHR*)(&toCount->scratchData), count);
}

void count_VkAccelerationStructureCreateInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAccelerationStructureCreateInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkAccelerationStructureCreateFlagsKHR);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkAccelerationStructureTypeKHR);
    *count += sizeof(VkDeviceAddress);
}

void count_VkWriteDescriptorSetAccelerationStructureKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkWriteDescriptorSetAccelerationStructureKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pAccelerationStructures)
    {
        if (toCount->accelerationStructureCount)
        {
            *count += toCount->accelerationStructureCount * 8;
        }
    }
}

void count_VkPhysicalDeviceAccelerationStructureFeaturesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceAccelerationStructureFeaturesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceAccelerationStructurePropertiesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceAccelerationStructurePropertiesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint64_t);
    *count += sizeof(uint64_t);
    *count += sizeof(uint64_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkAccelerationStructureDeviceAddressInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAccelerationStructureDeviceAddressInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
}

void count_VkAccelerationStructureVersionInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAccelerationStructureVersionInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    if (toCount)
    {
        *count += 2*VK_UUID_SIZE * sizeof(const uint8_t);
    }
}

void count_VkCopyAccelerationStructureToMemoryInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCopyAccelerationStructureToMemoryInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    count_VkDeviceOrHostAddressKHR(featureBits, rootType, (VkDeviceOrHostAddressKHR*)(&toCount->dst), count);
    *count += sizeof(VkCopyAccelerationStructureModeKHR);
}

void count_VkCopyMemoryToAccelerationStructureInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCopyMemoryToAccelerationStructureInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    count_VkDeviceOrHostAddressConstKHR(featureBits, rootType, (VkDeviceOrHostAddressConstKHR*)(&toCount->src), count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    *count += sizeof(VkCopyAccelerationStructureModeKHR);
}

void count_VkCopyAccelerationStructureInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkCopyAccelerationStructureInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    uint64_t cgen_var_0;
    *count += 1 * 8;
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(VkCopyAccelerationStructureModeKHR);
}

void count_VkAccelerationStructureBuildSizesInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkAccelerationStructureBuildSizesInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
}

#endif
#ifdef VK_KHR_ray_tracing_pipeline
void count_VkRayTracingShaderGroupCreateInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkRayTracingShaderGroupCreateInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkRayTracingShaderGroupTypeKHR);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pShaderGroupCaptureReplayHandle)
    {
        *count += sizeof(const uint8_t);
    }
}

void count_VkRayTracingPipelineInterfaceCreateInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkRayTracingPipelineInterfaceCreateInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkRayTracingPipelineCreateInfoKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkRayTracingPipelineCreateInfoKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkPipelineCreateFlags);
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->stageCount; ++i)
        {
            count_VkPipelineShaderStageCreateInfo(featureBits, rootType, (const VkPipelineShaderStageCreateInfo*)(toCount->pStages + i), count);
        }
    }
    *count += sizeof(uint32_t);
    if (toCount)
    {
        for (uint32_t i = 0; i < (uint32_t)toCount->groupCount; ++i)
        {
            count_VkRayTracingShaderGroupCreateInfoKHR(featureBits, rootType, (const VkRayTracingShaderGroupCreateInfoKHR*)(toCount->pGroups + i), count);
        }
    }
    *count += sizeof(uint32_t);
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pLibraryInfo)
    {
        count_VkPipelineLibraryCreateInfoKHR(featureBits, rootType, (const VkPipelineLibraryCreateInfoKHR*)(toCount->pLibraryInfo), count);
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pLibraryInterface)
    {
        count_VkRayTracingPipelineInterfaceCreateInfoKHR(featureBits, rootType, (const VkRayTracingPipelineInterfaceCreateInfoKHR*)(toCount->pLibraryInterface), count);
    }
    // WARNING PTR CHECK
    *count += 8;
    if (toCount->pDynamicState)
    {
        count_VkPipelineDynamicStateCreateInfo(featureBits, rootType, (const VkPipelineDynamicStateCreateInfo*)(toCount->pDynamicState), count);
    }
    uint64_t cgen_var_0;
    *count += 1 * 8;
    uint64_t cgen_var_1;
    *count += 1 * 8;
    *count += sizeof(int32_t);
}

void count_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceRayTracingPipelineFeaturesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
    *count += sizeof(VkBool32);
}

void count_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceRayTracingPipelinePropertiesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

void count_VkStridedDeviceAddressRegionKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkStridedDeviceAddressRegionKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkDeviceAddress);
    *count += sizeof(VkDeviceSize);
    *count += sizeof(VkDeviceSize);
}

void count_VkTraceRaysIndirectCommandKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkTraceRaysIndirectCommandKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
    *count += sizeof(uint32_t);
}

#endif
#ifdef VK_KHR_ray_query
void count_VkPhysicalDeviceRayQueryFeaturesKHR(
    uint32_t featureBits,
    VkStructureType rootType,
    const VkPhysicalDeviceRayQueryFeaturesKHR* toCount,
    size_t* count)
{
    (void)featureBits;
    (void)rootType;
    (void)toCount;
    (void)count;
    *count += sizeof(VkStructureType);
    if (rootType == VK_STRUCTURE_TYPE_MAX_ENUM)
    {
        rootType = toCount->sType;
    }
    count_extension_struct(featureBits, rootType, toCount->pNext, count);
    *count += sizeof(VkBool32);
}

#endif
void count_extension_struct(
    uint32_t featureBits,
    VkStructureType rootType,
    const void* structExtension,
    size_t* count)
{
    VkInstanceCreateInfo* structAccess = (VkInstanceCreateInfo*)(structExtension);
    size_t currExtSize = goldfish_vk_extension_struct_size_with_stream_features(featureBits, rootType, structExtension);
    if (!currExtSize && structExtension)
    {
        // unknown struct extension; skip and call on its pNext field
        count_extension_struct(featureBits, rootType, (void*)structAccess->pNext, count);
        return;
    }
    else
    {
        // known or null extension struct
        *count += sizeof(uint32_t);
        if (!currExtSize)
        {
            // exit if this was a null extension struct (size == 0 in this branch)
            return;
        }
    }
    *count += sizeof(VkStructureType);
    if (!structExtension)
    {
        return;
    }
    uint32_t structType = (uint32_t)goldfish_vk_struct_type(structExtension);
    switch(structType)
    {
#ifdef VK_VERSION_1_1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            count_VkPhysicalDeviceSubgroupProperties(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceSubgroupProperties*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            count_VkPhysicalDevice16BitStorageFeatures(featureBits, rootType, reinterpret_cast<const VkPhysicalDevice16BitStorageFeatures*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            count_VkMemoryDedicatedRequirements(featureBits, rootType, reinterpret_cast<const VkMemoryDedicatedRequirements*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            count_VkMemoryDedicatedAllocateInfo(featureBits, rootType, reinterpret_cast<const VkMemoryDedicatedAllocateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            count_VkMemoryAllocateFlagsInfo(featureBits, rootType, reinterpret_cast<const VkMemoryAllocateFlagsInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            count_VkDeviceGroupRenderPassBeginInfo(featureBits, rootType, reinterpret_cast<const VkDeviceGroupRenderPassBeginInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
            count_VkDeviceGroupCommandBufferBeginInfo(featureBits, rootType, reinterpret_cast<const VkDeviceGroupCommandBufferBeginInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            count_VkDeviceGroupSubmitInfo(featureBits, rootType, reinterpret_cast<const VkDeviceGroupSubmitInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
            count_VkDeviceGroupBindSparseInfo(featureBits, rootType, reinterpret_cast<const VkDeviceGroupBindSparseInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
            count_VkBindBufferMemoryDeviceGroupInfo(featureBits, rootType, reinterpret_cast<const VkBindBufferMemoryDeviceGroupInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            count_VkBindImageMemoryDeviceGroupInfo(featureBits, rootType, reinterpret_cast<const VkBindImageMemoryDeviceGroupInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            count_VkDeviceGroupDeviceCreateInfo(featureBits, rootType, reinterpret_cast<const VkDeviceGroupDeviceCreateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            count_VkPhysicalDeviceFeatures2(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceFeatures2*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            count_VkPhysicalDevicePointClippingProperties(featureBits, rootType, reinterpret_cast<const VkPhysicalDevicePointClippingProperties*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
            count_VkRenderPassInputAttachmentAspectCreateInfo(featureBits, rootType, reinterpret_cast<const VkRenderPassInputAttachmentAspectCreateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
            count_VkImageViewUsageCreateInfo(featureBits, rootType, reinterpret_cast<const VkImageViewUsageCreateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
            count_VkPipelineTessellationDomainOriginStateCreateInfo(featureBits, rootType, reinterpret_cast<const VkPipelineTessellationDomainOriginStateCreateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
            count_VkRenderPassMultiviewCreateInfo(featureBits, rootType, reinterpret_cast<const VkRenderPassMultiviewCreateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            count_VkPhysicalDeviceMultiviewFeatures(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceMultiviewFeatures*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            count_VkPhysicalDeviceMultiviewProperties(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceMultiviewProperties*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
            count_VkPhysicalDeviceVariablePointersFeatures(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceVariablePointersFeatures*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            count_VkPhysicalDeviceProtectedMemoryFeatures(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            count_VkPhysicalDeviceProtectedMemoryProperties(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceProtectedMemoryProperties*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            count_VkProtectedSubmitInfo(featureBits, rootType, reinterpret_cast<const VkProtectedSubmitInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            count_VkSamplerYcbcrConversionInfo(featureBits, rootType, reinterpret_cast<const VkSamplerYcbcrConversionInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            count_VkBindImagePlaneMemoryInfo(featureBits, rootType, reinterpret_cast<const VkBindImagePlaneMemoryInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
            count_VkImagePlaneMemoryRequirementsInfo(featureBits, rootType, reinterpret_cast<const VkImagePlaneMemoryRequirementsInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            count_VkPhysicalDeviceSamplerYcbcrConversionFeatures(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            count_VkSamplerYcbcrConversionImageFormatProperties(featureBits, rootType, reinterpret_cast<const VkSamplerYcbcrConversionImageFormatProperties*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            count_VkPhysicalDeviceExternalImageFormatInfo(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceExternalImageFormatInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            count_VkExternalImageFormatProperties(featureBits, rootType, reinterpret_cast<const VkExternalImageFormatProperties*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            count_VkPhysicalDeviceIDProperties(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceIDProperties*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            count_VkExternalMemoryImageCreateInfo(featureBits, rootType, reinterpret_cast<const VkExternalMemoryImageCreateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            count_VkExternalMemoryBufferCreateInfo(featureBits, rootType, reinterpret_cast<const VkExternalMemoryBufferCreateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            count_VkExportMemoryAllocateInfo(featureBits, rootType, reinterpret_cast<const VkExportMemoryAllocateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
            count_VkExportFenceCreateInfo(featureBits, rootType, reinterpret_cast<const VkExportFenceCreateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            count_VkExportSemaphoreCreateInfo(featureBits, rootType, reinterpret_cast<const VkExportSemaphoreCreateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            count_VkPhysicalDeviceMaintenance3Properties(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceMaintenance3Properties*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
            count_VkPhysicalDeviceShaderDrawParametersFeatures(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceShaderDrawParametersFeatures*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_VERSION_1_2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {
            count_VkPhysicalDeviceVulkan11Features(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceVulkan11Features*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
        {
            count_VkPhysicalDeviceVulkan11Properties(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceVulkan11Properties*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {
            count_VkPhysicalDeviceVulkan12Features(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceVulkan12Features*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
        {
            count_VkPhysicalDeviceVulkan12Properties(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceVulkan12Properties*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
            count_VkImageFormatListCreateInfo(featureBits, rootType, reinterpret_cast<const VkImageFormatListCreateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {
            count_VkPhysicalDevice8BitStorageFeatures(featureBits, rootType, reinterpret_cast<const VkPhysicalDevice8BitStorageFeatures*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
        {
            count_VkPhysicalDeviceDriverProperties(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceDriverProperties*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
            count_VkPhysicalDeviceShaderAtomicInt64Features(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceShaderAtomicInt64Features*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
            count_VkPhysicalDeviceShaderFloat16Int8Features(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceShaderFloat16Int8Features*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
        {
            count_VkPhysicalDeviceFloatControlsProperties(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceFloatControlsProperties*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
        {
            count_VkDescriptorSetLayoutBindingFlagsCreateInfo(featureBits, rootType, reinterpret_cast<const VkDescriptorSetLayoutBindingFlagsCreateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
            count_VkPhysicalDeviceDescriptorIndexingFeatures(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingFeatures*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
        {
            count_VkPhysicalDeviceDescriptorIndexingProperties(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingProperties*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
        {
            count_VkDescriptorSetVariableDescriptorCountAllocateInfo(featureBits, rootType, reinterpret_cast<const VkDescriptorSetVariableDescriptorCountAllocateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
        {
            count_VkDescriptorSetVariableDescriptorCountLayoutSupport(featureBits, rootType, reinterpret_cast<const VkDescriptorSetVariableDescriptorCountLayoutSupport*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
        {
            count_VkSubpassDescriptionDepthStencilResolve(featureBits, rootType, reinterpret_cast<const VkSubpassDescriptionDepthStencilResolve*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
        {
            count_VkPhysicalDeviceDepthStencilResolveProperties(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceDepthStencilResolveProperties*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
            count_VkPhysicalDeviceScalarBlockLayoutFeatures(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceScalarBlockLayoutFeatures*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
            count_VkImageStencilUsageCreateInfo(featureBits, rootType, reinterpret_cast<const VkImageStencilUsageCreateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
        {
            count_VkSamplerReductionModeCreateInfo(featureBits, rootType, reinterpret_cast<const VkSamplerReductionModeCreateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
        {
            count_VkPhysicalDeviceSamplerFilterMinmaxProperties(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceSamplerFilterMinmaxProperties*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
            count_VkPhysicalDeviceVulkanMemoryModelFeatures(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceVulkanMemoryModelFeatures*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
            count_VkPhysicalDeviceImagelessFramebufferFeatures(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceImagelessFramebufferFeatures*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
        {
            count_VkFramebufferAttachmentsCreateInfo(featureBits, rootType, reinterpret_cast<const VkFramebufferAttachmentsCreateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
        {
            count_VkRenderPassAttachmentBeginInfo(featureBits, rootType, reinterpret_cast<const VkRenderPassAttachmentBeginInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
            count_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceUniformBufferStandardLayoutFeatures*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
            count_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
            count_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:
        {
            count_VkAttachmentReferenceStencilLayout(featureBits, rootType, reinterpret_cast<const VkAttachmentReferenceStencilLayout*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:
        {
            count_VkAttachmentDescriptionStencilLayout(featureBits, rootType, reinterpret_cast<const VkAttachmentDescriptionStencilLayout*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
            count_VkPhysicalDeviceHostQueryResetFeatures(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceHostQueryResetFeatures*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
            count_VkPhysicalDeviceTimelineSemaphoreFeatures(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceTimelineSemaphoreFeatures*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
        {
            count_VkPhysicalDeviceTimelineSemaphoreProperties(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceTimelineSemaphoreProperties*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
        {
            count_VkSemaphoreTypeCreateInfo(featureBits, rootType, reinterpret_cast<const VkSemaphoreTypeCreateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
            count_VkTimelineSemaphoreSubmitInfo(featureBits, rootType, reinterpret_cast<const VkTimelineSemaphoreSubmitInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
            count_VkPhysicalDeviceBufferDeviceAddressFeatures(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceBufferDeviceAddressFeatures*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
        {
            count_VkBufferOpaqueCaptureAddressCreateInfo(featureBits, rootType, reinterpret_cast<const VkBufferOpaqueCaptureAddressCreateInfo*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
        {
            count_VkMemoryOpaqueCaptureAddressAllocateInfo(featureBits, rootType, reinterpret_cast<const VkMemoryOpaqueCaptureAddressAllocateInfo*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_swapchain
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            count_VkImageSwapchainCreateInfoKHR(featureBits, rootType, reinterpret_cast<const VkImageSwapchainCreateInfoKHR*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            count_VkBindImageMemorySwapchainInfoKHR(featureBits, rootType, reinterpret_cast<const VkBindImageMemorySwapchainInfoKHR*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
            count_VkDeviceGroupPresentInfoKHR(featureBits, rootType, reinterpret_cast<const VkDeviceGroupPresentInfoKHR*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
            count_VkDeviceGroupSwapchainCreateInfoKHR(featureBits, rootType, reinterpret_cast<const VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_display_swapchain
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {
            count_VkDisplayPresentInfoKHR(featureBits, rootType, reinterpret_cast<const VkDisplayPresentInfoKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            count_VkImportMemoryWin32HandleInfoKHR(featureBits, rootType, reinterpret_cast<const VkImportMemoryWin32HandleInfoKHR*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            count_VkExportMemoryWin32HandleInfoKHR(featureBits, rootType, reinterpret_cast<const VkExportMemoryWin32HandleInfoKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_external_memory_fd
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
            count_VkImportMemoryFdInfoKHR(featureBits, rootType, reinterpret_cast<const VkImportMemoryFdInfoKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            count_VkWin32KeyedMutexAcquireReleaseInfoKHR(featureBits, rootType, reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_external_semaphore_win32
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {
            count_VkExportSemaphoreWin32HandleInfoKHR(featureBits, rootType, reinterpret_cast<const VkExportSemaphoreWin32HandleInfoKHR*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {
            count_VkD3D12FenceSubmitInfoKHR(featureBits, rootType, reinterpret_cast<const VkD3D12FenceSubmitInfoKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_push_descriptor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
            count_VkPhysicalDevicePushDescriptorPropertiesKHR(featureBits, rootType, reinterpret_cast<const VkPhysicalDevicePushDescriptorPropertiesKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_incremental_present
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
            count_VkPresentRegionsKHR(featureBits, rootType, reinterpret_cast<const VkPresentRegionsKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_shared_presentable_image
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {
            count_VkSharedPresentSurfaceCapabilitiesKHR(featureBits, rootType, reinterpret_cast<const VkSharedPresentSurfaceCapabilitiesKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_external_fence_win32
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {
            count_VkExportFenceWin32HandleInfoKHR(featureBits, rootType, reinterpret_cast<const VkExportFenceWin32HandleInfoKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_performance_query
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {
            count_VkPhysicalDevicePerformanceQueryFeaturesKHR(featureBits, rootType, reinterpret_cast<const VkPhysicalDevicePerformanceQueryFeaturesKHR*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
        {
            count_VkPhysicalDevicePerformanceQueryPropertiesKHR(featureBits, rootType, reinterpret_cast<const VkPhysicalDevicePerformanceQueryPropertiesKHR*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
        {
            count_VkQueryPoolPerformanceCreateInfoKHR(featureBits, rootType, reinterpret_cast<const VkQueryPoolPerformanceCreateInfoKHR*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
            count_VkPerformanceQuerySubmitInfoKHR(featureBits, rootType, reinterpret_cast<const VkPerformanceQuerySubmitInfoKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_portability_subset
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR:
        {
            count_VkPhysicalDevicePortabilitySubsetFeaturesKHR(featureBits, rootType, reinterpret_cast<const VkPhysicalDevicePortabilitySubsetFeaturesKHR*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR:
        {
            count_VkPhysicalDevicePortabilitySubsetPropertiesKHR(featureBits, rootType, reinterpret_cast<const VkPhysicalDevicePortabilitySubsetPropertiesKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_shader_clock
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {
            count_VkPhysicalDeviceShaderClockFeaturesKHR(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceShaderClockFeaturesKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_shader_terminate_invocation
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR:
        {
            count_VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_fragment_shading_rate
        case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {
            count_VkFragmentShadingRateAttachmentInfoKHR(featureBits, rootType, reinterpret_cast<const VkFragmentShadingRateAttachmentInfoKHR*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
        {
            count_VkPipelineFragmentShadingRateStateCreateInfoKHR(featureBits, rootType, reinterpret_cast<const VkPipelineFragmentShadingRateStateCreateInfoKHR*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {
            count_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateFeaturesKHR*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
        {
            count_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentShadingRatePropertiesKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_surface_protected_capabilities
        case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
        {
            count_VkSurfaceProtectedCapabilitiesKHR(featureBits, rootType, reinterpret_cast<const VkSurfaceProtectedCapabilitiesKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_pipeline_executable_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {
            count_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(featureBits, rootType, reinterpret_cast<const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_ANDROID_native_buffer
        case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID:
        {
            count_VkNativeBufferANDROID(featureBits, rootType, reinterpret_cast<const VkNativeBufferANDROID*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_debug_report
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            count_VkDebugReportCallbackCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkDebugReportCallbackCreateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_AMD_rasterization_order
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
            count_VkPipelineRasterizationStateRasterizationOrderAMD(featureBits, rootType, reinterpret_cast<const VkPipelineRasterizationStateRasterizationOrderAMD*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            count_VkDedicatedAllocationImageCreateInfoNV(featureBits, rootType, reinterpret_cast<const VkDedicatedAllocationImageCreateInfoNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            count_VkDedicatedAllocationBufferCreateInfoNV(featureBits, rootType, reinterpret_cast<const VkDedicatedAllocationBufferCreateInfoNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            count_VkDedicatedAllocationMemoryAllocateInfoNV(featureBits, rootType, reinterpret_cast<const VkDedicatedAllocationMemoryAllocateInfoNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_transform_feedback
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {
            count_VkPhysicalDeviceTransformFeedbackFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
        {
            count_VkPhysicalDeviceTransformFeedbackPropertiesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceTransformFeedbackPropertiesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
        {
            count_VkPipelineRasterizationStateStreamCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkPipelineRasterizationStateStreamCreateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_AMD_texture_gather_bias_lod
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            count_VkTextureLODGatherFormatPropertiesAMD(featureBits, rootType, reinterpret_cast<const VkTextureLODGatherFormatPropertiesAMD*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_corner_sampled_image
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {
            count_VkPhysicalDeviceCornerSampledImageFeaturesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceCornerSampledImageFeaturesNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_external_memory
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {
            count_VkExternalMemoryImageCreateInfoNV(featureBits, rootType, reinterpret_cast<const VkExternalMemoryImageCreateInfoNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {
            count_VkExportMemoryAllocateInfoNV(featureBits, rootType, reinterpret_cast<const VkExportMemoryAllocateInfoNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            count_VkImportMemoryWin32HandleInfoNV(featureBits, rootType, reinterpret_cast<const VkImportMemoryWin32HandleInfoNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            count_VkExportMemoryWin32HandleInfoNV(featureBits, rootType, reinterpret_cast<const VkExportMemoryWin32HandleInfoNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
        {
            count_VkWin32KeyedMutexAcquireReleaseInfoNV(featureBits, rootType, reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_validation_flags
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            count_VkValidationFlagsEXT(featureBits, rootType, reinterpret_cast<const VkValidationFlagsEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_texture_compression_astc_hdr
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT:
        {
            count_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_astc_decode_mode
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
        {
            count_VkImageViewASTCDecodeModeEXT(featureBits, rootType, reinterpret_cast<const VkImageViewASTCDecodeModeEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {
            count_VkPhysicalDeviceASTCDecodeFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceASTCDecodeFeaturesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_conditional_rendering
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            count_VkPhysicalDeviceConditionalRenderingFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
            count_VkCommandBufferInheritanceConditionalRenderingInfoEXT(featureBits, rootType, reinterpret_cast<const VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_clip_space_w_scaling
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
            count_VkPipelineViewportWScalingStateCreateInfoNV(featureBits, rootType, reinterpret_cast<const VkPipelineViewportWScalingStateCreateInfoNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_display_control
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {
            count_VkSwapchainCounterCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkSwapchainCounterCreateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_GOOGLE_display_timing
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {
            count_VkPresentTimesInfoGOOGLE(featureBits, rootType, reinterpret_cast<const VkPresentTimesInfoGOOGLE*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NVX_multiview_per_view_attributes
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {
            count_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_viewport_swizzle
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
            count_VkPipelineViewportSwizzleStateCreateInfoNV(featureBits, rootType, reinterpret_cast<const VkPipelineViewportSwizzleStateCreateInfoNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_discard_rectangles
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            count_VkPhysicalDeviceDiscardRectanglePropertiesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            count_VkPipelineDiscardRectangleStateCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkPipelineDiscardRectangleStateCreateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_conservative_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            count_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
            count_VkPipelineRasterizationConservativeStateCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkPipelineRasterizationConservativeStateCreateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_depth_clip_enable
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {
            count_VkPhysicalDeviceDepthClipEnableFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
        {
            count_VkPipelineRasterizationDepthClipStateCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkPipelineRasterizationDepthClipStateCreateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_debug_utils
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            count_VkDebugUtilsMessengerCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkDebugUtilsMessengerCreateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
        {
            count_VkAndroidHardwareBufferUsageANDROID(featureBits, rootType, reinterpret_cast<const VkAndroidHardwareBufferUsageANDROID*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
        {
            count_VkAndroidHardwareBufferFormatPropertiesANDROID(featureBits, rootType, reinterpret_cast<const VkAndroidHardwareBufferFormatPropertiesANDROID*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {
            count_VkImportAndroidHardwareBufferInfoANDROID(featureBits, rootType, reinterpret_cast<const VkImportAndroidHardwareBufferInfoANDROID*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
        {
            count_VkExternalFormatANDROID(featureBits, rootType, reinterpret_cast<const VkExternalFormatANDROID*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_inline_uniform_block
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT:
        {
            count_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceInlineUniformBlockFeaturesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT:
        {
            count_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceInlineUniformBlockPropertiesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT:
        {
            count_VkWriteDescriptorSetInlineUniformBlockEXT(featureBits, rootType, reinterpret_cast<const VkWriteDescriptorSetInlineUniformBlockEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT:
        {
            count_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkDescriptorPoolInlineUniformBlockCreateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_sample_locations
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            count_VkSampleLocationsInfoEXT(featureBits, rootType, reinterpret_cast<const VkSampleLocationsInfoEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
            count_VkRenderPassSampleLocationsBeginInfoEXT(featureBits, rootType, reinterpret_cast<const VkRenderPassSampleLocationsBeginInfoEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
            count_VkPipelineSampleLocationsStateCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkPipelineSampleLocationsStateCreateInfoEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            count_VkPhysicalDeviceSampleLocationsPropertiesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceSampleLocationsPropertiesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_blend_operation_advanced
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            count_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            count_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
            count_VkPipelineColorBlendAdvancedStateCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_fragment_coverage_to_color
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
            count_VkPipelineCoverageToColorStateCreateInfoNV(featureBits, rootType, reinterpret_cast<const VkPipelineCoverageToColorStateCreateInfoNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_framebuffer_mixed_samples
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
            count_VkPipelineCoverageModulationStateCreateInfoNV(featureBits, rootType, reinterpret_cast<const VkPipelineCoverageModulationStateCreateInfoNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_shader_sm_builtins
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
        {
            count_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {
            count_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_image_drm_format_modifier
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
        {
            count_VkDrmFormatModifierPropertiesListEXT(featureBits, rootType, reinterpret_cast<const VkDrmFormatModifierPropertiesListEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
        {
            count_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceImageDrmFormatModifierInfoEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
        {
            count_VkImageDrmFormatModifierListCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkImageDrmFormatModifierListCreateInfoEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
        {
            count_VkImageDrmFormatModifierExplicitCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkImageDrmFormatModifierExplicitCreateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_validation_cache
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            count_VkShaderModuleValidationCacheCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkShaderModuleValidationCacheCreateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_shading_rate_image
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
        {
            count_VkPipelineViewportShadingRateImageStateCreateInfoNV(featureBits, rootType, reinterpret_cast<const VkPipelineViewportShadingRateImageStateCreateInfoNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {
            count_VkPhysicalDeviceShadingRateImageFeaturesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceShadingRateImageFeaturesNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
        {
            count_VkPhysicalDeviceShadingRateImagePropertiesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceShadingRateImagePropertiesNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
        {
            count_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(featureBits, rootType, reinterpret_cast<const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_ray_tracing
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
        {
            count_VkWriteDescriptorSetAccelerationStructureNV(featureBits, rootType, reinterpret_cast<const VkWriteDescriptorSetAccelerationStructureNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
        {
            count_VkPhysicalDeviceRayTracingPropertiesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceRayTracingPropertiesNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_representative_fragment_test
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {
            count_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
        {
            count_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(featureBits, rootType, reinterpret_cast<const VkPipelineRepresentativeFragmentTestStateCreateInfoNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_filter_cubic
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
        {
            count_VkPhysicalDeviceImageViewImageFormatInfoEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceImageViewImageFormatInfoEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
        {
            count_VkFilterCubicImageViewImageFormatPropertiesEXT(featureBits, rootType, reinterpret_cast<const VkFilterCubicImageViewImageFormatPropertiesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_global_priority
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
        {
            count_VkDeviceQueueGlobalPriorityCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkDeviceQueueGlobalPriorityCreateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_external_memory_host
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            count_VkImportMemoryHostPointerInfoEXT(featureBits, rootType, reinterpret_cast<const VkImportMemoryHostPointerInfoEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            count_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_AMD_pipeline_compiler_control
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
        {
            count_VkPipelineCompilerControlCreateInfoAMD(featureBits, rootType, reinterpret_cast<const VkPipelineCompilerControlCreateInfoAMD*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            count_VkPhysicalDeviceShaderCorePropertiesAMD(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceShaderCorePropertiesAMD*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_AMD_memory_overallocation_behavior
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
        {
            count_VkDeviceMemoryOverallocationCreateInfoAMD(featureBits, rootType, reinterpret_cast<const VkDeviceMemoryOverallocationCreateInfoAMD*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_vertex_attribute_divisor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            count_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
            count_VkPipelineVertexInputDivisorStateCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkPipelineVertexInputDivisorStateCreateInfoEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
        {
            count_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_GGP_frame_token
        case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
        {
            count_VkPresentFrameTokenGGP(featureBits, rootType, reinterpret_cast<const VkPresentFrameTokenGGP*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_pipeline_creation_feedback
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT:
        {
            count_VkPipelineCreationFeedbackCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkPipelineCreationFeedbackCreateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_compute_shader_derivatives
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
        {
            count_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_mesh_shader
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {
            count_VkPhysicalDeviceMeshShaderFeaturesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceMeshShaderFeaturesNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
        {
            count_VkPhysicalDeviceMeshShaderPropertiesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceMeshShaderPropertiesNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_fragment_shader_barycentric
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV:
        {
            count_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_shader_image_footprint
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {
            count_VkPhysicalDeviceShaderImageFootprintFeaturesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_scissor_exclusive
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
        {
            count_VkPipelineViewportExclusiveScissorStateCreateInfoNV(featureBits, rootType, reinterpret_cast<const VkPipelineViewportExclusiveScissorStateCreateInfoNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {
            count_VkPhysicalDeviceExclusiveScissorFeaturesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceExclusiveScissorFeaturesNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            count_VkQueueFamilyCheckpointPropertiesNV(featureBits, rootType, reinterpret_cast<const VkQueueFamilyCheckpointPropertiesNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_INTEL_shader_integer_functions2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {
            count_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_INTEL_performance_query
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
        {
            count_VkQueryPoolPerformanceQueryCreateInfoINTEL(featureBits, rootType, reinterpret_cast<const VkQueryPoolPerformanceQueryCreateInfoINTEL*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_pci_bus_info
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
        {
            count_VkPhysicalDevicePCIBusInfoPropertiesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDevicePCIBusInfoPropertiesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_AMD_display_native_hdr
        case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
        {
            count_VkDisplayNativeHdrSurfaceCapabilitiesAMD(featureBits, rootType, reinterpret_cast<const VkDisplayNativeHdrSurfaceCapabilitiesAMD*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
        {
            count_VkSwapchainDisplayNativeHdrCreateInfoAMD(featureBits, rootType, reinterpret_cast<const VkSwapchainDisplayNativeHdrCreateInfoAMD*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_fragment_density_map
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
        {
            switch(rootType)
            {
                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
                {
                    count_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(structExtension), count);
                    break;
                }
                case VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO:
                {
                    count_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(structExtension), count);
                    break;
                }
                case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:
                {
                    count_VkImportColorBufferGOOGLE(featureBits, rootType, reinterpret_cast<const VkImportColorBufferGOOGLE*>(structExtension), count);
                    break;
                }
                default:
                {
                    count_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(structExtension), count);
                    break;
                }
            }
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
        {
            switch(rootType)
            {
                case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2:
                {
                    count_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentDensityMapPropertiesEXT*>(structExtension), count);
                    break;
                }
                case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:
                {
                    count_VkImportPhysicalAddressGOOGLE(featureBits, rootType, reinterpret_cast<const VkImportPhysicalAddressGOOGLE*>(structExtension), count);
                    break;
                }
                default:
                {
                    count_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentDensityMapPropertiesEXT*>(structExtension), count);
                    break;
                }
            }
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
        {
            switch(rootType)
            {
                case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO:
                {
                    count_VkRenderPassFragmentDensityMapCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkRenderPassFragmentDensityMapCreateInfoEXT*>(structExtension), count);
                    break;
                }
                case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2:
                {
                    count_VkRenderPassFragmentDensityMapCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkRenderPassFragmentDensityMapCreateInfoEXT*>(structExtension), count);
                    break;
                }
                case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:
                {
                    count_VkImportBufferGOOGLE(featureBits, rootType, reinterpret_cast<const VkImportBufferGOOGLE*>(structExtension), count);
                    break;
                }
                default:
                {
                    count_VkRenderPassFragmentDensityMapCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkRenderPassFragmentDensityMapCreateInfoEXT*>(structExtension), count);
                    break;
                }
            }
            break;
        }
#endif
#ifdef VK_EXT_subgroup_size_control
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT:
        {
            count_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT:
        {
            count_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT:
        {
            count_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
        {
            count_VkPhysicalDeviceShaderCoreProperties2AMD(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceShaderCoreProperties2AMD*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_AMD_device_coherent_memory
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {
            count_VkPhysicalDeviceCoherentMemoryFeaturesAMD(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceCoherentMemoryFeaturesAMD*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_shader_image_atomic_int64
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {
            count_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_memory_budget
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
        {
            count_VkPhysicalDeviceMemoryBudgetPropertiesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceMemoryBudgetPropertiesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_memory_priority
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {
            count_VkPhysicalDeviceMemoryPriorityFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceMemoryPriorityFeaturesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
        {
            count_VkMemoryPriorityAllocateInfoEXT(featureBits, rootType, reinterpret_cast<const VkMemoryPriorityAllocateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation_image_aliasing
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {
            count_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_buffer_device_address
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {
            count_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
        {
            count_VkBufferDeviceAddressCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkBufferDeviceAddressCreateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_validation_features
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
        {
            count_VkValidationFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkValidationFeaturesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_cooperative_matrix
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {
            count_VkPhysicalDeviceCooperativeMatrixFeaturesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceCooperativeMatrixFeaturesNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {
            count_VkPhysicalDeviceCooperativeMatrixPropertiesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceCooperativeMatrixPropertiesNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_coverage_reduction_mode
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {
            count_VkPhysicalDeviceCoverageReductionModeFeaturesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceCoverageReductionModeFeaturesNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
        {
            count_VkPipelineCoverageReductionStateCreateInfoNV(featureBits, rootType, reinterpret_cast<const VkPipelineCoverageReductionStateCreateInfoNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_fragment_shader_interlock
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {
            count_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_ycbcr_image_arrays
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {
            count_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_full_screen_exclusive
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
        {
            count_VkSurfaceFullScreenExclusiveInfoEXT(featureBits, rootType, reinterpret_cast<const VkSurfaceFullScreenExclusiveInfoEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
        {
            count_VkSurfaceCapabilitiesFullScreenExclusiveEXT(featureBits, rootType, reinterpret_cast<const VkSurfaceCapabilitiesFullScreenExclusiveEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
        {
            count_VkSurfaceFullScreenExclusiveWin32InfoEXT(featureBits, rootType, reinterpret_cast<const VkSurfaceFullScreenExclusiveWin32InfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_line_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
        {
            count_VkPhysicalDeviceLineRasterizationFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceLineRasterizationFeaturesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
        {
            count_VkPhysicalDeviceLineRasterizationPropertiesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceLineRasterizationPropertiesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
        {
            count_VkPipelineRasterizationLineStateCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkPipelineRasterizationLineStateCreateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_shader_atomic_float
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {
            count_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_index_type_uint8
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
        {
            count_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceIndexTypeUint8FeaturesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_extended_dynamic_state
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {
            count_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_shader_demote_to_helper_invocation
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT:
        {
            count_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_device_generated_commands
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
        {
            count_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {
            count_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
        {
            count_VkGraphicsPipelineShaderGroupsCreateInfoNV(featureBits, rootType, reinterpret_cast<const VkGraphicsPipelineShaderGroupsCreateInfoNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_texel_buffer_alignment
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {
            count_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT:
        {
            count_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_QCOM_render_pass_transform
        case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM:
        {
            count_VkRenderPassTransformBeginInfoQCOM(featureBits, rootType, reinterpret_cast<const VkRenderPassTransformBeginInfoQCOM*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
        {
            count_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(featureBits, rootType, reinterpret_cast<const VkCommandBufferInheritanceRenderPassTransformInfoQCOM*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_device_memory_report
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT:
        {
            count_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT:
        {
            count_VkDeviceDeviceMemoryReportCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkDeviceDeviceMemoryReportCreateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_robustness2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
        {
            count_VkPhysicalDeviceRobustness2FeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceRobustness2FeaturesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT:
        {
            count_VkPhysicalDeviceRobustness2PropertiesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceRobustness2PropertiesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_custom_border_color
        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
        {
            count_VkSamplerCustomBorderColorCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkSamplerCustomBorderColorCreateInfoEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
        {
            count_VkPhysicalDeviceCustomBorderColorPropertiesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceCustomBorderColorPropertiesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {
            count_VkPhysicalDeviceCustomBorderColorFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceCustomBorderColorFeaturesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_private_data
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT:
        {
            count_VkPhysicalDevicePrivateDataFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDevicePrivateDataFeaturesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT:
        {
            count_VkDevicePrivateDataCreateInfoEXT(featureBits, rootType, reinterpret_cast<const VkDevicePrivateDataCreateInfoEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_pipeline_creation_cache_control
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT:
        {
            count_VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_device_diagnostics_config
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {
            count_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceDiagnosticsConfigFeaturesNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
        {
            count_VkDeviceDiagnosticsConfigCreateInfoNV(featureBits, rootType, reinterpret_cast<const VkDeviceDiagnosticsConfigCreateInfoNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_NV_fragment_shading_rate_enums
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {
            count_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
        {
            count_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
        {
            count_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(featureBits, rootType, reinterpret_cast<const VkPipelineFragmentShadingRateEnumStateCreateInfoNV*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_fragment_density_map2
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {
            count_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
        {
            count_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_QCOM_rotated_copy_commands
        case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
        {
            count_VkCopyCommandTransformInfoQCOM(featureBits, rootType, reinterpret_cast<const VkCopyCommandTransformInfoQCOM*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_image_robustness
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT:
        {
            count_VkPhysicalDeviceImageRobustnessFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceImageRobustnessFeaturesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_EXT_4444_formats
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {
            count_VkPhysicalDevice4444FormatsFeaturesEXT(featureBits, rootType, reinterpret_cast<const VkPhysicalDevice4444FormatsFeaturesEXT*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_GOOGLE_gfxstream
        case VK_STRUCTURE_TYPE_IMPORT_COLOR_BUFFER_GOOGLE:
        {
            count_VkImportColorBufferGOOGLE(featureBits, rootType, reinterpret_cast<const VkImportColorBufferGOOGLE*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_BUFFER_GOOGLE:
        {
            count_VkImportBufferGOOGLE(featureBits, rootType, reinterpret_cast<const VkImportBufferGOOGLE*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_PHYSICAL_ADDRESS_GOOGLE:
        {
            count_VkImportPhysicalAddressGOOGLE(featureBits, rootType, reinterpret_cast<const VkImportPhysicalAddressGOOGLE*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_acceleration_structure
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
        {
            count_VkWriteDescriptorSetAccelerationStructureKHR(featureBits, rootType, reinterpret_cast<const VkWriteDescriptorSetAccelerationStructureKHR*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {
            count_VkPhysicalDeviceAccelerationStructureFeaturesKHR(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceAccelerationStructureFeaturesKHR*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
        {
            count_VkPhysicalDeviceAccelerationStructurePropertiesKHR(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceAccelerationStructurePropertiesKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_ray_tracing_pipeline
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {
            count_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceRayTracingPipelineFeaturesKHR*>(structExtension), count);
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
        {
            count_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceRayTracingPipelinePropertiesKHR*>(structExtension), count);
            break;
        }
#endif
#ifdef VK_KHR_ray_query
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {
            count_VkPhysicalDeviceRayQueryFeaturesKHR(featureBits, rootType, reinterpret_cast<const VkPhysicalDeviceRayQueryFeaturesKHR*>(structExtension), count);
            break;
        }
#endif
        default:
        {
            // fatal; the switch is only taken if the extension struct is known
            abort();
        }
    }
}


} // namespace goldfish_vk
